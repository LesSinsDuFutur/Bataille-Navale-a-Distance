;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
01E2  5046      	MOVF FC_CAL_Por_00042_arg_Tris+D'1', W
01E4  6EEA      	MOVWF FSR0H
01E6  5045      	MOVF FC_CAL_Por_00042_arg_Tris, W
01E8  6EE9      	MOVWF FSR0L
01EA  5047      	MOVF FC_CAL_Por_00042_arg_InMask, W
01EC  10EF      	IORWF INDF0, W
01EE  6E49      	MOVWF CompTempVar1825
01F0  5049      	MOVF CompTempVar1825, W
01F2  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
01F4  5044      	MOVF FC_CAL_Por_00042_arg_Port+D'1', W
01F6  6EEA      	MOVWF FSR0H
01F8  5043      	MOVF FC_CAL_Por_00042_arg_Port, W
01FA  6EE9      	MOVWF FSR0L
01FC  5047      	MOVF FC_CAL_Por_00042_arg_InMask, W
01FE  14EF      	ANDWF INDF0, W
0200  6E49      	MOVWF CompTempVarRet1822
0202  5048      	MOVF FC_CAL_Por_00042_arg_Shift, W
0204  6E4A      	MOVWF CompTempVar1827
0206            label26
0206  B4D8      	BTFSC STATUS,Z
020A  90D8      	BCF STATUS,C
020C  3249      	RRCF CompTempVarRet1822, F
020E  064A      	DECF CompTempVar1827, F
0210  D7FA      	BRA	label26

		}
0208  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BatailleNavale\Hitbox_v2.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Monday, January 23, 2017 16:08:10
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0xFB
#endif
#ifdef HI_TECH_C
__CONFIG(0xFB);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_HITBOX;
MX_GLOBAL MX_UINT16 FCV_Y;
MX_GLOBAL MX_UINT16 FCV_X;
MX_GLOBAL MX_UINT8 FCV_APPUI_ECRAN;

void FCM_X_144();
void FCM_test();
void FCM_Affichage_bateau1();
void FCM_X_72();
void FCM_test2(MX_UINT8 FCL_JHVJH, MX_UINT8 FCL_GFYHG);
void FCM_X_168();
void FCM_Initialisation();
void FCM_Reinitialisation_tactile();
void FCM_X_96();
void FCM_Hitbox();
void FCM_lignesV();
void FCM_X_24();
void FCM_X_240();
void FCM_X_48();
void FCM_Appui_tactile();
void FCM_Recuperation_coordonees();
void FCM_lignesH();
void FCM_X_192();
void FCM_X_120();
void FCM_X_216();

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 porta
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 porta
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisa
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisa
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (2)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
125E  0E00      	MOVLW 0x00
1260  6E36      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
1262  0E01      	MOVLW 0x01
1264  6E37      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
1266  0E02      	MOVLW 0x02
1268  6E38      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
126A  0E03      	MOVLW 0x03
126C  6E39      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
126E  0E04      	MOVLW 0x04
1270  6E3A      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
1272  0E05      	MOVLW 0x05
1274  6E3B      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
1276  0E06      	MOVLW 0x06
1278  6E3C      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
127A  0E07      	MOVLW 0x07
127C  6E3D      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
127E  6A19      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009
1280  6A1A      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1'
1282  6A1B      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2'
1284  6A1C      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3'

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
1286  6A3E      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x63);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)

{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;
0FFC  6A40      	CLRF FCD_0f051__0006A_1_FCR_RETVAL
0FFE  6A41      	CLRF FCD_0f051__0006A_1_FCR_RETVAL+D'1'


	if (FCL_AXIS == 0)
1000  523F      	MOVF FCD_0f051__0006A_arg_FCL_AXIS, F
1002  E007      	BZ	label137

	{

	} else {

		if (FCL_AXIS == 'x')
1004  0E78      	MOVLW 0x78
1006  623F      	CPFSEQ FCD_0f051__0006A_arg_FCL_AXIS
1008  D001      	BRA	label136
100C            label136

		{

		} else {
100A  D003      	BRA	label137


			if (FCL_AXIS == 'X')
100C  0E58      	MOVLW 0x58
100E  623F      	CPFSEQ FCD_0f051__0006A_arg_FCL_AXIS
1010  D004      	BRA	label138
1012            label137

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;
1012  5029      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W
1014  6E40      	MOVWF FCD_0f051__0006A_1_FCR_RETVAL
1016  502A      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', W
1018  6E41      	MOVWF FCD_0f051__0006A_1_FCR_RETVAL+D'1'


FCC_G4D_ReadTouchCoordinatesPicaso_A:
101A            label138

;

	if (FCL_AXIS == 1)
101A  043F      	DECF FCD_0f051__0006A_arg_FCL_AXIS, W
101C  E007      	BZ	label140

	{

	} else {

		if (FCL_AXIS == 'y')
101E  0E79      	MOVLW 0x79
1020  623F      	CPFSEQ FCD_0f051__0006A_arg_FCL_AXIS
1022  D001      	BRA	label139
1026            label139

		{

		} else {
1024  D003      	BRA	label140


			if (FCL_AXIS == 'Y')
1026  0E59      	MOVLW 0x59
1028  623F      	CPFSEQ FCD_0f051__0006A_arg_FCL_AXIS
102A  D004      	BRA	label141
102C            label140

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;
102C  5027      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W
102E  6E40      	MOVWF FCD_0f051__0006A_1_FCR_RETVAL
1030  5028      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', W
1032  6E41      	MOVWF FCD_0f051__0006A_1_FCR_RETVAL+D'1'


FCC_G4D_ReadTouchCoordinatesPicaso_B:
1034            label141

;

	return (FCR_RETVAL);
1034  5040      	MOVF FCD_0f051__0006A_1_FCR_RETVAL, W
1036  6E42      	MOVWF CompTempVarRet2684
1038  5041      	MOVF FCD_0f051__0006A_1_FCR_RETVAL+D'1', W
103A  6E43      	MOVWF CompTempVarRet2684+D'1'


}
103C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x6F);
0B42  0E6F      	MOVLW 0x6F
0B44  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0B46  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0B48  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(4);
0B4C  0E04      	MOVLW 0x04
0B4E  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0B50  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0B52  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
0B56  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0B58  EC4EF000  	CALL FC_CAL_UAR_00072


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0B5C  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0B5E  EC4EF000  	CALL FC_CAL_UAR_00072
0B62  5056      	MOVF CompTempVarRet2697, W
0B64  6E40      	MOVWF FCD_0f051__0006E_1_FCR_RETVAL


	FC_CAL_UART_Receive_1(255);
0B66  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0B68  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(255);
0B6C  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0B6E  EC4EF000  	CALL FC_CAL_UAR_00072


	if (FCR_RETVAL)
0B72  5240      	MOVF FCD_0f051__0006E_1_FCR_RETVAL, F
0B74  E032      	BZ	label117
0BDA            label117

	{

		FC_CAL_UART_Send_1(0x6F);
0B76  0E6F      	MOVLW 0x6F
0B78  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0B7A  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0B7C  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(5);
0B80  0E05      	MOVLW 0x05
0B82  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0B84  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0B86  EC46F000  	CALL FC_CAL_UAR_00073


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_1(255);
0B8A  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0B8C  EC4EF000  	CALL FC_CAL_UAR_00072
0B90  5056      	MOVF CompTempVarRet2697, W
0B92  6E29      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F
0B94  5057      	MOVF CompTempVarRet2697+D'1', W
0B96  6E2A      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1'


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
0B98  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0B9A  EC4EF000  	CALL FC_CAL_UAR_00072
0B9E  5056      	MOVF CompTempVarRet2697, W
0BA0  6E3F      	MOVWF FCD_0f051__0006E_1_FCL_TEMP


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
0BA2  6A41      	CLRF CompTempVar2689
0BA4  5029      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W
0BA6  6E2A      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1'
0BA8  5041      	MOVF CompTempVar2689, W
0BAA  6E29      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;
0BAC  503F      	MOVF FCD_0f051__0006E_1_FCL_TEMP, W
0BAE  1229      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000F, F
0BB0  522A      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', F


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_1(255);
0BB2  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0BB4  EC4EF000  	CALL FC_CAL_UAR_00072
0BB8  5056      	MOVF CompTempVarRet2697, W
0BBA  6E27      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E
0BBC  5057      	MOVF CompTempVarRet2697+D'1', W
0BBE  6E28      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1'


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
0BC0  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0BC2  EC4EF000  	CALL FC_CAL_UAR_00072
0BC6  5056      	MOVF CompTempVarRet2697, W
0BC8  6E3F      	MOVWF FCD_0f051__0006E_1_FCL_TEMP


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
0BCA  6A41      	CLRF CompTempVar2693
0BCC  5027      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W
0BCE  6E28      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1'
0BD0  5041      	MOVF CompTempVar2693, W
0BD2  6E27      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;
0BD4  503F      	MOVF FCD_0f051__0006E_1_FCL_TEMP, W
0BD6  1227      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000E, F
0BD8  5228      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', F


	// } else {

	}

	return (FCR_RETVAL);
0BDA  5040      	MOVF FCD_0f051__0006E_1_FCR_RETVAL, W
0BDC  6E41      	MOVWF CompTempVarRet2688


}
0BDE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_1(FCL_RADIUS);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
0212  6A47      	CLRF FCD_0f051__00068_1_FCL_D1
0214  6A48      	CLRF FCD_0f051__00068_1_FCL_D1+D'1'

	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
0216  0E01      	MOVLW 0x01
0218  6E49      	MOVWF FCD_0f051__00068_1_FCL_YINC
021A  6A4A      	CLRF FCD_0f051__00068_1_FCL_YINC+D'1'

	MX_SINT16 FCL_XINC = (1);
021C  0E01      	MOVLW 0x01
021E  6E4B      	MOVWF FCD_0f051__00068_1_FCL_XINC
0220  6A4C      	CLRF FCD_0f051__00068_1_FCL_XINC+D'1'



	FC_CAL_UART_Send_1(0x4C);
0222  0E4C      	MOVLW 0x4C
0224  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0226  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0228  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
022C  5040      	MOVF FCD_0f051__00068_arg_FCL_X1+D'1', W
022E  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0230  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0232  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1);
0236  503F      	MOVF FCD_0f051__00068_arg_FCL_X1, W
0238  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
023A  5040      	MOVF FCD_0f051__00068_arg_FCL_X1+D'1', W
023C  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
023E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0242  5042      	MOVF FCD_0f051__00068_arg_FCL_Y1+D'1', W
0244  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0246  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0248  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1);
024C  5041      	MOVF FCD_0f051__00068_arg_FCL_Y1, W
024E  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0250  5042      	MOVF FCD_0f051__00068_arg_FCL_Y1+D'1', W
0252  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0254  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
0258  5044      	MOVF FCD_0f051__00068_arg_FCL_X2+D'1', W
025A  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
025C  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
025E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2);
0262  5043      	MOVF FCD_0f051__00068_arg_FCL_X2, W
0264  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0266  5044      	MOVF FCD_0f051__00068_arg_FCL_X2+D'1', W
0268  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
026A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
026E  5046      	MOVF FCD_0f051__00068_arg_FCL_Y2+D'1', W
0270  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0272  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0274  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2);
0278  5045      	MOVF FCD_0f051__00068_arg_FCL_Y2, W
027A  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
027C  5046      	MOVF FCD_0f051__00068_arg_FCL_Y2+D'1', W
027E  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0280  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
0284  5026      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
0286  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0288  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
028A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
028E  5025      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W
0290  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0292  5026      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
0294  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0296  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
029A  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
029C  EC4EF000  	CALL FC_CAL_UAR_00072


}
02A0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_POSH >> 8);

	FC_CAL_UART_Send_1(FCL_POSH);

	FC_CAL_UART_Send_1(FCL_POSL >> 8);

	FC_CAL_UART_Send_1(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
0C40  0E59      	MOVLW 0x59
0C42  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0C44  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0C46  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x05);
0C4A  0E05      	MOVLW 0x05
0C4C  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0C4E  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0C50  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x01);
0C54  0E01      	MOVLW 0x01
0C56  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0C58  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0C5A  EC46F000  	CALL FC_CAL_UAR_00073


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0C5E  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0C60  EC4EF000  	CALL FC_CAL_UAR_00072
0C64  5056      	MOVF CompTempVarRet2697, W
0C66  6E3F      	MOVWF FCD_0f051__00066_1_FCR_RETVAL


	if (FCR_RETVAL == 6)
0C68  0E06      	MOVLW 0x06
0C6A  623F      	CPFSEQ FCD_0f051__00066_1_FCR_RETVAL
0C6C  D002      	BRA	label120
0C72            label120

	{

		FCR_RETVAL = 0;
0C6E  6A3F      	CLRF FCD_0f051__00066_1_FCR_RETVAL


	} else {
0C70  D001      	BRA	label121
0C74            label121


		FCR_RETVAL = 255;
0C72  683F      	SETF FCD_0f051__00066_1_FCR_RETVAL


	}

	return (FCR_RETVAL);
0C74  503F      	MOVF FCD_0f051__00066_1_FCR_RETVAL, W
0C76  6E40      	MOVWF CompTempVarRet2672


}
0C78  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x00);

	FC_CAL_UART_Send_1(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x01);

	FC_CAL_UART_Send_1(FCL_DISPLAY);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x02);

	FC_CAL_UART_Send_1(FCL_CONTRAST);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
0BE0  0E59      	MOVLW 0x59
0BE2  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0BE4  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0BE6  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x05);
0BEA  0E05      	MOVLW 0x05
0BEC  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0BEE  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0BF0  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x00);
0BF4  6A4D      	CLRF FC_CAL_UAR_00073_arg_nChar
0BF6  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0BF8  EC46F000  	CALL FC_CAL_UAR_00073


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0BFC  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0BFE  EC4EF000  	CALL FC_CAL_UAR_00072
0C02  5056      	MOVF CompTempVarRet2697, W
0C04  6E3F      	MOVWF FCD_0f051__00067_1_FCR_RETVAL


	FC_CAL_UART_Send_1(0x59);
0C06  0E59      	MOVLW 0x59
0C08  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0C0A  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0C0C  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x05);
0C10  0E05      	MOVLW 0x05
0C12  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0C14  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0C16  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x02);
0C1A  0E02      	MOVLW 0x02
0C1C  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0C1E  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0C20  EC46F000  	CALL FC_CAL_UAR_00073


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0C24  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0C26  EC4EF000  	CALL FC_CAL_UAR_00072
0C2A  5056      	MOVF CompTempVarRet2697, W
0C2C  6E3F      	MOVWF FCD_0f051__00067_1_FCR_RETVAL


	if (FCR_RETVAL == 6)
0C2E  0E06      	MOVLW 0x06
0C30  623F      	CPFSEQ FCD_0f051__00067_1_FCR_RETVAL
0C32  D002      	BRA	label118
0C38            label118

	{

		FCR_RETVAL = 0;
0C34  6A3F      	CLRF FCD_0f051__00067_1_FCR_RETVAL


	} else {
0C36  D001      	BRA	label119
0C3A            label119


		FCR_RETVAL = 255;
0C38  683F      	SETF FCD_0f051__00067_1_FCR_RETVAL


	}

	return (FCR_RETVAL);
0C3A  503F      	MOVF FCD_0f051__00067_1_FCR_RETVAL, W
0C3C  6E40      	MOVWF CompTempVarRet2673


}
0C3E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x56);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_1(0x10);

	} else {

		FC_CAL_UART_Send_1(0x08);

	}

	FC_CAL_UART_Send_1(FCL_DELAY);

	FC_CAL_UART_Send_1(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_1(FCL_FRAMES);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x76);

	FC_CAL_UART_Send_1(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_1(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_1(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_1(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_1(0x03);

		}
	}

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x65);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RX >> 8);

	FC_CAL_UART_Send_1(FCL_RX);

	FC_CAL_UART_Send_1(FCL_RY >> 8);

	FC_CAL_UART_Send_1(FCL_RY);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);


	FC_CAL_UART_Send_1(0x4F);

	if (FCL_TRANSPARENT)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x53);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_FONT);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Send_1(1);

	FC_CAL_UART_Send_1(1);

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		if (FCL_STR[FCL_IDX] == 0)
		{

			goto FCC_Print_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_STR[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_Print_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x0c);

	FC_CAL_UART_Send_1(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
02A2  6A43      	CLRF FCD_0f051__00062_1_FCL_Y
02A4  6A44      	CLRF FCD_0f051__00062_1_FCL_Y+D'1'

	MX_UINT16 FCL_X = (0x0);
02A6  6A45      	CLRF FCD_0f051__00062_1_FCL_X
02A8  6A46      	CLRF FCD_0f051__00062_1_FCL_X+D'1'



	FC_CAL_UART_Send_1(0x42);
02AA  0E42      	MOVLW 0x42
02AC  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
02AE  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
02B0  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
02B4  5024      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
02B6  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
02B8  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
02BA  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
02BE  5023      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W
02C0  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
02C2  5024      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
02C4  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
02C6  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
02CA  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
02CC  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Send_1(0x45);
02D0  0E45      	MOVLW 0x45
02D2  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
02D4  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
02D6  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
02DA  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
02DC  EC4EF000  	CALL FC_CAL_UAR_00072


}
02E0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x49);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x75);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6C);

	FC_CAL_UART_Send_1(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)

{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
0EB6  5247      	MOVF FCD_0f051__000A5_arg_FCL_T_000A6, F
0EB8  E14D      	BNZ	label133
0EBA  5248      	MOVF FCD_0f051__000A5_arg_FCL_SOLID, F
0EBC  E14B      	BNZ	label133
0F54            label133

	{

		FC_CAL_UART_Send_1(0x70);
0EBE  0E70      	MOVLW 0x70
0EC0  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0EC2  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0EC4  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(0x00);
0EC8  6A4D      	CLRF FC_CAL_UAR_00073_arg_nChar
0ECA  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0ECC  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Receive_1(255);
0ED0  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0ED2  EC4EF000  	CALL FC_CAL_UAR_00072


		FC_CAL_UART_Send_1(0x72);
0ED6  0E72      	MOVLW 0x72
0ED8  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0EDA  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0EDC  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X1 >> 8);
0EE0  5040      	MOVF FCD_0f051__000A5_arg_FCL_X1+D'1', W
0EE2  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0EE4  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0EE6  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X1);
0EEA  503F      	MOVF FCD_0f051__000A5_arg_FCL_X1, W
0EEC  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0EEE  5040      	MOVF FCD_0f051__000A5_arg_FCL_X1+D'1', W
0EF0  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0EF2  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0EF6  5042      	MOVF FCD_0f051__000A5_arg_FCL_Y1+D'1', W
0EF8  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0EFA  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0EFC  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y1);
0F00  5041      	MOVF FCD_0f051__000A5_arg_FCL_Y1, W
0F02  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F04  5042      	MOVF FCD_0f051__000A5_arg_FCL_Y1+D'1', W
0F06  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0F08  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X2 >> 8);
0F0C  5044      	MOVF FCD_0f051__000A5_arg_FCL_X2+D'1', W
0F0E  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F10  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0F12  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X2);
0F16  5043      	MOVF FCD_0f051__000A5_arg_FCL_X2, W
0F18  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F1A  5044      	MOVF FCD_0f051__000A5_arg_FCL_X2+D'1', W
0F1C  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0F1E  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y2 >> 8);
0F22  5046      	MOVF FCD_0f051__000A5_arg_FCL_Y2+D'1', W
0F24  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F26  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0F28  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y2);
0F2C  5045      	MOVF FCD_0f051__000A5_arg_FCL_Y2, W
0F2E  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F30  5046      	MOVF FCD_0f051__000A5_arg_FCL_Y2+D'1', W
0F32  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0F34  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
0F38  5024      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
0F3A  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F3C  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0F3E  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
0F42  5023      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W
0F44  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F46  5024      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
0F48  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0F4A  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Receive_1(255);
0F4E  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0F50  EC4EF000  	CALL FC_CAL_UAR_00072


	// } else {

	}

	FC_CAL_UART_Send_1(0x70);
0F54  0E70      	MOVLW 0x70
0F56  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F58  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0F5A  EC46F000  	CALL FC_CAL_UAR_00073


	if (FCL_SOLID)
0F5E  5248      	MOVF FCD_0f051__000A5_arg_FCL_SOLID, F
0F60  E005      	BZ	label134
0F6C            label134

	{

		FC_CAL_UART_Send_1(0x00);
0F62  6A4D      	CLRF FC_CAL_UAR_00073_arg_nChar
0F64  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0F66  EC46F000  	CALL FC_CAL_UAR_00073


	} else {
0F6A  D005      	BRA	label135
0F76            label135


		FC_CAL_UART_Send_1(0x01);
0F6C  0E01      	MOVLW 0x01
0F6E  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F70  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0F72  EC46F000  	CALL FC_CAL_UAR_00073


	}

	FC_CAL_UART_Receive_1(255);
0F76  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0F78  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Send_1(0x72);
0F7C  0E72      	MOVLW 0x72
0F7E  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F80  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0F82  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0F86  5040      	MOVF FCD_0f051__000A5_arg_FCL_X1+D'1', W
0F88  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F8A  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0F8C  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1);
0F90  503F      	MOVF FCD_0f051__000A5_arg_FCL_X1, W
0F92  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0F94  5040      	MOVF FCD_0f051__000A5_arg_FCL_X1+D'1', W
0F96  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0F98  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0F9C  5042      	MOVF FCD_0f051__000A5_arg_FCL_Y1+D'1', W
0F9E  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0FA0  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0FA2  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1);
0FA6  5041      	MOVF FCD_0f051__000A5_arg_FCL_Y1, W
0FA8  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0FAA  5042      	MOVF FCD_0f051__000A5_arg_FCL_Y1+D'1', W
0FAC  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0FAE  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
0FB2  5044      	MOVF FCD_0f051__000A5_arg_FCL_X2+D'1', W
0FB4  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0FB6  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0FB8  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2);
0FBC  5043      	MOVF FCD_0f051__000A5_arg_FCL_X2, W
0FBE  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0FC0  5044      	MOVF FCD_0f051__000A5_arg_FCL_X2+D'1', W
0FC2  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0FC4  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
0FC8  5046      	MOVF FCD_0f051__000A5_arg_FCL_Y2+D'1', W
0FCA  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0FCC  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0FCE  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2);
0FD2  5045      	MOVF FCD_0f051__000A5_arg_FCL_Y2, W
0FD4  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0FD6  5046      	MOVF FCD_0f051__000A5_arg_FCL_Y2+D'1', W
0FD8  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0FDA  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
0FDE  5026      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
0FE0  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0FE2  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0FE4  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0FE8  5025      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W
0FEA  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0FEC  5026      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
0FEE  6E4E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0FF0  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
0FF4  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0FF6  EC4EF000  	CALL FC_CAL_UAR_00072


}
0FFA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, C, 0x20, 0x5, 0);
0C7A  6A43      	CLRF FCD_0f051__00061_2_ptmp
0C7C  9A94      	BCF gbl_trisc,5
0C7E  5243      	MOVF FCD_0f051__00061_2_ptmp, F
0C80  E004      	BZ	label122
0C82  0E20      	MOVLW 0x20
0C84  108B      	IORWF gbl_latc, W
0C86  6E82      	MOVWF gbl_portc
0C88  D003      	BRA	label123
0C8A            label122
0C8A  0EDF      	MOVLW 0xDF
0C8C  148B      	ANDWF gbl_latc, W
0C8E  6E82      	MOVWF gbl_portc
0C90            label123


	FC_CAL_UART_Init_1();
0C90  ECA0F000  	CALL FC_CAL_UAR_00074


	FCI_DELAYBYTE_US(100);
0C94  0E64      	MOVLW 0x64
0C96  6E43      	MOVWF delay_us_00000_arg_del
0C98  EC2EF000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, C, 0x20, 0x5);
0C9C  0E0F      	MOVLW HIGH(gbl_portc+D'0')
0C9E  6E44      	MOVWF FC_CAL_Por_00042_arg_Port+D'1'
0CA0  0E82      	MOVLW LOW(gbl_portc+D'0')
0CA2  6E43      	MOVWF FC_CAL_Por_00042_arg_Port
0CA4  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
0CA6  6E46      	MOVWF FC_CAL_Por_00042_arg_Tris+D'1'
0CA8  0E94      	MOVLW LOW(gbl_trisc+D'0')
0CAA  6E45      	MOVWF FC_CAL_Por_00042_arg_Tris
0CAC  0E20      	MOVLW 0x20
0CAE  6E47      	MOVWF FC_CAL_Por_00042_arg_InMask
0CB0  0E05      	MOVLW 0x05
0CB2  6E48      	MOVWF FC_CAL_Por_00042_arg_Shift
0CB4  ECF1F000  	CALL FC_CAL_Por_00042
0CB8  5049      	MOVF CompTempVarRet1822, W
0CBA  6E42      	MOVWF FCD_0f051__00061_1_FCL_DUMMY


	FCI_DELAYBYTE_S(3);
0CBC  0E03      	MOVLW 0x03
0CBE  6E43      	MOVWF delay_s_00000_arg_del
0CC0  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_1(0);
0CC4  6A4D      	CLRF FC_CAL_UAR_00072_arg_nTimeout
0CC6  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(0);
0CCA  6A4D      	CLRF FC_CAL_UAR_00072_arg_nTimeout
0CCC  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(0);
0CD0  6A4D      	CLRF FC_CAL_UAR_00072_arg_nTimeout
0CD2  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Send_1(0x55);
0CD6  0E55      	MOVLW 0x55
0CD8  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0CDA  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0CDC  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
0CE0  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0CE2  EC4EF000  	CALL FC_CAL_UAR_00072


	#if (1) // 1 == 1

		#if (1) // 1 != 0

			FC_CAL_UART_Send_1(0x51);
0CE6  0E51      	MOVLW 0x51
0CE8  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0CEA  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0CEC  EC46F000  	CALL FC_CAL_UAR_00073


			FC_CAL_UART_Send_1(0x0C);
0CF0  0E0C      	MOVLW 0x0C
0CF2  6E4D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0CF4  6A4E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0CF6  EC46F000  	CALL FC_CAL_UAR_00073


			FC_CAL_UART_Receive_1(255);
0CFA  684D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0CFC  EC4EF000  	CALL FC_CAL_UAR_00072


			FC_CAL_UART_UpdateBaud_1(6);
0D00  0E06      	MOVLW 0x06
0D02  6E43      	MOVWF FC_CAL_UAR_00070_arg_new_baud
0D04  ECA9F000  	CALL FC_CAL_UAR_00070



		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_1(10);
0D08  0E0A      	MOVLW 0x0A
0D0A  6E4D      	MOVWF FC_CAL_UAR_00072_arg_nTimeout
0D0C  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(10);
0D10  0E0A      	MOVLW 0x0A
0D12  6E4D      	MOVWF FC_CAL_UAR_00072_arg_nTimeout
0D14  EC4EF000  	CALL FC_CAL_UAR_00072


	FCL_RED = 0 & 0xFF;
0D18  6A3F      	CLRF FCD_0f051__00061_1_FCL_RED

	FCL_RED = FCL_RED >> (8 - 5);
0D1A  323F      	RRCF FCD_0f051__00061_1_FCL_RED, F
0D1C  323F      	RRCF FCD_0f051__00061_1_FCL_RED, F
0D1E  323F      	RRCF FCD_0f051__00061_1_FCL_RED, F
0D20  0E1F      	MOVLW 0x1F
0D22  163F      	ANDWF FCD_0f051__00061_1_FCL_RED, F

	FCL_GREEN = (0 >> 8) & 0xFF;
0D24  6A40      	CLRF FCD_0f051__00061_1_FCL_GREEN

	FCL_GREEN = FCL_GREEN >> (8 - 6);
0D26  3240      	RRCF FCD_0f051__00061_1_FCL_GREEN, F
0D28  3240      	RRCF FCD_0f051__00061_1_FCL_GREEN, F
0D2A  0E3F      	MOVLW 0x3F
0D2C  1640      	ANDWF FCD_0f051__00061_1_FCL_GREEN, F

	FCL_BLUE = (0 >> 16) & 0xFF;
0D2E  6A41      	CLRF FCD_0f051__00061_1_FCL_BLUE

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0D30  3241      	RRCF FCD_0f051__00061_1_FCL_BLUE, F
0D32  3241      	RRCF FCD_0f051__00061_1_FCL_BLUE, F
0D34  3241      	RRCF FCD_0f051__00061_1_FCL_BLUE, F
0D36  0E1F      	MOVLW 0x1F
0D38  1641      	ANDWF FCD_0f051__00061_1_FCL_BLUE, F

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
0D3A  5040      	MOVF FCD_0f051__00061_1_FCL_GREEN, W
0D3C  6E43      	MOVWF CompTempVar2651
0D3E  6A26      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1'
0D40  3643      	RLCF CompTempVar2651, F
0D42  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0D44  3643      	RLCF CompTempVar2651, F
0D46  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0D48  3643      	RLCF CompTempVar2651, F
0D4A  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0D4C  3643      	RLCF CompTempVar2651, F
0D4E  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0D50  3643      	RLCF CompTempVar2651, F
0D52  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0D54  0EE0      	MOVLW 0xE0
0D56  1643      	ANDWF CompTempVar2651, F
0D58  5043      	MOVF CompTempVar2651, W
0D5A  1041      	IORWF FCD_0f051__00061_1_FCL_BLUE, W
0D5C  6E25      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
0D5E  6A43      	CLRF CompTempVar2655
0D60  503F      	MOVF FCD_0f051__00061_1_FCL_RED, W
0D62  6E44      	MOVWF CompTempVar2656
0D64  90D8      	BCF STATUS,C
0D66  3644      	RLCF CompTempVar2656, F
0D68  90D8      	BCF STATUS,C
0D6A  3644      	RLCF CompTempVar2656, F
0D6C  90D8      	BCF STATUS,C
0D6E  3644      	RLCF CompTempVar2656, F
0D70  5043      	MOVF CompTempVar2655, W
0D72  1225      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F
0D74  5044      	MOVF CompTempVar2656, W
0D76  1226      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F

	FCL_RED = 16777215 & 0xFF;
0D78  683F      	SETF FCD_0f051__00061_1_FCL_RED

	FCL_RED = FCL_RED >> (8 - 5);
0D7A  323F      	RRCF FCD_0f051__00061_1_FCL_RED, F
0D7C  323F      	RRCF FCD_0f051__00061_1_FCL_RED, F
0D7E  323F      	RRCF FCD_0f051__00061_1_FCL_RED, F
0D80  0E1F      	MOVLW 0x1F
0D82  163F      	ANDWF FCD_0f051__00061_1_FCL_RED, F

	FCL_GREEN = (16777215 >> 8) & 0xFF;
0D84  6840      	SETF FCD_0f051__00061_1_FCL_GREEN

	FCL_GREEN = FCL_GREEN >> (8 - 6);
0D86  3240      	RRCF FCD_0f051__00061_1_FCL_GREEN, F
0D88  3240      	RRCF FCD_0f051__00061_1_FCL_GREEN, F
0D8A  0E3F      	MOVLW 0x3F
0D8C  1640      	ANDWF FCD_0f051__00061_1_FCL_GREEN, F

	FCL_BLUE = (16777215 >> 16) & 0xFF;
0D8E  6841      	SETF FCD_0f051__00061_1_FCL_BLUE

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0D90  3241      	RRCF FCD_0f051__00061_1_FCL_BLUE, F
0D92  3241      	RRCF FCD_0f051__00061_1_FCL_BLUE, F
0D94  3241      	RRCF FCD_0f051__00061_1_FCL_BLUE, F
0D96  0E1F      	MOVLW 0x1F
0D98  1641      	ANDWF FCD_0f051__00061_1_FCL_BLUE, F

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
0D9A  5040      	MOVF FCD_0f051__00061_1_FCL_GREEN, W
0D9C  6E43      	MOVWF CompTempVar2662
0D9E  6A24      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1'
0DA0  3643      	RLCF CompTempVar2662, F
0DA2  3624      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
0DA4  3643      	RLCF CompTempVar2662, F
0DA6  3624      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
0DA8  3643      	RLCF CompTempVar2662, F
0DAA  3624      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
0DAC  3643      	RLCF CompTempVar2662, F
0DAE  3624      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
0DB0  3643      	RLCF CompTempVar2662, F
0DB2  3624      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
0DB4  0EE0      	MOVLW 0xE0
0DB6  1643      	ANDWF CompTempVar2662, F
0DB8  5043      	MOVF CompTempVar2662, W
0DBA  1041      	IORWF FCD_0f051__00061_1_FCL_BLUE, W
0DBC  6E23      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
0DBE  6A43      	CLRF CompTempVar2666
0DC0  503F      	MOVF FCD_0f051__00061_1_FCL_RED, W
0DC2  6E44      	MOVWF CompTempVar2667
0DC4  90D8      	BCF STATUS,C
0DC6  3644      	RLCF CompTempVar2667, F
0DC8  90D8      	BCF STATUS,C
0DCA  3644      	RLCF CompTempVar2667, F
0DCC  90D8      	BCF STATUS,C
0DCE  3644      	RLCF CompTempVar2667, F
0DD0  5043      	MOVF CompTempVar2666, W
0DD2  1223      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F
0DD4  5044      	MOVF CompTempVar2667, W
0DD6  1224      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
0DD8  EC51F001  	CALL FCD_0f051__00062


	FC_CAL_UART_Receive_1(10);
0DDC  0E0A      	MOVLW 0x0A
0DDE  6E4D      	MOVWF FC_CAL_UAR_00072_arg_nTimeout
0DE0  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(10);
0DE4  0E0A      	MOVLW 0x0A
0DE6  6E4D      	MOVWF FC_CAL_UAR_00072_arg_nTimeout
0DE8  EC4EF000  	CALL FC_CAL_UAR_00072


}
0DEC  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_144()

{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
09FE  0E18      	MOVLW 0x18
0A00  5C1F      	SUBWF gbl_FCV_Y, W
0A02  E205      	BC	label99
0A04  6620      	TSTFSZ gbl_FCV_Y+D'1'
0A06  D003      	BRA	label99
0A0E            label99

	{

		// Calcul
		// Calcul:
		//  hitbox = 6
		FCV_HITBOX = 6;
0A08  0E06      	MOVLW 0x06
0A0A  6E34      	MOVWF gbl_FCV_HITBOX


	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
0A0E  0E30      	MOVLW 0x30
0A10  5C1F      	SUBWF gbl_FCV_Y, W
0A12  E205      	BC	label100
0A14  6620      	TSTFSZ gbl_FCV_Y+D'1'
0A16  D003      	BRA	label100
0A1E            label100

		{

			// Calcul
			// Calcul:
			//  hitbox = 16
			FCV_HITBOX = 16;
0A18  0E10      	MOVLW 0x10
0A1A  6E34      	MOVWF gbl_FCV_HITBOX


		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
0A1E  0E48      	MOVLW 0x48
0A20  5C1F      	SUBWF gbl_FCV_Y, W
0A22  E205      	BC	label101
0A24  6620      	TSTFSZ gbl_FCV_Y+D'1'
0A26  D003      	BRA	label101
0A2E            label101

			{

				// Calcul
				// Calcul:
				//  hitbox = 26
				FCV_HITBOX = 26;
0A28  0E1A      	MOVLW 0x1A
0A2A  6E34      	MOVWF gbl_FCV_HITBOX


			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
0A2E  0E60      	MOVLW 0x60
0A30  5C1F      	SUBWF gbl_FCV_Y, W
0A32  E205      	BC	label102
0A34  6620      	TSTFSZ gbl_FCV_Y+D'1'
0A36  D003      	BRA	label102
0A3E            label102

				{

					// Calcul
					// Calcul:
					//  hitbox = 36
					FCV_HITBOX = 36;
0A38  0E24      	MOVLW 0x24
0A3A  6E34      	MOVWF gbl_FCV_HITBOX


				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
0A3E  0E78      	MOVLW 0x78
0A40  5C1F      	SUBWF gbl_FCV_Y, W
0A42  E205      	BC	label103
0A44  6620      	TSTFSZ gbl_FCV_Y+D'1'
0A46  D003      	BRA	label103
0A4E            label103

					{

						// 
						// Calcul:
						//  hitbox = 46
						FCV_HITBOX = 46;
0A48  0E2E      	MOVLW 0x2E
0A4A  6E34      	MOVWF gbl_FCV_HITBOX


					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
0A4E  0E90      	MOVLW 0x90
0A50  5C1F      	SUBWF gbl_FCV_Y, W
0A52  E205      	BC	label104
0A54  6620      	TSTFSZ gbl_FCV_Y+D'1'
0A56  D003      	BRA	label104
0A5E            label104

						{

							// Calcul
							// Calcul:
							//  hitbox = 56
							FCV_HITBOX = 56;
0A58  0E38      	MOVLW 0x38
0A5A  6E34      	MOVWF gbl_FCV_HITBOX


						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
0A5E  0EA8      	MOVLW 0xA8
0A60  5C1F      	SUBWF gbl_FCV_Y, W
0A62  E205      	BC	label105
0A64  6620      	TSTFSZ gbl_FCV_Y+D'1'
0A66  D003      	BRA	label105
0A6E            label105

							{

								// Calcul
								// Calcul:
								//  hitbox = 66
								FCV_HITBOX = 66;
0A68  0E42      	MOVLW 0x42
0A6A  6E34      	MOVWF gbl_FCV_HITBOX


							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
0A6E  0EC0      	MOVLW 0xC0
0A70  5C1F      	SUBWF gbl_FCV_Y, W
0A72  E205      	BC	label106
0A74  6620      	TSTFSZ gbl_FCV_Y+D'1'
0A76  D003      	BRA	label106
0A7E            label106

								{

									// Calcul
									// Calcul:
									//  hitbox = 76
									FCV_HITBOX = 76;
0A78  0E4C      	MOVLW 0x4C
0A7A  6E34      	MOVWF gbl_FCV_HITBOX


								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
0A7E  0ED8      	MOVLW 0xD8
0A80  5C1F      	SUBWF gbl_FCV_Y, W
0A82  E205      	BC	label107
0A84  6620      	TSTFSZ gbl_FCV_Y+D'1'
0A86  D003      	BRA	label107
0A8E            label107

									{

										// Calcul
										// Calcul:
										//  hitbox = 86
										FCV_HITBOX = 86;
0A88  0E56      	MOVLW 0x56
0A8A  6E34      	MOVWF gbl_FCV_HITBOX


									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
0A8E  0EF0      	MOVLW 0xF0
0A90  5C1F      	SUBWF gbl_FCV_Y, W
0A92  B0D8      	BTFSC STATUS,C
0A96  6620      	TSTFSZ gbl_FCV_Y+D'1'

										{

											// Calcul
											// Calcul:
											//  hitbox = 96
											FCV_HITBOX = 96;
0A9A  0E60      	MOVLW 0x60
0A9C  6E34      	MOVWF gbl_FCV_HITBOX


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
0A0C  0012      	RETURN
0A1C  0012      	RETURN
0A2C  0012      	RETURN
0A3C  0012      	RETURN
0A4C  0012      	RETURN
0A5C  0012      	RETURN
0A6C  0012      	RETURN
0A7C  0012      	RETURN
0A8C  0012      	RETURN
0A94  0012      	RETURN
0A98  0012      	RETURN
0A9E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_test()
{
	//Définitions des variables locales
	MX_UINT8 FCL_VAR1 = (0x0);
	MX_UINT8 FCL_VAR2;


	// Calcul
	// Calcul:
	//  .var1 = .var2
	FCL_VAR1 = FCL_VAR2;

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(.var1, .var2, Y)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(FCL_VAR1, FCL_VAR2, FCV_Y);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Affichage_bateau1()
{
	//Définitions des variables locales
	MX_UINT8 FCL_COULEUR_BLEU;
	MX_UINT8 FCL_COULEUR_ROUGE;
	MX_UINT8 FCL_COULEUR_VERT;
	MX_UINT16 FCL_POS_X1;
	MX_UINT16 FCL_POS_X2;
	MX_UINT8 FCL_POS_Y1;
	MX_UINT8 FCL_POS_Y2;


}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_72()

{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
0590  0E18      	MOVLW 0x18
0592  5C1F      	SUBWF gbl_FCV_Y, W
0594  E205      	BC	label36
0596  6620      	TSTFSZ gbl_FCV_Y+D'1'
0598  D003      	BRA	label36
05A0            label36

	{

		// Calcul
		// Calcul:
		//  hitbox = 3
		FCV_HITBOX = 3;
059A  0E03      	MOVLW 0x03
059C  6E34      	MOVWF gbl_FCV_HITBOX


	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
05A0  0E30      	MOVLW 0x30
05A2  5C1F      	SUBWF gbl_FCV_Y, W
05A4  E205      	BC	label37
05A6  6620      	TSTFSZ gbl_FCV_Y+D'1'
05A8  D003      	BRA	label37
05B0            label37

		{

			// Calcul
			// Calcul:
			//  hitbox = 13
			FCV_HITBOX = 13;
05AA  0E0D      	MOVLW 0x0D
05AC  6E34      	MOVWF gbl_FCV_HITBOX


		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
05B0  0E48      	MOVLW 0x48
05B2  5C1F      	SUBWF gbl_FCV_Y, W
05B4  E205      	BC	label38
05B6  6620      	TSTFSZ gbl_FCV_Y+D'1'
05B8  D003      	BRA	label38
05C0            label38

			{

				// Calcul
				// Calcul:
				//  hitbox = 23
				FCV_HITBOX = 23;
05BA  0E17      	MOVLW 0x17
05BC  6E34      	MOVWF gbl_FCV_HITBOX


			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
05C0  0E60      	MOVLW 0x60
05C2  5C1F      	SUBWF gbl_FCV_Y, W
05C4  E205      	BC	label39
05C6  6620      	TSTFSZ gbl_FCV_Y+D'1'
05C8  D003      	BRA	label39
05D0            label39

				{

					// Calcul
					// Calcul:
					//  hitbox = 33
					FCV_HITBOX = 33;
05CA  0E21      	MOVLW 0x21
05CC  6E34      	MOVWF gbl_FCV_HITBOX


				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
05D0  0E78      	MOVLW 0x78
05D2  5C1F      	SUBWF gbl_FCV_Y, W
05D4  E205      	BC	label40
05D6  6620      	TSTFSZ gbl_FCV_Y+D'1'
05D8  D003      	BRA	label40
05E0            label40

					{

						// Calcul
						// Calcul:
						//  hitbox = 43
						FCV_HITBOX = 43;
05DA  0E2B      	MOVLW 0x2B
05DC  6E34      	MOVWF gbl_FCV_HITBOX


					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
05E0  0E90      	MOVLW 0x90
05E2  5C1F      	SUBWF gbl_FCV_Y, W
05E4  E205      	BC	label41
05E6  6620      	TSTFSZ gbl_FCV_Y+D'1'
05E8  D003      	BRA	label41
05F0            label41

						{

							// Calcul
							// Calcul:
							//  hitbox = 53
							FCV_HITBOX = 53;
05EA  0E35      	MOVLW 0x35
05EC  6E34      	MOVWF gbl_FCV_HITBOX


						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
05F0  0EA8      	MOVLW 0xA8
05F2  5C1F      	SUBWF gbl_FCV_Y, W
05F4  E205      	BC	label42
05F6  6620      	TSTFSZ gbl_FCV_Y+D'1'
05F8  D003      	BRA	label42
0600            label42

							{

								// Calcul
								// Calcul:
								//  hitbox = 63
								FCV_HITBOX = 63;
05FA  0E3F      	MOVLW 0x3F
05FC  6E34      	MOVWF gbl_FCV_HITBOX


							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
0600  0EC0      	MOVLW 0xC0
0602  5C1F      	SUBWF gbl_FCV_Y, W
0604  E205      	BC	label43
0606  6620      	TSTFSZ gbl_FCV_Y+D'1'
0608  D003      	BRA	label43
0610            label43

								{

									// Calcul
									// Calcul:
									//  hitbox = 73
									FCV_HITBOX = 73;
060A  0E49      	MOVLW 0x49
060C  6E34      	MOVWF gbl_FCV_HITBOX


								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
0610  0ED8      	MOVLW 0xD8
0612  5C1F      	SUBWF gbl_FCV_Y, W
0614  E205      	BC	label44
0616  6620      	TSTFSZ gbl_FCV_Y+D'1'
0618  D003      	BRA	label44
0620            label44

									{

										// Calcul
										// Calcul:
										//  hitbox = 83
										FCV_HITBOX = 83;
061A  0E53      	MOVLW 0x53
061C  6E34      	MOVWF gbl_FCV_HITBOX


									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
0620  0EF0      	MOVLW 0xF0
0622  5C1F      	SUBWF gbl_FCV_Y, W
0624  B0D8      	BTFSC STATUS,C
0628  6620      	TSTFSZ gbl_FCV_Y+D'1'

										{

											// Calcul
											// Calcul:
											//  hitbox = 93
											FCV_HITBOX = 93;
062C  0E5D      	MOVLW 0x5D
062E  6E34      	MOVWF gbl_FCV_HITBOX


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
059E  0012      	RETURN
05AE  0012      	RETURN
05BE  0012      	RETURN
05CE  0012      	RETURN
05DE  0012      	RETURN
05EE  0012      	RETURN
05FE  0012      	RETURN
060E  0012      	RETURN
061E  0012      	RETURN
0626  0012      	RETURN
062A  0012      	RETURN
0630  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro test2 :
       :  jhvjh : MX_UINT8
       :  gfyhg : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCM_test2(MX_UINT8 FCL_JHVJH, MX_UINT8 FCL_GFYHG)
{

	// Calcul
	// Calcul:
	//  .jhvjh = .gfyhg
	FCL_JHVJH = FCL_GFYHG;

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_168()

{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
095C  0E18      	MOVLW 0x18
095E  5C1F      	SUBWF gbl_FCV_Y, W
0960  E205      	BC	label90
0962  6620      	TSTFSZ gbl_FCV_Y+D'1'
0964  D003      	BRA	label90
096C            label90

	{

		// Calcul
		// Calcul:
		//  hitbox = 7
		FCV_HITBOX = 7;
0966  0E07      	MOVLW 0x07
0968  6E34      	MOVWF gbl_FCV_HITBOX


	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
096C  0E30      	MOVLW 0x30
096E  5C1F      	SUBWF gbl_FCV_Y, W
0970  E205      	BC	label91
0972  6620      	TSTFSZ gbl_FCV_Y+D'1'
0974  D003      	BRA	label91
097C            label91

		{

			// Calcul
			// Calcul:
			//  hitbox = 17
			FCV_HITBOX = 17;
0976  0E11      	MOVLW 0x11
0978  6E34      	MOVWF gbl_FCV_HITBOX


		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
097C  0E48      	MOVLW 0x48
097E  5C1F      	SUBWF gbl_FCV_Y, W
0980  E205      	BC	label92
0982  6620      	TSTFSZ gbl_FCV_Y+D'1'
0984  D003      	BRA	label92
098C            label92

			{

				// Calcul
				// Calcul:
				//  hitbox = 27
				FCV_HITBOX = 27;
0986  0E1B      	MOVLW 0x1B
0988  6E34      	MOVWF gbl_FCV_HITBOX


			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
098C  0E60      	MOVLW 0x60
098E  5C1F      	SUBWF gbl_FCV_Y, W
0990  E205      	BC	label93
0992  6620      	TSTFSZ gbl_FCV_Y+D'1'
0994  D003      	BRA	label93
099C            label93

				{

					// Calcul
					// Calcul:
					//  hitbox = 37
					FCV_HITBOX = 37;
0996  0E25      	MOVLW 0x25
0998  6E34      	MOVWF gbl_FCV_HITBOX


				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
099C  0E78      	MOVLW 0x78
099E  5C1F      	SUBWF gbl_FCV_Y, W
09A0  E205      	BC	label94
09A2  6620      	TSTFSZ gbl_FCV_Y+D'1'
09A4  D003      	BRA	label94
09AC            label94

					{

						// 
						// Calcul:
						//  hitbox = 47
						FCV_HITBOX = 47;
09A6  0E2F      	MOVLW 0x2F
09A8  6E34      	MOVWF gbl_FCV_HITBOX


					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
09AC  0E90      	MOVLW 0x90
09AE  5C1F      	SUBWF gbl_FCV_Y, W
09B0  E205      	BC	label95
09B2  6620      	TSTFSZ gbl_FCV_Y+D'1'
09B4  D003      	BRA	label95
09BC            label95

						{

							// Calcul
							// Calcul:
							//  hitbox = 57
							FCV_HITBOX = 57;
09B6  0E39      	MOVLW 0x39
09B8  6E34      	MOVWF gbl_FCV_HITBOX


						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
09BC  0EA8      	MOVLW 0xA8
09BE  5C1F      	SUBWF gbl_FCV_Y, W
09C0  E205      	BC	label96
09C2  6620      	TSTFSZ gbl_FCV_Y+D'1'
09C4  D003      	BRA	label96
09CC            label96

							{

								// Calcul
								// Calcul:
								//  hitbox = 67
								FCV_HITBOX = 67;
09C6  0E43      	MOVLW 0x43
09C8  6E34      	MOVWF gbl_FCV_HITBOX


							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
09CC  0EC0      	MOVLW 0xC0
09CE  5C1F      	SUBWF gbl_FCV_Y, W
09D0  E205      	BC	label97
09D2  6620      	TSTFSZ gbl_FCV_Y+D'1'
09D4  D003      	BRA	label97
09DC            label97

								{

									// Calcul
									// Calcul:
									//  hitbox = 77
									FCV_HITBOX = 77;
09D6  0E4D      	MOVLW 0x4D
09D8  6E34      	MOVWF gbl_FCV_HITBOX


								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
09DC  0ED8      	MOVLW 0xD8
09DE  5C1F      	SUBWF gbl_FCV_Y, W
09E0  E205      	BC	label98
09E2  6620      	TSTFSZ gbl_FCV_Y+D'1'
09E4  D003      	BRA	label98
09EC            label98

									{

										// Calcul
										// Calcul:
										//  hitbox = 87
										FCV_HITBOX = 87;
09E6  0E57      	MOVLW 0x57
09E8  6E34      	MOVWF gbl_FCV_HITBOX


									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
09EC  0EF0      	MOVLW 0xF0
09EE  5C1F      	SUBWF gbl_FCV_Y, W
09F0  B0D8      	BTFSC STATUS,C
09F4  6620      	TSTFSZ gbl_FCV_Y+D'1'

										{

											// Calcul
											// Calcul:
											//  hitbox = 97
											FCV_HITBOX = 97;
09F8  0E61      	MOVLW 0x61
09FA  6E34      	MOVWF gbl_FCV_HITBOX


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
096A  0012      	RETURN
097A  0012      	RETURN
098A  0012      	RETURN
099A  0012      	RETURN
09AA  0012      	RETURN
09BA  0012      	RETURN
09CA  0012      	RETURN
09DA  0012      	RETURN
09EA  0012      	RETURN
09F2  0012      	RETURN
09F6  0012      	RETURN
09FC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Initialisation()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
0E02  EC3DF006  	CALL FCD_0f051__00061


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
0E06  EC51F001  	CALL FCD_0f051__00062


	// lignes horizontales
	// Appel d'une Macro: lignesH()
	FCM_lignesH();
0E0A  ECF4F001  	CALL FCM_lignes_00063


	// Appel d'une Macro
	// Appel d'une Macro: lignesV()
	FCM_lignesV();
0E0E  EC71F001  	CALL FCM_lignes_00064


}
0E12  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_tactile()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_DisableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
0DEE  EC20F006  	CALL FCD_0f051__00066


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_EnableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
0DF2  ECF0F005  	CALL FCD_0f051__00067


}
0DF6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_96()

{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
04EE  0E18      	MOVLW 0x18
04F0  5C1F      	SUBWF gbl_FCV_Y, W
04F2  E205      	BC	label27
04F4  6620      	TSTFSZ gbl_FCV_Y+D'1'
04F6  D003      	BRA	label27
04FE            label27

	{

		// Calcul
		// Calcul:
		//  hitbox = 4
		FCV_HITBOX = 4;
04F8  0E04      	MOVLW 0x04
04FA  6E34      	MOVWF gbl_FCV_HITBOX


	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
04FE  0E30      	MOVLW 0x30
0500  5C1F      	SUBWF gbl_FCV_Y, W
0502  E205      	BC	label28
0504  6620      	TSTFSZ gbl_FCV_Y+D'1'
0506  D003      	BRA	label28
050E            label28

		{

			// Calcul
			// Calcul:
			//  hitbox = 14
			FCV_HITBOX = 14;
0508  0E0E      	MOVLW 0x0E
050A  6E34      	MOVWF gbl_FCV_HITBOX


		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
050E  0E48      	MOVLW 0x48
0510  5C1F      	SUBWF gbl_FCV_Y, W
0512  E205      	BC	label29
0514  6620      	TSTFSZ gbl_FCV_Y+D'1'
0516  D003      	BRA	label29
051E            label29

			{

				// Calcul
				// Calcul:
				//  hitbox = 24
				FCV_HITBOX = 24;
0518  0E18      	MOVLW 0x18
051A  6E34      	MOVWF gbl_FCV_HITBOX


			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
051E  0E60      	MOVLW 0x60
0520  5C1F      	SUBWF gbl_FCV_Y, W
0522  E205      	BC	label30
0524  6620      	TSTFSZ gbl_FCV_Y+D'1'
0526  D003      	BRA	label30
052E            label30

				{

					// Calcul
					// Calcul:
					//  hitbox = 34
					FCV_HITBOX = 34;
0528  0E22      	MOVLW 0x22
052A  6E34      	MOVWF gbl_FCV_HITBOX


				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
052E  0E78      	MOVLW 0x78
0530  5C1F      	SUBWF gbl_FCV_Y, W
0532  E205      	BC	label31
0534  6620      	TSTFSZ gbl_FCV_Y+D'1'
0536  D003      	BRA	label31
053E            label31

					{

						// 
						// Calcul:
						//  hitbox = 44
						FCV_HITBOX = 44;
0538  0E2C      	MOVLW 0x2C
053A  6E34      	MOVWF gbl_FCV_HITBOX


					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
053E  0E90      	MOVLW 0x90
0540  5C1F      	SUBWF gbl_FCV_Y, W
0542  E205      	BC	label32
0544  6620      	TSTFSZ gbl_FCV_Y+D'1'
0546  D003      	BRA	label32
054E            label32

						{

							// Calcul
							// Calcul:
							//  hitbox = 54
							FCV_HITBOX = 54;
0548  0E36      	MOVLW 0x36
054A  6E34      	MOVWF gbl_FCV_HITBOX


						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
054E  0EA8      	MOVLW 0xA8
0550  5C1F      	SUBWF gbl_FCV_Y, W
0552  E205      	BC	label33
0554  6620      	TSTFSZ gbl_FCV_Y+D'1'
0556  D003      	BRA	label33
055E            label33

							{

								// Calcul
								// Calcul:
								//  hitbox = 64
								FCV_HITBOX = 64;
0558  0E40      	MOVLW 0x40
055A  6E34      	MOVWF gbl_FCV_HITBOX


							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
055E  0EC0      	MOVLW 0xC0
0560  5C1F      	SUBWF gbl_FCV_Y, W
0562  E205      	BC	label34
0564  6620      	TSTFSZ gbl_FCV_Y+D'1'
0566  D003      	BRA	label34
056E            label34

								{

									// Calcul
									// Calcul:
									//  hitbox = 74
									FCV_HITBOX = 74;
0568  0E4A      	MOVLW 0x4A
056A  6E34      	MOVWF gbl_FCV_HITBOX


								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
056E  0ED8      	MOVLW 0xD8
0570  5C1F      	SUBWF gbl_FCV_Y, W
0572  E205      	BC	label35
0574  6620      	TSTFSZ gbl_FCV_Y+D'1'
0576  D003      	BRA	label35
057E            label35

									{

										// Calcul
										// Calcul:
										//  hitbox = 84
										FCV_HITBOX = 84;
0578  0E54      	MOVLW 0x54
057A  6E34      	MOVWF gbl_FCV_HITBOX


									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
057E  0EF0      	MOVLW 0xF0
0580  5C1F      	SUBWF gbl_FCV_Y, W
0582  B0D8      	BTFSC STATUS,C
0586  6620      	TSTFSZ gbl_FCV_Y+D'1'

										{

											// Calcul
											// Calcul:
											//  hitbox = 94
											FCV_HITBOX = 94;
058A  0E5E      	MOVLW 0x5E
058C  6E34      	MOVWF gbl_FCV_HITBOX


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
04FC  0012      	RETURN
050C  0012      	RETURN
051C  0012      	RETURN
052C  0012      	RETURN
053C  0012      	RETURN
054C  0012      	RETURN
055C  0012      	RETURN
056C  0012      	RETURN
057C  0012      	RETURN
0584  0012      	RETURN
0588  0012      	RETURN
058E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Hitbox()

{

	// Décision
	// Décision: X < 24?
	if (FCV_X < 24)
0E14  0E18      	MOVLW 0x18
0E16  5C21      	SUBWF gbl_FCV_X, W
0E18  E205      	BC	label124
0E1A  6622      	TSTFSZ gbl_FCV_X+D'1'
0E1C  D003      	BRA	label124
0E24            label124

	{

		// Appel d'une Macro
		// Appel d'une Macro: X_24()
		FCM_X_24();
0E1E  EC6AF003  	CALL FCM_X_24_00000


	} else {

		// Décision
		// Décision: X < 48?
		if (FCV_X < 48)
0E24  0E30      	MOVLW 0x30
0E26  5C21      	SUBWF gbl_FCV_X, W
0E28  E205      	BC	label125
0E2A  6622      	TSTFSZ gbl_FCV_X+D'1'
0E2C  D003      	BRA	label125
0E34            label125

		{

			// Appel d'une Macro
			// Appel d'une Macro: X_48()
			FCM_X_48();
0E2E  EC19F003  	CALL FCM_X_48_00000


		} else {

			// Décision
			// Décision: X < 72?
			if (FCV_X < 72)
0E34  0E48      	MOVLW 0x48
0E36  5C21      	SUBWF gbl_FCV_X, W
0E38  E205      	BC	label126
0E3A  6622      	TSTFSZ gbl_FCV_X+D'1'
0E3C  D003      	BRA	label126
0E44            label126

			{

				// Appel d'une Macro
				// Appel d'une Macro: X_72()
				FCM_X_72();
0E3E  ECC8F002  	CALL FCM_X_72_00000


			} else {

				// Décision
				// Décision: X < 96?
				if (FCV_X < 96)
0E44  0E60      	MOVLW 0x60
0E46  5C21      	SUBWF gbl_FCV_X, W
0E48  E205      	BC	label127
0E4A  6622      	TSTFSZ gbl_FCV_X+D'1'
0E4C  D003      	BRA	label127
0E54            label127

				{

					// Appel d'une Macro
					// Appel d'une Macro: X_96()
					FCM_X_96();
0E4E  EC77F002  	CALL FCM_X_96_00000


				} else {

					// Décision
					// Décision: X < 120?
					if (FCV_X < 120)
0E54  0E78      	MOVLW 0x78
0E56  5C21      	SUBWF gbl_FCV_X, W
0E58  E205      	BC	label128
0E5A  6622      	TSTFSZ gbl_FCV_X+D'1'
0E5C  D003      	BRA	label128
0E64            label128

					{

						// Appel d'une Macro
						// Appel d'une Macro: X_120()
						FCM_X_120();
0E5E  EC50F005  	CALL FCM_X_120_00000


					} else {

						// Décision
						// Décision: X < 144?
						if (FCV_X < 144)
0E64  0E90      	MOVLW 0x90
0E66  5C21      	SUBWF gbl_FCV_X, W
0E68  E205      	BC	label129
0E6A  6622      	TSTFSZ gbl_FCV_X+D'1'
0E6C  D003      	BRA	label129
0E74            label129

						{

							// Appel d'une Macro
							// Appel d'une Macro: X_144()
							FCM_X_144();
0E6E  ECFFF004  	CALL FCM_X_144_00000


						} else {

							// Décision
							// Décision: X < 168?
							if (FCV_X < 168)
0E74  0EA8      	MOVLW 0xA8
0E76  5C21      	SUBWF gbl_FCV_X, W
0E78  E205      	BC	label130
0E7A  6622      	TSTFSZ gbl_FCV_X+D'1'
0E7C  D003      	BRA	label130
0E84            label130

							{

								// Appel d'une Macro
								// Appel d'une Macro: X_168()
								FCM_X_168();
0E7E  ECAEF004  	CALL FCM_X_168_00000


							} else {

								// Décision
								// Décision: X < 192?
								if (FCV_X < 192)
0E84  0EC0      	MOVLW 0xC0
0E86  5C21      	SUBWF gbl_FCV_X, W
0E88  E205      	BC	label131
0E8A  6622      	TSTFSZ gbl_FCV_X+D'1'
0E8C  D003      	BRA	label131
0E94            label131

								{

									// Appel d'une Macro
									// Appel d'une Macro: X_192()
									FCM_X_192();
0E8E  EC5DF004  	CALL FCM_X_192_00000


								} else {

									// Décision
									// Décision: X < 216?
									if (FCV_X < 216)
0E94  0ED8      	MOVLW 0xD8
0E96  5C21      	SUBWF gbl_FCV_X, W
0E98  E205      	BC	label132
0E9A  6622      	TSTFSZ gbl_FCV_X+D'1'
0E9C  D003      	BRA	label132
0EA4            label132

									{

										// Appel d'une Macro
										// Appel d'une Macro: X_216()
										FCM_X_216();
0E9E  EC0CF004  	CALL FCM_X_216_00000


									} else {

										// Décision
										// Décision: X < 240?
										if (FCV_X < 240)
0EA4  0EF0      	MOVLW 0xF0
0EA6  5C21      	SUBWF gbl_FCV_X, W
0EA8  B0D8      	BTFSC STATUS,C
0EAC  6622      	TSTFSZ gbl_FCV_X+D'1'

										{

											// Appel d'une Macro
											// Appel d'une Macro: X_240()
											FCM_X_240();
0EB0  ECBBF003  	CALL FCM_X_240_00000


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
0E22  0012      	RETURN
0E32  0012      	RETURN
0E42  0012      	RETURN
0E52  0012      	RETURN
0E62  0012      	RETURN
0E72  0012      	RETURN
0E82  0012      	RETURN
0E92  0012      	RETURN
0EA2  0012      	RETURN
0EAA  0012      	RETURN
0EAE  0012      	RETURN
0EB4  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_lignesV()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(24, 0, 24, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(24, 0, 24, 240);
02E2  0E18      	MOVLW 0x18
02E4  6E3F      	MOVWF FCD_0f051__00068_arg_FCL_X1
02E6  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
02E8  6A41      	CLRF FCD_0f051__00068_arg_FCL_Y1
02EA  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
02EC  0E18      	MOVLW 0x18
02EE  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
02F0  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
02F2  0EF0      	MOVLW 0xF0
02F4  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
02F6  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
02F8  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(48, 0, 48, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(48, 0, 48, 240);
02FC  0E30      	MOVLW 0x30
02FE  6E3F      	MOVWF FCD_0f051__00068_arg_FCL_X1
0300  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
0302  6A41      	CLRF FCD_0f051__00068_arg_FCL_Y1
0304  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
0306  0E30      	MOVLW 0x30
0308  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
030A  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
030C  0EF0      	MOVLW 0xF0
030E  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
0310  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
0312  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(72, 0, 72, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(72, 0, 72, 240);
0316  0E48      	MOVLW 0x48
0318  6E3F      	MOVWF FCD_0f051__00068_arg_FCL_X1
031A  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
031C  6A41      	CLRF FCD_0f051__00068_arg_FCL_Y1
031E  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
0320  0E48      	MOVLW 0x48
0322  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
0324  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
0326  0EF0      	MOVLW 0xF0
0328  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
032A  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
032C  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(96, 0, 96, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(96, 0, 96, 240);
0330  0E60      	MOVLW 0x60
0332  6E3F      	MOVWF FCD_0f051__00068_arg_FCL_X1
0334  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
0336  6A41      	CLRF FCD_0f051__00068_arg_FCL_Y1
0338  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
033A  0E60      	MOVLW 0x60
033C  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
033E  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
0340  0EF0      	MOVLW 0xF0
0342  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
0344  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
0346  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(120, 0, 120, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(120, 0, 120, 240);
034A  0E78      	MOVLW 0x78
034C  6E3F      	MOVWF FCD_0f051__00068_arg_FCL_X1
034E  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
0350  6A41      	CLRF FCD_0f051__00068_arg_FCL_Y1
0352  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
0354  0E78      	MOVLW 0x78
0356  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
0358  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
035A  0EF0      	MOVLW 0xF0
035C  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
035E  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
0360  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(144, 0, 144, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(144, 0, 144, 240);
0364  0E90      	MOVLW 0x90
0366  6E3F      	MOVWF FCD_0f051__00068_arg_FCL_X1
0368  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
036A  6A41      	CLRF FCD_0f051__00068_arg_FCL_Y1
036C  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
036E  0E90      	MOVLW 0x90
0370  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
0372  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
0374  0EF0      	MOVLW 0xF0
0376  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
0378  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
037A  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(168, 0, 168, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(168, 0, 168, 240);
037E  0EA8      	MOVLW 0xA8
0380  6E3F      	MOVWF FCD_0f051__00068_arg_FCL_X1
0382  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
0384  6A41      	CLRF FCD_0f051__00068_arg_FCL_Y1
0386  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
0388  0EA8      	MOVLW 0xA8
038A  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
038C  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
038E  0EF0      	MOVLW 0xF0
0390  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
0392  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
0394  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(192, 0, 192, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(192, 0, 192, 240);
0398  0EC0      	MOVLW 0xC0
039A  6E3F      	MOVWF FCD_0f051__00068_arg_FCL_X1
039C  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
039E  6A41      	CLRF FCD_0f051__00068_arg_FCL_Y1
03A0  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
03A2  0EC0      	MOVLW 0xC0
03A4  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
03A6  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
03A8  0EF0      	MOVLW 0xF0
03AA  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
03AC  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
03AE  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(216, 0, 216, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(216, 0, 216, 240);
03B2  0ED8      	MOVLW 0xD8
03B4  6E3F      	MOVWF FCD_0f051__00068_arg_FCL_X1
03B6  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
03B8  6A41      	CLRF FCD_0f051__00068_arg_FCL_Y1
03BA  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
03BC  0ED8      	MOVLW 0xD8
03BE  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
03C0  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
03C2  0EF0      	MOVLW 0xF0
03C4  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
03C6  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
03C8  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(240, 0, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(240, 0, 240, 240);
03CC  0EF0      	MOVLW 0xF0
03CE  6E3F      	MOVWF FCD_0f051__00068_arg_FCL_X1
03D0  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
03D2  6A41      	CLRF FCD_0f051__00068_arg_FCL_Y1
03D4  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
03D6  0EF0      	MOVLW 0xF0
03D8  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
03DA  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
03DC  0EF0      	MOVLW 0xF0
03DE  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
03E0  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
03E2  EC09F001  	CALL FCD_0f051__00068


}
03E6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_24()

{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
06D4  0E18      	MOVLW 0x18
06D6  5C1F      	SUBWF gbl_FCV_Y, W
06D8  E205      	BC	label54
06DA  6620      	TSTFSZ gbl_FCV_Y+D'1'
06DC  D003      	BRA	label54
06E4            label54

	{

		// Calcul
		// Calcul:
		//  hitbox = 1
		FCV_HITBOX = 1;
06DE  0E01      	MOVLW 0x01
06E0  6E34      	MOVWF gbl_FCV_HITBOX


	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
06E4  0E30      	MOVLW 0x30
06E6  5C1F      	SUBWF gbl_FCV_Y, W
06E8  E205      	BC	label55
06EA  6620      	TSTFSZ gbl_FCV_Y+D'1'
06EC  D003      	BRA	label55
06F4            label55

		{

			// Calcul
			// Calcul:
			//  hitbox = 11
			FCV_HITBOX = 11;
06EE  0E0B      	MOVLW 0x0B
06F0  6E34      	MOVWF gbl_FCV_HITBOX


		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
06F4  0E48      	MOVLW 0x48
06F6  5C1F      	SUBWF gbl_FCV_Y, W
06F8  E205      	BC	label56
06FA  6620      	TSTFSZ gbl_FCV_Y+D'1'
06FC  D003      	BRA	label56
0704            label56

			{

				// Calcul
				// Calcul:
				//  hitbox = 21
				FCV_HITBOX = 21;
06FE  0E15      	MOVLW 0x15
0700  6E34      	MOVWF gbl_FCV_HITBOX


			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
0704  0E60      	MOVLW 0x60
0706  5C1F      	SUBWF gbl_FCV_Y, W
0708  E205      	BC	label57
070A  6620      	TSTFSZ gbl_FCV_Y+D'1'
070C  D003      	BRA	label57
0714            label57

				{

					// Calcul
					// Calcul:
					//  hitbox = 31
					FCV_HITBOX = 31;
070E  0E1F      	MOVLW 0x1F
0710  6E34      	MOVWF gbl_FCV_HITBOX


				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
0714  0E78      	MOVLW 0x78
0716  5C1F      	SUBWF gbl_FCV_Y, W
0718  E205      	BC	label58
071A  6620      	TSTFSZ gbl_FCV_Y+D'1'
071C  D003      	BRA	label58
0724            label58

					{

						// 
						// Calcul:
						//  hitbox = 41
						FCV_HITBOX = 41;
071E  0E29      	MOVLW 0x29
0720  6E34      	MOVWF gbl_FCV_HITBOX


					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
0724  0E90      	MOVLW 0x90
0726  5C1F      	SUBWF gbl_FCV_Y, W
0728  E205      	BC	label59
072A  6620      	TSTFSZ gbl_FCV_Y+D'1'
072C  D003      	BRA	label59
0734            label59

						{

							// Calcul
							// Calcul:
							//  hitbox = 51
							FCV_HITBOX = 51;
072E  0E33      	MOVLW 0x33
0730  6E34      	MOVWF gbl_FCV_HITBOX


						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
0734  0EA8      	MOVLW 0xA8
0736  5C1F      	SUBWF gbl_FCV_Y, W
0738  E205      	BC	label60
073A  6620      	TSTFSZ gbl_FCV_Y+D'1'
073C  D003      	BRA	label60
0744            label60

							{

								// Calcul
								// Calcul:
								//  hitbox = 61
								FCV_HITBOX = 61;
073E  0E3D      	MOVLW 0x3D
0740  6E34      	MOVWF gbl_FCV_HITBOX


							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
0744  0EC0      	MOVLW 0xC0
0746  5C1F      	SUBWF gbl_FCV_Y, W
0748  E205      	BC	label61
074A  6620      	TSTFSZ gbl_FCV_Y+D'1'
074C  D003      	BRA	label61
0754            label61

								{

									// Calcul
									// Calcul:
									//  hitbox = 71
									FCV_HITBOX = 71;
074E  0E47      	MOVLW 0x47
0750  6E34      	MOVWF gbl_FCV_HITBOX


								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
0754  0ED8      	MOVLW 0xD8
0756  5C1F      	SUBWF gbl_FCV_Y, W
0758  E205      	BC	label62
075A  6620      	TSTFSZ gbl_FCV_Y+D'1'
075C  D003      	BRA	label62
0764            label62

									{

										// Calcul
										// Calcul:
										//  hitbox = 81
										FCV_HITBOX = 81;
075E  0E51      	MOVLW 0x51
0760  6E34      	MOVWF gbl_FCV_HITBOX


									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
0764  0EF0      	MOVLW 0xF0
0766  5C1F      	SUBWF gbl_FCV_Y, W
0768  B0D8      	BTFSC STATUS,C
076C  6620      	TSTFSZ gbl_FCV_Y+D'1'

										{

											// Calcul
											// Calcul:
											//  hitbox = 91
											FCV_HITBOX = 91;
0770  0E5B      	MOVLW 0x5B
0772  6E34      	MOVWF gbl_FCV_HITBOX


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
06E2  0012      	RETURN
06F2  0012      	RETURN
0702  0012      	RETURN
0712  0012      	RETURN
0722  0012      	RETURN
0732  0012      	RETURN
0742  0012      	RETURN
0752  0012      	RETURN
0762  0012      	RETURN
076A  0012      	RETURN
076E  0012      	RETURN
0774  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_240()

{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
0776  0E18      	MOVLW 0x18
0778  5C1F      	SUBWF gbl_FCV_Y, W
077A  E205      	BC	label63
077C  6620      	TSTFSZ gbl_FCV_Y+D'1'
077E  D003      	BRA	label63
0786            label63

	{

		// Calcul
		// Calcul:
		//  hitbox = 10
		FCV_HITBOX = 10;
0780  0E0A      	MOVLW 0x0A
0782  6E34      	MOVWF gbl_FCV_HITBOX


	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
0786  0E30      	MOVLW 0x30
0788  5C1F      	SUBWF gbl_FCV_Y, W
078A  E205      	BC	label64
078C  6620      	TSTFSZ gbl_FCV_Y+D'1'
078E  D003      	BRA	label64
0796            label64

		{

			// Calcul
			// Calcul:
			//  hitbox = 20
			FCV_HITBOX = 20;
0790  0E14      	MOVLW 0x14
0792  6E34      	MOVWF gbl_FCV_HITBOX


		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
0796  0E48      	MOVLW 0x48
0798  5C1F      	SUBWF gbl_FCV_Y, W
079A  E205      	BC	label65
079C  6620      	TSTFSZ gbl_FCV_Y+D'1'
079E  D003      	BRA	label65
07A6            label65

			{

				// Calcul
				// Calcul:
				//  hitbox = 30
				FCV_HITBOX = 30;
07A0  0E1E      	MOVLW 0x1E
07A2  6E34      	MOVWF gbl_FCV_HITBOX


			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
07A6  0E60      	MOVLW 0x60
07A8  5C1F      	SUBWF gbl_FCV_Y, W
07AA  E205      	BC	label66
07AC  6620      	TSTFSZ gbl_FCV_Y+D'1'
07AE  D003      	BRA	label66
07B6            label66

				{

					// Calcul
					// Calcul:
					//  hitbox = 40
					FCV_HITBOX = 40;
07B0  0E28      	MOVLW 0x28
07B2  6E34      	MOVWF gbl_FCV_HITBOX


				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
07B6  0E78      	MOVLW 0x78
07B8  5C1F      	SUBWF gbl_FCV_Y, W
07BA  E205      	BC	label67
07BC  6620      	TSTFSZ gbl_FCV_Y+D'1'
07BE  D003      	BRA	label67
07C6            label67

					{

						// 
						// Calcul:
						//  hitbox = 50
						FCV_HITBOX = 50;
07C0  0E32      	MOVLW 0x32
07C2  6E34      	MOVWF gbl_FCV_HITBOX


					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
07C6  0E90      	MOVLW 0x90
07C8  5C1F      	SUBWF gbl_FCV_Y, W
07CA  E205      	BC	label68
07CC  6620      	TSTFSZ gbl_FCV_Y+D'1'
07CE  D003      	BRA	label68
07D6            label68

						{

							// Calcul
							// Calcul:
							//  hitbox = 60
							FCV_HITBOX = 60;
07D0  0E3C      	MOVLW 0x3C
07D2  6E34      	MOVWF gbl_FCV_HITBOX


						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
07D6  0EA8      	MOVLW 0xA8
07D8  5C1F      	SUBWF gbl_FCV_Y, W
07DA  E205      	BC	label69
07DC  6620      	TSTFSZ gbl_FCV_Y+D'1'
07DE  D003      	BRA	label69
07E6            label69

							{

								// Calcul
								// Calcul:
								//  hitbox = 70
								FCV_HITBOX = 70;
07E0  0E46      	MOVLW 0x46
07E2  6E34      	MOVWF gbl_FCV_HITBOX


							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
07E6  0EC0      	MOVLW 0xC0
07E8  5C1F      	SUBWF gbl_FCV_Y, W
07EA  E205      	BC	label70
07EC  6620      	TSTFSZ gbl_FCV_Y+D'1'
07EE  D003      	BRA	label70
07F6            label70

								{

									// Calcul
									// Calcul:
									//  hitbox = 80
									FCV_HITBOX = 80;
07F0  0E50      	MOVLW 0x50
07F2  6E34      	MOVWF gbl_FCV_HITBOX


								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
07F6  0ED8      	MOVLW 0xD8
07F8  5C1F      	SUBWF gbl_FCV_Y, W
07FA  E205      	BC	label71
07FC  6620      	TSTFSZ gbl_FCV_Y+D'1'
07FE  D003      	BRA	label71
0806            label71

									{

										// Calcul
										// Calcul:
										//  hitbox = 90
										FCV_HITBOX = 90;
0800  0E5A      	MOVLW 0x5A
0802  6E34      	MOVWF gbl_FCV_HITBOX


									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
0806  0EF0      	MOVLW 0xF0
0808  5C1F      	SUBWF gbl_FCV_Y, W
080A  B0D8      	BTFSC STATUS,C
080E  6620      	TSTFSZ gbl_FCV_Y+D'1'

										{

											// Calcul
											// Calcul:
											//  hitbox = 100
											FCV_HITBOX = 100;
0812  0E64      	MOVLW 0x64
0814  6E34      	MOVWF gbl_FCV_HITBOX


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
0784  0012      	RETURN
0794  0012      	RETURN
07A4  0012      	RETURN
07B4  0012      	RETURN
07C4  0012      	RETURN
07D4  0012      	RETURN
07E4  0012      	RETURN
07F4  0012      	RETURN
0804  0012      	RETURN
080C  0012      	RETURN
0810  0012      	RETURN
0816  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_48()

{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
0632  0E18      	MOVLW 0x18
0634  5C1F      	SUBWF gbl_FCV_Y, W
0636  E205      	BC	label45
0638  6620      	TSTFSZ gbl_FCV_Y+D'1'
063A  D003      	BRA	label45
0642            label45

	{

		// Calcul
		// Calcul:
		//  hitbox = 2
		FCV_HITBOX = 2;
063C  0E02      	MOVLW 0x02
063E  6E34      	MOVWF gbl_FCV_HITBOX


	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
0642  0E30      	MOVLW 0x30
0644  5C1F      	SUBWF gbl_FCV_Y, W
0646  E205      	BC	label46
0648  6620      	TSTFSZ gbl_FCV_Y+D'1'
064A  D003      	BRA	label46
0652            label46

		{

			// Calcul
			// Calcul:
			//  hitbox = 12
			FCV_HITBOX = 12;
064C  0E0C      	MOVLW 0x0C
064E  6E34      	MOVWF gbl_FCV_HITBOX


		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
0652  0E48      	MOVLW 0x48
0654  5C1F      	SUBWF gbl_FCV_Y, W
0656  E205      	BC	label47
0658  6620      	TSTFSZ gbl_FCV_Y+D'1'
065A  D003      	BRA	label47
0662            label47

			{

				// Calcul
				// Calcul:
				//  hitbox = 22
				FCV_HITBOX = 22;
065C  0E16      	MOVLW 0x16
065E  6E34      	MOVWF gbl_FCV_HITBOX


			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
0662  0E60      	MOVLW 0x60
0664  5C1F      	SUBWF gbl_FCV_Y, W
0666  E205      	BC	label48
0668  6620      	TSTFSZ gbl_FCV_Y+D'1'
066A  D003      	BRA	label48
0672            label48

				{

					// Calcul
					// Calcul:
					//  hitbox = 32
					FCV_HITBOX = 32;
066C  0E20      	MOVLW 0x20
066E  6E34      	MOVWF gbl_FCV_HITBOX


				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
0672  0E78      	MOVLW 0x78
0674  5C1F      	SUBWF gbl_FCV_Y, W
0676  E205      	BC	label49
0678  6620      	TSTFSZ gbl_FCV_Y+D'1'
067A  D003      	BRA	label49
0682            label49

					{

						// Calcul
						// Calcul:
						//  hitbox = 42
						FCV_HITBOX = 42;
067C  0E2A      	MOVLW 0x2A
067E  6E34      	MOVWF gbl_FCV_HITBOX


					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
0682  0E90      	MOVLW 0x90
0684  5C1F      	SUBWF gbl_FCV_Y, W
0686  E205      	BC	label50
0688  6620      	TSTFSZ gbl_FCV_Y+D'1'
068A  D003      	BRA	label50
0692            label50

						{

							// Calcul
							// Calcul:
							//  hitbox = 52
							FCV_HITBOX = 52;
068C  0E34      	MOVLW 0x34
068E  6E34      	MOVWF gbl_FCV_HITBOX


						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
0692  0EA8      	MOVLW 0xA8
0694  5C1F      	SUBWF gbl_FCV_Y, W
0696  E205      	BC	label51
0698  6620      	TSTFSZ gbl_FCV_Y+D'1'
069A  D003      	BRA	label51
06A2            label51

							{

								// Calcul
								// Calcul:
								//  hitbox = 62
								FCV_HITBOX = 62;
069C  0E3E      	MOVLW 0x3E
069E  6E34      	MOVWF gbl_FCV_HITBOX


							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
06A2  0EC0      	MOVLW 0xC0
06A4  5C1F      	SUBWF gbl_FCV_Y, W
06A6  E205      	BC	label52
06A8  6620      	TSTFSZ gbl_FCV_Y+D'1'
06AA  D003      	BRA	label52
06B2            label52

								{

									// Calcul
									// Calcul:
									//  hitbox = 72
									FCV_HITBOX = 72;
06AC  0E48      	MOVLW 0x48
06AE  6E34      	MOVWF gbl_FCV_HITBOX


								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
06B2  0ED8      	MOVLW 0xD8
06B4  5C1F      	SUBWF gbl_FCV_Y, W
06B6  E205      	BC	label53
06B8  6620      	TSTFSZ gbl_FCV_Y+D'1'
06BA  D003      	BRA	label53
06C2            label53

									{

										// Calcul
										// Calcul:
										//  hitbox = 82
										FCV_HITBOX = 82;
06BC  0E52      	MOVLW 0x52
06BE  6E34      	MOVWF gbl_FCV_HITBOX


									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
06C2  0EF0      	MOVLW 0xF0
06C4  5C1F      	SUBWF gbl_FCV_Y, W
06C6  B0D8      	BTFSC STATUS,C
06CA  6620      	TSTFSZ gbl_FCV_Y+D'1'

										{

											// Calcul
											// Calcul:
											//  hitbox = 92
											FCV_HITBOX = 92;
06CE  0E5C      	MOVLW 0x5C
06D0  6E34      	MOVWF gbl_FCV_HITBOX


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
0640  0012      	RETURN
0650  0012      	RETURN
0660  0012      	RETURN
0670  0012      	RETURN
0680  0012      	RETURN
0690  0012      	RETURN
06A0  0012      	RETURN
06B0  0012      	RETURN
06C0  0012      	RETURN
06C8  0012      	RETURN
06CC  0012      	RETURN
06D2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Appui_tactile()
{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	#if 0 // Disabled code
	//Commentaire:
	//Coordonnée pour X

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: X=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);

	#if 0 // Disabled code
	//Commentaire:
	//Coordonée pour Y

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(X, 80, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_X, 80, 150, 2, 1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(Y, 120, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_Y, 120, 150, 2, 1);

	// Pause
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	// Calcul
	// Calcul:
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	FCV_APPUI_ECRAN = 0;
	FCV_X = 0;
	FCV_Y = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Recuperation_coordonees()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Appui_Ecran=gLCD_EB076_4D1::G4D_GetTouchCoordinatesPicaso()
	FCV_APPUI_ECRAN = FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
0DF8  ECA1F005  	CALL FCD_0f051__0006E
0DFC  5041      	MOVF CompTempVarRet2688, W
0DFE  6E35      	MOVWF gbl_FCV_APPUI_ECRAN


}
0E00  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_lignesH()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 24, 240, 24)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 24, 240, 24);
03E8  6A3F      	CLRF FCD_0f051__00068_arg_FCL_X1
03EA  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
03EC  0E18      	MOVLW 0x18
03EE  6E41      	MOVWF FCD_0f051__00068_arg_FCL_Y1
03F0  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
03F2  0EF0      	MOVLW 0xF0
03F4  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
03F6  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
03F8  0E18      	MOVLW 0x18
03FA  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
03FC  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
03FE  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 48, 240, 48)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 48, 240, 48);
0402  6A3F      	CLRF FCD_0f051__00068_arg_FCL_X1
0404  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
0406  0E30      	MOVLW 0x30
0408  6E41      	MOVWF FCD_0f051__00068_arg_FCL_Y1
040A  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
040C  0EF0      	MOVLW 0xF0
040E  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
0410  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
0412  0E30      	MOVLW 0x30
0414  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
0416  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
0418  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 72, 240, 72)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 72, 240, 72);
041C  6A3F      	CLRF FCD_0f051__00068_arg_FCL_X1
041E  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
0420  0E48      	MOVLW 0x48
0422  6E41      	MOVWF FCD_0f051__00068_arg_FCL_Y1
0424  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
0426  0EF0      	MOVLW 0xF0
0428  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
042A  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
042C  0E48      	MOVLW 0x48
042E  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
0430  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
0432  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 96, 240, 96)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 96, 240, 96);
0436  6A3F      	CLRF FCD_0f051__00068_arg_FCL_X1
0438  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
043A  0E60      	MOVLW 0x60
043C  6E41      	MOVWF FCD_0f051__00068_arg_FCL_Y1
043E  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
0440  0EF0      	MOVLW 0xF0
0442  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
0444  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
0446  0E60      	MOVLW 0x60
0448  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
044A  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
044C  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 120, 240, 120)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 120, 240, 120);
0450  6A3F      	CLRF FCD_0f051__00068_arg_FCL_X1
0452  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
0454  0E78      	MOVLW 0x78
0456  6E41      	MOVWF FCD_0f051__00068_arg_FCL_Y1
0458  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
045A  0EF0      	MOVLW 0xF0
045C  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
045E  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
0460  0E78      	MOVLW 0x78
0462  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
0464  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
0466  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 144, 240, 144)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 144, 240, 144);
046A  6A3F      	CLRF FCD_0f051__00068_arg_FCL_X1
046C  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
046E  0E90      	MOVLW 0x90
0470  6E41      	MOVWF FCD_0f051__00068_arg_FCL_Y1
0472  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
0474  0EF0      	MOVLW 0xF0
0476  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
0478  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
047A  0E90      	MOVLW 0x90
047C  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
047E  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
0480  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 168, 240, 168)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 168, 240, 168);
0484  6A3F      	CLRF FCD_0f051__00068_arg_FCL_X1
0486  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
0488  0EA8      	MOVLW 0xA8
048A  6E41      	MOVWF FCD_0f051__00068_arg_FCL_Y1
048C  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
048E  0EF0      	MOVLW 0xF0
0490  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
0492  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
0494  0EA8      	MOVLW 0xA8
0496  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
0498  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
049A  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 192, 240, 192)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 192, 240, 192);
049E  6A3F      	CLRF FCD_0f051__00068_arg_FCL_X1
04A0  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
04A2  0EC0      	MOVLW 0xC0
04A4  6E41      	MOVWF FCD_0f051__00068_arg_FCL_Y1
04A6  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
04A8  0EF0      	MOVLW 0xF0
04AA  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
04AC  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
04AE  0EC0      	MOVLW 0xC0
04B0  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
04B2  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
04B4  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 216, 240, 216)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 216, 240, 216);
04B8  6A3F      	CLRF FCD_0f051__00068_arg_FCL_X1
04BA  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
04BC  0ED8      	MOVLW 0xD8
04BE  6E41      	MOVWF FCD_0f051__00068_arg_FCL_Y1
04C0  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
04C2  0EF0      	MOVLW 0xF0
04C4  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
04C6  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
04C8  0ED8      	MOVLW 0xD8
04CA  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
04CC  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
04CE  EC09F001  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 240, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 240, 240, 240);
04D2  6A3F      	CLRF FCD_0f051__00068_arg_FCL_X1
04D4  6A40      	CLRF FCD_0f051__00068_arg_FCL_X1+D'1'
04D6  0EF0      	MOVLW 0xF0
04D8  6E41      	MOVWF FCD_0f051__00068_arg_FCL_Y1
04DA  6A42      	CLRF FCD_0f051__00068_arg_FCL_Y1+D'1'
04DC  0EF0      	MOVLW 0xF0
04DE  6E43      	MOVWF FCD_0f051__00068_arg_FCL_X2
04E0  6A44      	CLRF FCD_0f051__00068_arg_FCL_X2+D'1'
04E2  0EF0      	MOVLW 0xF0
04E4  6E45      	MOVWF FCD_0f051__00068_arg_FCL_Y2
04E6  6A46      	CLRF FCD_0f051__00068_arg_FCL_Y2+D'1'
04E8  EC09F001  	CALL FCD_0f051__00068


}
04EC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_192()

{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
08BA  0E18      	MOVLW 0x18
08BC  5C1F      	SUBWF gbl_FCV_Y, W
08BE  E205      	BC	label81
08C0  6620      	TSTFSZ gbl_FCV_Y+D'1'
08C2  D003      	BRA	label81
08CA            label81

	{

		// Calcul
		// Calcul:
		//  hitbox = 8
		FCV_HITBOX = 8;
08C4  0E08      	MOVLW 0x08
08C6  6E34      	MOVWF gbl_FCV_HITBOX


	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
08CA  0E30      	MOVLW 0x30
08CC  5C1F      	SUBWF gbl_FCV_Y, W
08CE  E205      	BC	label82
08D0  6620      	TSTFSZ gbl_FCV_Y+D'1'
08D2  D003      	BRA	label82
08DA            label82

		{

			// Calcul
			// Calcul:
			//  hitbox = 18
			FCV_HITBOX = 18;
08D4  0E12      	MOVLW 0x12
08D6  6E34      	MOVWF gbl_FCV_HITBOX


		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
08DA  0E48      	MOVLW 0x48
08DC  5C1F      	SUBWF gbl_FCV_Y, W
08DE  E205      	BC	label83
08E0  6620      	TSTFSZ gbl_FCV_Y+D'1'
08E2  D003      	BRA	label83
08EA            label83

			{

				// Calcul
				// Calcul:
				//  hitbox = 28
				FCV_HITBOX = 28;
08E4  0E1C      	MOVLW 0x1C
08E6  6E34      	MOVWF gbl_FCV_HITBOX


			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
08EA  0E60      	MOVLW 0x60
08EC  5C1F      	SUBWF gbl_FCV_Y, W
08EE  E205      	BC	label84
08F0  6620      	TSTFSZ gbl_FCV_Y+D'1'
08F2  D003      	BRA	label84
08FA            label84

				{

					// Calcul
					// Calcul:
					//  hitbox = 38
					FCV_HITBOX = 38;
08F4  0E26      	MOVLW 0x26
08F6  6E34      	MOVWF gbl_FCV_HITBOX


				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
08FA  0E78      	MOVLW 0x78
08FC  5C1F      	SUBWF gbl_FCV_Y, W
08FE  E205      	BC	label85
0900  6620      	TSTFSZ gbl_FCV_Y+D'1'
0902  D003      	BRA	label85
090A            label85

					{

						// 
						// Calcul:
						//  hitbox = 48
						FCV_HITBOX = 48;
0904  0E30      	MOVLW 0x30
0906  6E34      	MOVWF gbl_FCV_HITBOX


					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
090A  0E90      	MOVLW 0x90
090C  5C1F      	SUBWF gbl_FCV_Y, W
090E  E205      	BC	label86
0910  6620      	TSTFSZ gbl_FCV_Y+D'1'
0912  D003      	BRA	label86
091A            label86

						{

							// Calcul
							// Calcul:
							//  hitbox = 58
							FCV_HITBOX = 58;
0914  0E3A      	MOVLW 0x3A
0916  6E34      	MOVWF gbl_FCV_HITBOX


						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
091A  0EA8      	MOVLW 0xA8
091C  5C1F      	SUBWF gbl_FCV_Y, W
091E  E205      	BC	label87
0920  6620      	TSTFSZ gbl_FCV_Y+D'1'
0922  D003      	BRA	label87
092A            label87

							{

								// Calcul
								// Calcul:
								//  hitbox = 68
								FCV_HITBOX = 68;
0924  0E44      	MOVLW 0x44
0926  6E34      	MOVWF gbl_FCV_HITBOX


							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
092A  0EC0      	MOVLW 0xC0
092C  5C1F      	SUBWF gbl_FCV_Y, W
092E  E205      	BC	label88
0930  6620      	TSTFSZ gbl_FCV_Y+D'1'
0932  D003      	BRA	label88
093A            label88

								{

									// Calcul
									// Calcul:
									//  hitbox = 78
									FCV_HITBOX = 78;
0934  0E4E      	MOVLW 0x4E
0936  6E34      	MOVWF gbl_FCV_HITBOX


								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
093A  0ED8      	MOVLW 0xD8
093C  5C1F      	SUBWF gbl_FCV_Y, W
093E  E205      	BC	label89
0940  6620      	TSTFSZ gbl_FCV_Y+D'1'
0942  D003      	BRA	label89
094A            label89

									{

										// Calcul
										// Calcul:
										//  hitbox = 88
										FCV_HITBOX = 88;
0944  0E58      	MOVLW 0x58
0946  6E34      	MOVWF gbl_FCV_HITBOX


									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
094A  0EF0      	MOVLW 0xF0
094C  5C1F      	SUBWF gbl_FCV_Y, W
094E  B0D8      	BTFSC STATUS,C
0952  6620      	TSTFSZ gbl_FCV_Y+D'1'

										{

											// Calcul
											// Calcul:
											//  hitbox = 98
											FCV_HITBOX = 98;
0956  0E62      	MOVLW 0x62
0958  6E34      	MOVWF gbl_FCV_HITBOX


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
08C8  0012      	RETURN
08D8  0012      	RETURN
08E8  0012      	RETURN
08F8  0012      	RETURN
0908  0012      	RETURN
0918  0012      	RETURN
0928  0012      	RETURN
0938  0012      	RETURN
0948  0012      	RETURN
0950  0012      	RETURN
0954  0012      	RETURN
095A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_120()

{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
0AA0  0E18      	MOVLW 0x18
0AA2  5C1F      	SUBWF gbl_FCV_Y, W
0AA4  E205      	BC	label108
0AA6  6620      	TSTFSZ gbl_FCV_Y+D'1'
0AA8  D003      	BRA	label108
0AB0            label108

	{

		// Calcul
		// Calcul:
		//  hitbox = 5
		FCV_HITBOX = 5;
0AAA  0E05      	MOVLW 0x05
0AAC  6E34      	MOVWF gbl_FCV_HITBOX


	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
0AB0  0E30      	MOVLW 0x30
0AB2  5C1F      	SUBWF gbl_FCV_Y, W
0AB4  E205      	BC	label109
0AB6  6620      	TSTFSZ gbl_FCV_Y+D'1'
0AB8  D003      	BRA	label109
0AC0            label109

		{

			// Calcul
			// Calcul:
			//  hitbox = 15
			FCV_HITBOX = 15;
0ABA  0E0F      	MOVLW 0x0F
0ABC  6E34      	MOVWF gbl_FCV_HITBOX


		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
0AC0  0E48      	MOVLW 0x48
0AC2  5C1F      	SUBWF gbl_FCV_Y, W
0AC4  E205      	BC	label110
0AC6  6620      	TSTFSZ gbl_FCV_Y+D'1'
0AC8  D003      	BRA	label110
0AD0            label110

			{

				// Calcul
				// Calcul:
				//  hitbox = 25
				FCV_HITBOX = 25;
0ACA  0E19      	MOVLW 0x19
0ACC  6E34      	MOVWF gbl_FCV_HITBOX


			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
0AD0  0E60      	MOVLW 0x60
0AD2  5C1F      	SUBWF gbl_FCV_Y, W
0AD4  E205      	BC	label111
0AD6  6620      	TSTFSZ gbl_FCV_Y+D'1'
0AD8  D003      	BRA	label111
0AE0            label111

				{

					// Calcul
					// Calcul:
					//  hitbox = 35
					FCV_HITBOX = 35;
0ADA  0E23      	MOVLW 0x23
0ADC  6E34      	MOVWF gbl_FCV_HITBOX


				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
0AE0  0E78      	MOVLW 0x78
0AE2  5C1F      	SUBWF gbl_FCV_Y, W
0AE4  E205      	BC	label112
0AE6  6620      	TSTFSZ gbl_FCV_Y+D'1'
0AE8  D003      	BRA	label112
0AF0            label112

					{

						// 
						// Calcul:
						//  hitbox = 45
						FCV_HITBOX = 45;
0AEA  0E2D      	MOVLW 0x2D
0AEC  6E34      	MOVWF gbl_FCV_HITBOX


					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
0AF0  0E90      	MOVLW 0x90
0AF2  5C1F      	SUBWF gbl_FCV_Y, W
0AF4  E205      	BC	label113
0AF6  6620      	TSTFSZ gbl_FCV_Y+D'1'
0AF8  D003      	BRA	label113
0B00            label113

						{

							// Calcul
							// Calcul:
							//  hitbox = 55
							FCV_HITBOX = 55;
0AFA  0E37      	MOVLW 0x37
0AFC  6E34      	MOVWF gbl_FCV_HITBOX


						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
0B00  0EA8      	MOVLW 0xA8
0B02  5C1F      	SUBWF gbl_FCV_Y, W
0B04  E205      	BC	label114
0B06  6620      	TSTFSZ gbl_FCV_Y+D'1'
0B08  D003      	BRA	label114
0B10            label114

							{

								// Calcul
								// Calcul:
								//  hitbox = 65
								FCV_HITBOX = 65;
0B0A  0E41      	MOVLW 0x41
0B0C  6E34      	MOVWF gbl_FCV_HITBOX


							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
0B10  0EC0      	MOVLW 0xC0
0B12  5C1F      	SUBWF gbl_FCV_Y, W
0B14  E205      	BC	label115
0B16  6620      	TSTFSZ gbl_FCV_Y+D'1'
0B18  D003      	BRA	label115
0B20            label115

								{

									// Calcul
									// Calcul:
									//  hitbox = 75
									FCV_HITBOX = 75;
0B1A  0E4B      	MOVLW 0x4B
0B1C  6E34      	MOVWF gbl_FCV_HITBOX


								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
0B20  0ED8      	MOVLW 0xD8
0B22  5C1F      	SUBWF gbl_FCV_Y, W
0B24  E205      	BC	label116
0B26  6620      	TSTFSZ gbl_FCV_Y+D'1'
0B28  D003      	BRA	label116
0B30            label116

									{

										// Calcul
										// Calcul:
										//  hitbox = 85
										FCV_HITBOX = 85;
0B2A  0E55      	MOVLW 0x55
0B2C  6E34      	MOVWF gbl_FCV_HITBOX


									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
0B30  0EF0      	MOVLW 0xF0
0B32  5C1F      	SUBWF gbl_FCV_Y, W
0B34  B0D8      	BTFSC STATUS,C
0B38  6620      	TSTFSZ gbl_FCV_Y+D'1'

										{

											// Calcul
											// Calcul:
											//  hitbox = 95
											FCV_HITBOX = 95;
0B3C  0E5F      	MOVLW 0x5F
0B3E  6E34      	MOVWF gbl_FCV_HITBOX


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
0AAE  0012      	RETURN
0ABE  0012      	RETURN
0ACE  0012      	RETURN
0ADE  0012      	RETURN
0AEE  0012      	RETURN
0AFE  0012      	RETURN
0B0E  0012      	RETURN
0B1E  0012      	RETURN
0B2E  0012      	RETURN
0B36  0012      	RETURN
0B3A  0012      	RETURN
0B40  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_216()

{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
0818  0E18      	MOVLW 0x18
081A  5C1F      	SUBWF gbl_FCV_Y, W
081C  E205      	BC	label72
081E  6620      	TSTFSZ gbl_FCV_Y+D'1'
0820  D003      	BRA	label72
0828            label72

	{

		// Calcul
		// Calcul:
		//  hitbox = 9
		FCV_HITBOX = 9;
0822  0E09      	MOVLW 0x09
0824  6E34      	MOVWF gbl_FCV_HITBOX


	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
0828  0E30      	MOVLW 0x30
082A  5C1F      	SUBWF gbl_FCV_Y, W
082C  E205      	BC	label73
082E  6620      	TSTFSZ gbl_FCV_Y+D'1'
0830  D003      	BRA	label73
0838            label73

		{

			// Calcul
			// Calcul:
			//  hitbox = 19
			FCV_HITBOX = 19;
0832  0E13      	MOVLW 0x13
0834  6E34      	MOVWF gbl_FCV_HITBOX


		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
0838  0E48      	MOVLW 0x48
083A  5C1F      	SUBWF gbl_FCV_Y, W
083C  E205      	BC	label74
083E  6620      	TSTFSZ gbl_FCV_Y+D'1'
0840  D003      	BRA	label74
0848            label74

			{

				// Calcul
				// Calcul:
				//  hitbox = 29
				FCV_HITBOX = 29;
0842  0E1D      	MOVLW 0x1D
0844  6E34      	MOVWF gbl_FCV_HITBOX


			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
0848  0E60      	MOVLW 0x60
084A  5C1F      	SUBWF gbl_FCV_Y, W
084C  E205      	BC	label75
084E  6620      	TSTFSZ gbl_FCV_Y+D'1'
0850  D003      	BRA	label75
0858            label75

				{

					// Calcul
					// Calcul:
					//  hitbox = 39
					FCV_HITBOX = 39;
0852  0E27      	MOVLW 0x27
0854  6E34      	MOVWF gbl_FCV_HITBOX


				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
0858  0E78      	MOVLW 0x78
085A  5C1F      	SUBWF gbl_FCV_Y, W
085C  E205      	BC	label76
085E  6620      	TSTFSZ gbl_FCV_Y+D'1'
0860  D003      	BRA	label76
0868            label76

					{

						// 
						// Calcul:
						//  hitbox = 49
						FCV_HITBOX = 49;
0862  0E31      	MOVLW 0x31
0864  6E34      	MOVWF gbl_FCV_HITBOX


					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
0868  0E90      	MOVLW 0x90
086A  5C1F      	SUBWF gbl_FCV_Y, W
086C  E205      	BC	label77
086E  6620      	TSTFSZ gbl_FCV_Y+D'1'
0870  D003      	BRA	label77
0878            label77

						{

							// Calcul
							// Calcul:
							//  hitbox = 59
							FCV_HITBOX = 59;
0872  0E3B      	MOVLW 0x3B
0874  6E34      	MOVWF gbl_FCV_HITBOX


						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
0878  0EA8      	MOVLW 0xA8
087A  5C1F      	SUBWF gbl_FCV_Y, W
087C  E205      	BC	label78
087E  6620      	TSTFSZ gbl_FCV_Y+D'1'
0880  D003      	BRA	label78
0888            label78

							{

								// Calcul
								// Calcul:
								//  hitbox = 69
								FCV_HITBOX = 69;
0882  0E45      	MOVLW 0x45
0884  6E34      	MOVWF gbl_FCV_HITBOX


							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
0888  0EC0      	MOVLW 0xC0
088A  5C1F      	SUBWF gbl_FCV_Y, W
088C  E205      	BC	label79
088E  6620      	TSTFSZ gbl_FCV_Y+D'1'
0890  D003      	BRA	label79
0898            label79

								{

									// Calcul
									// Calcul:
									//  hitbox = 79
									FCV_HITBOX = 79;
0892  0E4F      	MOVLW 0x4F
0894  6E34      	MOVWF gbl_FCV_HITBOX


								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
0898  0ED8      	MOVLW 0xD8
089A  5C1F      	SUBWF gbl_FCV_Y, W
089C  E205      	BC	label80
089E  6620      	TSTFSZ gbl_FCV_Y+D'1'
08A0  D003      	BRA	label80
08A8            label80

									{

										// Calcul
										// Calcul:
										//  hitbox = 89
										FCV_HITBOX = 89;
08A2  0E59      	MOVLW 0x59
08A4  6E34      	MOVWF gbl_FCV_HITBOX


									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
08A8  0EF0      	MOVLW 0xF0
08AA  5C1F      	SUBWF gbl_FCV_Y, W
08AC  B0D8      	BTFSC STATUS,C
08B0  6620      	TSTFSZ gbl_FCV_Y+D'1'

										{

											// Calcul
											// Calcul:
											//  hitbox = 99
											FCV_HITBOX = 99;
08B4  0E63      	MOVLW 0x63
08B6  6E34      	MOVWF gbl_FCV_HITBOX


										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}
0826  0012      	RETURN
0836  0012      	RETURN
0846  0012      	RETURN
0856  0012      	RETURN
0866  0012      	RETURN
0876  0012      	RETURN
0886  0012      	RETURN
0896  0012      	RETURN
08A6  0012      	RETURN
08AE  0012      	RETURN
08B2  0012      	RETURN
08B8  0012      	RETURN




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
103E  0E0F      	MOVLW 0x0F
1040  6EC1      	MOVWF gbl_adcon1





	// Appel d'une Macro
	// Appel d'une Macro: Initialisation()
	FCM_Initialisation();
1042  EC01F007  	CALL FCM_Initia_00060


	// Boucle
	// Boucle: While 1
	while (1)
1046            label142
1216  D717      	BRA	label142

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_tactile()
		FCM_Reinitialisation_tactile();
1046  ECF7F006  	CALL FCM_Reinit_00065


		// Boucle
		// Boucle: While Appui_Ecran = 0
		while (FCV_APPUI_ECRAN == 0)
104A            label143
104A  5235      	MOVF gbl_FCV_APPUI_ECRAN, F
104C  E103      	BNZ	label144
1052  D7FB      	BRA	label143
1054            label144
10C0  D098      	BRA	label162
1212            label163

		{

			// Appel d'une Macro
			// Appel d'une Macro: Recuperation_coordonees()
			FCM_Recuperation_coordonees();
104E  ECFCF006  	CALL FCM_Recupe_0006D



		}

		// Appel de la Routine Composant
		// Appel de la Routine Composant: X=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
		FCV_X = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);
1054  6A3F      	CLRF FCD_0f051__0006A_arg_FCL_AXIS
1056  ECFEF007  	CALL FCD_0f051__0006A
105A  5042      	MOVF CompTempVarRet2684, W
105C  6E21      	MOVWF gbl_FCV_X
105E  5043      	MOVF CompTempVarRet2684+D'1', W
1060  6E22      	MOVWF gbl_FCV_X+D'1'


		// Appel de la Routine Composant
		// Appel de la Routine Composant: Y=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
		FCV_Y = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);
1062  0E01      	MOVLW 0x01
1064  6E3F      	MOVWF FCD_0f051__0006A_arg_FCL_AXIS
1066  ECFEF007  	CALL FCD_0f051__0006A
106A  5042      	MOVF CompTempVarRet2684, W
106C  6E1F      	MOVWF gbl_FCV_Y
106E  5043      	MOVF CompTempVarRet2684+D'1', W
1070  6E20      	MOVWF gbl_FCV_Y+D'1'


		// Appel d'une Macro
		// Appel d'une Macro: Hitbox()
		FCM_Hitbox();
1072  EC0AF007  	CALL FCM_Hitbox_00000


		// Multi-Décision
		// Multi-Décision: hitbox?
		switch (FCV_HITBOX)
		{
			case 1:
1076  0434      	DECF gbl_FCV_HITBOX, W
1078  E024      	BZ	label153
10C2            label153

			{
				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 0, 24, 24, 0, 1)
				FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 0, 24, 24, 0, 1);
10C2  6A3F      	CLRF FCD_0f051__000A5_arg_FCL_X1
10C4  6A40      	CLRF FCD_0f051__000A5_arg_FCL_X1+D'1'
10C6  6A41      	CLRF FCD_0f051__000A5_arg_FCL_Y1
10C8  6A42      	CLRF FCD_0f051__000A5_arg_FCL_Y1+D'1'
10CA  0E18      	MOVLW 0x18
10CC  6E43      	MOVWF FCD_0f051__000A5_arg_FCL_X2
10CE  6A44      	CLRF FCD_0f051__000A5_arg_FCL_X2+D'1'
10D0  0E18      	MOVLW 0x18
10D2  6E45      	MOVWF FCD_0f051__000A5_arg_FCL_Y2
10D4  6A46      	CLRF FCD_0f051__000A5_arg_FCL_Y2+D'1'
10D6  6A47      	CLRF FCD_0f051__000A5_arg_FCL_T_000A6
10D8  0E01      	MOVLW 0x01
10DA  6E48      	MOVWF FCD_0f051__000A5_arg_FCL_SOLID
10DC  EC5BF007  	CALL FCD_0f051__000A5


				break;
10E0  D098      	BRA	label163

			}
			case 11:
107A  0E0B      	MOVLW 0x0B
107C  6234      	CPFSEQ gbl_FCV_HITBOX
107E  D001      	BRA	label145
1080  D030      	BRA	label154
1082            label145
10E2            label154

			{
				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 24, 24, 48, 0, 1)
				FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 24, 24, 48, 0, 1);
10E2  6A3F      	CLRF FCD_0f051__000A5_arg_FCL_X1
10E4  6A40      	CLRF FCD_0f051__000A5_arg_FCL_X1+D'1'
10E6  0E18      	MOVLW 0x18
10E8  6E41      	MOVWF FCD_0f051__000A5_arg_FCL_Y1
10EA  6A42      	CLRF FCD_0f051__000A5_arg_FCL_Y1+D'1'
10EC  0E18      	MOVLW 0x18
10EE  6E43      	MOVWF FCD_0f051__000A5_arg_FCL_X2
10F0  6A44      	CLRF FCD_0f051__000A5_arg_FCL_X2+D'1'
10F2  0E30      	MOVLW 0x30
10F4  6E45      	MOVWF FCD_0f051__000A5_arg_FCL_Y2
10F6  6A46      	CLRF FCD_0f051__000A5_arg_FCL_Y2+D'1'
10F8  6A47      	CLRF FCD_0f051__000A5_arg_FCL_T_000A6
10FA  0E01      	MOVLW 0x01
10FC  6E48      	MOVWF FCD_0f051__000A5_arg_FCL_SOLID
10FE  EC5BF007  	CALL FCD_0f051__000A5


				break;
1102  D087      	BRA	label163

			}
			case 21:
1082  0E15      	MOVLW 0x15
1084  6234      	CPFSEQ gbl_FCV_HITBOX
1086  D001      	BRA	label146
1088  D03D      	BRA	label155
108A            label146
1104            label155

			{
				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 48, 24, 72, 0, 1)
				FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 48, 24, 72, 0, 1);
1104  6A3F      	CLRF FCD_0f051__000A5_arg_FCL_X1
1106  6A40      	CLRF FCD_0f051__000A5_arg_FCL_X1+D'1'
1108  0E30      	MOVLW 0x30
110A  6E41      	MOVWF FCD_0f051__000A5_arg_FCL_Y1
110C  6A42      	CLRF FCD_0f051__000A5_arg_FCL_Y1+D'1'
110E  0E18      	MOVLW 0x18
1110  6E43      	MOVWF FCD_0f051__000A5_arg_FCL_X2
1112  6A44      	CLRF FCD_0f051__000A5_arg_FCL_X2+D'1'
1114  0E48      	MOVLW 0x48
1116  6E45      	MOVWF FCD_0f051__000A5_arg_FCL_Y2
1118  6A46      	CLRF FCD_0f051__000A5_arg_FCL_Y2+D'1'
111A  6A47      	CLRF FCD_0f051__000A5_arg_FCL_T_000A6
111C  0E01      	MOVLW 0x01
111E  6E48      	MOVWF FCD_0f051__000A5_arg_FCL_SOLID
1120  EC5BF007  	CALL FCD_0f051__000A5


				break;
1124  D076      	BRA	label163

			}
			case 31:
108A  0E1F      	MOVLW 0x1F
108C  6234      	CPFSEQ gbl_FCV_HITBOX
108E  D001      	BRA	label147
1090  D04A      	BRA	label156
1092            label147
1126            label156

			{
				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 72, 24, 96, 0, 1)
				FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 72, 24, 96, 0, 1);
1126  6A3F      	CLRF FCD_0f051__000A5_arg_FCL_X1
1128  6A40      	CLRF FCD_0f051__000A5_arg_FCL_X1+D'1'
112A  0E48      	MOVLW 0x48
112C  6E41      	MOVWF FCD_0f051__000A5_arg_FCL_Y1
112E  6A42      	CLRF FCD_0f051__000A5_arg_FCL_Y1+D'1'
1130  0E18      	MOVLW 0x18
1132  6E43      	MOVWF FCD_0f051__000A5_arg_FCL_X2
1134  6A44      	CLRF FCD_0f051__000A5_arg_FCL_X2+D'1'
1136  0E60      	MOVLW 0x60
1138  6E45      	MOVWF FCD_0f051__000A5_arg_FCL_Y2
113A  6A46      	CLRF FCD_0f051__000A5_arg_FCL_Y2+D'1'
113C  6A47      	CLRF FCD_0f051__000A5_arg_FCL_T_000A6
113E  0E01      	MOVLW 0x01
1140  6E48      	MOVWF FCD_0f051__000A5_arg_FCL_SOLID
1142  EC5BF007  	CALL FCD_0f051__000A5


				break;
1146  D065      	BRA	label163

			}
			case 41:
1092  0E29      	MOVLW 0x29
1094  6234      	CPFSEQ gbl_FCV_HITBOX
1096  D001      	BRA	label148
1098  D057      	BRA	label157
109A            label148
1148            label157

			{
				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 96, 24, 120, 0, 1)
				FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 96, 24, 120, 0, 1);
1148  6A3F      	CLRF FCD_0f051__000A5_arg_FCL_X1
114A  6A40      	CLRF FCD_0f051__000A5_arg_FCL_X1+D'1'
114C  0E60      	MOVLW 0x60
114E  6E41      	MOVWF FCD_0f051__000A5_arg_FCL_Y1
1150  6A42      	CLRF FCD_0f051__000A5_arg_FCL_Y1+D'1'
1152  0E18      	MOVLW 0x18
1154  6E43      	MOVWF FCD_0f051__000A5_arg_FCL_X2
1156  6A44      	CLRF FCD_0f051__000A5_arg_FCL_X2+D'1'
1158  0E78      	MOVLW 0x78
115A  6E45      	MOVWF FCD_0f051__000A5_arg_FCL_Y2
115C  6A46      	CLRF FCD_0f051__000A5_arg_FCL_Y2+D'1'
115E  6A47      	CLRF FCD_0f051__000A5_arg_FCL_T_000A6
1160  0E01      	MOVLW 0x01
1162  6E48      	MOVWF FCD_0f051__000A5_arg_FCL_SOLID
1164  EC5BF007  	CALL FCD_0f051__000A5


				break;
1168  D054      	BRA	label163

			}
			case 51:
109A  0E33      	MOVLW 0x33
109C  6234      	CPFSEQ gbl_FCV_HITBOX
109E  D001      	BRA	label149
10A0  D064      	BRA	label158
10A2            label149
116A            label158

			{
				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 120, 24, 144, 0, 1)
				FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 120, 24, 144, 0, 1);
116A  6A3F      	CLRF FCD_0f051__000A5_arg_FCL_X1
116C  6A40      	CLRF FCD_0f051__000A5_arg_FCL_X1+D'1'
116E  0E78      	MOVLW 0x78
1170  6E41      	MOVWF FCD_0f051__000A5_arg_FCL_Y1
1172  6A42      	CLRF FCD_0f051__000A5_arg_FCL_Y1+D'1'
1174  0E18      	MOVLW 0x18
1176  6E43      	MOVWF FCD_0f051__000A5_arg_FCL_X2
1178  6A44      	CLRF FCD_0f051__000A5_arg_FCL_X2+D'1'
117A  0E90      	MOVLW 0x90
117C  6E45      	MOVWF FCD_0f051__000A5_arg_FCL_Y2
117E  6A46      	CLRF FCD_0f051__000A5_arg_FCL_Y2+D'1'
1180  6A47      	CLRF FCD_0f051__000A5_arg_FCL_T_000A6
1182  0E01      	MOVLW 0x01
1184  6E48      	MOVWF FCD_0f051__000A5_arg_FCL_SOLID
1186  EC5BF007  	CALL FCD_0f051__000A5


				break;
118A  D043      	BRA	label163

			}
			case 61:
10A2  0E3D      	MOVLW 0x3D
10A4  6234      	CPFSEQ gbl_FCV_HITBOX
10A6  D001      	BRA	label150
10A8  D071      	BRA	label159
10AA            label150
118C            label159

			{
				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 144, 24, 168, 0, 1)
				FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 144, 24, 168, 0, 1);
118C  6A3F      	CLRF FCD_0f051__000A5_arg_FCL_X1
118E  6A40      	CLRF FCD_0f051__000A5_arg_FCL_X1+D'1'
1190  0E90      	MOVLW 0x90
1192  6E41      	MOVWF FCD_0f051__000A5_arg_FCL_Y1
1194  6A42      	CLRF FCD_0f051__000A5_arg_FCL_Y1+D'1'
1196  0E18      	MOVLW 0x18
1198  6E43      	MOVWF FCD_0f051__000A5_arg_FCL_X2
119A  6A44      	CLRF FCD_0f051__000A5_arg_FCL_X2+D'1'
119C  0EA8      	MOVLW 0xA8
119E  6E45      	MOVWF FCD_0f051__000A5_arg_FCL_Y2
11A0  6A46      	CLRF FCD_0f051__000A5_arg_FCL_Y2+D'1'
11A2  6A47      	CLRF FCD_0f051__000A5_arg_FCL_T_000A6
11A4  0E01      	MOVLW 0x01
11A6  6E48      	MOVWF FCD_0f051__000A5_arg_FCL_SOLID
11A8  EC5BF007  	CALL FCD_0f051__000A5


				break;
11AC  D032      	BRA	label163

			}
			case 71:
10AA  0E47      	MOVLW 0x47
10AC  6234      	CPFSEQ gbl_FCV_HITBOX
10AE  D001      	BRA	label151
10B0  D07E      	BRA	label160
10B2            label151
11AE            label160

			{
				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 168, 24, 192, 0, 1)
				FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 168, 24, 192, 0, 1);
11AE  6A3F      	CLRF FCD_0f051__000A5_arg_FCL_X1
11B0  6A40      	CLRF FCD_0f051__000A5_arg_FCL_X1+D'1'
11B2  0EA8      	MOVLW 0xA8
11B4  6E41      	MOVWF FCD_0f051__000A5_arg_FCL_Y1
11B6  6A42      	CLRF FCD_0f051__000A5_arg_FCL_Y1+D'1'
11B8  0E18      	MOVLW 0x18
11BA  6E43      	MOVWF FCD_0f051__000A5_arg_FCL_X2
11BC  6A44      	CLRF FCD_0f051__000A5_arg_FCL_X2+D'1'
11BE  0EC0      	MOVLW 0xC0
11C0  6E45      	MOVWF FCD_0f051__000A5_arg_FCL_Y2
11C2  6A46      	CLRF FCD_0f051__000A5_arg_FCL_Y2+D'1'
11C4  6A47      	CLRF FCD_0f051__000A5_arg_FCL_T_000A6
11C6  0E01      	MOVLW 0x01
11C8  6E48      	MOVWF FCD_0f051__000A5_arg_FCL_SOLID
11CA  EC5BF007  	CALL FCD_0f051__000A5


				break;
11CE  D021      	BRA	label163

			}
			case 81:
10B2  0E51      	MOVLW 0x51
10B4  6234      	CPFSEQ gbl_FCV_HITBOX
10B6  D001      	BRA	label152
10B8  D08B      	BRA	label161
10BA            label152
11D0            label161

			{
				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 192, 24, 216, 0, 1)
				FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 192, 24, 216, 0, 1);
11D0  6A3F      	CLRF FCD_0f051__000A5_arg_FCL_X1
11D2  6A40      	CLRF FCD_0f051__000A5_arg_FCL_X1+D'1'
11D4  0EC0      	MOVLW 0xC0
11D6  6E41      	MOVWF FCD_0f051__000A5_arg_FCL_Y1
11D8  6A42      	CLRF FCD_0f051__000A5_arg_FCL_Y1+D'1'
11DA  0E18      	MOVLW 0x18
11DC  6E43      	MOVWF FCD_0f051__000A5_arg_FCL_X2
11DE  6A44      	CLRF FCD_0f051__000A5_arg_FCL_X2+D'1'
11E0  0ED8      	MOVLW 0xD8
11E2  6E45      	MOVWF FCD_0f051__000A5_arg_FCL_Y2
11E4  6A46      	CLRF FCD_0f051__000A5_arg_FCL_Y2+D'1'
11E6  6A47      	CLRF FCD_0f051__000A5_arg_FCL_T_000A6
11E8  0E01      	MOVLW 0x01
11EA  6E48      	MOVWF FCD_0f051__000A5_arg_FCL_SOLID
11EC  EC5BF007  	CALL FCD_0f051__000A5


				break;
11F0  D010      	BRA	label163

			}
			case 91:
10BA  0E5B      	MOVLW 0x5B
10BC  6234      	CPFSEQ gbl_FCV_HITBOX
10BE  D0A9      	BRA	label163
11F2            label162

			{
				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 216, 24, 240, 0, 1)
				FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 216, 24, 240, 0, 1);
11F2  6A3F      	CLRF FCD_0f051__000A5_arg_FCL_X1
11F4  6A40      	CLRF FCD_0f051__000A5_arg_FCL_X1+D'1'
11F6  0ED8      	MOVLW 0xD8
11F8  6E41      	MOVWF FCD_0f051__000A5_arg_FCL_Y1
11FA  6A42      	CLRF FCD_0f051__000A5_arg_FCL_Y1+D'1'
11FC  0E18      	MOVLW 0x18
11FE  6E43      	MOVWF FCD_0f051__000A5_arg_FCL_X2
1200  6A44      	CLRF FCD_0f051__000A5_arg_FCL_X2+D'1'
1202  0EF0      	MOVLW 0xF0
1204  6E45      	MOVWF FCD_0f051__000A5_arg_FCL_Y2
1206  6A46      	CLRF FCD_0f051__000A5_arg_FCL_Y2+D'1'
1208  6A47      	CLRF FCD_0f051__000A5_arg_FCL_T_000A6
120A  0E01      	MOVLW 0x01
120C  6E48      	MOVWF FCD_0f051__000A5_arg_FCL_SOLID
120E  EC5BF007  	CALL FCD_0f051__000A5


				break;

			}
			// default:

		}

		#if 0 // Disabled code
		// Multi-Décision
		// Multi-Décision: hitbox?
		switch (FCV_HITBOX)
		{
			case 1:
			{
				break;
			}
			case 2:
			{
				// Appel d'une Macro
				// Appel d'une Macro: test()
				FCM_test();

				break;
			}
			case 3:
			{
				// Appel de la Routine Composant
				// Appel d'une Macro: test2(0, 0)
				FCM_test2(0, 0);

				break;
			}
			case 4:
			{
				break;
			}
			case 5:
			{
				break;
			}
			case 6:
			{
				break;
			}
			case 7:
			{
				break;
			}
			case 8:
			{
				break;
			}
			case 9:
			{
				break;
			}
			case 10:
			{
				break;
			}
			// default:

		}

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Pause
		// Pause: 2 s
		FCI_DELAYBYTE_S(2);

		#endif // #if 0: Disabled code
		// Calcul
		// Calcul:
		//  Appui_Ecran = 0
		//  hitbox = 0
		FCV_APPUI_ECRAN = 0;
1212  6A35      	CLRF gbl_FCV_APPUI_ECRAN

		FCV_HITBOX = 0;
1214  6A34      	CLRF gbl_FCV_HITBOX



	}

	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

}
128C  CFEAF001  	MOVFF FSR0H,  Int1Context
1290  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1294  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
1298  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
129C  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
12A0  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
12A4  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
12A8  C001FFEA  	MOVFF Int1Context,  FSR0H
12AC  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0140  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0142  0E7F      	MOVLW 0x7F
0144  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0146  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0148  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
014A  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
014C  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
014E  9A9D      	BCF gbl_pie1,5

			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0150  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
013A  6AAB      	CLRF gbl_rcsta

			txsta = 0;
013C  6AAC      	CLRF gbl_txsta

		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}
013E  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
008C            label5
008C  0E10      	MOVLW 0x10
008E  149E      	ANDWF gbl_pir1, W
0090  6E4F      	MOVWF CompTempVar2701
0092  524F      	MOVF CompTempVar2701, F
0094  E0FB      	BZ	label5


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0096  504D      	MOVF FC_CAL_UAR_00073_arg_nChar, W
0098  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
009A  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
009C  684E      	SETF FC_CAL_UAR_00072_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
009E  6A4F      	CLRF FC_CAL_UAR_00072_1_delay1

	MX_UINT8 regcheck = 0;
00A0  6A50      	CLRF FC_CAL_UAR_00072_1_regcheck

	MX_UINT8 bWaitForever = 0;
00A2  6A51      	CLRF FC_CAL_UAR_00072_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
00A4  6A52      	CLRF FC_CAL_UAR_00072_1_rxStatus

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
00A6  6A55      	CLRF FC_CAL_UAR_00072_1_dummy

  #endif

	if (nTimeout == 255)
00A8  284D      	INCF FC_CAL_UAR_00072_arg_nTimeout, W
00AA  E102      	BNZ	label6
00B0            label6

		bWaitForever = 1;
00AC  0E01      	MOVLW 0x01
00AE  6E51      	MOVWF FC_CAL_UAR_00072_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00B0  5252      	MOVF FC_CAL_UAR_00072_1_rxStatus, F
00B2  E124      	BNZ	label11
00FA  D7DA      	BRA	label6
00FC            label11

	{
		if (bWaitForever == 0)
00B4  5251      	MOVF FC_CAL_UAR_00072_1_bWaitForever, F
00B6  E118      	BNZ	label10

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00B8  524D      	MOVF FC_CAL_UAR_00072_arg_nTimeout, F
00BA  E103      	BNZ	label7
00C2            label7

			{
				rxStatus = UART_STATUS_TIMEOUT;
00BC  0E01      	MOVLW 0x01
00BE  6E52      	MOVWF FC_CAL_UAR_00072_1_rxStatus

			}
			else
00C0  D013      	BRA	label10

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00C2  6A53      	CLRF FC_CAL_UAR_00072_1_delaycnt
00C4  6A54      	CLRF FC_CAL_UAR_00072_1_delaycnt+D'1'
00C6            label8
00C6  0E31      	MOVLW 0x31
00C8  5C53      	SUBWF FC_CAL_UAR_00072_1_delaycnt, W
00CA  E205      	BC	label9
00CC  6654      	TSTFSZ FC_CAL_UAR_00072_1_delaycnt+D'1'
00CE  D003      	BRA	label9
00D0  4A53      	INFSNZ FC_CAL_UAR_00072_1_delaycnt, F
00D2  2A54      	INCF FC_CAL_UAR_00072_1_delaycnt+D'1', F
00D4  D7F8      	BRA	label8
00D6            label9

				delay1 = delay1 + 1;
00D6  284F      	INCF FC_CAL_UAR_00072_1_delay1, W
00D8  6E4F      	MOVWF FC_CAL_UAR_00072_1_delay1

				if(delay1 == 100)
00DA  0E64      	MOVLW 0x64
00DC  624F      	CPFSEQ FC_CAL_UAR_00072_1_delay1
00DE  D004      	BRA	label10
00E8            label10

				{
					nTimeout = nTimeout - 1;
00E0  044D      	DECF FC_CAL_UAR_00072_arg_nTimeout, W
00E2  6E4D      	MOVWF FC_CAL_UAR_00072_arg_nTimeout

					MX_CLEAR_WATCHDOG;
00E4  0004      	CLRWDT

					delay1 = 0;
00E6  6A4F      	CLRF FC_CAL_UAR_00072_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00E8  0E20      	MOVLW 0x20
00EA  149E      	ANDWF gbl_pir1, W
00EC  6E56      	MOVWF CompTempVar2698
00EE  5056      	MOVF CompTempVar2698, W
00F0  6E50      	MOVWF FC_CAL_UAR_00072_1_regcheck

			if (regcheck != 0)
00F2  5250      	MOVF FC_CAL_UAR_00072_1_regcheck, F
00F4  E0DD      	BZ	label6

				rxStatus = UART_STATUS_RXBYTE;
00F6  0E02      	MOVLW 0x02
00F8  6E52      	MOVWF FC_CAL_UAR_00072_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00FC  0E02      	MOVLW 0x02
00FE  6252      	CPFSEQ FC_CAL_UAR_00072_1_rxStatus
0100  D018      	BRA	label14

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0102  0E04      	MOVLW 0x04
0104  14AB      	ANDWF gbl_rcsta, W
0106  6E56      	MOVWF CompTempVar2699
0108  5056      	MOVF CompTempVar2699, W
010A  6E50      	MOVWF FC_CAL_UAR_00072_1_regcheck

			if (regcheck != 0)
010C  5250      	MOVF FC_CAL_UAR_00072_1_regcheck, F
010E  E003      	BZ	label12
0116            label12

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0110  50AE      	MOVF gbl_rcreg, W
0112  6E55      	MOVWF FC_CAL_UAR_00072_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0114  D00E      	BRA	label14

			{
				regcheck = ts_bit(rcsta, OERR);
0116  0E02      	MOVLW 0x02
0118  14AB      	ANDWF gbl_rcsta, W
011A  6E56      	MOVWF CompTempVar2700
011C  5056      	MOVF CompTempVar2700, W
011E  6E50      	MOVWF FC_CAL_UAR_00072_1_regcheck

				if (regcheck != 0)
0120  5250      	MOVF FC_CAL_UAR_00072_1_regcheck, F
0122  E003      	BZ	label13
012A            label13

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0124  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0126  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0128  D004      	BRA	label14
0132            label14

				{
					retVal = 0;
012A  6A4E      	CLRF FC_CAL_UAR_00072_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
012C  50AE      	MOVF gbl_rcreg, W
012E  104E      	IORWF FC_CAL_UAR_00072_1_retVal, W
0130  6E4E      	MOVWF FC_CAL_UAR_00072_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0132  504E      	MOVF FC_CAL_UAR_00072_1_retVal, W
0134  6E56      	MOVWF CompTempVarRet2697
0136  6A57      	CLRF CompTempVarRet2697+D'1'

}
0138  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))

{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
0152  0E07      	MOVLW 0x07
0154  6443      	CPFSGT FC_CAL_UAR_00070_arg_new_baud
0156  D001      	BRA	label15
015A            label15

		return;

	if (new_baud == 0)
015A  5243      	MOVF FC_CAL_UAR_00070_arg_new_baud, F
015C  E104      	BNZ	label16
0166            label16

	{
		baudrate = MX_HARD_BAUD_1200;
015E  6844      	SETF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_1200;
0160  0E01      	MOVLW 0x01
0162  6E45      	MOVWF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 1)
0164  D02F      	BRA	label23
0166  0443      	DECF FC_CAL_UAR_00070_arg_new_baud, W
0168  E105      	BNZ	label17
0174            label17

	{
		baudrate = MX_HARD_BAUD_2400;
016A  0E7F      	MOVLW 0x7F
016C  6E44      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_2400;
016E  0E01      	MOVLW 0x01
0170  6E45      	MOVWF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 2)
0172  D028      	BRA	label23
0174  0E02      	MOVLW 0x02
0176  6243      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
0178  D003      	BRA	label18
0180            label18

	{
		baudrate = MX_HARD_BAUD_4800;
017A  6844      	SETF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_4800;
017C  6A45      	CLRF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 3)
017E  D022      	BRA	label23
0180  0E03      	MOVLW 0x03
0182  6243      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
0184  D004      	BRA	label19
018E            label19

	{
		baudrate = MX_HARD_BAUD_9600;
0186  0E7F      	MOVLW 0x7F
0188  6E44      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_9600;
018A  6A45      	CLRF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 4)
018C  D01B      	BRA	label23
018E  0E04      	MOVLW 0x04
0190  6243      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
0192  D004      	BRA	label20
019C            label20

	{
		baudrate = MX_HARD_BAUD_19200;
0194  0E3F      	MOVLW 0x3F
0196  6E44      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_19200;
0198  6A45      	CLRF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 5)
019A  D014      	BRA	label23
019C  0E05      	MOVLW 0x05
019E  6243      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
01A0  D004      	BRA	label21
01AA            label21

	{
		baudrate = MX_HARD_BAUD_38400;
01A2  0E1F      	MOVLW 0x1F
01A4  6E44      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_38400;
01A6  6A45      	CLRF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 6)
01A8  D00D      	BRA	label23
01AA  0E06      	MOVLW 0x06
01AC  6243      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
01AE  D004      	BRA	label22
01B8            label22

	{
		baudrate = MX_HARD_BAUD_57600;
01B0  0E14      	MOVLW 0x14
01B2  6E44      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_57600;
01B4  6A45      	CLRF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 7)
01B6  D006      	BRA	label23
01B8  0E07      	MOVLW 0x07
01BA  6243      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
01BC  D003      	BRA	label23
01C4            label23

	{
		baudrate = MX_HARD_BAUD_115200;
01BE  0E0A      	MOVLW 0x0A
01C0  6E44      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_115200;
01C2  6A45      	CLRF FC_CAL_UAR_00070_1_baudmode

	}

	UART_Uninit();
01C4  EC9DF000  	CALL FC_CAL_UAR_00071


	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
01C8  0445      	DECF FC_CAL_UAR_00070_1_baudmode, W
01CA  E102      	BNZ	label24
01D0            label24

			cr_bit(txsta, BRGH);					//Low Speed
01CC  94AC      	BCF gbl_txsta,2

	    else
01CE  D001      	BRA	label25
01D2            label25

			st_bit(txsta, BRGH);					//High Speed
01D0  84AC      	BSF gbl_txsta,2


		spbrg = baudrate;   						// set the baud rate
01D2  5044      	MOVF FC_CAL_UAR_00070_1_baudrate, W
01D4  6EAF      	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
01D6  6AAB      	CLRF gbl_rcsta


		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
01D8  8EAB      	BSF gbl_rcsta,7

		st_bit(txsta, TXEN);
01DA  8AAC      	BSF gbl_txsta,5

		st_bit(rcsta, CREN);
01DC  88AB      	BSF gbl_rcsta,4


		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
01DE  9A9D      	BCF gbl_pie1,5

		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0158  0012      	RETURN
01E0  0012      	RETURN


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF0CF009  	GOTO	_startup

0008  EF46F009  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  5244      	MOVF delay_ms_00000_arg_del, F
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF5      	MOVLW 0xF5
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0FFF      	ADDLW 0xFF
0038  A4D8      	BTFSS STATUS,Z
003A  D7ED      	BRA	label2
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  2E44      	DECFSZ delay_ms_00000_arg_del, F
0058  D7DD      	BRA	label1
005A  0012      	RETURN
005C            ; } delay_ms function end

005C            delay_us_00000
005C            ; { delay_us ; function begin
005C            label3
005C  0000      	NOP
005E  0000      	NOP
0060  2E43      	DECFSZ delay_us_00000_arg_del, F
0062  D7FC      	BRA	label3
0064  0012      	RETURN
0066            ; } delay_us function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6E44      	MOVWF delay_ms_00000_arg_del
006A  EC06F000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6E44      	MOVWF delay_ms_00000_arg_del
0072  EC06F000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6E44      	MOVWF delay_ms_00000_arg_del
007A  EC06F000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6E44      	MOVWF delay_ms_00000_arg_del
0082  EC06F000  	CALL delay_ms_00000
0086  2E43      	DECFSZ delay_s_00000_arg_del, F
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end



















































1218            _startup
1218  0ED5      	MOVLW 0xD5
121A  6E05      	MOVWF gbl_14_LSR
121C  0EC4      	MOVLW 0xC4
121E  6E06      	MOVWF gbl_14_LSR+D'1'
1220  0EBB      	MOVLW 0xBB
1222  6E07      	MOVWF gbl_14_LSR+D'2'
1224  0EDC      	MOVLW 0xDC
1226  6E08      	MOVWF gbl_14_LSR+D'3'
1228  6A09      	CLRF gbl_15_gbl_aSig
122A  6A0A      	CLRF gbl_15_gbl_aSig+D'1'
122C  6A0B      	CLRF gbl_15_gbl_aSig+D'2'
122E  6A0C      	CLRF gbl_15_gbl_aSig+D'3'
1230  6A0D      	CLRF gbl_15_gbl_bSig
1232  6A0E      	CLRF gbl_15_gbl_bSig+D'1'
1234  6A0F      	CLRF gbl_15_gbl_bSig+D'2'
1236  6A10      	CLRF gbl_15_gbl_bSig+D'3'
1238  6A11      	CLRF gbl_15_gbl_zSig
123A  6A12      	CLRF gbl_15_gbl_zSig+D'1'
123C  6A13      	CLRF gbl_15_gbl_zSig+D'2'
123E  6A14      	CLRF gbl_15_gbl_zSig+D'3'
1240  6A2E      	CLRF gbl_15_gbl_aExp
1242  6A2F      	CLRF gbl_15_gbl_bExp
1244  6A1D      	CLRF gbl_15_gbl_zExp
1246  6A1E      	CLRF gbl_15_gbl_zExp+D'1'
1248  6A30      	CLRF gbl_15_gbl_aSign
124A  6A31      	CLRF gbl_15_gbl_bSign
124C  6A32      	CLRF gbl_15_gbl_zSign
124E  6A33      	CLRF gbl_15_gbl_zSigZero
1250  6A15      	CLRF gbl_15_gbl_ret
1252  6A16      	CLRF gbl_15_gbl_ret+D'1'
1254  6A17      	CLRF gbl_15_gbl_ret+D'2'
1256  6A18      	CLRF gbl_15_gbl_ret+D'3'
1258  6A2C      	CLRF gbl_float_rounding_mode
125A  6A2D      	CLRF gbl_float_exception_flags
125C  6A2B      	CLRF gbl_float_detect_tininess



1288  EF1FF008  	GOTO	main

300000  32FF      	DW 0x32FF
300002  FEFF      	DW 0xFEFF
300004  FBFF      	DW 0xFBFF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
