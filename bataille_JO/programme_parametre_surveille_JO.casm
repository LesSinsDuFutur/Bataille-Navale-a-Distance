;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
05A0  5046      	MOVF FC_CAL_Por_00042_arg_Tris+D'1', W
05A2  6EEA      	MOVWF FSR0H
05A4  5045      	MOVF FC_CAL_Por_00042_arg_Tris, W
05A6  6EE9      	MOVWF FSR0L
05A8  5047      	MOVF FC_CAL_Por_00042_arg_InMask, W
05AA  10EF      	IORWF INDF0, W
05AC  6E49      	MOVWF CompTempVar1825
05AE  5049      	MOVF CompTempVar1825, W
05B0  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
05B2  5044      	MOVF FC_CAL_Por_00042_arg_Port+D'1', W
05B4  6EEA      	MOVWF FSR0H
05B6  5043      	MOVF FC_CAL_Por_00042_arg_Port, W
05B8  6EE9      	MOVWF FSR0L
05BA  5047      	MOVF FC_CAL_Por_00042_arg_InMask, W
05BC  14EF      	ANDWF INDF0, W
05BE  6E49      	MOVWF CompTempVarRet1822
05C0  5048      	MOVF FC_CAL_Por_00042_arg_Shift, W
05C2  6E4A      	MOVWF CompTempVar1827
05C4            label81
05C4  B4D8      	BTFSC STATUS,Z
05C8  90D8      	BCF STATUS,C
05CA  3249      	RRCF CompTempVarRet1822, F
05CC  064A      	DECF CompTempVar1827, F
05CE  D7FA      	BRA	label81

		}
05C6  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
0222  6A54      	CLRF FCI_GETLEN_0004B_1_tmp
0224            label18
0224  5053      	MOVF FCI_GETLEN_0004B_arg_iStr1_len, W
0226  6054      	CPFSLT FCI_GETLEN_0004B_1_tmp
0228  D009      	BRA	label19
022A  5052      	MOVF FCI_GETLEN_0004B_arg_sStr1+D'1', W
022C  6EEA      	MOVWF FSR0H
022E  5051      	MOVF FCI_GETLEN_0004B_arg_sStr1, W
0230  2454      	ADDWF FCI_GETLEN_0004B_1_tmp, W
0232  6EE9      	MOVWF FSR0L
0234  52EF      	MOVF INDF0, F
0236  E002      	BZ	label19
0238  2A54      	INCF FCI_GETLEN_0004B_1_tmp, F
023A  D7F4      	BRA	label18
023C            label19

	return (tmp);
023C  5054      	MOVF FCI_GETLEN_0004B_1_tmp, W
023E  6E55      	MOVWF CompTempVarRet1850

}
0240  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)

{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;
05D0  504B      	MOVF FCI_TOSTRI_0004F_arg_iSrc1, W
05D2  6E53      	MOVWF FCI_TOSTRI_0004F_1_iSrc
05D4  504C      	MOVF FCI_TOSTRI_0004F_arg_iSrc1+D'1', W
05D6  6E54      	MOVWF FCI_TOSTRI_0004F_1_iSrc+D'1'
05D8  504D      	MOVF FCI_TOSTRI_0004F_arg_iSrc1+D'2', W
05DA  6E55      	MOVWF FCI_TOSTRI_0004F_1_iSrc+D'2'
05DC  504E      	MOVF FCI_TOSTRI_0004F_arg_iSrc1+D'3', W
05DE  6E56      	MOVWF FCI_TOSTRI_0004F_1_iSrc+D'3'


	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
05E0  6A57      	CLRF FCI_TOSTRI_0004F_1_top
05E2  0ECA      	MOVLW 0xCA
05E4  6E58      	MOVWF FCI_TOSTRI_0004F_1_top+D'1'
05E6  0E9A      	MOVLW 0x9A
05E8  6E59      	MOVWF FCI_TOSTRI_0004F_1_top+D'2'
05EA  0E3B      	MOVLW 0x3B
05EC  6E5A      	MOVWF FCI_TOSTRI_0004F_1_top+D'3'

	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;
05EE  6A5B      	CLRF FCI_TOSTRI_0004F_1_idx


	if (iDst_len == 0) return sDst;
05F0  5251      	MOVF FCI_TOSTRI_0004F_arg_iDst_len, F
05F2  E105      	BNZ	label82
05F4  504F      	MOVF FCI_TOSTRI_0004F_arg_sDst, W
05F6  6E5C      	MOVWF CompTempVarRet1863
05F8  5050      	MOVF FCI_TOSTRI_0004F_arg_sDst+D'1', W
05FA  6E5D      	MOVWF CompTempVarRet1863+D'1'
05FE            label82


	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
05FE  AE56      	BTFSS FCI_TOSTRI_0004F_1_iSrc+D'3',7
0600  D014      	BRA	label83

	{
		sDst[0] = '-';
0602  5050      	MOVF FCI_TOSTRI_0004F_arg_sDst+D'1', W
0604  6EEA      	MOVWF FSR0H
0606  504F      	MOVF FCI_TOSTRI_0004F_arg_sDst, W
0608  6EE9      	MOVWF FSR0L
060A  6A5E      	CLRF CompTempVar1865
060C  505E      	MOVF CompTempVar1865, W
060E  26E9      	ADDWF FSR0L, F
0610  0E2D      	MOVLW 0x2D
0612  6EEF      	MOVWF INDF0

		idx++;
0614  2A5B      	INCF FCI_TOSTRI_0004F_1_idx, F

		iSrc = -iSrc;
0616  1E53      	COMF FCI_TOSTRI_0004F_1_iSrc, F
0618  1E54      	COMF FCI_TOSTRI_0004F_1_iSrc+D'1', F
061A  1E55      	COMF FCI_TOSTRI_0004F_1_iSrc+D'2', F
061C  1E56      	COMF FCI_TOSTRI_0004F_1_iSrc+D'3', F
061E  3E53      	INCFSZ FCI_TOSTRI_0004F_1_iSrc, F
0620  D004      	BRA	label83
0622  3E54      	INCFSZ FCI_TOSTRI_0004F_1_iSrc+D'1', F
0624  D002      	BRA	label83
0626  4A55      	INFSNZ FCI_TOSTRI_0004F_1_iSrc+D'2', F
0628  2A56      	INCF FCI_TOSTRI_0004F_1_iSrc+D'3', F
062A            label83

	}

	tmp1 = 0;    // Nothing added yet
062A  6A52      	CLRF FCI_TOSTRI_0004F_1_tmp1

	if (iSrc == 0) // Force showing zero
062C  5053      	MOVF FCI_TOSTRI_0004F_1_iSrc, W
062E  1054      	IORWF FCI_TOSTRI_0004F_1_iSrc+D'1', W
0630  1055      	IORWF FCI_TOSTRI_0004F_1_iSrc+D'2', W
0632  1056      	IORWF FCI_TOSTRI_0004F_1_iSrc+D'3', W
0634  0BFF      	ANDLW 0xFF
0636  E106      	BNZ	label84
0644            label84

	{
		tmp1 = 1;
0638  0E01      	MOVLW 0x01
063A  6E52      	MOVWF FCI_TOSTRI_0004F_1_tmp1

		top = 1;
063C  6E57      	MOVWF FCI_TOSTRI_0004F_1_top
063E  6A58      	CLRF FCI_TOSTRI_0004F_1_top+D'1'
0640  6A59      	CLRF FCI_TOSTRI_0004F_1_top+D'2'
0642  6A5A      	CLRF FCI_TOSTRI_0004F_1_top+D'3'

	}
	while (( idx < iDst_len) && (top > 0))
0644  5051      	MOVF FCI_TOSTRI_0004F_arg_iDst_len, W
0646  605B      	CPFSLT FCI_TOSTRI_0004F_1_idx
0648  D072      	BRA	label89
064A  505A      	MOVF FCI_TOSTRI_0004F_1_top+D'3', W
064C  0800      	SUBLW 0x00
064E  E108      	BNZ	label85
0650  5059      	MOVF FCI_TOSTRI_0004F_1_top+D'2', W
0652  0800      	SUBLW 0x00
0654  E105      	BNZ	label85
0656  5058      	MOVF FCI_TOSTRI_0004F_1_top+D'1', W
0658  0800      	SUBLW 0x00
065A  E102      	BNZ	label85
065C  5057      	MOVF FCI_TOSTRI_0004F_1_top, W
065E  0800      	SUBLW 0x00
0660            label85
0660  E266      	BC	label89
072C  D78B      	BRA	label84
072E            label89

	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
0662  505A      	MOVF FCI_TOSTRI_0004F_1_top+D'3', W
0664  5C56      	SUBWF FCI_TOSTRI_0004F_1_iSrc+D'3', W
0666  E108      	BNZ	label86
0668  5059      	MOVF FCI_TOSTRI_0004F_1_top+D'2', W
066A  5C55      	SUBWF FCI_TOSTRI_0004F_1_iSrc+D'2', W
066C  E105      	BNZ	label86
066E  5058      	MOVF FCI_TOSTRI_0004F_1_top+D'1', W
0670  5C54      	SUBWF FCI_TOSTRI_0004F_1_iSrc+D'1', W
0672  E102      	BNZ	label86
0674  5057      	MOVF FCI_TOSTRI_0004F_1_top, W
0676  5C53      	SUBWF FCI_TOSTRI_0004F_1_iSrc, W
0678            label86
0678  E202      	BC	label87
067A  5252      	MOVF FCI_TOSTRI_0004F_1_tmp1, F
067C  E040      	BZ	label88
067E            label87
06FE            label88

		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
067E  5053      	MOVF FCI_TOSTRI_0004F_1_iSrc, W
0680  6E5E      	MOVWF __div_32_3_00011_arg_a
0682  5054      	MOVF FCI_TOSTRI_0004F_1_iSrc+D'1', W
0684  6E5F      	MOVWF __div_32_3_00011_arg_a+D'1'
0686  5055      	MOVF FCI_TOSTRI_0004F_1_iSrc+D'2', W
0688  6E60      	MOVWF __div_32_3_00011_arg_a+D'2'
068A  5056      	MOVF FCI_TOSTRI_0004F_1_iSrc+D'3', W
068C  6E61      	MOVWF __div_32_3_00011_arg_a+D'3'
068E  5057      	MOVF FCI_TOSTRI_0004F_1_top, W
0690  6E62      	MOVWF __div_32_3_00011_arg_b
0692  5058      	MOVF FCI_TOSTRI_0004F_1_top+D'1', W
0694  6E63      	MOVWF __div_32_3_00011_arg_b+D'1'
0696  5059      	MOVF FCI_TOSTRI_0004F_1_top+D'2', W
0698  6E64      	MOVWF __div_32_3_00011_arg_b+D'2'
069A  505A      	MOVF FCI_TOSTRI_0004F_1_top+D'3', W
069C  6E65      	MOVWF __div_32_3_00011_arg_b+D'3'
069E  EC85F000  	CALL __div_32_3_00011
06A2  506C      	MOVF CompTempVarRet172, W
06A4  6E52      	MOVWF FCI_TOSTRI_0004F_1_tmp1

			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
06A6  5052      	MOVF FCI_TOSTRI_0004F_1_tmp1, W
06A8  0F30      	ADDLW 0x30
06AA  6E5E      	MOVWF CompTempVar1871
06AC  5050      	MOVF FCI_TOSTRI_0004F_arg_sDst+D'1', W
06AE  6EEA      	MOVWF FSR0H
06B0  504F      	MOVF FCI_TOSTRI_0004F_arg_sDst, W
06B2  245B      	ADDWF FCI_TOSTRI_0004F_1_idx, W
06B4  6EE9      	MOVWF FSR0L
06B6  505E      	MOVF CompTempVar1871, W
06B8  6EEF      	MOVWF INDF0

			idx++;
06BA  2A5B      	INCF FCI_TOSTRI_0004F_1_idx, F

			iSrc -= tmp1 * top;				// Remove digit
06BC  5052      	MOVF FCI_TOSTRI_0004F_1_tmp1, W
06BE  6E5E      	MOVWF __mul_32_3_00016_arg_a
06C0  6A5F      	CLRF __mul_32_3_00016_arg_a+D'1'
06C2  6A60      	CLRF __mul_32_3_00016_arg_a+D'2'
06C4  6A61      	CLRF __mul_32_3_00016_arg_a+D'3'
06C6  5057      	MOVF FCI_TOSTRI_0004F_1_top, W
06C8  6E62      	MOVWF __mul_32_3_00016_arg_b
06CA  5058      	MOVF FCI_TOSTRI_0004F_1_top+D'1', W
06CC  6E63      	MOVWF __mul_32_3_00016_arg_b+D'1'
06CE  5059      	MOVF FCI_TOSTRI_0004F_1_top+D'2', W
06D0  6E64      	MOVWF __mul_32_3_00016_arg_b+D'2'
06D2  505A      	MOVF FCI_TOSTRI_0004F_1_top+D'3', W
06D4  6E65      	MOVWF __mul_32_3_00016_arg_b+D'3'
06D6  EC46F000  	CALL __mul_32_3_00016
06DA  506A      	MOVF CompTempVarRet414, W
06DC  6E66      	MOVWF CompTempVar1872
06DE  506B      	MOVF CompTempVarRet414+D'1', W
06E0  6E67      	MOVWF CompTempVar1873
06E2  506C      	MOVF CompTempVarRet414+D'2', W
06E4  6E68      	MOVWF CompTempVar1874
06E6  506D      	MOVF CompTempVarRet414+D'3', W
06E8  6E69      	MOVWF CompTempVar1875
06EA  5066      	MOVF CompTempVar1872, W
06EC  5E53      	SUBWF FCI_TOSTRI_0004F_1_iSrc, F
06EE  5067      	MOVF CompTempVar1873, W
06F0  5A54      	SUBWFB FCI_TOSTRI_0004F_1_iSrc+D'1', F
06F2  5068      	MOVF CompTempVar1874, W
06F4  5A55      	SUBWFB FCI_TOSTRI_0004F_1_iSrc+D'2', F
06F6  5069      	MOVF CompTempVar1875, W
06F8  5A56      	SUBWFB FCI_TOSTRI_0004F_1_iSrc+D'3', F

			tmp1 = 1;						// Add zeros now
06FA  0E01      	MOVLW 0x01
06FC  6E52      	MOVWF FCI_TOSTRI_0004F_1_tmp1

		}
		top /= 10;							// Go to next digit
06FE  5057      	MOVF FCI_TOSTRI_0004F_1_top, W
0700  6E5E      	MOVWF __div_32_3_00011_arg_a
0702  5058      	MOVF FCI_TOSTRI_0004F_1_top+D'1', W
0704  6E5F      	MOVWF __div_32_3_00011_arg_a+D'1'
0706  5059      	MOVF FCI_TOSTRI_0004F_1_top+D'2', W
0708  6E60      	MOVWF __div_32_3_00011_arg_a+D'2'
070A  505A      	MOVF FCI_TOSTRI_0004F_1_top+D'3', W
070C  6E61      	MOVWF __div_32_3_00011_arg_a+D'3'
070E  0E0A      	MOVLW 0x0A
0710  6E62      	MOVWF __div_32_3_00011_arg_b
0712  6A63      	CLRF __div_32_3_00011_arg_b+D'1'
0714  6A64      	CLRF __div_32_3_00011_arg_b+D'2'
0716  6A65      	CLRF __div_32_3_00011_arg_b+D'3'
0718  EC85F000  	CALL __div_32_3_00011
071C  506C      	MOVF CompTempVarRet172, W
071E  6E57      	MOVWF FCI_TOSTRI_0004F_1_top
0720  506D      	MOVF CompTempVarRet172+D'1', W
0722  6E58      	MOVWF FCI_TOSTRI_0004F_1_top+D'1'
0724  506E      	MOVF CompTempVarRet172+D'2', W
0726  6E59      	MOVWF FCI_TOSTRI_0004F_1_top+D'2'
0728  506F      	MOVF CompTempVarRet172+D'3', W
072A  6E5A      	MOVWF FCI_TOSTRI_0004F_1_top+D'3'

	}

	if (idx < iDst_len)						//add terminating null (if we can)
072E  5051      	MOVF FCI_TOSTRI_0004F_arg_iDst_len, W
0730  605B      	CPFSLT FCI_TOSTRI_0004F_1_idx
0732  D007      	BRA	label90
0742            label90

		sDst[idx] = '\0';
0734  5050      	MOVF FCI_TOSTRI_0004F_arg_sDst+D'1', W
0736  6EEA      	MOVWF FSR0H
0738  504F      	MOVF FCI_TOSTRI_0004F_arg_sDst, W
073A  245B      	ADDWF FCI_TOSTRI_0004F_1_idx, W
073C  6EE9      	MOVWF FSR0L
073E  0E00      	MOVLW 0x00
0740  6EEF      	MOVWF INDF0

	return (sDst);
0742  504F      	MOVF FCI_TOSTRI_0004F_arg_sDst, W
0744  6E5C      	MOVWF CompTempVarRet1863
0746  5050      	MOVF FCI_TOSTRI_0004F_arg_sDst+D'1', W
0748  6E5D      	MOVWF CompTempVarRet1863+D'1'

}
05FC  0012      	RETURN
074A  0012      	RETURN




void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BatailleNavale\programme_parametre_surveille_JO.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Tuesday, April 04, 2017 14:44:26
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x79
#endif
#ifdef HI_TECH_C
__CONFIG(0x79);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_Y_HOLD = (0x0);
0B5A  6A34      	CLRF gbl_FCV_Y_HOLD

MX_GLOBAL MX_UINT16 FCV_Y = (0x0);
0B5C  6A1F      	CLRF gbl_FCV_Y
0B5E  6A20      	CLRF gbl_FCV_Y+D'1'

MX_GLOBAL MX_UINT16 FCV_X = (0x0);
0B60  6A21      	CLRF gbl_FCV_X
0B62  6A22      	CLRF gbl_FCV_X+D'1'

MX_GLOBAL MX_UINT8 FCV_Y_OLD = (0x1);
0B64  0E01      	MOVLW 0x01
0B66  6E35      	MOVWF gbl_FCV_Y_OLD



/*========================================================================*\
   Use :ctrl_lcd
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_eb005
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_0ad31_lcd_eb005__Clear FCD_04071_LCD__Clear
#define FCD_0ad31_lcd_eb005__PrintString FCD_04071_LCD__PrintString
#define FCD_0ad31_lcd_eb005__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0ad31_lcd_eb005__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0ad31_lcd_eb005__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0ad31_lcd_eb005__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0ad31_lcd_eb005__Cursor FCD_04071_LCD__Cursor
#define FCD_0ad31_lcd_eb005__Command FCD_04071_LCD__Command
#define FCD_0ad31_lcd_eb005__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0ad31_lcd_eb005__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0ad31_lcd_eb005__RawSend FCD_04071_LCD__RawSend
#define FCD_0ad31_lcd_eb005__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 porta
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 porta
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisa
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisa
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (2)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
0B68  0E00      	MOVLW 0x00
0B6A  6E36      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
0B6C  0E01      	MOVLW 0x01
0B6E  6E37      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
0B70  0E02      	MOVLW 0x02
0B72  6E38      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
0B74  0E03      	MOVLW 0x03
0B76  6E39      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
0B78  0E04      	MOVLW 0x04
0B7A  6E3A      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
0B7C  0E05      	MOVLW 0x05
0B7E  6E3B      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
0B80  0E06      	MOVLW 0x06
0B82  6E3C      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
0B84  0E07      	MOVLW 0x07
0B86  6E3D      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
0B88  6A19      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009
0B8A  6A1A      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1'
0B8C  6A1B      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2'
0B8E  6A1C      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3'

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
0B90  6A3E      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :ctrl_lcd
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()

{




	FCD_04071_LCD__RawSend(0x01, 0);
0AAE  0E01      	MOVLW 0x01
0AB0  6E51      	MOVWF FCD_04071__0005C_arg_FCL_DATA
0AB2  9052      	BCF FCD_04071__0005C_arg_FCL_TYPE,0
0AB4  EC21F001  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
0AB8  0E02      	MOVLW 0x02
0ABA  6E44      	MOVWF delay_ms_00000_arg_del
0ABC  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x02, 0);
0AC0  0E02      	MOVLW 0x02
0AC2  6E51      	MOVWF FCD_04071__0005C_arg_FCL_DATA
0AC4  9052      	BCF FCD_04071__0005C_arg_FCL_TYPE,0
0AC6  EC21F001  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
0ACA  0E02      	MOVLW 0x02
0ACC  6E44      	MOVWF delay_ms_00000_arg_del
0ACE  EC0BF000  	CALL delay_ms_00000


}
0AD2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Param??tres pour la macro PrintString :
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
078C  6A4F      	CLRF FCD_04071__0005D_1_FCL_IDX

	MX_UINT8 FCL_COUNT;



	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);
078E  504B      	MOVF FCD_04071__0005D_arg_FCL_TEXT, W
0790  6E51      	MOVWF FCI_GETLEN_0004B_arg_sStr1
0792  504C      	MOVF FCD_04071__0005D_arg_FCL_TEXT+D'1', W
0794  6E52      	MOVWF FCI_GETLEN_0004B_arg_sStr1+D'1'
0796  504D      	MOVF FCD_04071__0005D_arg_FCLsz_TEXT, W
0798  6E53      	MOVWF FCI_GETLEN_0004B_arg_iStr1_len
079A  EC11F001  	CALL FCI_GETLEN_0004B
079E  5055      	MOVF CompTempVarRet1850, W
07A0  6E50      	MOVWF FCD_04071__0005D_1_FCL_COUNT


	while (FCL_IDX < FCL_COUNT)
07A2            label91
07A2  5050      	MOVF FCD_04071__0005D_1_FCL_COUNT, W
07A4  604F      	CPFSLT FCD_04071__0005D_1_FCL_IDX
07C0  D7F0      	BRA	label91

	{

		FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);
07A8  504C      	MOVF FCD_04071__0005D_arg_FCL_TEXT+D'1', W
07AA  6EEA      	MOVWF FSR0H
07AC  504B      	MOVF FCD_04071__0005D_arg_FCL_TEXT, W
07AE  244F      	ADDWF FCD_04071__0005D_1_FCL_IDX, W
07B0  6EE9      	MOVWF FSR0L
07B2  50EF      	MOVF INDF0, W
07B4  6E51      	MOVWF FCD_04071__0005C_arg_FCL_DATA
07B6  8052      	BSF FCD_04071__0005C_arg_FCL_TYPE,0
07B8  EC21F001  	CALL FCD_04071__0005C


		FCL_IDX = FCL_IDX + 1;
07BC  284F      	INCF FCD_04071__0005D_1_FCL_IDX, W
07BE  6E4F      	MOVWF FCD_04071__0005D_1_FCL_IDX



	}


}
07A6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Param??tres pour la macro PrintAscii :
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)

{
	//Définitions des variables locales
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);
0A76  503F      	MOVF FCD_04071__00060_arg_FCL_NUMBER, W
0A78  6E4B      	MOVWF FCI_TOSTRI_0004F_arg_iSrc1
0A7A  5040      	MOVF FCD_04071__00060_arg_FCL_NUMBER+D'1', W
0A7C  6E4C      	MOVWF FCI_TOSTRI_0004F_arg_iSrc1+D'1'
0A7E  6A4D      	CLRF FCI_TOSTRI_0004F_arg_iSrc1+D'2'
0A80  6A4E      	CLRF FCI_TOSTRI_0004F_arg_iSrc1+D'3'
0A82  AE40      	BTFSS FCD_04071__00060_arg_FCL_NUMBER+D'1',7
0A84  D002      	BRA	label103
0A86  064D      	DECF FCI_TOSTRI_0004F_arg_iSrc1+D'2', F
0A88  064E      	DECF FCI_TOSTRI_0004F_arg_iSrc1+D'3', F
0A8A            label103
0A8A  0E00      	MOVLW HIGH(FCD_04071__00060_1_FCL_S+D'0')
0A8C  6E50      	MOVWF FCI_TOSTRI_0004F_arg_sDst+D'1'
0A8E  0E41      	MOVLW LOW(FCD_04071__00060_1_FCL_S+D'0')
0A90  6E4F      	MOVWF FCI_TOSTRI_0004F_arg_sDst
0A92  0E0A      	MOVLW 0x0A
0A94  6E51      	MOVWF FCI_TOSTRI_0004F_arg_iDst_len
0A96  ECE8F002  	CALL FCI_TOSTRI_0004F


	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);
0A9A  0E00      	MOVLW HIGH(FCD_04071__00060_1_FCL_S+D'0')
0A9C  6E4C      	MOVWF FCD_04071__0005D_arg_FCL_TEXT+D'1'
0A9E  0E41      	MOVLW LOW(FCD_04071__00060_1_FCL_S+D'0')
0AA0  6E4B      	MOVWF FCD_04071__0005D_arg_FCL_TEXT
0AA2  0E0A      	MOVLW 0x0A
0AA4  6E4D      	MOVWF FCD_04071__0005D_arg_FCLsz_TEXT
0AA6  6A4E      	CLRF FCD_04071__0005D_arg_FCLsz_TEXT+D'1'
0AA8  ECC6F003  	CALL FCD_04071__0005D


	//Définitions des variables locales
	#undef FCLsz_S
}
0AAC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Param??tres pour la macro RAMWrite :
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Param??tres pour la macro ClearLine :
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Param??tres pour la macro Cursor :
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{



	#if (0) // 2 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
		{

			FCL_Y = 0x80;

		} else {

			FCL_Y = 0xC0;

		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 2 == 4

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Param??tres pour la macro Command :
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Param??tres pour la macro PrintFormattedNumber :
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Définitions des variables locales
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Param??tres pour la macro ScrollDisplay :
       :  Position : Holds the number of positions to shift the display
       :  direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Définitions des variables locales
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	switch (FCL_DIRECTION)
	{
		case 0:
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'l':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'L':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 1:
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'r':
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'R':
		{
			FCL_CMD = 0x1C;


			break;
		}
		// default:

	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Param??tres pour la macro RawSend :
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)

{
	//Définitions des variables locales
	MX_UINT8 FCL_NIBBLE;


	//Commentaire:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, B, 0x1, 0x0, 0);
0242  6A54      	CLRF FCD_04071__0005C_2_ptmp
0244  9093      	BCF gbl_trisb,0
0246  5254      	MOVF FCD_04071__0005C_2_ptmp, F
0248  E004      	BZ	label20
024A  0E01      	MOVLW 0x01
024C  108A      	IORWF gbl_latb, W
024E  6E81      	MOVWF gbl_portb
0250  D003      	BRA	label21
0252            label20
0252  0EFE      	MOVLW 0xFE
0254  148A      	ANDWF gbl_latb, W
0256  6E81      	MOVWF gbl_portb
0258            label21

		FCP_SET(B, B, 0x2, 0x1, 0);
0258  6A54      	CLRF FCD_04071__0005C_9_ptmp
025A  9293      	BCF gbl_trisb,1
025C  5254      	MOVF FCD_04071__0005C_9_ptmp, F
025E  E004      	BZ	label22
0260  0E02      	MOVLW 0x02
0262  108A      	IORWF gbl_latb, W
0264  6E81      	MOVWF gbl_portb
0266  D003      	BRA	label23
0268            label22
0268  0EFD      	MOVLW 0xFD
026A  148A      	ANDWF gbl_latb, W
026C  6E81      	MOVWF gbl_portb
026E            label23

		FCP_SET(B, B, 0x4, 0x2, 0);
026E  6A54      	CLRF FCD_04071__0005C_16_ptmp
0270  9493      	BCF gbl_trisb,2
0272  5254      	MOVF FCD_04071__0005C_16_ptmp, F
0274  E004      	BZ	label24
0276  0E04      	MOVLW 0x04
0278  108A      	IORWF gbl_latb, W
027A  6E81      	MOVWF gbl_portb
027C  D003      	BRA	label25
027E            label24
027E  0EFB      	MOVLW 0xFB
0280  148A      	ANDWF gbl_latb, W
0282  6E81      	MOVWF gbl_portb
0284            label25

		FCP_SET(B, B, 0x8, 0x3, 0);
0284  6A54      	CLRF FCD_04071__0005C_23_ptmp
0286  9693      	BCF gbl_trisb,3
0288  5254      	MOVF FCD_04071__0005C_23_ptmp, F
028A  E004      	BZ	label26
028C  0E08      	MOVLW 0x08
028E  108A      	IORWF gbl_latb, W
0290  6E81      	MOVWF gbl_portb
0292  D003      	BRA	label27
0294            label26
0294  0EF7      	MOVLW 0xF7
0296  148A      	ANDWF gbl_latb, W
0298  6E81      	MOVWF gbl_portb
029A            label27

		FCP_SET(B, B, 0x10, 0x4, 0);
029A  6A54      	CLRF FCD_04071__0005C_30_ptmp
029C  9893      	BCF gbl_trisb,4
029E  5254      	MOVF FCD_04071__0005C_30_ptmp, F
02A0  E004      	BZ	label28
02A2  0E10      	MOVLW 0x10
02A4  108A      	IORWF gbl_latb, W
02A6  6E81      	MOVWF gbl_portb
02A8  D003      	BRA	label29
02AA            label28
02AA  0EEF      	MOVLW 0xEF
02AC  148A      	ANDWF gbl_latb, W
02AE  6E81      	MOVWF gbl_portb
02B0            label29

		FCP_SET(B, B, 0x20, 0x5, 0);
02B0  6A54      	CLRF FCD_04071__0005C_37_ptmp
02B2  9A93      	BCF gbl_trisb,5
02B4  5254      	MOVF FCD_04071__0005C_37_ptmp, F
02B6  E004      	BZ	label30
02B8  0E20      	MOVLW 0x20
02BA  108A      	IORWF gbl_latb, W
02BC  6E81      	MOVWF gbl_portb
02BE  D003      	BRA	label31
02C0            label30
02C0  0EDF      	MOVLW 0xDF
02C2  148A      	ANDWF gbl_latb, W
02C4  6E81      	MOVWF gbl_portb
02C6            label31


		#if (0)

		//Le code a été optimisé par le préprocesseur
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
02C6  3851      	SWAPF FCD_04071__0005C_arg_FCL_DATA, W
02C8  0B0F      	ANDLW 0x0F
02CA  6E53      	MOVWF FCD_04071__0005C_1_FCL_NIBBLE

		FCP_SET(B, B, 0x1, 0x0, (FCL_NIBBLE & 0x01));
02CC  0E01      	MOVLW 0x01
02CE  1453      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W
02D0  6E54      	MOVWF FCD_04071__0005C_46_ptmp
02D2  9093      	BCF gbl_trisb,0
02D4  5254      	MOVF FCD_04071__0005C_46_ptmp, F
02D6  E004      	BZ	label32
02D8  0E01      	MOVLW 0x01
02DA  108A      	IORWF gbl_latb, W
02DC  6E81      	MOVWF gbl_portb
02DE  D003      	BRA	label33
02E0            label32
02E0  0EFE      	MOVLW 0xFE
02E2  148A      	ANDWF gbl_latb, W
02E4  6E81      	MOVWF gbl_portb
02E6            label33

		FCL_NIBBLE = FCL_NIBBLE >> 1;
02E6  5253      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F
02E8  90D8      	BCF STATUS,C
02EA  3253      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F

		FCP_SET(B, B, 0x2, 0x1, (FCL_NIBBLE & 0x01));
02EC  0E01      	MOVLW 0x01
02EE  1453      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W
02F0  6E54      	MOVWF FCD_04071__0005C_55_ptmp
02F2  9293      	BCF gbl_trisb,1
02F4  5254      	MOVF FCD_04071__0005C_55_ptmp, F
02F6  E004      	BZ	label34
02F8  0E02      	MOVLW 0x02
02FA  108A      	IORWF gbl_latb, W
02FC  6E81      	MOVWF gbl_portb
02FE  D003      	BRA	label35
0300            label34
0300  0EFD      	MOVLW 0xFD
0302  148A      	ANDWF gbl_latb, W
0304  6E81      	MOVWF gbl_portb
0306            label35

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0306  5253      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F
0308  90D8      	BCF STATUS,C
030A  3253      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F

		FCP_SET(B, B, 0x4, 0x2, (FCL_NIBBLE & 0x01));
030C  0E01      	MOVLW 0x01
030E  1453      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W
0310  6E54      	MOVWF FCD_04071__0005C_64_ptmp
0312  9493      	BCF gbl_trisb,2
0314  5254      	MOVF FCD_04071__0005C_64_ptmp, F
0316  E004      	BZ	label36
0318  0E04      	MOVLW 0x04
031A  108A      	IORWF gbl_latb, W
031C  6E81      	MOVWF gbl_portb
031E  D003      	BRA	label37
0320            label36
0320  0EFB      	MOVLW 0xFB
0322  148A      	ANDWF gbl_latb, W
0324  6E81      	MOVWF gbl_portb
0326            label37

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0326  5253      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F
0328  90D8      	BCF STATUS,C
032A  3253      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F

		FCP_SET(B, B, 0x8, 0x3, (FCL_NIBBLE & 0x01));
032C  0E01      	MOVLW 0x01
032E  1453      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W
0330  6E54      	MOVWF FCD_04071__0005C_73_ptmp
0332  9693      	BCF gbl_trisb,3
0334  5254      	MOVF FCD_04071__0005C_73_ptmp, F
0336  E004      	BZ	label38
0338  0E08      	MOVLW 0x08
033A  108A      	IORWF gbl_latb, W
033C  6E81      	MOVWF gbl_portb
033E  D003      	BRA	label39
0340            label38
0340  0EF7      	MOVLW 0xF7
0342  148A      	ANDWF gbl_latb, W
0344  6E81      	MOVWF gbl_portb
0346            label39


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	//Commentaire:
	//Output byte to pins

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	//Commentaire:
	//Output byte to port

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	if (FCL_TYPE)
0346  A052      	BTFSS FCD_04071__0005C_arg_FCL_TYPE,0
0348  D00C      	BRA	label41

	{

		FCP_SET(B, B, 0x10, 0x4, 1);
034A  0E01      	MOVLW 0x01
034C  6E54      	MOVWF FCD_04071__0005C_82_ptmp
034E  9893      	BCF gbl_trisb,4
0350  5254      	MOVF FCD_04071__0005C_82_ptmp, F
0352  E004      	BZ	label40
0354  0E10      	MOVLW 0x10
0356  108A      	IORWF gbl_latb, W
0358  6E81      	MOVWF gbl_portb
035A  D003      	BRA	label41
035C            label40
035C  0EEF      	MOVLW 0xEF
035E  148A      	ANDWF gbl_latb, W
0360  6E81      	MOVWF gbl_portb
0362            label41


	// } else {

	}

	FCI_DELAYBYTE_US(100);
0362  0E64      	MOVLW 0x64
0364  6E54      	MOVWF delay_us_00000_arg_del
0366  EC06F000  	CALL delay_us_00000


	//Commentaire:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, B, 0x20, 0x5, 1);
036A  0E01      	MOVLW 0x01
036C  6E54      	MOVWF FCD_04071__0005C_93_ptmp
036E  9A93      	BCF gbl_trisb,5
0370  5254      	MOVF FCD_04071__0005C_93_ptmp, F
0372  E004      	BZ	label42
0374  0E20      	MOVLW 0x20
0376  108A      	IORWF gbl_latb, W
0378  6E81      	MOVWF gbl_portb
037A  D003      	BRA	label43
037C            label42
037C  0EDF      	MOVLW 0xDF
037E  148A      	ANDWF gbl_latb, W
0380  6E81      	MOVWF gbl_portb
0382            label43


	FCI_DELAYBYTE_US(100);
0382  0E64      	MOVLW 0x64
0384  6E54      	MOVWF delay_us_00000_arg_del
0386  EC06F000  	CALL delay_us_00000


	FCP_SET(B, B, 0x20, 0x5, 0);
038A  6A54      	CLRF FCD_04071__0005C_104_ptmp
038C  9A93      	BCF gbl_trisb,5
038E  5254      	MOVF FCD_04071__0005C_104_ptmp, F
0390  E004      	BZ	label44
0392  0E20      	MOVLW 0x20
0394  108A      	IORWF gbl_latb, W
0396  6E81      	MOVWF gbl_portb
0398  D003      	BRA	label45
039A            label44
039A  0EDF      	MOVLW 0xDF
039C  148A      	ANDWF gbl_latb, W
039E  6E81      	MOVWF gbl_portb
03A0            label45


	FCI_DELAYBYTE_US(100);
03A0  0E64      	MOVLW 0x64
03A2  6E54      	MOVWF delay_us_00000_arg_del
03A4  EC06F000  	CALL delay_us_00000


	#if (1) // 0 == 0

		FCP_SET(B, B, 0x1, 0x0, 0);
03A8  6A54      	CLRF FCD_04071__0005C_115_ptmp
03AA  9093      	BCF gbl_trisb,0
03AC  5254      	MOVF FCD_04071__0005C_115_ptmp, F
03AE  E004      	BZ	label46
03B0  0E01      	MOVLW 0x01
03B2  108A      	IORWF gbl_latb, W
03B4  6E81      	MOVWF gbl_portb
03B6  D003      	BRA	label47
03B8            label46
03B8  0EFE      	MOVLW 0xFE
03BA  148A      	ANDWF gbl_latb, W
03BC  6E81      	MOVWF gbl_portb
03BE            label47

		FCP_SET(B, B, 0x2, 0x1, 0);
03BE  6A54      	CLRF FCD_04071__0005C_122_ptmp
03C0  9293      	BCF gbl_trisb,1
03C2  5254      	MOVF FCD_04071__0005C_122_ptmp, F
03C4  E004      	BZ	label48
03C6  0E02      	MOVLW 0x02
03C8  108A      	IORWF gbl_latb, W
03CA  6E81      	MOVWF gbl_portb
03CC  D003      	BRA	label49
03CE            label48
03CE  0EFD      	MOVLW 0xFD
03D0  148A      	ANDWF gbl_latb, W
03D2  6E81      	MOVWF gbl_portb
03D4            label49

		FCP_SET(B, B, 0x4, 0x2, 0);
03D4  6A54      	CLRF FCD_04071__0005C_129_ptmp
03D6  9493      	BCF gbl_trisb,2
03D8  5254      	MOVF FCD_04071__0005C_129_ptmp, F
03DA  E004      	BZ	label50
03DC  0E04      	MOVLW 0x04
03DE  108A      	IORWF gbl_latb, W
03E0  6E81      	MOVWF gbl_portb
03E2  D003      	BRA	label51
03E4            label50
03E4  0EFB      	MOVLW 0xFB
03E6  148A      	ANDWF gbl_latb, W
03E8  6E81      	MOVWF gbl_portb
03EA            label51

		FCP_SET(B, B, 0x8, 0x3, 0);
03EA  6A54      	CLRF FCD_04071__0005C_136_ptmp
03EC  9693      	BCF gbl_trisb,3
03EE  5254      	MOVF FCD_04071__0005C_136_ptmp, F
03F0  E004      	BZ	label52
03F2  0E08      	MOVLW 0x08
03F4  108A      	IORWF gbl_latb, W
03F6  6E81      	MOVWF gbl_portb
03F8  D003      	BRA	label53
03FA            label52
03FA  0EF7      	MOVLW 0xF7
03FC  148A      	ANDWF gbl_latb, W
03FE  6E81      	MOVWF gbl_portb
0400            label53

		FCP_SET(B, B, 0x10, 0x4, 0);
0400  6A54      	CLRF FCD_04071__0005C_143_ptmp
0402  9893      	BCF gbl_trisb,4
0404  5254      	MOVF FCD_04071__0005C_143_ptmp, F
0406  E004      	BZ	label54
0408  0E10      	MOVLW 0x10
040A  108A      	IORWF gbl_latb, W
040C  6E81      	MOVWF gbl_portb
040E  D003      	BRA	label55
0410            label54
0410  0EEF      	MOVLW 0xEF
0412  148A      	ANDWF gbl_latb, W
0414  6E81      	MOVWF gbl_portb
0416            label55


		FCL_NIBBLE = (FCL_DATA & 0xf);
0416  0E0F      	MOVLW 0x0F
0418  1451      	ANDWF FCD_04071__0005C_arg_FCL_DATA, W
041A  6E54      	MOVWF CompTempVar2641
041C  5054      	MOVF CompTempVar2641, W
041E  6E53      	MOVWF FCD_04071__0005C_1_FCL_NIBBLE

		FCP_SET(B, B, 0x1, 0x0, (FCL_NIBBLE & 0x01));
0420  0E01      	MOVLW 0x01
0422  1453      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W
0424  6E54      	MOVWF FCD_04071__0005C_152_ptmp
0426  9093      	BCF gbl_trisb,0
0428  5254      	MOVF FCD_04071__0005C_152_ptmp, F
042A  E004      	BZ	label56
042C  0E01      	MOVLW 0x01
042E  108A      	IORWF gbl_latb, W
0430  6E81      	MOVWF gbl_portb
0432  D003      	BRA	label57
0434            label56
0434  0EFE      	MOVLW 0xFE
0436  148A      	ANDWF gbl_latb, W
0438  6E81      	MOVWF gbl_portb
043A            label57

		FCL_NIBBLE = FCL_NIBBLE >> 1;
043A  5253      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F
043C  90D8      	BCF STATUS,C
043E  3253      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F

		FCP_SET(B, B, 0x2, 0x1, (FCL_NIBBLE & 0x01));
0440  0E01      	MOVLW 0x01
0442  1453      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W
0444  6E54      	MOVWF FCD_04071__0005C_161_ptmp
0446  9293      	BCF gbl_trisb,1
0448  5254      	MOVF FCD_04071__0005C_161_ptmp, F
044A  E004      	BZ	label58
044C  0E02      	MOVLW 0x02
044E  108A      	IORWF gbl_latb, W
0450  6E81      	MOVWF gbl_portb
0452  D003      	BRA	label59
0454            label58
0454  0EFD      	MOVLW 0xFD
0456  148A      	ANDWF gbl_latb, W
0458  6E81      	MOVWF gbl_portb
045A            label59

		FCL_NIBBLE = FCL_NIBBLE >> 1;
045A  5253      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F
045C  90D8      	BCF STATUS,C
045E  3253      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F

		FCP_SET(B, B, 0x4, 0x2, (FCL_NIBBLE & 0x01));
0460  0E01      	MOVLW 0x01
0462  1453      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W
0464  6E54      	MOVWF FCD_04071__0005C_170_ptmp
0466  9493      	BCF gbl_trisb,2
0468  5254      	MOVF FCD_04071__0005C_170_ptmp, F
046A  E004      	BZ	label60
046C  0E04      	MOVLW 0x04
046E  108A      	IORWF gbl_latb, W
0470  6E81      	MOVWF gbl_portb
0472  D003      	BRA	label61
0474            label60
0474  0EFB      	MOVLW 0xFB
0476  148A      	ANDWF gbl_latb, W
0478  6E81      	MOVWF gbl_portb
047A            label61

		FCL_NIBBLE = FCL_NIBBLE >> 1;
047A  5253      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F
047C  90D8      	BCF STATUS,C
047E  3253      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F

		FCP_SET(B, B, 0x8, 0x3, (FCL_NIBBLE & 0x01));
0480  0E01      	MOVLW 0x01
0482  1453      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W
0484  6E54      	MOVWF FCD_04071__0005C_179_ptmp
0486  9693      	BCF gbl_trisb,3
0488  5254      	MOVF FCD_04071__0005C_179_ptmp, F
048A  E004      	BZ	label62
048C  0E08      	MOVLW 0x08
048E  108A      	IORWF gbl_latb, W
0490  6E81      	MOVWF gbl_portb
0492  D003      	BRA	label63
0494            label62
0494  0EF7      	MOVLW 0xF7
0496  148A      	ANDWF gbl_latb, W
0498  6E81      	MOVWF gbl_portb
049A            label63


		if (FCL_TYPE)
049A  A052      	BTFSS FCD_04071__0005C_arg_FCL_TYPE,0
049C  D00C      	BRA	label65

		{

			FCP_SET(B, B, 0x10, 0x4, 1);
049E  0E01      	MOVLW 0x01
04A0  6E54      	MOVWF FCD_04071__0005C_188_ptmp
04A2  9893      	BCF gbl_trisb,4
04A4  5254      	MOVF FCD_04071__0005C_188_ptmp, F
04A6  E004      	BZ	label64
04A8  0E10      	MOVLW 0x10
04AA  108A      	IORWF gbl_latb, W
04AC  6E81      	MOVWF gbl_portb
04AE  D003      	BRA	label65
04B0            label64
04B0  0EEF      	MOVLW 0xEF
04B2  148A      	ANDWF gbl_latb, W
04B4  6E81      	MOVWF gbl_portb
04B6            label65


		// } else {

		}

		FCI_DELAYBYTE_US(100);
04B6  0E64      	MOVLW 0x64
04B8  6E54      	MOVWF delay_us_00000_arg_del
04BA  EC06F000  	CALL delay_us_00000


		FCP_SET(B, B, 0x20, 0x5, 1);
04BE  0E01      	MOVLW 0x01
04C0  6E54      	MOVWF FCD_04071__0005C_199_ptmp
04C2  9A93      	BCF gbl_trisb,5
04C4  5254      	MOVF FCD_04071__0005C_199_ptmp, F
04C6  E004      	BZ	label66
04C8  0E20      	MOVLW 0x20
04CA  108A      	IORWF gbl_latb, W
04CC  6E81      	MOVWF gbl_portb
04CE  D003      	BRA	label67
04D0            label66
04D0  0EDF      	MOVLW 0xDF
04D2  148A      	ANDWF gbl_latb, W
04D4  6E81      	MOVWF gbl_portb
04D6            label67


		FCI_DELAYBYTE_US(100);
04D6  0E64      	MOVLW 0x64
04D8  6E54      	MOVWF delay_us_00000_arg_del
04DA  EC06F000  	CALL delay_us_00000


		FCP_SET(B, B, 0x20, 0x5, 0);
04DE  6A54      	CLRF FCD_04071__0005C_210_ptmp
04E0  9A93      	BCF gbl_trisb,5
04E2  5254      	MOVF FCD_04071__0005C_210_ptmp, F
04E4  E004      	BZ	label68
04E6  0E20      	MOVLW 0x20
04E8  108A      	IORWF gbl_latb, W
04EA  6E81      	MOVWF gbl_portb
04EC  D003      	BRA	label69
04EE            label68
04EE  0EDF      	MOVLW 0xDF
04F0  148A      	ANDWF gbl_latb, W
04F2  6E81      	MOVWF gbl_portb
04F4            label69


		FCI_DELAYBYTE_US(100);
04F4  0E64      	MOVLW 0x64
04F6  6E54      	MOVWF delay_us_00000_arg_del
04F8  EC06F000  	CALL delay_us_00000


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

}
04FC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()
{



	#if (1) // 0 == 0

		FCP_SET(B, B, 0x1, 0x0, 0);
		FCP_SET(B, B, 0x2, 0x1, 0);
		FCP_SET(B, B, 0x4, 0x2, 0);
		FCP_SET(B, B, 0x8, 0x3, 0);
		FCP_SET(B, B, 0x10, 0x4, 0);
		FCP_SET(B, B, 0x20, 0x5, 0);

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0)

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	#if (0) // 0 > 0

	//Le code a été optimisé par le préprocesseur
	#else

		FCD_04071_LCD__RawSend(0x32, 0);

		FCI_DELAYBYTE_MS(2);

		FCD_04071_LCD__RawSend(0x2c, 0);

	#endif

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x06, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x0c, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__Clear();

}


/*========================================================================*\
   Use :lcd_eb005
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x63);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)

{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;
0A34  6A40      	CLRF FCD_0f051__00088_1_FCR_RETVAL
0A36  6A41      	CLRF FCD_0f051__00088_1_FCR_RETVAL+D'1'


	if (FCL_AXIS == 0)
0A38  523F      	MOVF FCD_0f051__00088_arg_FCL_AXIS, F
0A3A  E007      	BZ	label98

	{

	} else {

		if (FCL_AXIS == 'x')
0A3C  0E78      	MOVLW 0x78
0A3E  623F      	CPFSEQ FCD_0f051__00088_arg_FCL_AXIS
0A40  D001      	BRA	label97
0A44            label97

		{

		} else {
0A42  D003      	BRA	label98


			if (FCL_AXIS == 'X')
0A44  0E58      	MOVLW 0x58
0A46  623F      	CPFSEQ FCD_0f051__00088_arg_FCL_AXIS
0A48  D004      	BRA	label99
0A4A            label98

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;
0A4A  5029      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W
0A4C  6E40      	MOVWF FCD_0f051__00088_1_FCR_RETVAL
0A4E  502A      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', W
0A50  6E41      	MOVWF FCD_0f051__00088_1_FCR_RETVAL+D'1'


FCC_G4D_ReadTouchCoordinatesPicaso_A:
0A52            label99

;

	if (FCL_AXIS == 1)
0A52  043F      	DECF FCD_0f051__00088_arg_FCL_AXIS, W
0A54  E007      	BZ	label101

	{

	} else {

		if (FCL_AXIS == 'y')
0A56  0E79      	MOVLW 0x79
0A58  623F      	CPFSEQ FCD_0f051__00088_arg_FCL_AXIS
0A5A  D001      	BRA	label100
0A5E            label100

		{

		} else {
0A5C  D003      	BRA	label101


			if (FCL_AXIS == 'Y')
0A5E  0E59      	MOVLW 0x59
0A60  623F      	CPFSEQ FCD_0f051__00088_arg_FCL_AXIS
0A62  D004      	BRA	label102
0A64            label101

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;
0A64  5027      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W
0A66  6E40      	MOVWF FCD_0f051__00088_1_FCR_RETVAL
0A68  5028      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', W
0A6A  6E41      	MOVWF FCD_0f051__00088_1_FCR_RETVAL+D'1'


FCC_G4D_ReadTouchCoordinatesPicaso_B:
0A6C            label102

;

	return (FCR_RETVAL);
0A6C  5040      	MOVF FCD_0f051__00088_1_FCR_RETVAL, W
0A6E  6E42      	MOVWF CompTempVarRet2813
0A70  5041      	MOVF FCD_0f051__00088_1_FCR_RETVAL+D'1', W
0A72  6E43      	MOVWF CompTempVarRet2813+D'1'


}
0A74  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x6F);
0996  0E6F      	MOVLW 0x6F
0998  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
099A  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
099C  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Send_1(4);
09A0  0E04      	MOVLW 0x04
09A2  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
09A4  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
09A6  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Receive_1(255);
09AA  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
09AC  ECBFF000  	CALL FC_CAL_UAR_0006E


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
09B0  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
09B2  ECBFF000  	CALL FC_CAL_UAR_0006E
09B6  5050      	MOVF CompTempVarRet2662, W
09B8  6E40      	MOVWF FCD_0f051__00089_1_FCR_RETVAL


	FC_CAL_UART_Receive_1(255);
09BA  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
09BC  ECBFF000  	CALL FC_CAL_UAR_0006E


	FC_CAL_UART_Receive_1(255);
09C0  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
09C2  ECBFF000  	CALL FC_CAL_UAR_0006E


	if (FCR_RETVAL)
09C6  5240      	MOVF FCD_0f051__00089_1_FCR_RETVAL, F
09C8  E032      	BZ	label96
0A2E            label96

	{

		FC_CAL_UART_Send_1(0x6F);
09CA  0E6F      	MOVLW 0x6F
09CC  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
09CE  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
09D0  ECB7F000  	CALL FC_CAL_UAR_0006F


		FC_CAL_UART_Send_1(5);
09D4  0E05      	MOVLW 0x05
09D6  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
09D8  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
09DA  ECB7F000  	CALL FC_CAL_UAR_0006F


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_1(255);
09DE  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
09E0  ECBFF000  	CALL FC_CAL_UAR_0006E
09E4  5050      	MOVF CompTempVarRet2662, W
09E6  6E29      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F
09E8  5051      	MOVF CompTempVarRet2662+D'1', W
09EA  6E2A      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1'


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
09EC  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
09EE  ECBFF000  	CALL FC_CAL_UAR_0006E
09F2  5050      	MOVF CompTempVarRet2662, W
09F4  6E3F      	MOVWF FCD_0f051__00089_1_FCL_TEMP


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
09F6  6A41      	CLRF CompTempVar2815
09F8  5029      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W
09FA  6E2A      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1'
09FC  5041      	MOVF CompTempVar2815, W
09FE  6E29      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;
0A00  503F      	MOVF FCD_0f051__00089_1_FCL_TEMP, W
0A02  1229      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000F, F
0A04  522A      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', F


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_1(255);
0A06  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
0A08  ECBFF000  	CALL FC_CAL_UAR_0006E
0A0C  5050      	MOVF CompTempVarRet2662, W
0A0E  6E27      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E
0A10  5051      	MOVF CompTempVarRet2662+D'1', W
0A12  6E28      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1'


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
0A14  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
0A16  ECBFF000  	CALL FC_CAL_UAR_0006E
0A1A  5050      	MOVF CompTempVarRet2662, W
0A1C  6E3F      	MOVWF FCD_0f051__00089_1_FCL_TEMP


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
0A1E  6A41      	CLRF CompTempVar2819
0A20  5027      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W
0A22  6E28      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1'
0A24  5041      	MOVF CompTempVar2819, W
0A26  6E27      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;
0A28  503F      	MOVF FCD_0f051__00089_1_FCL_TEMP, W
0A2A  1227      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000E, F
0A2C  5228      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', F


	// } else {

	}

	return (FCR_RETVAL);
0A2E  5040      	MOVF FCD_0f051__00089_1_FCR_RETVAL, W
0A30  6E41      	MOVWF CompTempVarRet2814


}
0A32  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_1(FCL_RADIUS);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FC_CAL_UART_Send_1(0x4C);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_POSH >> 8);

	FC_CAL_UART_Send_1(FCL_POSH);

	FC_CAL_UART_Send_1(FCL_POSL >> 8);

	FC_CAL_UART_Send_1(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x05);

	FC_CAL_UART_Send_1(0x01);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x00);

	FC_CAL_UART_Send_1(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x01);

	FC_CAL_UART_Send_1(FCL_DISPLAY);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x02);

	FC_CAL_UART_Send_1(FCL_CONTRAST);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
0936  0E59      	MOVLW 0x59
0938  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
093A  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
093C  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Send_1(0x05);
0940  0E05      	MOVLW 0x05
0942  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
0944  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
0946  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Send_1(0x00);
094A  6A47      	CLRF FC_CAL_UAR_0006F_arg_nChar
094C  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
094E  ECB7F000  	CALL FC_CAL_UAR_0006F


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0952  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
0954  ECBFF000  	CALL FC_CAL_UAR_0006E
0958  5050      	MOVF CompTempVarRet2662, W
095A  6E3F      	MOVWF FCD_0f051__00097_1_FCR_RETVAL


	FC_CAL_UART_Send_1(0x59);
095C  0E59      	MOVLW 0x59
095E  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
0960  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
0962  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Send_1(0x05);
0966  0E05      	MOVLW 0x05
0968  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
096A  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
096C  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Send_1(0x02);
0970  0E02      	MOVLW 0x02
0972  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
0974  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
0976  ECB7F000  	CALL FC_CAL_UAR_0006F


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
097A  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
097C  ECBFF000  	CALL FC_CAL_UAR_0006E
0980  5050      	MOVF CompTempVarRet2662, W
0982  6E3F      	MOVWF FCD_0f051__00097_1_FCR_RETVAL


	if (FCR_RETVAL == 6)
0984  0E06      	MOVLW 0x06
0986  623F      	CPFSEQ FCD_0f051__00097_1_FCR_RETVAL
0988  D002      	BRA	label94
098E            label94

	{

		FCR_RETVAL = 0;
098A  6A3F      	CLRF FCD_0f051__00097_1_FCR_RETVAL


	} else {
098C  D001      	BRA	label95
0990            label95


		FCR_RETVAL = 255;
098E  683F      	SETF FCD_0f051__00097_1_FCR_RETVAL


	}

	return (FCR_RETVAL);
0990  503F      	MOVF FCD_0f051__00097_1_FCR_RETVAL, W
0992  6E40      	MOVWF CompTempVarRet2878


}
0994  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x56);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_1(0x10);

	} else {

		FC_CAL_UART_Send_1(0x08);

	}

	FC_CAL_UART_Send_1(FCL_DELAY);

	FC_CAL_UART_Send_1(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_1(FCL_FRAMES);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x76);

	FC_CAL_UART_Send_1(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_1(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_1(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_1(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_1(0x03);

		}
	}

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x65);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RX >> 8);

	FC_CAL_UART_Send_1(FCL_RX);

	FC_CAL_UART_Send_1(FCL_RY >> 8);

	FC_CAL_UART_Send_1(FCL_RY);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);


	FC_CAL_UART_Send_1(0x4F);

	if (FCL_TRANSPARENT)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x53);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_FONT);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Send_1(1);

	FC_CAL_UART_Send_1(1);

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		if (FCL_STR[FCL_IDX] == 0)
		{

			goto FCC_Print_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_STR[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_Print_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x0c);

	FC_CAL_UART_Send_1(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
074C  6A43      	CLRF FCD_0f051__000A1_1_FCL_Y
074E  6A44      	CLRF FCD_0f051__000A1_1_FCL_Y+D'1'

	MX_UINT16 FCL_X = (0x0);
0750  6A45      	CLRF FCD_0f051__000A1_1_FCL_X
0752  6A46      	CLRF FCD_0f051__000A1_1_FCL_X+D'1'



	FC_CAL_UART_Send_1(0x42);
0754  0E42      	MOVLW 0x42
0756  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
0758  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
075A  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
075E  5024      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
0760  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
0762  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
0764  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
0768  5023      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W
076A  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
076C  5024      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
076E  6E48      	MOVWF FC_CAL_UAR_0006F_arg_nChar+D'1'
0770  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Receive_1(255);
0774  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
0776  ECBFF000  	CALL FC_CAL_UAR_0006E


	FC_CAL_UART_Send_1(0x45);
077A  0E45      	MOVLW 0x45
077C  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
077E  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
0780  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Receive_1(255);
0784  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
0786  ECBFF000  	CALL FC_CAL_UAR_0006E


}
078A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x49);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x75);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6C);

	FC_CAL_UART_Send_1(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
	{

		FC_CAL_UART_Send_1(0x70);

		FC_CAL_UART_Send_1(0x00);

		FC_CAL_UART_Receive_1(255);

		FC_CAL_UART_Send_1(0x72);

		FC_CAL_UART_Send_1(FCL_X1 >> 8);

		FC_CAL_UART_Send_1(FCL_X1);

		FC_CAL_UART_Send_1(FCL_Y1 >> 8);

		FC_CAL_UART_Send_1(FCL_Y1);

		FC_CAL_UART_Send_1(FCL_X2 >> 8);

		FC_CAL_UART_Send_1(FCL_X2);

		FC_CAL_UART_Send_1(FCL_Y2 >> 8);

		FC_CAL_UART_Send_1(FCL_Y2);

		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

		FC_CAL_UART_Receive_1(255);

	// } else {

	}

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x72);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, C, 0x20, 0x5, 0);
07C2  6A43      	CLRF FCD_0f051__000AC_2_ptmp
07C4  9A94      	BCF gbl_trisc,5
07C6  5243      	MOVF FCD_0f051__000AC_2_ptmp, F
07C8  E004      	BZ	label92
07CA  0E20      	MOVLW 0x20
07CC  108B      	IORWF gbl_latc, W
07CE  6E82      	MOVWF gbl_portc
07D0  D003      	BRA	label93
07D2            label92
07D2  0EDF      	MOVLW 0xDF
07D4  148B      	ANDWF gbl_latc, W
07D6  6E82      	MOVWF gbl_portc
07D8            label93


	FC_CAL_UART_Init_1();
07D8  EC7FF002  	CALL FC_CAL_UAR_00070


	FCI_DELAYBYTE_US(100);
07DC  0E64      	MOVLW 0x64
07DE  6E54      	MOVWF delay_us_00000_arg_del
07E0  EC06F000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, C, 0x20, 0x5);
07E4  0E0F      	MOVLW HIGH(gbl_portc+D'0')
07E6  6E44      	MOVWF FC_CAL_Por_00042_arg_Port+D'1'
07E8  0E82      	MOVLW LOW(gbl_portc+D'0')
07EA  6E43      	MOVWF FC_CAL_Por_00042_arg_Port
07EC  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
07EE  6E46      	MOVWF FC_CAL_Por_00042_arg_Tris+D'1'
07F0  0E94      	MOVLW LOW(gbl_trisc+D'0')
07F2  6E45      	MOVWF FC_CAL_Por_00042_arg_Tris
07F4  0E20      	MOVLW 0x20
07F6  6E47      	MOVWF FC_CAL_Por_00042_arg_InMask
07F8  0E05      	MOVLW 0x05
07FA  6E48      	MOVWF FC_CAL_Por_00042_arg_Shift
07FC  ECD0F002  	CALL FC_CAL_Por_00042
0800  5049      	MOVF CompTempVarRet1822, W
0802  6E42      	MOVWF FCD_0f051__000AC_1_FCL_DUMMY


	FCI_DELAYBYTE_S(3);
0804  0E03      	MOVLW 0x03
0806  6E43      	MOVWF delay_s_00000_arg_del
0808  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_1(0);
080C  6A47      	CLRF FC_CAL_UAR_0006E_arg_nTimeout
080E  ECBFF000  	CALL FC_CAL_UAR_0006E


	FC_CAL_UART_Receive_1(0);
0812  6A47      	CLRF FC_CAL_UAR_0006E_arg_nTimeout
0814  ECBFF000  	CALL FC_CAL_UAR_0006E


	FC_CAL_UART_Receive_1(0);
0818  6A47      	CLRF FC_CAL_UAR_0006E_arg_nTimeout
081A  ECBFF000  	CALL FC_CAL_UAR_0006E


	FC_CAL_UART_Send_1(0x55);
081E  0E55      	MOVLW 0x55
0820  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
0822  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
0824  ECB7F000  	CALL FC_CAL_UAR_0006F


	FC_CAL_UART_Receive_1(255);
0828  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
082A  ECBFF000  	CALL FC_CAL_UAR_0006E


	#if (1) // 1 == 1

		#if (1) // 1 != 0

			FC_CAL_UART_Send_1(0x51);
082E  0E51      	MOVLW 0x51
0830  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
0832  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
0834  ECB7F000  	CALL FC_CAL_UAR_0006F


			FC_CAL_UART_Send_1(0x0C);
0838  0E0C      	MOVLW 0x0C
083A  6E47      	MOVWF FC_CAL_UAR_0006F_arg_nChar
083C  6A48      	CLRF FC_CAL_UAR_0006F_arg_nChar+D'1'
083E  ECB7F000  	CALL FC_CAL_UAR_0006F


			FC_CAL_UART_Receive_1(255);
0842  6847      	SETF FC_CAL_UAR_0006E_arg_nTimeout
0844  ECBFF000  	CALL FC_CAL_UAR_0006E


			FC_CAL_UART_UpdateBaud_1(6);
0848  0E06      	MOVLW 0x06
084A  6E43      	MOVWF FC_CAL_UAR_0006C_arg_new_baud
084C  EC88F002  	CALL FC_CAL_UAR_0006C



		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_1(10);
0850  0E0A      	MOVLW 0x0A
0852  6E47      	MOVWF FC_CAL_UAR_0006E_arg_nTimeout
0854  ECBFF000  	CALL FC_CAL_UAR_0006E


	FC_CAL_UART_Receive_1(10);
0858  0E0A      	MOVLW 0x0A
085A  6E47      	MOVWF FC_CAL_UAR_0006E_arg_nTimeout
085C  ECBFF000  	CALL FC_CAL_UAR_0006E


	FCL_RED = 0 & 0xFF;
0860  6A3F      	CLRF FCD_0f051__000AC_1_FCL_RED

	FCL_RED = FCL_RED >> (8 - 5);
0862  323F      	RRCF FCD_0f051__000AC_1_FCL_RED, F
0864  323F      	RRCF FCD_0f051__000AC_1_FCL_RED, F
0866  323F      	RRCF FCD_0f051__000AC_1_FCL_RED, F
0868  0E1F      	MOVLW 0x1F
086A  163F      	ANDWF FCD_0f051__000AC_1_FCL_RED, F

	FCL_GREEN = (0 >> 8) & 0xFF;
086C  6A40      	CLRF FCD_0f051__000AC_1_FCL_GREEN

	FCL_GREEN = FCL_GREEN >> (8 - 6);
086E  3240      	RRCF FCD_0f051__000AC_1_FCL_GREEN, F
0870  3240      	RRCF FCD_0f051__000AC_1_FCL_GREEN, F
0872  0E3F      	MOVLW 0x3F
0874  1640      	ANDWF FCD_0f051__000AC_1_FCL_GREEN, F

	FCL_BLUE = (0 >> 16) & 0xFF;
0876  6A41      	CLRF FCD_0f051__000AC_1_FCL_BLUE

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0878  3241      	RRCF FCD_0f051__000AC_1_FCL_BLUE, F
087A  3241      	RRCF FCD_0f051__000AC_1_FCL_BLUE, F
087C  3241      	RRCF FCD_0f051__000AC_1_FCL_BLUE, F
087E  0E1F      	MOVLW 0x1F
0880  1641      	ANDWF FCD_0f051__000AC_1_FCL_BLUE, F

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
0882  5040      	MOVF FCD_0f051__000AC_1_FCL_GREEN, W
0884  6E43      	MOVWF CompTempVar2991
0886  6A26      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1'
0888  3643      	RLCF CompTempVar2991, F
088A  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
088C  3643      	RLCF CompTempVar2991, F
088E  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0890  3643      	RLCF CompTempVar2991, F
0892  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0894  3643      	RLCF CompTempVar2991, F
0896  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0898  3643      	RLCF CompTempVar2991, F
089A  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
089C  0EE0      	MOVLW 0xE0
089E  1643      	ANDWF CompTempVar2991, F
08A0  5043      	MOVF CompTempVar2991, W
08A2  1041      	IORWF FCD_0f051__000AC_1_FCL_BLUE, W
08A4  6E25      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
08A6  6A43      	CLRF CompTempVar2995
08A8  503F      	MOVF FCD_0f051__000AC_1_FCL_RED, W
08AA  6E44      	MOVWF CompTempVar2996
08AC  90D8      	BCF STATUS,C
08AE  3644      	RLCF CompTempVar2996, F
08B0  90D8      	BCF STATUS,C
08B2  3644      	RLCF CompTempVar2996, F
08B4  90D8      	BCF STATUS,C
08B6  3644      	RLCF CompTempVar2996, F
08B8  5043      	MOVF CompTempVar2995, W
08BA  1225      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F
08BC  5044      	MOVF CompTempVar2996, W
08BE  1226      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F

	FCL_RED = 16777215 & 0xFF;
08C0  683F      	SETF FCD_0f051__000AC_1_FCL_RED

	FCL_RED = FCL_RED >> (8 - 5);
08C2  323F      	RRCF FCD_0f051__000AC_1_FCL_RED, F
08C4  323F      	RRCF FCD_0f051__000AC_1_FCL_RED, F
08C6  323F      	RRCF FCD_0f051__000AC_1_FCL_RED, F
08C8  0E1F      	MOVLW 0x1F
08CA  163F      	ANDWF FCD_0f051__000AC_1_FCL_RED, F

	FCL_GREEN = (16777215 >> 8) & 0xFF;
08CC  6840      	SETF FCD_0f051__000AC_1_FCL_GREEN

	FCL_GREEN = FCL_GREEN >> (8 - 6);
08CE  3240      	RRCF FCD_0f051__000AC_1_FCL_GREEN, F
08D0  3240      	RRCF FCD_0f051__000AC_1_FCL_GREEN, F
08D2  0E3F      	MOVLW 0x3F
08D4  1640      	ANDWF FCD_0f051__000AC_1_FCL_GREEN, F

	FCL_BLUE = (16777215 >> 16) & 0xFF;
08D6  6841      	SETF FCD_0f051__000AC_1_FCL_BLUE

	FCL_BLUE = FCL_BLUE >> (8 - 5);
08D8  3241      	RRCF FCD_0f051__000AC_1_FCL_BLUE, F
08DA  3241      	RRCF FCD_0f051__000AC_1_FCL_BLUE, F
08DC  3241      	RRCF FCD_0f051__000AC_1_FCL_BLUE, F
08DE  0E1F      	MOVLW 0x1F
08E0  1641      	ANDWF FCD_0f051__000AC_1_FCL_BLUE, F

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
08E2  5040      	MOVF FCD_0f051__000AC_1_FCL_GREEN, W
08E4  6E43      	MOVWF CompTempVar3002
08E6  6A24      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1'
08E8  3643      	RLCF CompTempVar3002, F
08EA  3624      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
08EC  3643      	RLCF CompTempVar3002, F
08EE  3624      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
08F0  3643      	RLCF CompTempVar3002, F
08F2  3624      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
08F4  3643      	RLCF CompTempVar3002, F
08F6  3624      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
08F8  3643      	RLCF CompTempVar3002, F
08FA  3624      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
08FC  0EE0      	MOVLW 0xE0
08FE  1643      	ANDWF CompTempVar3002, F
0900  5043      	MOVF CompTempVar3002, W
0902  1041      	IORWF FCD_0f051__000AC_1_FCL_BLUE, W
0904  6E23      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
0906  6A43      	CLRF CompTempVar3006
0908  503F      	MOVF FCD_0f051__000AC_1_FCL_RED, W
090A  6E44      	MOVWF CompTempVar3007
090C  90D8      	BCF STATUS,C
090E  3644      	RLCF CompTempVar3007, F
0910  90D8      	BCF STATUS,C
0912  3644      	RLCF CompTempVar3007, F
0914  90D8      	BCF STATUS,C
0916  3644      	RLCF CompTempVar3007, F
0918  5043      	MOVF CompTempVar3006, W
091A  1223      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F
091C  5044      	MOVF CompTempVar3007, W
091E  1224      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
0920  ECA6F003  	CALL FCD_0f051__000A1


	FC_CAL_UART_Receive_1(10);
0924  0E0A      	MOVLW 0x0A
0926  6E47      	MOVWF FC_CAL_UAR_0006E_arg_nTimeout
0928  ECBFF000  	CALL FC_CAL_UAR_0006E


	FC_CAL_UART_Receive_1(10);
092C  0E0A      	MOVLW 0x0A
092E  6E47      	MOVWF FC_CAL_UAR_0006E_arg_nTimeout
0930  ECBFF000  	CALL FC_CAL_UAR_0006E


}
0934  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/


/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
0AD4  0E0F      	MOVLW 0x0F
0AD6  6EC1      	MOVWF gbl_adcon1





	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
0AD8  ECE1F003  	CALL FCD_0f051__000AC


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_EnableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
0ADC  EC9BF004  	CALL FCD_0f051__00097


	// Boucle
	// Boucle: While 1
	while (1)
0AE0            label104
0B12  D7E6      	BRA	label104

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: X=gLCD_EB076_4D1::G4D_GetTouchCoordinatesPicaso()
		FCV_X = FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
0AE0  ECCBF004  	CALL FCD_0f051__00089
0AE4  5041      	MOVF CompTempVarRet2814, W
0AE6  6E21      	MOVWF gbl_FCV_X
0AE8  6A22      	CLRF gbl_FCV_X+D'1'


		// Appel de la Routine Composant
		// Appel de la Routine Composant: Y=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
		FCV_Y = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);
0AEA  0E01      	MOVLW 0x01
0AEC  6E3F      	MOVWF FCD_0f051__00088_arg_FCL_AXIS
0AEE  EC1AF005  	CALL FCD_0f051__00088
0AF2  5042      	MOVF CompTempVarRet2813, W
0AF4  6E1F      	MOVWF gbl_FCV_Y
0AF6  5043      	MOVF CompTempVarRet2813+D'1', W
0AF8  6E20      	MOVWF gbl_FCV_Y+D'1'


		#if 0 // Disabled code
		// Pause
		// Pause: 200 ms
		FCI_DELAYBYTE_MS(200);

		#endif // #if 0: Disabled code
		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();
0AFA  EC57F005  	CALL FCD_04071__0005B


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintNumber(Y)
		FCD_0ad31_lcd_eb005__PrintNumber(FCV_Y);
0AFE  501F      	MOVF gbl_FCV_Y, W
0B00  6E3F      	MOVWF FCD_04071__00060_arg_FCL_NUMBER
0B02  5020      	MOVF gbl_FCV_Y+D'1', W
0B04  6E40      	MOVWF FCD_04071__00060_arg_FCL_NUMBER+D'1'
0B06  EC3BF005  	CALL FCD_04071__00060


		#if 0 // Disabled code
		// Décision
		// Décision: Y <> Y_old?
		if (FCV_Y != FCV_Y_OLD)
		{

			// Calcul
			// Calcul:
			//  Y_old = Y
			FCV_Y_OLD = FCV_Y;

		// } else {

		}

		#endif // #if 0: Disabled code
		// Calcul
		// Calcul:
		//  Y = 0
		//  X = 0
		FCV_Y = 0;
0B0A  6A1F      	CLRF gbl_FCV_Y
0B0C  6A20      	CLRF gbl_FCV_Y+D'1'

		FCV_X = 0;
0B0E  6A21      	CLRF gbl_FCV_X
0B10  6A22      	CLRF gbl_FCV_X+D'1'



	}

	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

}
0B96  CFEAF001  	MOVFF FSR0H,  Int1Context
0B9A  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
0B9E  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
0BA2  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
0BA6  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
0BAA  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
0BAE  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
0BB2  C001FFEA  	MOVFF Int1Context,  FSR0H
0BB6  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
04FE  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0500  0E7F      	MOVLW 0x7F
0502  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0504  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0506  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
0508  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
050A  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
050C  9A9D      	BCF gbl_pie1,5

			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
050E  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
021C  6AAB      	CLRF gbl_rcsta

			txsta = 0;
021E  6AAC      	CLRF gbl_txsta

		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}
0220  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
016E            label8
016E  0E10      	MOVLW 0x10
0170  149E      	ANDWF gbl_pir1, W
0172  6E49      	MOVWF CompTempVar2666
0174  5249      	MOVF CompTempVar2666, F
0176  E0FB      	BZ	label8


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0178  5047      	MOVF FC_CAL_UAR_0006F_arg_nChar, W
017A  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
017C  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
017E  6848      	SETF FC_CAL_UAR_0006E_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
0180  6A49      	CLRF FC_CAL_UAR_0006E_1_delay1

	MX_UINT8 regcheck = 0;
0182  6A4A      	CLRF FC_CAL_UAR_0006E_1_regcheck

	MX_UINT8 bWaitForever = 0;
0184  6A4B      	CLRF FC_CAL_UAR_0006E_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
0186  6A4C      	CLRF FC_CAL_UAR_0006E_1_rxStatus

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0188  6A4F      	CLRF FC_CAL_UAR_0006E_1_dummy

  #endif

	if (nTimeout == 255)
018A  2847      	INCF FC_CAL_UAR_0006E_arg_nTimeout, W
018C  E102      	BNZ	label9
0192            label9

		bWaitForever = 1;
018E  0E01      	MOVLW 0x01
0190  6E4B      	MOVWF FC_CAL_UAR_0006E_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
0192  524C      	MOVF FC_CAL_UAR_0006E_1_rxStatus, F
0194  E124      	BNZ	label14
01DC  D7DA      	BRA	label9
01DE            label14

	{
		if (bWaitForever == 0)
0196  524B      	MOVF FC_CAL_UAR_0006E_1_bWaitForever, F
0198  E118      	BNZ	label13

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
019A  5247      	MOVF FC_CAL_UAR_0006E_arg_nTimeout, F
019C  E103      	BNZ	label10
01A4            label10

			{
				rxStatus = UART_STATUS_TIMEOUT;
019E  0E01      	MOVLW 0x01
01A0  6E4C      	MOVWF FC_CAL_UAR_0006E_1_rxStatus

			}
			else
01A2  D013      	BRA	label13

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
01A4  6A4D      	CLRF FC_CAL_UAR_0006E_1_delaycnt
01A6  6A4E      	CLRF FC_CAL_UAR_0006E_1_delaycnt+D'1'
01A8            label11
01A8  0E31      	MOVLW 0x31
01AA  5C4D      	SUBWF FC_CAL_UAR_0006E_1_delaycnt, W
01AC  E205      	BC	label12
01AE  664E      	TSTFSZ FC_CAL_UAR_0006E_1_delaycnt+D'1'
01B0  D003      	BRA	label12
01B2  4A4D      	INFSNZ FC_CAL_UAR_0006E_1_delaycnt, F
01B4  2A4E      	INCF FC_CAL_UAR_0006E_1_delaycnt+D'1', F
01B6  D7F8      	BRA	label11
01B8            label12

				delay1 = delay1 + 1;
01B8  2849      	INCF FC_CAL_UAR_0006E_1_delay1, W
01BA  6E49      	MOVWF FC_CAL_UAR_0006E_1_delay1

				if(delay1 == 100)
01BC  0E64      	MOVLW 0x64
01BE  6249      	CPFSEQ FC_CAL_UAR_0006E_1_delay1
01C0  D004      	BRA	label13
01CA            label13

				{
					nTimeout = nTimeout - 1;
01C2  0447      	DECF FC_CAL_UAR_0006E_arg_nTimeout, W
01C4  6E47      	MOVWF FC_CAL_UAR_0006E_arg_nTimeout

					MX_CLEAR_WATCHDOG;
01C6  0004      	CLRWDT

					delay1 = 0;
01C8  6A49      	CLRF FC_CAL_UAR_0006E_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
01CA  0E20      	MOVLW 0x20
01CC  149E      	ANDWF gbl_pir1, W
01CE  6E50      	MOVWF CompTempVar2663
01D0  5050      	MOVF CompTempVar2663, W
01D2  6E4A      	MOVWF FC_CAL_UAR_0006E_1_regcheck

			if (regcheck != 0)
01D4  524A      	MOVF FC_CAL_UAR_0006E_1_regcheck, F
01D6  E0DD      	BZ	label9

				rxStatus = UART_STATUS_RXBYTE;
01D8  0E02      	MOVLW 0x02
01DA  6E4C      	MOVWF FC_CAL_UAR_0006E_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
01DE  0E02      	MOVLW 0x02
01E0  624C      	CPFSEQ FC_CAL_UAR_0006E_1_rxStatus
01E2  D018      	BRA	label17

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
01E4  0E04      	MOVLW 0x04
01E6  14AB      	ANDWF gbl_rcsta, W
01E8  6E50      	MOVWF CompTempVar2664
01EA  5050      	MOVF CompTempVar2664, W
01EC  6E4A      	MOVWF FC_CAL_UAR_0006E_1_regcheck

			if (regcheck != 0)
01EE  524A      	MOVF FC_CAL_UAR_0006E_1_regcheck, F
01F0  E003      	BZ	label15
01F8            label15

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
01F2  50AE      	MOVF gbl_rcreg, W
01F4  6E4F      	MOVWF FC_CAL_UAR_0006E_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
01F6  D00E      	BRA	label17

			{
				regcheck = ts_bit(rcsta, OERR);
01F8  0E02      	MOVLW 0x02
01FA  14AB      	ANDWF gbl_rcsta, W
01FC  6E50      	MOVWF CompTempVar2665
01FE  5050      	MOVF CompTempVar2665, W
0200  6E4A      	MOVWF FC_CAL_UAR_0006E_1_regcheck

				if (regcheck != 0)
0202  524A      	MOVF FC_CAL_UAR_0006E_1_regcheck, F
0204  E003      	BZ	label16
020C            label16

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0206  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0208  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
020A  D004      	BRA	label17
0214            label17

				{
					retVal = 0;
020C  6A48      	CLRF FC_CAL_UAR_0006E_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
020E  50AE      	MOVF gbl_rcreg, W
0210  1048      	IORWF FC_CAL_UAR_0006E_1_retVal, W
0212  6E48      	MOVWF FC_CAL_UAR_0006E_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0214  5048      	MOVF FC_CAL_UAR_0006E_1_retVal, W
0216  6E50      	MOVWF CompTempVarRet2662
0218  6A51      	CLRF CompTempVarRet2662+D'1'

}
021A  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))

{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
0510  0E07      	MOVLW 0x07
0512  6443      	CPFSGT FC_CAL_UAR_0006C_arg_new_baud
0514  D001      	BRA	label70
0518            label70

		return;

	if (new_baud == 0)
0518  5243      	MOVF FC_CAL_UAR_0006C_arg_new_baud, F
051A  E104      	BNZ	label71
0524            label71

	{
		baudrate = MX_HARD_BAUD_1200;
051C  6844      	SETF FC_CAL_UAR_0006C_1_baudrate

		baudmode = MX_HARD_SLOW_1200;
051E  0E01      	MOVLW 0x01
0520  6E45      	MOVWF FC_CAL_UAR_0006C_1_baudmode

	}
	else if (new_baud == 1)
0522  D02F      	BRA	label78
0524  0443      	DECF FC_CAL_UAR_0006C_arg_new_baud, W
0526  E105      	BNZ	label72
0532            label72

	{
		baudrate = MX_HARD_BAUD_2400;
0528  0E7F      	MOVLW 0x7F
052A  6E44      	MOVWF FC_CAL_UAR_0006C_1_baudrate

		baudmode = MX_HARD_SLOW_2400;
052C  0E01      	MOVLW 0x01
052E  6E45      	MOVWF FC_CAL_UAR_0006C_1_baudmode

	}
	else if (new_baud == 2)
0530  D028      	BRA	label78
0532  0E02      	MOVLW 0x02
0534  6243      	CPFSEQ FC_CAL_UAR_0006C_arg_new_baud
0536  D003      	BRA	label73
053E            label73

	{
		baudrate = MX_HARD_BAUD_4800;
0538  6844      	SETF FC_CAL_UAR_0006C_1_baudrate

		baudmode = MX_HARD_SLOW_4800;
053A  6A45      	CLRF FC_CAL_UAR_0006C_1_baudmode

	}
	else if (new_baud == 3)
053C  D022      	BRA	label78
053E  0E03      	MOVLW 0x03
0540  6243      	CPFSEQ FC_CAL_UAR_0006C_arg_new_baud
0542  D004      	BRA	label74
054C            label74

	{
		baudrate = MX_HARD_BAUD_9600;
0544  0E7F      	MOVLW 0x7F
0546  6E44      	MOVWF FC_CAL_UAR_0006C_1_baudrate

		baudmode = MX_HARD_SLOW_9600;
0548  6A45      	CLRF FC_CAL_UAR_0006C_1_baudmode

	}
	else if (new_baud == 4)
054A  D01B      	BRA	label78
054C  0E04      	MOVLW 0x04
054E  6243      	CPFSEQ FC_CAL_UAR_0006C_arg_new_baud
0550  D004      	BRA	label75
055A            label75

	{
		baudrate = MX_HARD_BAUD_19200;
0552  0E3F      	MOVLW 0x3F
0554  6E44      	MOVWF FC_CAL_UAR_0006C_1_baudrate

		baudmode = MX_HARD_SLOW_19200;
0556  6A45      	CLRF FC_CAL_UAR_0006C_1_baudmode

	}
	else if (new_baud == 5)
0558  D014      	BRA	label78
055A  0E05      	MOVLW 0x05
055C  6243      	CPFSEQ FC_CAL_UAR_0006C_arg_new_baud
055E  D004      	BRA	label76
0568            label76

	{
		baudrate = MX_HARD_BAUD_38400;
0560  0E1F      	MOVLW 0x1F
0562  6E44      	MOVWF FC_CAL_UAR_0006C_1_baudrate

		baudmode = MX_HARD_SLOW_38400;
0564  6A45      	CLRF FC_CAL_UAR_0006C_1_baudmode

	}
	else if (new_baud == 6)
0566  D00D      	BRA	label78
0568  0E06      	MOVLW 0x06
056A  6243      	CPFSEQ FC_CAL_UAR_0006C_arg_new_baud
056C  D004      	BRA	label77
0576            label77

	{
		baudrate = MX_HARD_BAUD_57600;
056E  0E14      	MOVLW 0x14
0570  6E44      	MOVWF FC_CAL_UAR_0006C_1_baudrate

		baudmode = MX_HARD_SLOW_57600;
0572  6A45      	CLRF FC_CAL_UAR_0006C_1_baudmode

	}
	else if (new_baud == 7)
0574  D006      	BRA	label78
0576  0E07      	MOVLW 0x07
0578  6243      	CPFSEQ FC_CAL_UAR_0006C_arg_new_baud
057A  D003      	BRA	label78
0582            label78

	{
		baudrate = MX_HARD_BAUD_115200;
057C  0E0A      	MOVLW 0x0A
057E  6E44      	MOVWF FC_CAL_UAR_0006C_1_baudrate

		baudmode = MX_HARD_SLOW_115200;
0580  6A45      	CLRF FC_CAL_UAR_0006C_1_baudmode

	}

	UART_Uninit();
0582  EC0EF001  	CALL FC_CAL_UAR_0006D


	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
0586  0445      	DECF FC_CAL_UAR_0006C_1_baudmode, W
0588  E102      	BNZ	label79
058E            label79

			cr_bit(txsta, BRGH);					//Low Speed
058A  94AC      	BCF gbl_txsta,2

	    else
058C  D001      	BRA	label80
0590            label80

			st_bit(txsta, BRGH);					//High Speed
058E  84AC      	BSF gbl_txsta,2


		spbrg = baudrate;   						// set the baud rate
0590  5044      	MOVF FC_CAL_UAR_0006C_1_baudrate, W
0592  6EAF      	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
0594  6AAB      	CLRF gbl_rcsta


		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
0596  8EAB      	BSF gbl_rcsta,7

		st_bit(txsta, TXEN);
0598  8AAC      	BSF gbl_txsta,5

		st_bit(rcsta, CREN);
059A  88AB      	BSF gbl_rcsta,4


		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
059C  9A9D      	BCF gbl_pie1,5

		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0516  0012      	RETURN
059E  0012      	RETURN


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF8AF005  	GOTO	_startup

0008  EFCBF005  	GOTO	interrupt
000C            delay_us_00000
000C            ; { delay_us ; function begin
000C            label1
000C  0000      	NOP
000E  0000      	NOP
0010  2E54      	DECFSZ delay_us_00000_arg_del, F
0012  D7FC      	BRA	label1
0014  0012      	RETURN
0016            ; } delay_us function end

0016            delay_ms_00000
0016            ; { delay_ms ; function begin
0016  5244      	MOVF delay_ms_00000_arg_del, F
0018  0000      	NOP
001A  E101      	BNZ	label2
001C  0012      	RETURN
001E            label2
001E  0EF5      	MOVLW 0xF5
0020            label3
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0000      	NOP
0040  0FFF      	ADDLW 0xFF
0042  A4D8      	BTFSS STATUS,Z
0044  D7ED      	BRA	label3
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  0000      	NOP
0058  0000      	NOP
005A  0000      	NOP
005C  0000      	NOP
005E  0000      	NOP
0060  2E44      	DECFSZ delay_ms_00000_arg_del, F
0062  D7DD      	BRA	label2
0064  0012      	RETURN
0066            ; } delay_ms function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6E44      	MOVWF delay_ms_00000_arg_del
006A  EC0BF000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6E44      	MOVWF delay_ms_00000_arg_del
0072  EC0BF000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6E44      	MOVWF delay_ms_00000_arg_del
007A  EC0BF000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6E44      	MOVWF delay_ms_00000_arg_del
0082  EC0BF000  	CALL delay_ms_00000
0086  2E43      	DECFSZ delay_s_00000_arg_del, F
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end

008C            __mul_32_3_00016
008C            ; { __mul_32_32 ; function begin
008C  6A6A      	CLRF CompTempVarRet414
008E  6A6B      	CLRF CompTempVarRet414+D'1'
0090  6A6C      	CLRF CompTempVarRet414+D'2'
0092  6A6D      	CLRF CompTempVarRet414+D'3'
0094  6A6C      	CLRF CompTempVarRet414+D'2'
0096  6A6D      	CLRF CompTempVarRet414+D'3'
0098  505E      	MOVF __mul_32_3_00016_arg_a, W
009A  0262      	MULWF __mul_32_3_00016_arg_b
009C  50F3      	MOVF gbl_prodl, W
009E  6E6A      	MOVWF CompTempVarRet414
00A0  50F4      	MOVF gbl_prodh, W
00A2  6E6B      	MOVWF CompTempVarRet414+D'1'
00A4  505F      	MOVF __mul_32_3_00016_arg_a+D'1', W
00A6  0262      	MULWF __mul_32_3_00016_arg_b
00A8  50F3      	MOVF gbl_prodl, W
00AA  266B      	ADDWF CompTempVarRet414+D'1', F
00AC  50F4      	MOVF gbl_prodh, W
00AE  226C      	ADDWFC CompTempVarRet414+D'2', F
00B0  B0D8      	BTFSC gbl_status,0
00B2  2A6D      	INCF CompTempVarRet414+D'3', F
00B4  5060      	MOVF __mul_32_3_00016_arg_a+D'2', W
00B6  0262      	MULWF __mul_32_3_00016_arg_b
00B8  50F3      	MOVF gbl_prodl, W
00BA  266C      	ADDWF CompTempVarRet414+D'2', F
00BC  50F4      	MOVF gbl_prodh, W
00BE  226D      	ADDWFC CompTempVarRet414+D'3', F
00C0  5061      	MOVF __mul_32_3_00016_arg_a+D'3', W
00C2  0262      	MULWF __mul_32_3_00016_arg_b
00C4  50F3      	MOVF gbl_prodl, W
00C6  266D      	ADDWF CompTempVarRet414+D'3', F
00C8  505E      	MOVF __mul_32_3_00016_arg_a, W
00CA  0263      	MULWF __mul_32_3_00016_arg_b+D'1'
00CC  50F3      	MOVF gbl_prodl, W
00CE  266B      	ADDWF CompTempVarRet414+D'1', F
00D0  50F4      	MOVF gbl_prodh, W
00D2  226C      	ADDWFC CompTempVarRet414+D'2', F
00D4  B0D8      	BTFSC gbl_status,0
00D6  2A6D      	INCF CompTempVarRet414+D'3', F
00D8  505F      	MOVF __mul_32_3_00016_arg_a+D'1', W
00DA  0263      	MULWF __mul_32_3_00016_arg_b+D'1'
00DC  50F3      	MOVF gbl_prodl, W
00DE  266C      	ADDWF CompTempVarRet414+D'2', F
00E0  50F4      	MOVF gbl_prodh, W
00E2  226D      	ADDWFC CompTempVarRet414+D'3', F
00E4  5060      	MOVF __mul_32_3_00016_arg_a+D'2', W
00E6  0263      	MULWF __mul_32_3_00016_arg_b+D'1'
00E8  50F3      	MOVF gbl_prodl, W
00EA  266D      	ADDWF CompTempVarRet414+D'3', F
00EC  505E      	MOVF __mul_32_3_00016_arg_a, W
00EE  0264      	MULWF __mul_32_3_00016_arg_b+D'2'
00F0  50F3      	MOVF gbl_prodl, W
00F2  266C      	ADDWF CompTempVarRet414+D'2', F
00F4  50F4      	MOVF gbl_prodh, W
00F6  226D      	ADDWFC CompTempVarRet414+D'3', F
00F8  505F      	MOVF __mul_32_3_00016_arg_a+D'1', W
00FA  0264      	MULWF __mul_32_3_00016_arg_b+D'2'
00FC  50F3      	MOVF gbl_prodl, W
00FE  266D      	ADDWF CompTempVarRet414+D'3', F
0100  505E      	MOVF __mul_32_3_00016_arg_a, W
0102  0265      	MULWF __mul_32_3_00016_arg_b+D'3'
0104  50F3      	MOVF gbl_prodl, W
0106  266D      	ADDWF CompTempVarRet414+D'3', F
0108  0012      	RETURN
010A            ; } __mul_32_32 function end

010A            __div_32_3_00011
010A            ; { __div_32_32 ; function begin
010A  6A66      	CLRF __div_32_3_00011_1_r
010C  6A67      	CLRF __div_32_3_00011_1_r+D'1'
010E  6A68      	CLRF __div_32_3_00011_1_r+D'2'
0110  6A69      	CLRF __div_32_3_00011_1_r+D'3'
0112  6A6C      	CLRF CompTempVarRet172
0114  6A6D      	CLRF CompTempVarRet172+D'1'
0116  6A6E      	CLRF CompTempVarRet172+D'2'
0118  6A6F      	CLRF CompTempVarRet172+D'3'
011A  6A6A      	CLRF __div_32_3_00011_1_i
011C            label5
011C  0E20      	MOVLW 0x20
011E  146A      	ANDWF __div_32_3_00011_1_i, W
0120  6E6B      	MOVWF CompTempVar174
0122  666B      	TSTFSZ CompTempVar174
0124  0012      	RETURN
0126  90D8      	BCF STATUS,C
0128  366C      	RLCF CompTempVarRet172, F
012A  366D      	RLCF CompTempVarRet172+D'1', F
012C  366E      	RLCF CompTempVarRet172+D'2', F
012E  366F      	RLCF CompTempVarRet172+D'3', F
0130  365E      	RLCF __div_32_3_00011_arg_a, F
0132  365F      	RLCF __div_32_3_00011_arg_a+D'1', F
0134  3660      	RLCF __div_32_3_00011_arg_a+D'2', F
0136  3661      	RLCF __div_32_3_00011_arg_a+D'3', F
0138  3666      	RLCF __div_32_3_00011_1_r, F
013A  3667      	RLCF __div_32_3_00011_1_r+D'1', F
013C  3668      	RLCF __div_32_3_00011_1_r+D'2', F
013E  3669      	RLCF __div_32_3_00011_1_r+D'3', F
0140  5065      	MOVF __div_32_3_00011_arg_b+D'3', W
0142  5C69      	SUBWF __div_32_3_00011_1_r+D'3', W
0144  E108      	BNZ	label6
0146  5064      	MOVF __div_32_3_00011_arg_b+D'2', W
0148  5C68      	SUBWF __div_32_3_00011_1_r+D'2', W
014A  E105      	BNZ	label6
014C  5063      	MOVF __div_32_3_00011_arg_b+D'1', W
014E  5C67      	SUBWF __div_32_3_00011_1_r+D'1', W
0150  E102      	BNZ	label6
0152  5062      	MOVF __div_32_3_00011_arg_b, W
0154  5C66      	SUBWF __div_32_3_00011_1_r, W
0156            label6
0156  E309      	BNC	label7
0158  5062      	MOVF __div_32_3_00011_arg_b, W
015A  5E66      	SUBWF __div_32_3_00011_1_r, F
015C  5063      	MOVF __div_32_3_00011_arg_b+D'1', W
015E  5A67      	SUBWFB __div_32_3_00011_1_r+D'1', F
0160  5064      	MOVF __div_32_3_00011_arg_b+D'2', W
0162  5A68      	SUBWFB __div_32_3_00011_1_r+D'2', F
0164  5065      	MOVF __div_32_3_00011_arg_b+D'3', W
0166  5A69      	SUBWFB __div_32_3_00011_1_r+D'3', F
0168  806C      	BSF CompTempVarRet172,0
016A            label7
016A  2A6A      	INCF __div_32_3_00011_1_i, F
016C  D7D7      	BRA	label5
016E            ; } __div_32_32 function end











































































0B14            _startup
0B14  0ED5      	MOVLW 0xD5
0B16  6E05      	MOVWF gbl_14_LSR
0B18  0EC4      	MOVLW 0xC4
0B1A  6E06      	MOVWF gbl_14_LSR+D'1'
0B1C  0EBB      	MOVLW 0xBB
0B1E  6E07      	MOVWF gbl_14_LSR+D'2'
0B20  0EDC      	MOVLW 0xDC
0B22  6E08      	MOVWF gbl_14_LSR+D'3'
0B24  6A09      	CLRF gbl_15_gbl_aSig
0B26  6A0A      	CLRF gbl_15_gbl_aSig+D'1'
0B28  6A0B      	CLRF gbl_15_gbl_aSig+D'2'
0B2A  6A0C      	CLRF gbl_15_gbl_aSig+D'3'
0B2C  6A0D      	CLRF gbl_15_gbl_bSig
0B2E  6A0E      	CLRF gbl_15_gbl_bSig+D'1'
0B30  6A0F      	CLRF gbl_15_gbl_bSig+D'2'
0B32  6A10      	CLRF gbl_15_gbl_bSig+D'3'
0B34  6A11      	CLRF gbl_15_gbl_zSig
0B36  6A12      	CLRF gbl_15_gbl_zSig+D'1'
0B38  6A13      	CLRF gbl_15_gbl_zSig+D'2'
0B3A  6A14      	CLRF gbl_15_gbl_zSig+D'3'
0B3C  6A2E      	CLRF gbl_15_gbl_aExp
0B3E  6A2F      	CLRF gbl_15_gbl_bExp
0B40  6A1D      	CLRF gbl_15_gbl_zExp
0B42  6A1E      	CLRF gbl_15_gbl_zExp+D'1'
0B44  6A30      	CLRF gbl_15_gbl_aSign
0B46  6A31      	CLRF gbl_15_gbl_bSign
0B48  6A32      	CLRF gbl_15_gbl_zSign
0B4A  6A33      	CLRF gbl_15_gbl_zSigZero
0B4C  6A15      	CLRF gbl_15_gbl_ret
0B4E  6A16      	CLRF gbl_15_gbl_ret+D'1'
0B50  6A17      	CLRF gbl_15_gbl_ret+D'2'
0B52  6A18      	CLRF gbl_15_gbl_ret+D'3'
0B54  6A2C      	CLRF gbl_float_rounding_mode
0B56  6A2D      	CLRF gbl_float_exception_flags
0B58  6A2B      	CLRF gbl_float_detect_tininess






0B92  EF6AF005  	GOTO	main

300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  79FF      	DW 0x79FF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
