;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
02E4  5042      	MOVF FC_CAL_Por_00042_arg_Tris+D'1', W
02E6  6EEA      	MOVWF FSR0H
02E8  5041      	MOVF FC_CAL_Por_00042_arg_Tris, W
02EA  6EE9      	MOVWF FSR0L
02EC  5043      	MOVF FC_CAL_Por_00042_arg_InMask, W
02EE  10EF      	IORWF INDF0, W
02F0  6E45      	MOVWF CompTempVar1825
02F2  5045      	MOVF CompTempVar1825, W
02F4  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
02F6  5040      	MOVF FC_CAL_Por_00042_arg_Port+D'1', W
02F8  6EEA      	MOVWF FSR0H
02FA  503F      	MOVF FC_CAL_Por_00042_arg_Port, W
02FC  6EE9      	MOVWF FSR0L
02FE  5043      	MOVF FC_CAL_Por_00042_arg_InMask, W
0300  14EF      	ANDWF INDF0, W
0302  6E45      	MOVWF CompTempVarRet1822
0304  5044      	MOVF FC_CAL_Por_00042_arg_Shift, W
0306  6E46      	MOVWF CompTempVar1827
0308            label31
0308  B4D8      	BTFSC STATUS,Z
030C  90D8      	BCF STATUS,C
030E  3245      	RRCF CompTempVarRet1822, F
0310  0646      	DECF CompTempVar1827, F
0312  D7FA      	BRA	label31

		}
030A  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
0222  6A58      	CLRF FCI_GETLEN_0004B_1_tmp
0224            label18
0224  5057      	MOVF FCI_GETLEN_0004B_arg_iStr1_len, W
0226  6058      	CPFSLT FCI_GETLEN_0004B_1_tmp
0228  D009      	BRA	label19
022A  5056      	MOVF FCI_GETLEN_0004B_arg_sStr1+D'1', W
022C  6EEA      	MOVWF FSR0H
022E  5055      	MOVF FCI_GETLEN_0004B_arg_sStr1, W
0230  2458      	ADDWF FCI_GETLEN_0004B_1_tmp, W
0232  6EE9      	MOVWF FSR0L
0234  52EF      	MOVF INDF0, F
0236  E002      	BZ	label19
0238  2A58      	INCF FCI_GETLEN_0004B_1_tmp, F
023A  D7F4      	BRA	label18
023C            label19

	return (tmp);
023C  5058      	MOVF FCI_GETLEN_0004B_1_tmp, W
023E  6E59      	MOVWF CompTempVarRet1850

}
0240  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)

{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;
0314  5049      	MOVF FCI_TOSTRI_0004F_arg_iSrc1, W
0316  6E51      	MOVWF FCI_TOSTRI_0004F_1_iSrc
0318  504A      	MOVF FCI_TOSTRI_0004F_arg_iSrc1+D'1', W
031A  6E52      	MOVWF FCI_TOSTRI_0004F_1_iSrc+D'1'
031C  504B      	MOVF FCI_TOSTRI_0004F_arg_iSrc1+D'2', W
031E  6E53      	MOVWF FCI_TOSTRI_0004F_1_iSrc+D'2'
0320  504C      	MOVF FCI_TOSTRI_0004F_arg_iSrc1+D'3', W
0322  6E54      	MOVWF FCI_TOSTRI_0004F_1_iSrc+D'3'


	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
0324  6A55      	CLRF FCI_TOSTRI_0004F_1_top
0326  0ECA      	MOVLW 0xCA
0328  6E56      	MOVWF FCI_TOSTRI_0004F_1_top+D'1'
032A  0E9A      	MOVLW 0x9A
032C  6E57      	MOVWF FCI_TOSTRI_0004F_1_top+D'2'
032E  0E3B      	MOVLW 0x3B
0330  6E58      	MOVWF FCI_TOSTRI_0004F_1_top+D'3'

	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;
0332  6A59      	CLRF FCI_TOSTRI_0004F_1_idx


	if (iDst_len == 0) return sDst;
0334  524F      	MOVF FCI_TOSTRI_0004F_arg_iDst_len, F
0336  E105      	BNZ	label32
0338  504D      	MOVF FCI_TOSTRI_0004F_arg_sDst, W
033A  6E5A      	MOVWF CompTempVarRet1863
033C  504E      	MOVF FCI_TOSTRI_0004F_arg_sDst+D'1', W
033E  6E5B      	MOVWF CompTempVarRet1863+D'1'
0342            label32


	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
0342  AE54      	BTFSS FCI_TOSTRI_0004F_1_iSrc+D'3',7
0344  D014      	BRA	label33

	{
		sDst[0] = '-';
0346  504E      	MOVF FCI_TOSTRI_0004F_arg_sDst+D'1', W
0348  6EEA      	MOVWF FSR0H
034A  504D      	MOVF FCI_TOSTRI_0004F_arg_sDst, W
034C  6EE9      	MOVWF FSR0L
034E  6A5C      	CLRF CompTempVar1865
0350  505C      	MOVF CompTempVar1865, W
0352  26E9      	ADDWF FSR0L, F
0354  0E2D      	MOVLW 0x2D
0356  6EEF      	MOVWF INDF0

		idx++;
0358  2A59      	INCF FCI_TOSTRI_0004F_1_idx, F

		iSrc = -iSrc;
035A  1E51      	COMF FCI_TOSTRI_0004F_1_iSrc, F
035C  1E52      	COMF FCI_TOSTRI_0004F_1_iSrc+D'1', F
035E  1E53      	COMF FCI_TOSTRI_0004F_1_iSrc+D'2', F
0360  1E54      	COMF FCI_TOSTRI_0004F_1_iSrc+D'3', F
0362  3E51      	INCFSZ FCI_TOSTRI_0004F_1_iSrc, F
0364  D004      	BRA	label33
0366  3E52      	INCFSZ FCI_TOSTRI_0004F_1_iSrc+D'1', F
0368  D002      	BRA	label33
036A  4A53      	INFSNZ FCI_TOSTRI_0004F_1_iSrc+D'2', F
036C  2A54      	INCF FCI_TOSTRI_0004F_1_iSrc+D'3', F
036E            label33

	}

	tmp1 = 0;    // Nothing added yet
036E  6A50      	CLRF FCI_TOSTRI_0004F_1_tmp1

	if (iSrc == 0) // Force showing zero
0370  5051      	MOVF FCI_TOSTRI_0004F_1_iSrc, W
0372  1052      	IORWF FCI_TOSTRI_0004F_1_iSrc+D'1', W
0374  1053      	IORWF FCI_TOSTRI_0004F_1_iSrc+D'2', W
0376  1054      	IORWF FCI_TOSTRI_0004F_1_iSrc+D'3', W
0378  0BFF      	ANDLW 0xFF
037A  E106      	BNZ	label34
0388            label34

	{
		tmp1 = 1;
037C  0E01      	MOVLW 0x01
037E  6E50      	MOVWF FCI_TOSTRI_0004F_1_tmp1

		top = 1;
0380  6E55      	MOVWF FCI_TOSTRI_0004F_1_top
0382  6A56      	CLRF FCI_TOSTRI_0004F_1_top+D'1'
0384  6A57      	CLRF FCI_TOSTRI_0004F_1_top+D'2'
0386  6A58      	CLRF FCI_TOSTRI_0004F_1_top+D'3'

	}
	while (( idx < iDst_len) && (top > 0))
0388  504F      	MOVF FCI_TOSTRI_0004F_arg_iDst_len, W
038A  6059      	CPFSLT FCI_TOSTRI_0004F_1_idx
038C  D072      	BRA	label39
038E  5058      	MOVF FCI_TOSTRI_0004F_1_top+D'3', W
0390  0800      	SUBLW 0x00
0392  E108      	BNZ	label35
0394  5057      	MOVF FCI_TOSTRI_0004F_1_top+D'2', W
0396  0800      	SUBLW 0x00
0398  E105      	BNZ	label35
039A  5056      	MOVF FCI_TOSTRI_0004F_1_top+D'1', W
039C  0800      	SUBLW 0x00
039E  E102      	BNZ	label35
03A0  5055      	MOVF FCI_TOSTRI_0004F_1_top, W
03A2  0800      	SUBLW 0x00
03A4            label35
03A4  E266      	BC	label39
0470  D78B      	BRA	label34
0472            label39

	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
03A6  5058      	MOVF FCI_TOSTRI_0004F_1_top+D'3', W
03A8  5C54      	SUBWF FCI_TOSTRI_0004F_1_iSrc+D'3', W
03AA  E108      	BNZ	label36
03AC  5057      	MOVF FCI_TOSTRI_0004F_1_top+D'2', W
03AE  5C53      	SUBWF FCI_TOSTRI_0004F_1_iSrc+D'2', W
03B0  E105      	BNZ	label36
03B2  5056      	MOVF FCI_TOSTRI_0004F_1_top+D'1', W
03B4  5C52      	SUBWF FCI_TOSTRI_0004F_1_iSrc+D'1', W
03B6  E102      	BNZ	label36
03B8  5055      	MOVF FCI_TOSTRI_0004F_1_top, W
03BA  5C51      	SUBWF FCI_TOSTRI_0004F_1_iSrc, W
03BC            label36
03BC  E202      	BC	label37
03BE  5250      	MOVF FCI_TOSTRI_0004F_1_tmp1, F
03C0  E040      	BZ	label38
03C2            label37
0442            label38

		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
03C2  5051      	MOVF FCI_TOSTRI_0004F_1_iSrc, W
03C4  6E5C      	MOVWF __div_32_3_00011_arg_a
03C6  5052      	MOVF FCI_TOSTRI_0004F_1_iSrc+D'1', W
03C8  6E5D      	MOVWF __div_32_3_00011_arg_a+D'1'
03CA  5053      	MOVF FCI_TOSTRI_0004F_1_iSrc+D'2', W
03CC  6E5E      	MOVWF __div_32_3_00011_arg_a+D'2'
03CE  5054      	MOVF FCI_TOSTRI_0004F_1_iSrc+D'3', W
03D0  6E5F      	MOVWF __div_32_3_00011_arg_a+D'3'
03D2  5055      	MOVF FCI_TOSTRI_0004F_1_top, W
03D4  6E60      	MOVWF __div_32_3_00011_arg_b
03D6  5056      	MOVF FCI_TOSTRI_0004F_1_top+D'1', W
03D8  6E61      	MOVWF __div_32_3_00011_arg_b+D'1'
03DA  5057      	MOVF FCI_TOSTRI_0004F_1_top+D'2', W
03DC  6E62      	MOVWF __div_32_3_00011_arg_b+D'2'
03DE  5058      	MOVF FCI_TOSTRI_0004F_1_top+D'3', W
03E0  6E63      	MOVWF __div_32_3_00011_arg_b+D'3'
03E2  EC85F000  	CALL __div_32_3_00011
03E6  506A      	MOVF CompTempVarRet172, W
03E8  6E50      	MOVWF FCI_TOSTRI_0004F_1_tmp1

			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
03EA  5050      	MOVF FCI_TOSTRI_0004F_1_tmp1, W
03EC  0F30      	ADDLW 0x30
03EE  6E5C      	MOVWF CompTempVar1871
03F0  504E      	MOVF FCI_TOSTRI_0004F_arg_sDst+D'1', W
03F2  6EEA      	MOVWF FSR0H
03F4  504D      	MOVF FCI_TOSTRI_0004F_arg_sDst, W
03F6  2459      	ADDWF FCI_TOSTRI_0004F_1_idx, W
03F8  6EE9      	MOVWF FSR0L
03FA  505C      	MOVF CompTempVar1871, W
03FC  6EEF      	MOVWF INDF0

			idx++;
03FE  2A59      	INCF FCI_TOSTRI_0004F_1_idx, F

			iSrc -= tmp1 * top;				// Remove digit
0400  5050      	MOVF FCI_TOSTRI_0004F_1_tmp1, W
0402  6E5C      	MOVWF __mul_32_3_00016_arg_a
0404  6A5D      	CLRF __mul_32_3_00016_arg_a+D'1'
0406  6A5E      	CLRF __mul_32_3_00016_arg_a+D'2'
0408  6A5F      	CLRF __mul_32_3_00016_arg_a+D'3'
040A  5055      	MOVF FCI_TOSTRI_0004F_1_top, W
040C  6E60      	MOVWF __mul_32_3_00016_arg_b
040E  5056      	MOVF FCI_TOSTRI_0004F_1_top+D'1', W
0410  6E61      	MOVWF __mul_32_3_00016_arg_b+D'1'
0412  5057      	MOVF FCI_TOSTRI_0004F_1_top+D'2', W
0414  6E62      	MOVWF __mul_32_3_00016_arg_b+D'2'
0416  5058      	MOVF FCI_TOSTRI_0004F_1_top+D'3', W
0418  6E63      	MOVWF __mul_32_3_00016_arg_b+D'3'
041A  EC46F000  	CALL __mul_32_3_00016
041E  5068      	MOVF CompTempVarRet414, W
0420  6E64      	MOVWF CompTempVar1872
0422  5069      	MOVF CompTempVarRet414+D'1', W
0424  6E65      	MOVWF CompTempVar1873
0426  506A      	MOVF CompTempVarRet414+D'2', W
0428  6E66      	MOVWF CompTempVar1874
042A  506B      	MOVF CompTempVarRet414+D'3', W
042C  6E67      	MOVWF CompTempVar1875
042E  5064      	MOVF CompTempVar1872, W
0430  5E51      	SUBWF FCI_TOSTRI_0004F_1_iSrc, F
0432  5065      	MOVF CompTempVar1873, W
0434  5A52      	SUBWFB FCI_TOSTRI_0004F_1_iSrc+D'1', F
0436  5066      	MOVF CompTempVar1874, W
0438  5A53      	SUBWFB FCI_TOSTRI_0004F_1_iSrc+D'2', F
043A  5067      	MOVF CompTempVar1875, W
043C  5A54      	SUBWFB FCI_TOSTRI_0004F_1_iSrc+D'3', F

			tmp1 = 1;						// Add zeros now
043E  0E01      	MOVLW 0x01
0440  6E50      	MOVWF FCI_TOSTRI_0004F_1_tmp1

		}
		top /= 10;							// Go to next digit
0442  5055      	MOVF FCI_TOSTRI_0004F_1_top, W
0444  6E5C      	MOVWF __div_32_3_00011_arg_a
0446  5056      	MOVF FCI_TOSTRI_0004F_1_top+D'1', W
0448  6E5D      	MOVWF __div_32_3_00011_arg_a+D'1'
044A  5057      	MOVF FCI_TOSTRI_0004F_1_top+D'2', W
044C  6E5E      	MOVWF __div_32_3_00011_arg_a+D'2'
044E  5058      	MOVF FCI_TOSTRI_0004F_1_top+D'3', W
0450  6E5F      	MOVWF __div_32_3_00011_arg_a+D'3'
0452  0E0A      	MOVLW 0x0A
0454  6E60      	MOVWF __div_32_3_00011_arg_b
0456  6A61      	CLRF __div_32_3_00011_arg_b+D'1'
0458  6A62      	CLRF __div_32_3_00011_arg_b+D'2'
045A  6A63      	CLRF __div_32_3_00011_arg_b+D'3'
045C  EC85F000  	CALL __div_32_3_00011
0460  506A      	MOVF CompTempVarRet172, W
0462  6E55      	MOVWF FCI_TOSTRI_0004F_1_top
0464  506B      	MOVF CompTempVarRet172+D'1', W
0466  6E56      	MOVWF FCI_TOSTRI_0004F_1_top+D'1'
0468  506C      	MOVF CompTempVarRet172+D'2', W
046A  6E57      	MOVWF FCI_TOSTRI_0004F_1_top+D'2'
046C  506D      	MOVF CompTempVarRet172+D'3', W
046E  6E58      	MOVWF FCI_TOSTRI_0004F_1_top+D'3'

	}

	if (idx < iDst_len)						//add terminating null (if we can)
0472  504F      	MOVF FCI_TOSTRI_0004F_arg_iDst_len, W
0474  6059      	CPFSLT FCI_TOSTRI_0004F_1_idx
0476  D007      	BRA	label40
0486            label40

		sDst[idx] = '\0';
0478  504E      	MOVF FCI_TOSTRI_0004F_arg_sDst+D'1', W
047A  6EEA      	MOVWF FSR0H
047C  504D      	MOVF FCI_TOSTRI_0004F_arg_sDst, W
047E  2459      	ADDWF FCI_TOSTRI_0004F_1_idx, W
0480  6EE9      	MOVWF FSR0L
0482  0E00      	MOVLW 0x00
0484  6EEF      	MOVWF INDF0

	return (sDst);
0486  504D      	MOVF FCI_TOSTRI_0004F_arg_sDst, W
0488  6E5A      	MOVWF CompTempVarRet1863
048A  504E      	MOVF FCI_TOSTRI_0004F_arg_sDst+D'1', W
048C  6E5B      	MOVWF CompTempVarRet1863+D'1'

}
0340  0012      	RETURN
048E  0012      	RETURN




void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BatailleNavale\parametre_surveille_JO.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Tuesday, April 04, 2017 15:49:50
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x79
#endif
#ifdef HI_TECH_C
__CONFIG(0x79);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT16 FCV_VAR = (0x0);
07F2  6A1F      	CLRF gbl_FCV_VAR
07F4  6A20      	CLRF gbl_FCV_VAR+D'1'

MX_GLOBAL MX_UINT16 FCV_Y = (0x0);
07F6  6A21      	CLRF gbl_FCV_Y
07F8  6A22      	CLRF gbl_FCV_Y+D'1'

MX_GLOBAL MX_UINT16 FCV_X = (0x0);
07FA  6A23      	CLRF gbl_FCV_X
07FC  6A24      	CLRF gbl_FCV_X+D'1'



/*========================================================================*\
   Use :component_label1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_03d92_led_base1__TurnOn();
void FCD_03d92_led_base1__TurnOff();

/*========================================================================*\
   Use :default_target
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_083d2_default_target__TurnOn FCD_03d92_led_base1__TurnOn
#define FCD_083d2_default_target__TurnOff FCD_03d92_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_03d912_led_base1__TurnOn();
void FCD_03d912_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm8
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_083d12_led_5mm8__TurnOn FCD_03d912_led_base1__TurnOn
#define FCD_083d12_led_5mm8__TurnOff FCD_03d912_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_03d911_led_base1__TurnOn();
void FCD_03d911_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_083d11_led_5mm7__TurnOn FCD_03d911_led_base1__TurnOn
#define FCD_083d11_led_5mm7__TurnOff FCD_03d911_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_03d910_led_base1__TurnOn();
void FCD_03d910_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_083d10_led_5mm6__TurnOn FCD_03d910_led_base1__TurnOn
#define FCD_083d10_led_5mm6__TurnOff FCD_03d910_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_03d9f_led_base1__TurnOn();
void FCD_03d9f_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_083df_led_5mm5__TurnOn FCD_03d9f_led_base1__TurnOn
#define FCD_083df_led_5mm5__TurnOff FCD_03d9f_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_03d9e_led_base1__TurnOn();
void FCD_03d9e_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_083de_led_5mm4__TurnOn FCD_03d9e_led_base1__TurnOn
#define FCD_083de_led_5mm4__TurnOff FCD_03d9e_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_03d9d_led_base1__TurnOn();
void FCD_03d9d_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_083dd_led_5mm3__TurnOn FCD_03d9d_led_base1__TurnOn
#define FCD_083dd_led_5mm3__TurnOff FCD_03d9d_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_03d9c_led_base1__TurnOn();
void FCD_03d9c_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_083dc_led_5mm2__TurnOn FCD_03d9c_led_base1__TurnOn
#define FCD_083dc_led_5mm2__TurnOff FCD_03d9c_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_03d9b_led_base1__TurnOn();
void FCD_03d9b_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_083db_led_5mm1__TurnOn FCD_03d9b_led_base1__TurnOn
#define FCD_083db_led_5mm1__TurnOff FCD_03d9b_led_base1__TurnOff

/*========================================================================*\
   Use :led_array1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_0e1e1_led_array1__BarGraph(MX_UINT8 FCL_LENGTH);
void FCD_0e1e1_led_array1__LEDOn(MX_UINT8 FCL_INDEX);
void FCD_0e1e1_led_array1__AllOn();
void FCD_0e1e1_led_array1__LEDOff(MX_UINT8 FCL_INDEX);
void FCD_0e1e1_led_array1__PointGraph(MX_UINT8 FCL_INDEX);
void FCD_0e1e1_led_array1__WriteValue(MX_UINT8 FCL_VALUE);
void FCD_0e1e1_led_array1__AllOff();

/*========================================================================*\
   Use :component_label1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_03d91_led_base1__TurnOn();
void FCD_03d91_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_083d1_led_5mm1__TurnOn FCD_03d91_led_base1__TurnOn
#define FCD_083d1_led_5mm1__TurnOff FCD_03d91_led_base1__TurnOff

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 porta
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 porta
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisa
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisa
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (2)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
07FE  0E00      	MOVLW 0x00
0800  6E32      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
0802  0E01      	MOVLW 0x01
0804  6E33      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
0806  0E02      	MOVLW 0x02
0808  6E34      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
080A  0E03      	MOVLW 0x03
080C  6E35      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
080E  0E04      	MOVLW 0x04
0810  6E36      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
0812  0E05      	MOVLW 0x05
0814  6E37      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
0816  0E06      	MOVLW 0x06
0818  6E38      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
081A  0E07      	MOVLW 0x07
081C  6E39      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
081E  6A19      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009
0820  6A1A      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1'
0822  6A1B      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2'
0824  6A1C      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3'

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
0826  6A3A      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :component_label1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d92_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x1, 0x0, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d92_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x1, 0x0, 1 - 1);

}


/*========================================================================*\
   Use :default_target
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d912_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x80, 0x7, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d912_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x80, 0x7, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm8
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d911_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x40, 0x6, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d911_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x40, 0x6, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d910_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x20, 0x5, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d910_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x20, 0x5, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d9f_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x10, 0x4, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d9f_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x10, 0x4, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d9e_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x8, 0x3, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d9e_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x8, 0x3, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d9d_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x4, 0x2, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d9d_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x4, 0x2, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d9c_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x2, 0x1, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d9c_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x2, 0x1, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d9b_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x1, 0x0, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d9b_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x1, 0x0, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_array1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turns on the first N elements of the array - for generating bar graph metes etc.
       :
       :Param??tres pour la macro BarGraph :
       :  Length : How many items to light up.
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__BarGraph(MX_UINT8 FCL_LENGTH)
{
	//Définitions des variables locales
	MX_UINT8 FCL_INDEX;


	FCL_INDEX = 0;

	while (FCL_INDEX < 8)
	{

		if (FCL_INDEX >= FCL_LENGTH)
		{

			FCD_0e1e1_led_array1__LEDOff(FCL_INDEX);

		} else {

			FCD_0e1e1_led_array1__LEDOn(FCL_INDEX);

		}

		FCL_INDEX = FCL_INDEX + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Turn on the selected LED.
       :
       :Param??tres pour la macro LEDOn :
       :  Index : Index of the LED to turn on.
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__LEDOn(MX_UINT8 FCL_INDEX)
{

	switch (FCL_INDEX)
	{
		case 0:
		{
			#if (1) // 8 > 0

				FCP_SET(B, A, 0x1, 0x0, 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 1:
		{
			#if (1) // 8 > 1

				FCP_SET(B, A, 0x2, 0x1, 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 2:
		{
			#if (1) // 8 > 2

				FCP_SET(B, A, 0x4, 0x2, 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 3:
		{
			#if (1) // 8 > 3

				FCP_SET(B, A, 0x8, 0x3, 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 4:
		{
			#if (1) // 8 > 4

				FCP_SET(B, A, 0x10, 0x4, 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 5:
		{
			#if (1) // 8 > 5

				FCP_SET(B, A, 0x20, 0x5, 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 6:
		{
			#if (1) // 8 > 6

				FCP_SET(B, A, 0x40, 0x6, 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 7:
		{
			#if (1) // 8 > 7

				FCP_SET(B, A, 0x80, 0x7, 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		default:
		{
		}
	}

}

/*=----------------------------------------------------------------------=*\
   Use :Turns on all elements
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__AllOn()
{
	//Définitions des variables locales
	MX_UINT8 FCL_INDEX;


	#if (0) // 0 == 11

	//Le code a été optimisé par le préprocesseur
	#else

		#if (1) // 1 == 1

			FCP_SET(F, A, 0xff, 0x0, 255);

		#else

		//Le code a été optimisé par le préprocesseur
		#endif

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Turn off the selected led.
       :
       :Param??tres pour la macro LEDOff :
       :  Index : Index of the LED to turn on.
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__LEDOff(MX_UINT8 FCL_INDEX)
{

	switch (FCL_INDEX)
	{
		case 0:
		{
			#if (1) // 8 > 0

				FCP_SET(B, A, 0x1, 0x0, 1 - 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 1:
		{
			#if (1) // 8 > 1

				FCP_SET(B, A, 0x2, 0x1, 1 - 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 2:
		{
			#if (1) // 8 > 2

				FCP_SET(B, A, 0x4, 0x2, 1 - 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 3:
		{
			#if (1) // 8 > 3

				FCP_SET(B, A, 0x8, 0x3, 1 - 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 4:
		{
			#if (1) // 8 > 4

				FCP_SET(B, A, 0x10, 0x4, 1 - 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 5:
		{
			#if (1) // 8 > 5

				FCP_SET(B, A, 0x20, 0x5, 1 - 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 6:
		{
			#if (1) // 8 > 6

				FCP_SET(B, A, 0x40, 0x6, 1 - 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		case 7:
		{
			#if (1) // 8 > 7

				FCP_SET(B, A, 0x80, 0x7, 1 - 1);

			// #else

			//Le code a été optimisé par le préprocesseur
			#endif

			break;
		}
		default:
		{
		}
	}

}

/*=----------------------------------------------------------------------=*\
   Use :Turns on the Indexed LED and turns all others off.
       :Does nothing if the index is out of range.
       :
       :Param??tres pour la macro PointGraph :
       :  Index : The LED to show.
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__PointGraph(MX_UINT8 FCL_INDEX)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX;


	FCL_IDX = 0;

	while (FCL_IDX < 8)
	{

		if (FCL_IDX == FCL_INDEX)
		{

			FCD_0e1e1_led_array1__LEDOn(FCL_IDX);

		} else {

			FCD_0e1e1_led_array1__LEDOff(FCL_IDX);

		}

		FCL_IDX = FCL_IDX + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Write a number which is presented on the LEDs in binary.
       :
       :Param??tres pour la macro WriteValue :
       :  Value : Provide a value to be written to the LEDs in binary
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__WriteValue(MX_UINT8 FCL_VALUE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCL_TEMPVALUE = (0);
	MX_UINT16 FCL_MASK = (0x0);


	FCL_COUNT = 0;

	while (FCL_COUNT < 8)
	{

		if (FCL_VALUE & (1 << FCL_COUNT))
		{

			FCD_0e1e1_led_array1__LEDOn(FCL_COUNT);

		} else {

			FCD_0e1e1_led_array1__LEDOff(FCL_COUNT);

		}

		FCL_COUNT = FCL_COUNT + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Turns off all elements
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__AllOff()
{
	//Définitions des variables locales
	MX_UINT8 FCL_INDEX;


	#if (0) // 0 == 11

	//Le code a été optimisé par le préprocesseur
	#else

		#if (1) // 1 == 1

			FCP_SET(F, A, 0xff, 0x0, ~255);

		#else

		//Le code a été optimisé par le préprocesseur
		#endif

	#endif

}


/*========================================================================*\
   Use :component_label1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d91_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x1, 0x0, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d91_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x1, 0x0, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x63);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)
{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;

	if (FCL_AXIS == 0)
	{

	} else {

		if (FCL_AXIS == 'x')
		{

		} else {

			if (FCL_AXIS == 'X')
			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;

			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;

FCC_G4D_ReadTouchCoordinatesPicaso_A:
;

	if (FCL_AXIS == 1)
	{

	} else {

		if (FCL_AXIS == 'y')
		{

		} else {

			if (FCL_AXIS == 'Y')
			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;

			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;

FCC_G4D_ReadTouchCoordinatesPicaso_B:
;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()
{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x6F);

	FC_CAL_UART_Send_1(4);

	FC_CAL_UART_Receive_1(255);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL)
	{

		FC_CAL_UART_Send_1(0x6F);

		FC_CAL_UART_Send_1(5);

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_1(255);

		FCL_TEMP = FC_CAL_UART_Receive_1(255);

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_1(255);

		FCL_TEMP = FC_CAL_UART_Receive_1(255);

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;

	// } else {

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_1(FCL_RADIUS);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)

{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);
072A  503B      	MOVF FCD_0f051__00096_arg_FCL_NUMBER, W
072C  6E49      	MOVWF FCI_TOSTRI_0004F_arg_iSrc1
072E  503C      	MOVF FCD_0f051__00096_arg_FCL_NUMBER+D'1', W
0730  6E4A      	MOVWF FCI_TOSTRI_0004F_arg_iSrc1+D'1'
0732  6A4B      	CLRF FCI_TOSTRI_0004F_arg_iSrc1+D'2'
0734  6A4C      	CLRF FCI_TOSTRI_0004F_arg_iSrc1+D'3'
0736  AE3C      	BTFSS FCD_0f051__00096_arg_FCL_NUMBER+D'1',7
0738  D002      	BRA	label47
073A  064B      	DECF FCI_TOSTRI_0004F_arg_iSrc1+D'2', F
073C  064C      	DECF FCI_TOSTRI_0004F_arg_iSrc1+D'3', F
073E            label47
073E  0E00      	MOVLW HIGH(FCD_0f051__00096_1_FCL_TEMP+D'0')
0740  6E4E      	MOVWF FCI_TOSTRI_0004F_arg_sDst+D'1'
0742  0E43      	MOVLW LOW(FCD_0f051__00096_1_FCL_TEMP+D'0')
0744  6E4D      	MOVWF FCI_TOSTRI_0004F_arg_sDst
0746  0E06      	MOVLW 0x06
0748  6E4F      	MOVWF FCI_TOSTRI_0004F_arg_iDst_len
074A  EC8AF001  	CALL FCI_TOSTRI_0004F


	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);
074E  0E00      	MOVLW HIGH(FCD_0f051__00096_1_FCL_TEMP+D'0')
0750  6E4A      	MOVWF FCD_0f051__00098_arg_FCL_STR+D'1'
0752  0E43      	MOVLW LOW(FCD_0f051__00096_1_FCL_TEMP+D'0')
0754  6E49      	MOVWF FCD_0f051__00098_arg_FCL_STR
0756  0E06      	MOVLW 0x06
0758  6E4B      	MOVWF FCD_0f051__00098_arg_FCLsz_STR
075A  6A4C      	CLRF FCD_0f051__00098_arg_FCLsz_STR+D'1'
075C  503D      	MOVF FCD_0f051__00096_arg_FCL_X, W
075E  6E4D      	MOVWF FCD_0f051__00098_arg_FCL_X1
0760  503E      	MOVF FCD_0f051__00096_arg_FCL_X+D'1', W
0762  6E4E      	MOVWF FCD_0f051__00098_arg_FCL_X1+D'1'
0764  503F      	MOVF FCD_0f051__00096_arg_FCL_Y, W
0766  6E4F      	MOVWF FCD_0f051__00098_arg_FCL_Y1
0768  5040      	MOVF FCD_0f051__00096_arg_FCL_Y+D'1', W
076A  6E50      	MOVWF FCD_0f051__00098_arg_FCL_Y1+D'1'
076C  5041      	MOVF FCD_0f051__00096_arg_FCL_FONT, W
076E  6E51      	MOVWF FCD_0f051__00098_arg_FCL_FONT
0770  5042      	MOVF FCD_0f051__00096_arg_FCL_T_00097, W
0772  6E52      	MOVWF FCD_0f051__00098_arg_FCL_T_00099
0774  EC68F002  	CALL FCD_0f051__00098


	//Définitions des variables locales
	#undef FCLsz_TEMP
}
0778  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FC_CAL_UART_Send_1(0x4C);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_POSH >> 8);

	FC_CAL_UART_Send_1(FCL_POSH);

	FC_CAL_UART_Send_1(FCL_POSL >> 8);

	FC_CAL_UART_Send_1(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x05);

	FC_CAL_UART_Send_1(0x01);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x00);

	FC_CAL_UART_Send_1(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x01);

	FC_CAL_UART_Send_1(FCL_DISPLAY);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x02);

	FC_CAL_UART_Send_1(FCL_CONTRAST);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x05);

	FC_CAL_UART_Send_1(0x00);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x05);

	FC_CAL_UART_Send_1(0x02);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x56);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_1(0x10);

	} else {

		FC_CAL_UART_Send_1(0x08);

	}

	FC_CAL_UART_Send_1(FCL_DELAY);

	FC_CAL_UART_Send_1(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_1(FCL_FRAMES);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x76);

	FC_CAL_UART_Send_1(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_1(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_1(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_1(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_1(0x03);

		}
	}

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x65);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RX >> 8);

	FC_CAL_UART_Send_1(FCL_RX);

	FC_CAL_UART_Send_1(FCL_RY >> 8);

	FC_CAL_UART_Send_1(FCL_RY);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);
04D0  6A54      	CLRF FCD_0f051__00098_1_FCL_IDX



	FC_CAL_UART_Send_1(0x4F);
04D2  0E4F      	MOVLW 0x4F
04D4  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
04D6  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
04D8  ECB7F000  	CALL FC_CAL_UAR_0007A


	if (FCL_TRANSPARENT)
04DC  5252      	MOVF FCD_0f051__00098_arg_FCL_T_00099, F
04DE  E005      	BZ	label41
04EA            label41

	{

		FC_CAL_UART_Send_1(0x00);
04E0  6A55      	CLRF FC_CAL_UAR_0007A_arg_nChar
04E2  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
04E4  ECB7F000  	CALL FC_CAL_UAR_0007A


	} else {
04E8  D005      	BRA	label42
04F4            label42


		FC_CAL_UART_Send_1(0x01);
04EA  0E01      	MOVLW 0x01
04EC  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
04EE  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
04F0  ECB7F000  	CALL FC_CAL_UAR_0007A


	}

	FC_CAL_UART_Receive_1(255);
04F4  6855      	SETF FC_CAL_UAR_00079_arg_nTimeout
04F6  ECBFF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Send_1(0x53);
04FA  0E53      	MOVLW 0x53
04FC  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
04FE  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
0500  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0504  504E      	MOVF FCD_0f051__00098_arg_FCL_X1+D'1', W
0506  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
0508  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
050A  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X1);
050E  504D      	MOVF FCD_0f051__00098_arg_FCL_X1, W
0510  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
0512  504E      	MOVF FCD_0f051__00098_arg_FCL_X1+D'1', W
0514  6E56      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1'
0516  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
051A  5050      	MOVF FCD_0f051__00098_arg_FCL_Y1+D'1', W
051C  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
051E  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
0520  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y1);
0524  504F      	MOVF FCD_0f051__00098_arg_FCL_Y1, W
0526  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
0528  5050      	MOVF FCD_0f051__00098_arg_FCL_Y1+D'1', W
052A  6E56      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1'
052C  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_FONT);
0530  5051      	MOVF FCD_0f051__00098_arg_FCL_FONT, W
0532  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
0534  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
0536  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
053A  5028      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
053C  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
053E  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
0540  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0544  5027      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W
0546  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
0548  5028      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
054A  6E56      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1'
054C  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(1);
0550  0E01      	MOVLW 0x01
0552  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
0554  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
0556  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(1);
055A  0E01      	MOVLW 0x01
055C  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
055E  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
0560  ECB7F000  	CALL FC_CAL_UAR_0007A


	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);
0564  5049      	MOVF FCD_0f051__00098_arg_FCL_STR, W
0566  6E55      	MOVWF FCI_GETLEN_0004B_arg_sStr1
0568  504A      	MOVF FCD_0f051__00098_arg_FCL_STR+D'1', W
056A  6E56      	MOVWF FCI_GETLEN_0004B_arg_sStr1+D'1'
056C  504B      	MOVF FCD_0f051__00098_arg_FCLsz_STR, W
056E  6E57      	MOVWF FCI_GETLEN_0004B_arg_iStr1_len
0570  EC11F001  	CALL FCI_GETLEN_0004B
0574  5059      	MOVF CompTempVarRet1850, W
0576  6E53      	MOVWF FCD_0f051__00098_1_FCL_LEN_STR


	while (FCL_IDX < FCL_LEN_STR)
0578            label43
0578  5053      	MOVF FCD_0f051__00098_1_FCL_LEN_STR, W
057A  6054      	CPFSLT FCD_0f051__00098_1_FCL_IDX
057C  D014      	BRA	label44
05A4  D7E9      	BRA	label43
05A6            label44

	{

		if (FCL_STR[FCL_IDX] == 0)
057E  504A      	MOVF FCD_0f051__00098_arg_FCL_STR+D'1', W
0580  6EEA      	MOVWF FSR0H
0582  5049      	MOVF FCD_0f051__00098_arg_FCL_STR, W
0584  2454      	ADDWF FCD_0f051__00098_1_FCL_IDX, W
0586  6EE9      	MOVWF FSR0L
0588  52EF      	MOVF INDF0, F
058A  E00D      	BZ	label44

		{

			goto FCC_Print_A;


		// } else {

		}

		FC_CAL_UART_Send_1(FCL_STR[FCL_IDX]);
058C  504A      	MOVF FCD_0f051__00098_arg_FCL_STR+D'1', W
058E  6EEA      	MOVWF FSR0H
0590  5049      	MOVF FCD_0f051__00098_arg_FCL_STR, W
0592  2454      	ADDWF FCD_0f051__00098_1_FCL_IDX, W
0594  6EE9      	MOVWF FSR0L
0596  50EF      	MOVF INDF0, W
0598  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
059A  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
059C  ECB7F000  	CALL FC_CAL_UAR_0007A


		FCL_IDX = FCL_IDX + 1;
05A0  2854      	INCF FCD_0f051__00098_1_FCL_IDX, W
05A2  6E54      	MOVWF FCD_0f051__00098_1_FCL_IDX



	}

FCC_Print_A:
;

	FC_CAL_UART_Send_1(0);
05A6  6A55      	CLRF FC_CAL_UAR_0007A_arg_nChar
05A8  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
05AA  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
05AE  6855      	SETF FC_CAL_UAR_00079_arg_nTimeout
05B0  ECBFF000  	CALL FC_CAL_UAR_00079


}
05B4  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x0c);

	FC_CAL_UART_Send_1(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
0490  6A3F      	CLRF FCD_0f051__000AC_1_FCL_Y
0492  6A40      	CLRF FCD_0f051__000AC_1_FCL_Y+D'1'

	MX_UINT16 FCL_X = (0x0);
0494  6A41      	CLRF FCD_0f051__000AC_1_FCL_X
0496  6A42      	CLRF FCD_0f051__000AC_1_FCL_X+D'1'



	FC_CAL_UART_Send_1(0x42);
0498  0E42      	MOVLW 0x42
049A  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
049C  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
049E  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
04A2  5026      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
04A4  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
04A6  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
04A8  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
04AC  5025      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W
04AE  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
04B0  5026      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
04B2  6E56      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1'
04B4  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
04B8  6855      	SETF FC_CAL_UAR_00079_arg_nTimeout
04BA  ECBFF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Send_1(0x45);
04BE  0E45      	MOVLW 0x45
04C0  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
04C2  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
04C4  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
04C8  6855      	SETF FC_CAL_UAR_00079_arg_nTimeout
04CA  ECBFF000  	CALL FC_CAL_UAR_00079


}
04CE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x49);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x75);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6C);

	FC_CAL_UART_Send_1(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
	{

		FC_CAL_UART_Send_1(0x70);

		FC_CAL_UART_Send_1(0x00);

		FC_CAL_UART_Receive_1(255);

		FC_CAL_UART_Send_1(0x72);

		FC_CAL_UART_Send_1(FCL_X1 >> 8);

		FC_CAL_UART_Send_1(FCL_X1);

		FC_CAL_UART_Send_1(FCL_Y1 >> 8);

		FC_CAL_UART_Send_1(FCL_Y1);

		FC_CAL_UART_Send_1(FCL_X2 >> 8);

		FC_CAL_UART_Send_1(FCL_X2);

		FC_CAL_UART_Send_1(FCL_Y2 >> 8);

		FC_CAL_UART_Send_1(FCL_Y2);

		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

		FC_CAL_UART_Receive_1(255);

	// } else {

	}

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x72);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, C, 0x20, 0x5, 0);
05B6  6A3F      	CLRF FCD_0f051__000B7_2_ptmp
05B8  9A94      	BCF gbl_trisc,5
05BA  523F      	MOVF FCD_0f051__000B7_2_ptmp, F
05BC  E004      	BZ	label45
05BE  0E20      	MOVLW 0x20
05C0  108B      	IORWF gbl_latc, W
05C2  6E82      	MOVWF gbl_portc
05C4  D003      	BRA	label46
05C6            label45
05C6  0EDF      	MOVLW 0xDF
05C8  148B      	ANDWF gbl_latc, W
05CA  6E82      	MOVWF gbl_portc
05CC            label46


	FC_CAL_UART_Init_1();
05CC  EC21F001  	CALL FC_CAL_UAR_0007B


	FCI_DELAYBYTE_US(100);
05D0  0E64      	MOVLW 0x64
05D2  6E3F      	MOVWF delay_us_00000_arg_del
05D4  EC2EF000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, C, 0x20, 0x5);
05D8  0E0F      	MOVLW HIGH(gbl_portc+D'0')
05DA  6E40      	MOVWF FC_CAL_Por_00042_arg_Port+D'1'
05DC  0E82      	MOVLW LOW(gbl_portc+D'0')
05DE  6E3F      	MOVWF FC_CAL_Por_00042_arg_Port
05E0  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
05E2  6E42      	MOVWF FC_CAL_Por_00042_arg_Tris+D'1'
05E4  0E94      	MOVLW LOW(gbl_trisc+D'0')
05E6  6E41      	MOVWF FC_CAL_Por_00042_arg_Tris
05E8  0E20      	MOVLW 0x20
05EA  6E43      	MOVWF FC_CAL_Por_00042_arg_InMask
05EC  0E05      	MOVLW 0x05
05EE  6E44      	MOVWF FC_CAL_Por_00042_arg_Shift
05F0  EC72F001  	CALL FC_CAL_Por_00042
05F4  5045      	MOVF CompTempVarRet1822, W
05F6  6E3E      	MOVWF FCD_0f051__000B7_1_FCL_DUMMY


	FCI_DELAYBYTE_S(3);
05F8  0E03      	MOVLW 0x03
05FA  6E3F      	MOVWF delay_s_00000_arg_del
05FC  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_1(0);
0600  6A55      	CLRF FC_CAL_UAR_00079_arg_nTimeout
0602  ECBFF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Receive_1(0);
0606  6A55      	CLRF FC_CAL_UAR_00079_arg_nTimeout
0608  ECBFF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Receive_1(0);
060C  6A55      	CLRF FC_CAL_UAR_00079_arg_nTimeout
060E  ECBFF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Send_1(0x55);
0612  0E55      	MOVLW 0x55
0614  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
0616  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
0618  ECB7F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
061C  6855      	SETF FC_CAL_UAR_00079_arg_nTimeout
061E  ECBFF000  	CALL FC_CAL_UAR_00079


	#if (1) // 1 == 1

		#if (1) // 1 != 0

			FC_CAL_UART_Send_1(0x51);
0622  0E51      	MOVLW 0x51
0624  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
0626  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
0628  ECB7F000  	CALL FC_CAL_UAR_0007A


			FC_CAL_UART_Send_1(0x0C);
062C  0E0C      	MOVLW 0x0C
062E  6E55      	MOVWF FC_CAL_UAR_0007A_arg_nChar
0630  6A56      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1'
0632  ECB7F000  	CALL FC_CAL_UAR_0007A


			FC_CAL_UART_Receive_1(255);
0636  6855      	SETF FC_CAL_UAR_00079_arg_nTimeout
0638  ECBFF000  	CALL FC_CAL_UAR_00079


			FC_CAL_UART_UpdateBaud_1(6);
063C  0E06      	MOVLW 0x06
063E  6E3F      	MOVWF FC_CAL_UAR_00077_arg_new_baud
0640  EC2AF001  	CALL FC_CAL_UAR_00077



		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_1(10);
0644  0E0A      	MOVLW 0x0A
0646  6E55      	MOVWF FC_CAL_UAR_00079_arg_nTimeout
0648  ECBFF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Receive_1(10);
064C  0E0A      	MOVLW 0x0A
064E  6E55      	MOVWF FC_CAL_UAR_00079_arg_nTimeout
0650  ECBFF000  	CALL FC_CAL_UAR_00079


	FCL_RED = 0 & 0xFF;
0654  6A3B      	CLRF FCD_0f051__000B7_1_FCL_RED

	FCL_RED = FCL_RED >> (8 - 5);
0656  323B      	RRCF FCD_0f051__000B7_1_FCL_RED, F
0658  323B      	RRCF FCD_0f051__000B7_1_FCL_RED, F
065A  323B      	RRCF FCD_0f051__000B7_1_FCL_RED, F
065C  0E1F      	MOVLW 0x1F
065E  163B      	ANDWF FCD_0f051__000B7_1_FCL_RED, F

	FCL_GREEN = (0 >> 8) & 0xFF;
0660  6A3C      	CLRF FCD_0f051__000B7_1_FCL_GREEN

	FCL_GREEN = FCL_GREEN >> (8 - 6);
0662  323C      	RRCF FCD_0f051__000B7_1_FCL_GREEN, F
0664  323C      	RRCF FCD_0f051__000B7_1_FCL_GREEN, F
0666  0E3F      	MOVLW 0x3F
0668  163C      	ANDWF FCD_0f051__000B7_1_FCL_GREEN, F

	FCL_BLUE = (0 >> 16) & 0xFF;
066A  6A3D      	CLRF FCD_0f051__000B7_1_FCL_BLUE

	FCL_BLUE = FCL_BLUE >> (8 - 5);
066C  323D      	RRCF FCD_0f051__000B7_1_FCL_BLUE, F
066E  323D      	RRCF FCD_0f051__000B7_1_FCL_BLUE, F
0670  323D      	RRCF FCD_0f051__000B7_1_FCL_BLUE, F
0672  0E1F      	MOVLW 0x1F
0674  163D      	ANDWF FCD_0f051__000B7_1_FCL_BLUE, F

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
0676  503C      	MOVF FCD_0f051__000B7_1_FCL_GREEN, W
0678  6E3F      	MOVWF CompTempVar2965
067A  6A28      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1'
067C  363F      	RLCF CompTempVar2965, F
067E  3628      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0680  363F      	RLCF CompTempVar2965, F
0682  3628      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0684  363F      	RLCF CompTempVar2965, F
0686  3628      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0688  363F      	RLCF CompTempVar2965, F
068A  3628      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
068C  363F      	RLCF CompTempVar2965, F
068E  3628      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0690  0EE0      	MOVLW 0xE0
0692  163F      	ANDWF CompTempVar2965, F
0694  503F      	MOVF CompTempVar2965, W
0696  103D      	IORWF FCD_0f051__000B7_1_FCL_BLUE, W
0698  6E27      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
069A  6A3F      	CLRF CompTempVar2969
069C  503B      	MOVF FCD_0f051__000B7_1_FCL_RED, W
069E  6E40      	MOVWF CompTempVar2970
06A0  90D8      	BCF STATUS,C
06A2  3640      	RLCF CompTempVar2970, F
06A4  90D8      	BCF STATUS,C
06A6  3640      	RLCF CompTempVar2970, F
06A8  90D8      	BCF STATUS,C
06AA  3640      	RLCF CompTempVar2970, F
06AC  503F      	MOVF CompTempVar2969, W
06AE  1227      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F
06B0  5040      	MOVF CompTempVar2970, W
06B2  1228      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F

	FCL_RED = 16777215 & 0xFF;
06B4  683B      	SETF FCD_0f051__000B7_1_FCL_RED

	FCL_RED = FCL_RED >> (8 - 5);
06B6  323B      	RRCF FCD_0f051__000B7_1_FCL_RED, F
06B8  323B      	RRCF FCD_0f051__000B7_1_FCL_RED, F
06BA  323B      	RRCF FCD_0f051__000B7_1_FCL_RED, F
06BC  0E1F      	MOVLW 0x1F
06BE  163B      	ANDWF FCD_0f051__000B7_1_FCL_RED, F

	FCL_GREEN = (16777215 >> 8) & 0xFF;
06C0  683C      	SETF FCD_0f051__000B7_1_FCL_GREEN

	FCL_GREEN = FCL_GREEN >> (8 - 6);
06C2  323C      	RRCF FCD_0f051__000B7_1_FCL_GREEN, F
06C4  323C      	RRCF FCD_0f051__000B7_1_FCL_GREEN, F
06C6  0E3F      	MOVLW 0x3F
06C8  163C      	ANDWF FCD_0f051__000B7_1_FCL_GREEN, F

	FCL_BLUE = (16777215 >> 16) & 0xFF;
06CA  683D      	SETF FCD_0f051__000B7_1_FCL_BLUE

	FCL_BLUE = FCL_BLUE >> (8 - 5);
06CC  323D      	RRCF FCD_0f051__000B7_1_FCL_BLUE, F
06CE  323D      	RRCF FCD_0f051__000B7_1_FCL_BLUE, F
06D0  323D      	RRCF FCD_0f051__000B7_1_FCL_BLUE, F
06D2  0E1F      	MOVLW 0x1F
06D4  163D      	ANDWF FCD_0f051__000B7_1_FCL_BLUE, F

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
06D6  503C      	MOVF FCD_0f051__000B7_1_FCL_GREEN, W
06D8  6E3F      	MOVWF CompTempVar2976
06DA  6A26      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1'
06DC  363F      	RLCF CompTempVar2976, F
06DE  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
06E0  363F      	RLCF CompTempVar2976, F
06E2  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
06E4  363F      	RLCF CompTempVar2976, F
06E6  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
06E8  363F      	RLCF CompTempVar2976, F
06EA  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
06EC  363F      	RLCF CompTempVar2976, F
06EE  3626      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
06F0  0EE0      	MOVLW 0xE0
06F2  163F      	ANDWF CompTempVar2976, F
06F4  503F      	MOVF CompTempVar2976, W
06F6  103D      	IORWF FCD_0f051__000B7_1_FCL_BLUE, W
06F8  6E25      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
06FA  6A3F      	CLRF CompTempVar2980
06FC  503B      	MOVF FCD_0f051__000B7_1_FCL_RED, W
06FE  6E40      	MOVWF CompTempVar2981
0700  90D8      	BCF STATUS,C
0702  3640      	RLCF CompTempVar2981, F
0704  90D8      	BCF STATUS,C
0706  3640      	RLCF CompTempVar2981, F
0708  90D8      	BCF STATUS,C
070A  3640      	RLCF CompTempVar2981, F
070C  503F      	MOVF CompTempVar2980, W
070E  1225      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F
0710  5040      	MOVF CompTempVar2981, W
0712  1226      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
0714  EC48F002  	CALL FCD_0f051__000AC


	FC_CAL_UART_Receive_1(10);
0718  0E0A      	MOVLW 0x0A
071A  6E55      	MOVWF FC_CAL_UAR_00079_arg_nTimeout
071C  ECBFF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Receive_1(10);
0720  0E0A      	MOVLW 0x0A
0722  6E55      	MOVWF FC_CAL_UAR_00079_arg_nTimeout
0724  ECBFF000  	CALL FC_CAL_UAR_00079


}
0728  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/


/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
077A  0E0F      	MOVLW 0x0F
077C  6EC1      	MOVWF gbl_adcon1





	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
077E  ECDBF002  	CALL FCD_0f051__000B7


	// Boucle
	// Boucle: While 1
	while (1)
0782            label48
07AA  D7EB      	BRA	label48

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(var, 10, 20, 1, 1)
		FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_VAR, 10, 20, 1, 1);
0782  501F      	MOVF gbl_FCV_VAR, W
0784  6E3B      	MOVWF FCD_0f051__00096_arg_FCL_NUMBER
0786  5020      	MOVF gbl_FCV_VAR+D'1', W
0788  6E3C      	MOVWF FCD_0f051__00096_arg_FCL_NUMBER+D'1'
078A  0E0A      	MOVLW 0x0A
078C  6E3D      	MOVWF FCD_0f051__00096_arg_FCL_X
078E  6A3E      	CLRF FCD_0f051__00096_arg_FCL_X+D'1'
0790  0E14      	MOVLW 0x14
0792  6E3F      	MOVWF FCD_0f051__00096_arg_FCL_Y
0794  6A40      	CLRF FCD_0f051__00096_arg_FCL_Y+D'1'
0796  0E01      	MOVLW 0x01
0798  6E41      	MOVWF FCD_0f051__00096_arg_FCL_FONT
079A  6E42      	MOVWF FCD_0f051__00096_arg_FCL_T_00097
079C  EC95F003  	CALL FCD_0f051__00096


		// Calcul
		// Calcul:
		//  var = var + 1
		FCV_VAR = FCV_VAR + 1;
07A0  521F      	MOVF gbl_FCV_VAR, F
07A2  5220      	MOVF gbl_FCV_VAR+D'1', F
07A4  2A1F      	INCF gbl_FCV_VAR, F
07A6  B4D8      	BTFSC STATUS,Z
07A8  2A20      	INCF gbl_FCV_VAR+D'1', F



	}

	#if 0 // Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();

	#endif // #if 0: Disabled code
	#if 0 // Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_EnableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();

	#endif // #if 0: Disabled code
	#if 0 // Disabled code
	// Boucle
	// Boucle: While 1
	while (1)
	{

		#if 0 // Disabled code
		// Appel de la Routine Composant
		// Appel de la Routine Composant: X=gLCD_EB076_4D1::G4D_GetTouchCoordinatesPicaso()
		FCV_X = FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Boucle
		// Boucle: While X = 0
		while (FCV_X == 0)
		{


		}

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Appel de la Routine Composant
		// Appel de la Routine Composant: Y=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(Y)
		FCV_Y = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(FCV_Y);

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Sortie
		// Sortie: Y -> PORTD
		FCP_SET(F, D, 0xFF, 0, (FCV_Y));
		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
		FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Calcul
		// Calcul:
		//  X = 0
		//  Y = 0
		FCV_X = 0;
		FCV_Y = 0;

		#endif // #if 0: Disabled code

	}

	#endif // #if 0: Disabled code
	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

}
082C  CFEAF001  	MOVFF FSR0H,  Int1Context
0830  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
0834  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
0838  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
083C  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
0840  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
0844  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
0848  C001FFEA  	MOVFF Int1Context,  FSR0H
084C  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0242  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0244  0E7F      	MOVLW 0x7F
0246  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0248  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
024A  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
024C  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
024E  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0250  9A9D      	BCF gbl_pie1,5

			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0252  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
021C  6AAB      	CLRF gbl_rcsta

			txsta = 0;
021E  6AAC      	CLRF gbl_txsta

		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}
0220  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
016E            label8
016E  0E10      	MOVLW 0x10
0170  149E      	ANDWF gbl_pir1, W
0172  6E57      	MOVWF CompTempVar2640
0174  5257      	MOVF CompTempVar2640, F
0176  E0FB      	BZ	label8


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0178  5055      	MOVF FC_CAL_UAR_0007A_arg_nChar, W
017A  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
017C  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
017E  6856      	SETF FC_CAL_UAR_00079_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
0180  6A57      	CLRF FC_CAL_UAR_00079_1_delay1

	MX_UINT8 regcheck = 0;
0182  6A58      	CLRF FC_CAL_UAR_00079_1_regcheck

	MX_UINT8 bWaitForever = 0;
0184  6A59      	CLRF FC_CAL_UAR_00079_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
0186  6A5A      	CLRF FC_CAL_UAR_00079_1_rxStatus

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0188  6A5D      	CLRF FC_CAL_UAR_00079_1_dummy

  #endif

	if (nTimeout == 255)
018A  2855      	INCF FC_CAL_UAR_00079_arg_nTimeout, W
018C  E102      	BNZ	label9
0192            label9

		bWaitForever = 1;
018E  0E01      	MOVLW 0x01
0190  6E59      	MOVWF FC_CAL_UAR_00079_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
0192  525A      	MOVF FC_CAL_UAR_00079_1_rxStatus, F
0194  E124      	BNZ	label14
01DC  D7DA      	BRA	label9
01DE            label14

	{
		if (bWaitForever == 0)
0196  5259      	MOVF FC_CAL_UAR_00079_1_bWaitForever, F
0198  E118      	BNZ	label13

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
019A  5255      	MOVF FC_CAL_UAR_00079_arg_nTimeout, F
019C  E103      	BNZ	label10
01A4            label10

			{
				rxStatus = UART_STATUS_TIMEOUT;
019E  0E01      	MOVLW 0x01
01A0  6E5A      	MOVWF FC_CAL_UAR_00079_1_rxStatus

			}
			else
01A2  D013      	BRA	label13

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
01A4  6A5B      	CLRF FC_CAL_UAR_00079_1_delaycnt
01A6  6A5C      	CLRF FC_CAL_UAR_00079_1_delaycnt+D'1'
01A8            label11
01A8  0E31      	MOVLW 0x31
01AA  5C5B      	SUBWF FC_CAL_UAR_00079_1_delaycnt, W
01AC  E205      	BC	label12
01AE  665C      	TSTFSZ FC_CAL_UAR_00079_1_delaycnt+D'1'
01B0  D003      	BRA	label12
01B2  4A5B      	INFSNZ FC_CAL_UAR_00079_1_delaycnt, F
01B4  2A5C      	INCF FC_CAL_UAR_00079_1_delaycnt+D'1', F
01B6  D7F8      	BRA	label11
01B8            label12

				delay1 = delay1 + 1;
01B8  2857      	INCF FC_CAL_UAR_00079_1_delay1, W
01BA  6E57      	MOVWF FC_CAL_UAR_00079_1_delay1

				if(delay1 == 100)
01BC  0E64      	MOVLW 0x64
01BE  6257      	CPFSEQ FC_CAL_UAR_00079_1_delay1
01C0  D004      	BRA	label13
01CA            label13

				{
					nTimeout = nTimeout - 1;
01C2  0455      	DECF FC_CAL_UAR_00079_arg_nTimeout, W
01C4  6E55      	MOVWF FC_CAL_UAR_00079_arg_nTimeout

					MX_CLEAR_WATCHDOG;
01C6  0004      	CLRWDT

					delay1 = 0;
01C8  6A57      	CLRF FC_CAL_UAR_00079_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
01CA  0E20      	MOVLW 0x20
01CC  149E      	ANDWF gbl_pir1, W
01CE  6E5E      	MOVWF CompTempVar2637
01D0  505E      	MOVF CompTempVar2637, W
01D2  6E58      	MOVWF FC_CAL_UAR_00079_1_regcheck

			if (regcheck != 0)
01D4  5258      	MOVF FC_CAL_UAR_00079_1_regcheck, F
01D6  E0DD      	BZ	label9

				rxStatus = UART_STATUS_RXBYTE;
01D8  0E02      	MOVLW 0x02
01DA  6E5A      	MOVWF FC_CAL_UAR_00079_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
01DE  0E02      	MOVLW 0x02
01E0  625A      	CPFSEQ FC_CAL_UAR_00079_1_rxStatus
01E2  D018      	BRA	label17

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
01E4  0E04      	MOVLW 0x04
01E6  14AB      	ANDWF gbl_rcsta, W
01E8  6E5E      	MOVWF CompTempVar2638
01EA  505E      	MOVF CompTempVar2638, W
01EC  6E58      	MOVWF FC_CAL_UAR_00079_1_regcheck

			if (regcheck != 0)
01EE  5258      	MOVF FC_CAL_UAR_00079_1_regcheck, F
01F0  E003      	BZ	label15
01F8            label15

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
01F2  50AE      	MOVF gbl_rcreg, W
01F4  6E5D      	MOVWF FC_CAL_UAR_00079_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
01F6  D00E      	BRA	label17

			{
				regcheck = ts_bit(rcsta, OERR);
01F8  0E02      	MOVLW 0x02
01FA  14AB      	ANDWF gbl_rcsta, W
01FC  6E5E      	MOVWF CompTempVar2639
01FE  505E      	MOVF CompTempVar2639, W
0200  6E58      	MOVWF FC_CAL_UAR_00079_1_regcheck

				if (regcheck != 0)
0202  5258      	MOVF FC_CAL_UAR_00079_1_regcheck, F
0204  E003      	BZ	label16
020C            label16

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0206  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0208  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
020A  D004      	BRA	label17
0214            label17

				{
					retVal = 0;
020C  6A56      	CLRF FC_CAL_UAR_00079_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
020E  50AE      	MOVF gbl_rcreg, W
0210  1056      	IORWF FC_CAL_UAR_00079_1_retVal, W
0212  6E56      	MOVWF FC_CAL_UAR_00079_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0214  5056      	MOVF FC_CAL_UAR_00079_1_retVal, W
0216  6E5E      	MOVWF CompTempVarRet2636
0218  6A5F      	CLRF CompTempVarRet2636+D'1'

}
021A  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))

{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
0254  0E07      	MOVLW 0x07
0256  643F      	CPFSGT FC_CAL_UAR_00077_arg_new_baud
0258  D001      	BRA	label20
025C            label20

		return;

	if (new_baud == 0)
025C  523F      	MOVF FC_CAL_UAR_00077_arg_new_baud, F
025E  E104      	BNZ	label21
0268            label21

	{
		baudrate = MX_HARD_BAUD_1200;
0260  6840      	SETF FC_CAL_UAR_00077_1_baudrate

		baudmode = MX_HARD_SLOW_1200;
0262  0E01      	MOVLW 0x01
0264  6E41      	MOVWF FC_CAL_UAR_00077_1_baudmode

	}
	else if (new_baud == 1)
0266  D02F      	BRA	label28
0268  043F      	DECF FC_CAL_UAR_00077_arg_new_baud, W
026A  E105      	BNZ	label22
0276            label22

	{
		baudrate = MX_HARD_BAUD_2400;
026C  0E7F      	MOVLW 0x7F
026E  6E40      	MOVWF FC_CAL_UAR_00077_1_baudrate

		baudmode = MX_HARD_SLOW_2400;
0270  0E01      	MOVLW 0x01
0272  6E41      	MOVWF FC_CAL_UAR_00077_1_baudmode

	}
	else if (new_baud == 2)
0274  D028      	BRA	label28
0276  0E02      	MOVLW 0x02
0278  623F      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud
027A  D003      	BRA	label23
0282            label23

	{
		baudrate = MX_HARD_BAUD_4800;
027C  6840      	SETF FC_CAL_UAR_00077_1_baudrate

		baudmode = MX_HARD_SLOW_4800;
027E  6A41      	CLRF FC_CAL_UAR_00077_1_baudmode

	}
	else if (new_baud == 3)
0280  D022      	BRA	label28
0282  0E03      	MOVLW 0x03
0284  623F      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud
0286  D004      	BRA	label24
0290            label24

	{
		baudrate = MX_HARD_BAUD_9600;
0288  0E7F      	MOVLW 0x7F
028A  6E40      	MOVWF FC_CAL_UAR_00077_1_baudrate

		baudmode = MX_HARD_SLOW_9600;
028C  6A41      	CLRF FC_CAL_UAR_00077_1_baudmode

	}
	else if (new_baud == 4)
028E  D01B      	BRA	label28
0290  0E04      	MOVLW 0x04
0292  623F      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud
0294  D004      	BRA	label25
029E            label25

	{
		baudrate = MX_HARD_BAUD_19200;
0296  0E3F      	MOVLW 0x3F
0298  6E40      	MOVWF FC_CAL_UAR_00077_1_baudrate

		baudmode = MX_HARD_SLOW_19200;
029A  6A41      	CLRF FC_CAL_UAR_00077_1_baudmode

	}
	else if (new_baud == 5)
029C  D014      	BRA	label28
029E  0E05      	MOVLW 0x05
02A0  623F      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud
02A2  D004      	BRA	label26
02AC            label26

	{
		baudrate = MX_HARD_BAUD_38400;
02A4  0E1F      	MOVLW 0x1F
02A6  6E40      	MOVWF FC_CAL_UAR_00077_1_baudrate

		baudmode = MX_HARD_SLOW_38400;
02A8  6A41      	CLRF FC_CAL_UAR_00077_1_baudmode

	}
	else if (new_baud == 6)
02AA  D00D      	BRA	label28
02AC  0E06      	MOVLW 0x06
02AE  623F      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud
02B0  D004      	BRA	label27
02BA            label27

	{
		baudrate = MX_HARD_BAUD_57600;
02B2  0E14      	MOVLW 0x14
02B4  6E40      	MOVWF FC_CAL_UAR_00077_1_baudrate

		baudmode = MX_HARD_SLOW_57600;
02B6  6A41      	CLRF FC_CAL_UAR_00077_1_baudmode

	}
	else if (new_baud == 7)
02B8  D006      	BRA	label28
02BA  0E07      	MOVLW 0x07
02BC  623F      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud
02BE  D003      	BRA	label28
02C6            label28

	{
		baudrate = MX_HARD_BAUD_115200;
02C0  0E0A      	MOVLW 0x0A
02C2  6E40      	MOVWF FC_CAL_UAR_00077_1_baudrate

		baudmode = MX_HARD_SLOW_115200;
02C4  6A41      	CLRF FC_CAL_UAR_00077_1_baudmode

	}

	UART_Uninit();
02C6  EC0EF001  	CALL FC_CAL_UAR_00078


	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
02CA  0441      	DECF FC_CAL_UAR_00077_1_baudmode, W
02CC  E102      	BNZ	label29
02D2            label29

			cr_bit(txsta, BRGH);					//Low Speed
02CE  94AC      	BCF gbl_txsta,2

	    else
02D0  D001      	BRA	label30
02D4            label30

			st_bit(txsta, BRGH);					//High Speed
02D2  84AC      	BSF gbl_txsta,2


		spbrg = baudrate;   						// set the baud rate
02D4  5040      	MOVF FC_CAL_UAR_00077_1_baudrate, W
02D6  6EAF      	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
02D8  6AAB      	CLRF gbl_rcsta


		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
02DA  8EAB      	BSF gbl_rcsta,7

		st_bit(txsta, TXEN);
02DC  8AAC      	BSF gbl_txsta,5

		st_bit(rcsta, CREN);
02DE  88AB      	BSF gbl_rcsta,4


		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
02E0  9A9D      	BCF gbl_pie1,5

		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
025A  0012      	RETURN
02E2  0012      	RETURN


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EFD6F003  	GOTO	_startup

0008  EF16F004  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  5240      	MOVF delay_ms_00000_arg_del, F
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF5      	MOVLW 0xF5
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0FFF      	ADDLW 0xFF
0038  A4D8      	BTFSS STATUS,Z
003A  D7ED      	BRA	label2
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  2E40      	DECFSZ delay_ms_00000_arg_del, F
0058  D7DD      	BRA	label1
005A  0012      	RETURN
005C            ; } delay_ms function end

005C            delay_us_00000
005C            ; { delay_us ; function begin
005C            label3
005C  0000      	NOP
005E  0000      	NOP
0060  2E3F      	DECFSZ delay_us_00000_arg_del, F
0062  D7FC      	BRA	label3
0064  0012      	RETURN
0066            ; } delay_us function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6E40      	MOVWF delay_ms_00000_arg_del
006A  EC06F000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6E40      	MOVWF delay_ms_00000_arg_del
0072  EC06F000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6E40      	MOVWF delay_ms_00000_arg_del
007A  EC06F000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6E40      	MOVWF delay_ms_00000_arg_del
0082  EC06F000  	CALL delay_ms_00000
0086  2E3F      	DECFSZ delay_s_00000_arg_del, F
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end

008C            __mul_32_3_00016
008C            ; { __mul_32_32 ; function begin
008C  6A68      	CLRF CompTempVarRet414
008E  6A69      	CLRF CompTempVarRet414+D'1'
0090  6A6A      	CLRF CompTempVarRet414+D'2'
0092  6A6B      	CLRF CompTempVarRet414+D'3'
0094  6A6A      	CLRF CompTempVarRet414+D'2'
0096  6A6B      	CLRF CompTempVarRet414+D'3'
0098  505C      	MOVF __mul_32_3_00016_arg_a, W
009A  0260      	MULWF __mul_32_3_00016_arg_b
009C  50F3      	MOVF gbl_prodl, W
009E  6E68      	MOVWF CompTempVarRet414
00A0  50F4      	MOVF gbl_prodh, W
00A2  6E69      	MOVWF CompTempVarRet414+D'1'
00A4  505D      	MOVF __mul_32_3_00016_arg_a+D'1', W
00A6  0260      	MULWF __mul_32_3_00016_arg_b
00A8  50F3      	MOVF gbl_prodl, W
00AA  2669      	ADDWF CompTempVarRet414+D'1', F
00AC  50F4      	MOVF gbl_prodh, W
00AE  226A      	ADDWFC CompTempVarRet414+D'2', F
00B0  B0D8      	BTFSC gbl_status,0
00B2  2A6B      	INCF CompTempVarRet414+D'3', F
00B4  505E      	MOVF __mul_32_3_00016_arg_a+D'2', W
00B6  0260      	MULWF __mul_32_3_00016_arg_b
00B8  50F3      	MOVF gbl_prodl, W
00BA  266A      	ADDWF CompTempVarRet414+D'2', F
00BC  50F4      	MOVF gbl_prodh, W
00BE  226B      	ADDWFC CompTempVarRet414+D'3', F
00C0  505F      	MOVF __mul_32_3_00016_arg_a+D'3', W
00C2  0260      	MULWF __mul_32_3_00016_arg_b
00C4  50F3      	MOVF gbl_prodl, W
00C6  266B      	ADDWF CompTempVarRet414+D'3', F
00C8  505C      	MOVF __mul_32_3_00016_arg_a, W
00CA  0261      	MULWF __mul_32_3_00016_arg_b+D'1'
00CC  50F3      	MOVF gbl_prodl, W
00CE  2669      	ADDWF CompTempVarRet414+D'1', F
00D0  50F4      	MOVF gbl_prodh, W
00D2  226A      	ADDWFC CompTempVarRet414+D'2', F
00D4  B0D8      	BTFSC gbl_status,0
00D6  2A6B      	INCF CompTempVarRet414+D'3', F
00D8  505D      	MOVF __mul_32_3_00016_arg_a+D'1', W
00DA  0261      	MULWF __mul_32_3_00016_arg_b+D'1'
00DC  50F3      	MOVF gbl_prodl, W
00DE  266A      	ADDWF CompTempVarRet414+D'2', F
00E0  50F4      	MOVF gbl_prodh, W
00E2  226B      	ADDWFC CompTempVarRet414+D'3', F
00E4  505E      	MOVF __mul_32_3_00016_arg_a+D'2', W
00E6  0261      	MULWF __mul_32_3_00016_arg_b+D'1'
00E8  50F3      	MOVF gbl_prodl, W
00EA  266B      	ADDWF CompTempVarRet414+D'3', F
00EC  505C      	MOVF __mul_32_3_00016_arg_a, W
00EE  0262      	MULWF __mul_32_3_00016_arg_b+D'2'
00F0  50F3      	MOVF gbl_prodl, W
00F2  266A      	ADDWF CompTempVarRet414+D'2', F
00F4  50F4      	MOVF gbl_prodh, W
00F6  226B      	ADDWFC CompTempVarRet414+D'3', F
00F8  505D      	MOVF __mul_32_3_00016_arg_a+D'1', W
00FA  0262      	MULWF __mul_32_3_00016_arg_b+D'2'
00FC  50F3      	MOVF gbl_prodl, W
00FE  266B      	ADDWF CompTempVarRet414+D'3', F
0100  505C      	MOVF __mul_32_3_00016_arg_a, W
0102  0263      	MULWF __mul_32_3_00016_arg_b+D'3'
0104  50F3      	MOVF gbl_prodl, W
0106  266B      	ADDWF CompTempVarRet414+D'3', F
0108  0012      	RETURN
010A            ; } __mul_32_32 function end

010A            __div_32_3_00011
010A            ; { __div_32_32 ; function begin
010A  6A64      	CLRF __div_32_3_00011_1_r
010C  6A65      	CLRF __div_32_3_00011_1_r+D'1'
010E  6A66      	CLRF __div_32_3_00011_1_r+D'2'
0110  6A67      	CLRF __div_32_3_00011_1_r+D'3'
0112  6A6A      	CLRF CompTempVarRet172
0114  6A6B      	CLRF CompTempVarRet172+D'1'
0116  6A6C      	CLRF CompTempVarRet172+D'2'
0118  6A6D      	CLRF CompTempVarRet172+D'3'
011A  6A68      	CLRF __div_32_3_00011_1_i
011C            label5
011C  0E20      	MOVLW 0x20
011E  1468      	ANDWF __div_32_3_00011_1_i, W
0120  6E69      	MOVWF CompTempVar174
0122  6669      	TSTFSZ CompTempVar174
0124  0012      	RETURN
0126  90D8      	BCF STATUS,C
0128  366A      	RLCF CompTempVarRet172, F
012A  366B      	RLCF CompTempVarRet172+D'1', F
012C  366C      	RLCF CompTempVarRet172+D'2', F
012E  366D      	RLCF CompTempVarRet172+D'3', F
0130  365C      	RLCF __div_32_3_00011_arg_a, F
0132  365D      	RLCF __div_32_3_00011_arg_a+D'1', F
0134  365E      	RLCF __div_32_3_00011_arg_a+D'2', F
0136  365F      	RLCF __div_32_3_00011_arg_a+D'3', F
0138  3664      	RLCF __div_32_3_00011_1_r, F
013A  3665      	RLCF __div_32_3_00011_1_r+D'1', F
013C  3666      	RLCF __div_32_3_00011_1_r+D'2', F
013E  3667      	RLCF __div_32_3_00011_1_r+D'3', F
0140  5063      	MOVF __div_32_3_00011_arg_b+D'3', W
0142  5C67      	SUBWF __div_32_3_00011_1_r+D'3', W
0144  E108      	BNZ	label6
0146  5062      	MOVF __div_32_3_00011_arg_b+D'2', W
0148  5C66      	SUBWF __div_32_3_00011_1_r+D'2', W
014A  E105      	BNZ	label6
014C  5061      	MOVF __div_32_3_00011_arg_b+D'1', W
014E  5C65      	SUBWF __div_32_3_00011_1_r+D'1', W
0150  E102      	BNZ	label6
0152  5060      	MOVF __div_32_3_00011_arg_b, W
0154  5C64      	SUBWF __div_32_3_00011_1_r, W
0156            label6
0156  E309      	BNC	label7
0158  5060      	MOVF __div_32_3_00011_arg_b, W
015A  5E64      	SUBWF __div_32_3_00011_1_r, F
015C  5061      	MOVF __div_32_3_00011_arg_b+D'1', W
015E  5A65      	SUBWFB __div_32_3_00011_1_r+D'1', F
0160  5062      	MOVF __div_32_3_00011_arg_b+D'2', W
0162  5A66      	SUBWFB __div_32_3_00011_1_r+D'2', F
0164  5063      	MOVF __div_32_3_00011_arg_b+D'3', W
0166  5A67      	SUBWFB __div_32_3_00011_1_r+D'3', F
0168  806A      	BSF CompTempVarRet172,0
016A            label7
016A  2A68      	INCF __div_32_3_00011_1_i, F
016C  D7D7      	BRA	label5
016E            ; } __div_32_32 function end















































07AC            _startup
07AC  0ED5      	MOVLW 0xD5
07AE  6E05      	MOVWF gbl_14_LSR
07B0  0EC4      	MOVLW 0xC4
07B2  6E06      	MOVWF gbl_14_LSR+D'1'
07B4  0EBB      	MOVLW 0xBB
07B6  6E07      	MOVWF gbl_14_LSR+D'2'
07B8  0EDC      	MOVLW 0xDC
07BA  6E08      	MOVWF gbl_14_LSR+D'3'
07BC  6A09      	CLRF gbl_15_gbl_aSig
07BE  6A0A      	CLRF gbl_15_gbl_aSig+D'1'
07C0  6A0B      	CLRF gbl_15_gbl_aSig+D'2'
07C2  6A0C      	CLRF gbl_15_gbl_aSig+D'3'
07C4  6A0D      	CLRF gbl_15_gbl_bSig
07C6  6A0E      	CLRF gbl_15_gbl_bSig+D'1'
07C8  6A0F      	CLRF gbl_15_gbl_bSig+D'2'
07CA  6A10      	CLRF gbl_15_gbl_bSig+D'3'
07CC  6A11      	CLRF gbl_15_gbl_zSig
07CE  6A12      	CLRF gbl_15_gbl_zSig+D'1'
07D0  6A13      	CLRF gbl_15_gbl_zSig+D'2'
07D2  6A14      	CLRF gbl_15_gbl_zSig+D'3'
07D4  6A2C      	CLRF gbl_15_gbl_aExp
07D6  6A2D      	CLRF gbl_15_gbl_bExp
07D8  6A1D      	CLRF gbl_15_gbl_zExp
07DA  6A1E      	CLRF gbl_15_gbl_zExp+D'1'
07DC  6A2E      	CLRF gbl_15_gbl_aSign
07DE  6A2F      	CLRF gbl_15_gbl_bSign
07E0  6A30      	CLRF gbl_15_gbl_zSign
07E2  6A31      	CLRF gbl_15_gbl_zSigZero
07E4  6A15      	CLRF gbl_15_gbl_ret
07E6  6A16      	CLRF gbl_15_gbl_ret+D'1'
07E8  6A17      	CLRF gbl_15_gbl_ret+D'2'
07EA  6A18      	CLRF gbl_15_gbl_ret+D'3'
07EC  6A2A      	CLRF gbl_float_rounding_mode
07EE  6A2B      	CLRF gbl_float_exception_flags
07F0  6A29      	CLRF gbl_float_detect_tininess





0828  EFBDF003  	GOTO	main

300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  79FF      	DW 0x79FF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
