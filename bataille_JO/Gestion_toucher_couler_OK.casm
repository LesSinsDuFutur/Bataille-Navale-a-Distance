;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
0C20  51BE      	MOVF FC_CAL_Por_00042_arg_Tris+D'1', W, 1
0C22  6EEA      	MOVWF FSR0H
0C24  51BD      	MOVF FC_CAL_Por_00042_arg_Tris, W, 1
0C26  6EE9      	MOVWF FSR0L
0C28  51BF      	MOVF FC_CAL_Por_00042_arg_InMask, W, 1
0C2A  10EF      	IORWF INDF0, W
0C2C  6FC1      	MOVWF CompTempVar1825, 1
0C2E  51C1      	MOVF CompTempVar1825, W, 1
0C30  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
0C32  51BC      	MOVF FC_CAL_Por_00042_arg_Port+D'1', W, 1
0C34  6EEA      	MOVWF FSR0H
0C36  51BB      	MOVF FC_CAL_Por_00042_arg_Port, W, 1
0C38  6EE9      	MOVWF FSR0L
0C3A  51BF      	MOVF FC_CAL_Por_00042_arg_InMask, W, 1
0C3C  14EF      	ANDWF INDF0, W
0C3E  6FC1      	MOVWF CompTempVarRet1822, 1
0C40  51C0      	MOVF FC_CAL_Por_00042_arg_Shift, W, 1
0C42  6FC2      	MOVWF CompTempVar1827, 1
0C44            label56
0C44  B4D8      	BTFSC STATUS,Z
0C48  90D8      	BCF STATUS,C
0C4A  33C1      	RRCF CompTempVarRet1822, F, 1
0C4C  07C2      	DECF CompTempVar1827, F, 1
0C4E  D7FA      	BRA	label56

		}
0C46  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

// Delay by bytes
#define FCI_DELAYBYTE_S(count)     delay_s((count))
#define FCI_DELAYBYTE_MS(count)    delay_ms((count))
#define FCI_DELAYBYTE_US(count)    delay_us((count))
// With watchdog timer
#define FCI_DELAYBYTEWDT_S(count)  Wdt_Delay_S((count))
#define FCI_DELAYBYTEWDT_MS(count) Wdt_Delay_Ms((count))
#define FCI_DELAYBYTEWDT_US(count) delay_us((count))

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)
{
    char i;
    for (i=0; i<delay; i++)
    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
        delay_ms(1);
    }
}


void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)

{
  	while (Delay > 255)
1978            label136
1978  0EFF      	MOVLW 0xFF
197A  65B7      	CPFSGT FCI_DELAYI_00046_arg_Delay, 1
197C  67B8      	TSTFSZ FCI_DELAYI_00046_arg_Delay+D'1', 1
197E  D001      	BRA	label137
1980  D00C      	BRA	label138
1982            label137
1998  D7EF      	BRA	label136
199A            label138

  	{
	  	delay_ms(255);
1982  69BE      	SETF delay_ms_00000_arg_del, 1
1984  EC06F000  	CALL delay_ms_00000

	  	Delay = Delay - 255;
1988  0EFF      	MOVLW 0xFF
198A  5DB7      	SUBWF FCI_DELAYI_00046_arg_Delay, W, 1
198C  6FB9      	MOVWF CompTempVar1838, 1
198E  59B7      	SUBWFB FCI_DELAYI_00046_arg_Delay, W, 1
1990  08FF      	SUBLW 0xFF
1992  5FB8      	SUBWF FCI_DELAYI_00046_arg_Delay+D'1', F, 1
1994  51B9      	MOVF CompTempVar1838, W, 1
1996  6FB7      	MOVWF FCI_DELAYI_00046_arg_Delay, 1

  	}
  	if (Delay > 0)
199A  0E00      	MOVLW 0x00
199C  65B7      	CPFSGT FCI_DELAYI_00046_arg_Delay, 1
199E  67B8      	TSTFSZ FCI_DELAYI_00046_arg_Delay+D'1', 1
19A0  D001      	BRA	label139
19A4            label139

  		delay_ms(Delay & 0xFF);
19A4  51B7      	MOVF FCI_DELAYI_00046_arg_Delay, W, 1
19A6  6FBE      	MOVWF delay_ms_00000_arg_del, 1
19A8  EC06F000  	CALL delay_ms_00000

}
19A2  0012      	RETURN
19AC  0012      	RETURN


void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
0150  0101      	MOVLB 0x01
0152  6B02      	CLRF FCI_GETLEN_0004B_1_tmp, 1
0154            label15
0154  0100      	MOVLB 0x00
0156  51FF      	MOVF FCI_GETLEN_0004B_arg_iStr1_len, W, 1
0158  0101      	MOVLB 0x01
015A  6102      	CPFSLT FCI_GETLEN_0004B_1_tmp, 1
015C  D009      	BRA	label16
015E  5101      	MOVF FCI_GETLEN_0004B_arg_sStr1+D'1', W, 1
0160  6EEA      	MOVWF FSR0H
0162  5100      	MOVF FCI_GETLEN_0004B_arg_sStr1, W, 1
0164  2502      	ADDWF FCI_GETLEN_0004B_1_tmp, W, 1
0166  6EE9      	MOVWF FSR0L
0168  52EF      	MOVF INDF0, F
016A  E002      	BZ	label16
016C  2B02      	INCF FCI_GETLEN_0004B_1_tmp, F, 1
016E  D7F2      	BRA	label15
0170            label16

	return (tmp);
0170  5102      	MOVF FCI_GETLEN_0004B_1_tmp, W, 1
0172  6F03      	MOVWF CompTempVarRet1850, 1

}
0174  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	if (iDst_len == 0) return sDst;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (sDst);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BatailleNavale\Gestion_toucher_couler_OK.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Tuesday, March 21, 2017 16:19:52
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x79
#endif
#ifdef HI_TECH_C
__CONFIG(0x79);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_TABLEAU 101
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_CROISEUR = (0x0);
1CAA  6BA3      	CLRF gbl_FCV_CROISEUR, 1

MX_GLOBAL MX_UINT8 FCV_TORPILLEUR = (0x0);
1CAC  6BA4      	CLRF gbl_FCV_TORPILLEUR, 1

MX_GLOBAL MX_UINT16 FCV_Y_LIGNE = (0x18);
1CAE  0E18      	MOVLW 0x18
1CB0  6F84      	MOVWF gbl_FCV_Y_LIGNE, 1
1CB2  6B85      	CLRF gbl_FCV_Y_LIGNE+D'1', 1

MX_GLOBAL MX_UINT8 FCV_NUM_CASE = (0x0);
1CB4  6BA5      	CLRF gbl_FCV_NUM_CASE, 1

MX_GLOBAL MX_UINT16 FCV_X_SORTIE = (0x0);
1CB6  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1CB8  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

MX_GLOBAL MX_UINT16 FCV_Y_TOUCH = (0x0);
1CBA  6B88      	CLRF gbl_FCV_Y_TOUCH, 1
1CBC  6B89      	CLRF gbl_FCV_Y_TOUCH+D'1', 1

MX_GLOBAL MX_UINT8 FCV_HITBOX = (0x1);
1CBE  0E01      	MOVLW 0x01
1CC0  6FA6      	MOVWF gbl_FCV_HITBOX, 1

MX_GLOBAL MX_UINT16 FCV_X_LIGNE = (0x18);
1CC2  0E18      	MOVLW 0x18
1CC4  6F8A      	MOVWF gbl_FCV_X_LIGNE, 1
1CC6  6B8B      	CLRF gbl_FCV_X_LIGNE+D'1', 1

MX_GLOBAL MX_UINT16 FCV_Y = (0x18);
1CC8  0E18      	MOVLW 0x18
1CCA  6F8C      	MOVWF gbl_FCV_Y, 1
1CCC  6B8D      	CLRF gbl_FCV_Y+D'1', 1

MX_GLOBAL MX_UINT16 FCV_X = (0x18);
1CCE  0E18      	MOVLW 0x18
1CD0  6F8E      	MOVWF gbl_FCV_X, 1
1CD2  6B8F      	CLRF gbl_FCV_X+D'1', 1

MX_GLOBAL MX_UINT8 FCV_SOUS_MARIN = (0x0);
1CD4  6BA7      	CLRF gbl_FCV_SOUS_MARIN, 1

MX_GLOBAL MX_UINT16 FCV_X_TOUCH = (0x0);
1CD6  6B90      	CLRF gbl_FCV_X_TOUCH, 1
1CD8  6B91      	CLRF gbl_FCV_X_TOUCH+D'1', 1

MX_GLOBAL MX_UINT8 FCV_APPUI_ECRAN = (0x0);
1CDA  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

MX_GLOBAL MX_UINT8 FCV_HITBOX_2 = (0x0);
1CDC  6BA9      	CLRF gbl_FCV_HITBOX_2, 1

MX_GLOBAL MX_UINT8 FCV_BATEAU = (0x0);
1CDE  6BAA      	CLRF gbl_FCV_BATEAU, 1

MX_GLOBAL MX_UINT8 FCV_PORTE_AVION = (0x0);
1CE0  6BAB      	CLRF gbl_FCV_PORTE_AVION, 1

MX_GLOBAL MX_UINT8 FCV_JOUEUR1 = (0x0);
1CE2  6BAC      	CLRF gbl_FCV_JOUEUR1, 1

MX_GLOBAL MX_CHAR FCV_TABLEAU[FCVsz_TABLEAU];
MX_GLOBAL MX_UINT8 FCV_CONTRE_TORPILLEUR = (0x0);
1CE4  6BAD      	CLRF gbl_FCV_CONTRE_TORPILLEUR, 1


void FCM_Touche_Coule_TORP();
void FCM_Hitbox_v2();
void FCM_Touche_coule_PA();
void FCM_Lecture_Coordonnes();
void FCM_Croiseur();
void FCM_Torpilleur();
void FCM_Touche_Coule_SM();
void FCM_Initialisation();
void FCM_Message_bateau();
void FCM_Toucher_Couler();
void FCM_Reinitialisation_tactile();
void FCM_Choix_Bateau_Toucher();
void FCM_Choix_Bateaux();
void FCM_affichage_bateau();
void FCM_Sous_marin();
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2, MX_UINT8 FCL_ROUGE, MX_UINT8 FCL_VERT, MX_UINT8 FCL_BLEU);
void FCM_Reinitialisation_texte();
void FCM_Appui_tactile();
void FCM_Manque();
void FCM_Recuperation_coordonees();
void FCM_phase_debut();
void FCM_Fin_Jeu();
void FCM_Touche_Coule_CT();
void FCM_affichage_bateau_touche();
void FCM_Porte_avion();
void FCM_Touche_coule_CR();
void FCM_Phase_jeu();
void FCM_lignes();
void FCM_Contre_torpilleur();

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 porta
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 porta
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisa
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisa
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (2)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
1CE6  0E00      	MOVLW 0x00
1CE8  6FAE      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000, 1

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
1CEA  0E01      	MOVLW 0x01
1CEC  6FAF      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001, 1

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
1CEE  0E02      	MOVLW 0x02
1CF0  6FB0      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002, 1

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
1CF2  0E03      	MOVLW 0x03
1CF4  6FB1      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003, 1

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
1CF6  0E04      	MOVLW 0x04
1CF8  6FB2      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004, 1

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
1CFA  0E05      	MOVLW 0x05
1CFC  6FB3      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005, 1

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
1CFE  0E06      	MOVLW 0x06
1D00  6FB4      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006, 1

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
1D02  0E07      	MOVLW 0x07
1D04  6FB5      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007, 1

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
1D06  6B80      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009, 1
1D08  6B81      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1', 1
1D0A  6B82      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2', 1
1D0C  6B83      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3', 1

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
1D0E  6BB6      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B, 1


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x63);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)

{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;
0636  6BBF      	CLRF FCD_0f051__00068_1_FCR_RETVAL, 1
0638  6BC0      	CLRF FCD_0f051__00068_1_FCR_RETVAL+D'1', 1


	if (FCL_AXIS == 0)
063A  53BE      	MOVF FCD_0f051__00068_arg_FCL_AXIS, F, 1
063C  E007      	BZ	label28

	{

	} else {

		if (FCL_AXIS == 'x')
063E  0E78      	MOVLW 0x78
0640  63BE      	CPFSEQ FCD_0f051__00068_arg_FCL_AXIS, 1
0642  D001      	BRA	label27
0646            label27

		{

		} else {
0644  D003      	BRA	label28


			if (FCL_AXIS == 'X')
0646  0E58      	MOVLW 0x58
0648  63BE      	CPFSEQ FCD_0f051__00068_arg_FCL_AXIS, 1
064A  D004      	BRA	label29
064C            label28

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;
064C  5198      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W, 1
064E  6FBF      	MOVWF FCD_0f051__00068_1_FCR_RETVAL, 1
0650  5199      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', W, 1
0652  6FC0      	MOVWF FCD_0f051__00068_1_FCR_RETVAL+D'1', 1


FCC_G4D_ReadTouchCoordinatesPicaso_A:
0654            label29

;

	if (FCL_AXIS == 1)
0654  05BE      	DECF FCD_0f051__00068_arg_FCL_AXIS, W, 1
0656  E007      	BZ	label31

	{

	} else {

		if (FCL_AXIS == 'y')
0658  0E79      	MOVLW 0x79
065A  63BE      	CPFSEQ FCD_0f051__00068_arg_FCL_AXIS, 1
065C  D001      	BRA	label30
0660            label30

		{

		} else {
065E  D003      	BRA	label31


			if (FCL_AXIS == 'Y')
0660  0E59      	MOVLW 0x59
0662  63BE      	CPFSEQ FCD_0f051__00068_arg_FCL_AXIS, 1
0664  D004      	BRA	label32
0666            label31

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;
0666  5196      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W, 1
0668  6FBF      	MOVWF FCD_0f051__00068_1_FCR_RETVAL, 1
066A  5197      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', W, 1
066C  6FC0      	MOVWF FCD_0f051__00068_1_FCR_RETVAL+D'1', 1


FCC_G4D_ReadTouchCoordinatesPicaso_B:
066E            label32

;

	return (FCR_RETVAL);
066E  51BF      	MOVF FCD_0f051__00068_1_FCR_RETVAL, W, 1
0670  6FC1      	MOVWF CompTempVarRet2714, 1
0672  51C0      	MOVF FCD_0f051__00068_1_FCR_RETVAL+D'1', W, 1
0674  6FC2      	MOVWF CompTempVarRet2714+D'1', 1


}
0676  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x6F);
0418  0E6F      	MOVLW 0x6F
041A  0101      	MOVLB 0x01
041C  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
041E  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0420  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(4);
0424  0E04      	MOVLW 0x04
0426  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0428  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
042A  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Receive_1(255);
042E  0100      	MOVLB 0x00
0430  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
0432  EC50F000  	CALL FC_CAL_UAR_00088


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0436  0100      	MOVLB 0x00
0438  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
043A  EC50F000  	CALL FC_CAL_UAR_00088
043E  5108      	MOVF CompTempVarRet2890, W, 1
0440  0100      	MOVLB 0x00
0442  6FBF      	MOVWF FCD_0f051__00080_1_FCR_RETVAL, 1


	FC_CAL_UART_Receive_1(255);
0444  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
0446  EC50F000  	CALL FC_CAL_UAR_00088


	FC_CAL_UART_Receive_1(255);
044A  0100      	MOVLB 0x00
044C  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
044E  EC50F000  	CALL FC_CAL_UAR_00088


	if (FCR_RETVAL)
0452  0100      	MOVLB 0x00
0454  53BF      	MOVF FCD_0f051__00080_1_FCR_RETVAL, F, 1
0456  E03C      	BZ	label20
04D0            label20

	{

		FC_CAL_UART_Send_1(0x6F);
0458  0E6F      	MOVLW 0x6F
045A  0101      	MOVLB 0x01
045C  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
045E  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0460  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(5);
0464  0E05      	MOVLW 0x05
0466  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0468  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
046A  EC46F000  	CALL FC_CAL_UAR_00089


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_1(255);
046E  0100      	MOVLB 0x00
0470  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
0472  EC50F000  	CALL FC_CAL_UAR_00088
0476  5108      	MOVF CompTempVarRet2890, W, 1
0478  0100      	MOVLB 0x00
047A  6F98      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F, 1
047C  0101      	MOVLB 0x01
047E  5109      	MOVF CompTempVarRet2890+D'1', W, 1
0480  0100      	MOVLB 0x00
0482  6F99      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', 1


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
0484  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
0486  EC50F000  	CALL FC_CAL_UAR_00088
048A  5108      	MOVF CompTempVarRet2890, W, 1
048C  0100      	MOVLB 0x00
048E  6FBE      	MOVWF FCD_0f051__00080_1_FCL_TEMP, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
0490  6BC0      	CLRF CompTempVar2869, 1
0492  5198      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W, 1
0494  6F99      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', 1
0496  51C0      	MOVF CompTempVar2869, W, 1
0498  6F98      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F, 1

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;
049A  51BE      	MOVF FCD_0f051__00080_1_FCL_TEMP, W, 1
049C  1398      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000F, F, 1
049E  5399      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', F, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_1(255);
04A0  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
04A2  EC50F000  	CALL FC_CAL_UAR_00088
04A6  5108      	MOVF CompTempVarRet2890, W, 1
04A8  0100      	MOVLB 0x00
04AA  6F96      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E, 1
04AC  0101      	MOVLB 0x01
04AE  5109      	MOVF CompTempVarRet2890+D'1', W, 1
04B0  0100      	MOVLB 0x00
04B2  6F97      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', 1


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
04B4  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
04B6  EC50F000  	CALL FC_CAL_UAR_00088
04BA  5108      	MOVF CompTempVarRet2890, W, 1
04BC  0100      	MOVLB 0x00
04BE  6FBE      	MOVWF FCD_0f051__00080_1_FCL_TEMP, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
04C0  6BC0      	CLRF CompTempVar2873, 1
04C2  5196      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W, 1
04C4  6F97      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', 1
04C6  51C0      	MOVF CompTempVar2873, W, 1
04C8  6F96      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E, 1

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;
04CA  51BE      	MOVF FCD_0f051__00080_1_FCL_TEMP, W, 1
04CC  1396      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000E, F, 1
04CE  5397      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', F, 1


	// } else {

	}

	return (FCR_RETVAL);
04D0  51BF      	MOVF FCD_0f051__00080_1_FCR_RETVAL, W, 1
04D2  6FC0      	MOVWF CompTempVarRet2868, 1


}
04D4  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_1(FCL_RADIUS);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
13F6  6BC0      	CLRF FCD_0f051__00084_1_FCL_D1, 1
13F8  6BC1      	CLRF FCD_0f051__00084_1_FCL_D1+D'1', 1

	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
13FA  0E01      	MOVLW 0x01
13FC  6FC2      	MOVWF FCD_0f051__00084_1_FCL_YINC, 1
13FE  6BC3      	CLRF FCD_0f051__00084_1_FCL_YINC+D'1', 1

	MX_SINT16 FCL_XINC = (1);
1400  0E01      	MOVLW 0x01
1402  6FC4      	MOVWF FCD_0f051__00084_1_FCL_XINC, 1
1404  6BC5      	CLRF FCD_0f051__00084_1_FCL_XINC+D'1', 1



	FC_CAL_UART_Send_1(0x4C);
1406  0E4C      	MOVLW 0x4C
1408  0101      	MOVLB 0x01
140A  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
140C  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
140E  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
1412  0100      	MOVLB 0x00
1414  51B9      	MOVF FCD_0f051__00084_arg_FCL_X1+D'1', W, 1
1416  0101      	MOVLB 0x01
1418  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
141A  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
141C  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X1);
1420  0100      	MOVLB 0x00
1422  51B8      	MOVF FCD_0f051__00084_arg_FCL_X1, W, 1
1424  0101      	MOVLB 0x01
1426  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
1428  0100      	MOVLB 0x00
142A  51B9      	MOVF FCD_0f051__00084_arg_FCL_X1+D'1', W, 1
142C  0101      	MOVLB 0x01
142E  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
1430  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
1434  0100      	MOVLB 0x00
1436  51BB      	MOVF FCD_0f051__00084_arg_FCL_Y1+D'1', W, 1
1438  0101      	MOVLB 0x01
143A  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
143C  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
143E  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y1);
1442  0100      	MOVLB 0x00
1444  51BA      	MOVF FCD_0f051__00084_arg_FCL_Y1, W, 1
1446  0101      	MOVLB 0x01
1448  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
144A  0100      	MOVLB 0x00
144C  51BB      	MOVF FCD_0f051__00084_arg_FCL_Y1+D'1', W, 1
144E  0101      	MOVLB 0x01
1450  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
1452  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
1456  0100      	MOVLB 0x00
1458  51BD      	MOVF FCD_0f051__00084_arg_FCL_X2+D'1', W, 1
145A  0101      	MOVLB 0x01
145C  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
145E  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
1460  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X2);
1464  0100      	MOVLB 0x00
1466  51BC      	MOVF FCD_0f051__00084_arg_FCL_X2, W, 1
1468  0101      	MOVLB 0x01
146A  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
146C  0100      	MOVLB 0x00
146E  51BD      	MOVF FCD_0f051__00084_arg_FCL_X2+D'1', W, 1
1470  0101      	MOVLB 0x01
1472  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
1474  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
1478  0100      	MOVLB 0x00
147A  51BF      	MOVF FCD_0f051__00084_arg_FCL_Y2+D'1', W, 1
147C  0101      	MOVLB 0x01
147E  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
1480  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
1482  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y2);
1486  0100      	MOVLB 0x00
1488  51BE      	MOVF FCD_0f051__00084_arg_FCL_Y2, W, 1
148A  0101      	MOVLB 0x01
148C  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
148E  0100      	MOVLB 0x00
1490  51BF      	MOVF FCD_0f051__00084_arg_FCL_Y2+D'1', W, 1
1492  0101      	MOVLB 0x01
1494  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
1496  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
149A  0100      	MOVLB 0x00
149C  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
149E  0101      	MOVLB 0x01
14A0  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
14A2  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
14A4  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
14A8  0100      	MOVLB 0x00
14AA  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
14AC  0101      	MOVLB 0x01
14AE  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
14B0  0100      	MOVLB 0x00
14B2  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
14B4  0101      	MOVLB 0x01
14B6  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
14B8  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Receive_1(255);
14BC  0100      	MOVLB 0x00
14BE  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
14C0  EC50F000  	CALL FC_CAL_UAR_00088


}
14C4  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_POSH >> 8);

	FC_CAL_UART_Send_1(FCL_POSH);

	FC_CAL_UART_Send_1(FCL_POSL >> 8);

	FC_CAL_UART_Send_1(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
0542  0E59      	MOVLW 0x59
0544  0101      	MOVLB 0x01
0546  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0548  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
054A  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(0x05);
054E  0E05      	MOVLW 0x05
0550  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0552  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0554  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(0x01);
0558  0E01      	MOVLW 0x01
055A  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
055C  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
055E  EC46F000  	CALL FC_CAL_UAR_00089


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0562  0100      	MOVLB 0x00
0564  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
0566  EC50F000  	CALL FC_CAL_UAR_00088
056A  5108      	MOVF CompTempVarRet2890, W, 1
056C  0100      	MOVLB 0x00
056E  6FBE      	MOVWF FCD_0f051__00076_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
0570  0E06      	MOVLW 0x06
0572  63BE      	CPFSEQ FCD_0f051__00076_1_FCR_RETVAL, 1
0574  D002      	BRA	label23
057A            label23

	{

		FCR_RETVAL = 0;
0576  6BBE      	CLRF FCD_0f051__00076_1_FCR_RETVAL, 1


	} else {
0578  D001      	BRA	label24
057C            label24


		FCR_RETVAL = 255;
057A  69BE      	SETF FCD_0f051__00076_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
057C  51BE      	MOVF FCD_0f051__00076_1_FCR_RETVAL, W, 1
057E  6FBF      	MOVWF CompTempVarRet2832, 1


}
0580  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x00);

	FC_CAL_UART_Send_1(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x01);

	FC_CAL_UART_Send_1(FCL_DISPLAY);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x02);

	FC_CAL_UART_Send_1(FCL_CONTRAST);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
04D6  0E59      	MOVLW 0x59
04D8  0101      	MOVLB 0x01
04DA  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
04DC  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
04DE  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(0x05);
04E2  0E05      	MOVLW 0x05
04E4  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
04E6  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
04E8  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(0x00);
04EC  6B00      	CLRF FC_CAL_UAR_00089_arg_nChar, 1
04EE  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
04F0  EC46F000  	CALL FC_CAL_UAR_00089


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
04F4  0100      	MOVLB 0x00
04F6  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
04F8  EC50F000  	CALL FC_CAL_UAR_00088
04FC  5108      	MOVF CompTempVarRet2890, W, 1
04FE  0100      	MOVLB 0x00
0500  6FBE      	MOVWF FCD_0f051__00077_1_FCR_RETVAL, 1


	FC_CAL_UART_Send_1(0x59);
0502  0E59      	MOVLW 0x59
0504  0101      	MOVLB 0x01
0506  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0508  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
050A  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(0x05);
050E  0E05      	MOVLW 0x05
0510  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0512  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0514  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(0x02);
0518  0E02      	MOVLW 0x02
051A  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
051C  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
051E  EC46F000  	CALL FC_CAL_UAR_00089


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0522  0100      	MOVLB 0x00
0524  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
0526  EC50F000  	CALL FC_CAL_UAR_00088
052A  5108      	MOVF CompTempVarRet2890, W, 1
052C  0100      	MOVLB 0x00
052E  6FBE      	MOVWF FCD_0f051__00077_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
0530  0E06      	MOVLW 0x06
0532  63BE      	CPFSEQ FCD_0f051__00077_1_FCR_RETVAL, 1
0534  D002      	BRA	label21
053A            label21

	{

		FCR_RETVAL = 0;
0536  6BBE      	CLRF FCD_0f051__00077_1_FCR_RETVAL, 1


	} else {
0538  D001      	BRA	label22
053C            label22


		FCR_RETVAL = 255;
053A  69BE      	SETF FCD_0f051__00077_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
053C  51BE      	MOVF FCD_0f051__00077_1_FCR_RETVAL, W, 1
053E  6FBF      	MOVWF CompTempVarRet2833, 1


}
0540  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x56);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_1(0x10);

	} else {

		FC_CAL_UART_Send_1(0x08);

	}

	FC_CAL_UART_Send_1(FCL_DELAY);

	FC_CAL_UART_Send_1(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_1(FCL_FRAMES);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x76);

	FC_CAL_UART_Send_1(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_1(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_1(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_1(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_1(0x03);

		}
	}

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x65);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RX >> 8);

	FC_CAL_UART_Send_1(FCL_RX);

	FC_CAL_UART_Send_1(FCL_RY >> 8);

	FC_CAL_UART_Send_1(FCL_RY);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);
0678  6BFE      	CLRF FCD_0f051__0005D_1_FCL_IDX, 1



	FC_CAL_UART_Send_1(0x4F);
067A  0E4F      	MOVLW 0x4F
067C  0101      	MOVLB 0x01
067E  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0680  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0682  EC46F000  	CALL FC_CAL_UAR_00089


	if (FCL_TRANSPARENT)
0686  0100      	MOVLB 0x00
0688  53FC      	MOVF FCD_0f051__0005D_arg_FCL_T_0005E, F, 1
068A  E006      	BZ	label33
0698            label33

	{

		FC_CAL_UART_Send_1(0x00);
068C  0101      	MOVLB 0x01
068E  6B00      	CLRF FC_CAL_UAR_00089_arg_nChar, 1
0690  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0692  EC46F000  	CALL FC_CAL_UAR_00089


	} else {
0696  D006      	BRA	label34
06A4            label34


		FC_CAL_UART_Send_1(0x01);
0698  0E01      	MOVLW 0x01
069A  0101      	MOVLB 0x01
069C  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
069E  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
06A0  EC46F000  	CALL FC_CAL_UAR_00089


	}

	FC_CAL_UART_Receive_1(255);
06A4  0100      	MOVLB 0x00
06A6  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
06A8  EC50F000  	CALL FC_CAL_UAR_00088


	FC_CAL_UART_Send_1(0x53);
06AC  0E53      	MOVLW 0x53
06AE  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
06B0  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
06B2  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
06B6  0100      	MOVLB 0x00
06B8  51F8      	MOVF FCD_0f051__0005D_arg_FCL_X1+D'1', W, 1
06BA  0101      	MOVLB 0x01
06BC  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
06BE  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
06C0  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X1);
06C4  0100      	MOVLB 0x00
06C6  51F7      	MOVF FCD_0f051__0005D_arg_FCL_X1, W, 1
06C8  0101      	MOVLB 0x01
06CA  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
06CC  0100      	MOVLB 0x00
06CE  51F8      	MOVF FCD_0f051__0005D_arg_FCL_X1+D'1', W, 1
06D0  0101      	MOVLB 0x01
06D2  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
06D4  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
06D8  0100      	MOVLB 0x00
06DA  51FA      	MOVF FCD_0f051__0005D_arg_FCL_Y1+D'1', W, 1
06DC  0101      	MOVLB 0x01
06DE  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
06E0  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
06E2  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y1);
06E6  0100      	MOVLB 0x00
06E8  51F9      	MOVF FCD_0f051__0005D_arg_FCL_Y1, W, 1
06EA  0101      	MOVLB 0x01
06EC  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
06EE  0100      	MOVLB 0x00
06F0  51FA      	MOVF FCD_0f051__0005D_arg_FCL_Y1+D'1', W, 1
06F2  0101      	MOVLB 0x01
06F4  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
06F6  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_FONT);
06FA  0100      	MOVLB 0x00
06FC  51FB      	MOVF FCD_0f051__0005D_arg_FCL_FONT, W, 1
06FE  0101      	MOVLB 0x01
0700  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0702  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0704  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
0708  0100      	MOVLB 0x00
070A  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
070C  0101      	MOVLB 0x01
070E  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0710  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0712  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0716  0100      	MOVLB 0x00
0718  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
071A  0101      	MOVLB 0x01
071C  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
071E  0100      	MOVLB 0x00
0720  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0722  0101      	MOVLB 0x01
0724  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0726  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(1);
072A  0E01      	MOVLW 0x01
072C  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
072E  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0730  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(1);
0734  0E01      	MOVLW 0x01
0736  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0738  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
073A  EC46F000  	CALL FC_CAL_UAR_00089


	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);
073E  0100      	MOVLB 0x00
0740  51BE      	MOVF FCD_0f051__0005D_arg_FCL_STR, W, 1
0742  0101      	MOVLB 0x01
0744  6F00      	MOVWF FCI_GETLEN_0004B_arg_sStr1, 1
0746  0100      	MOVLB 0x00
0748  51BF      	MOVF FCD_0f051__0005D_arg_FCL_STR+D'1', W, 1
074A  0101      	MOVLB 0x01
074C  6F01      	MOVWF FCI_GETLEN_0004B_arg_sStr1+D'1', 1
074E  0100      	MOVLB 0x00
0750  51F5      	MOVF FCD_0f051__0005D_arg_FCLsz_STR, W, 1
0752  6FFF      	MOVWF FCI_GETLEN_0004B_arg_iStr1_len, 1
0754  ECA8F000  	CALL FCI_GETLEN_0004B
0758  5103      	MOVF CompTempVarRet1850, W, 1
075A  0100      	MOVLB 0x00
075C  6FFD      	MOVWF FCD_0f051__0005D_1_FCL_LEN_STR, 1


	while (FCL_IDX < FCL_LEN_STR)
075E            label35
075E  51FD      	MOVF FCD_0f051__0005D_1_FCL_LEN_STR, W, 1
0760  61FE      	CPFSLT FCD_0f051__0005D_1_FCL_IDX, 1
0762  D016      	BRA	label36
078E  D7E7      	BRA	label35
0790            label36

	{

		if (FCL_STR[FCL_IDX] == 0)
0764  51BF      	MOVF FCD_0f051__0005D_arg_FCL_STR+D'1', W, 1
0766  6EEA      	MOVWF FSR0H
0768  51BE      	MOVF FCD_0f051__0005D_arg_FCL_STR, W, 1
076A  25FE      	ADDWF FCD_0f051__0005D_1_FCL_IDX, W, 1
076C  6EE9      	MOVWF FSR0L
076E  52EF      	MOVF INDF0, F
0770  E00F      	BZ	label36

		{

			goto FCC_Print_A;


		// } else {

		}

		FC_CAL_UART_Send_1(FCL_STR[FCL_IDX]);
0772  51BF      	MOVF FCD_0f051__0005D_arg_FCL_STR+D'1', W, 1
0774  6EEA      	MOVWF FSR0H
0776  51BE      	MOVF FCD_0f051__0005D_arg_FCL_STR, W, 1
0778  25FE      	ADDWF FCD_0f051__0005D_1_FCL_IDX, W, 1
077A  6EE9      	MOVWF FSR0L
077C  50EF      	MOVF INDF0, W
077E  0101      	MOVLB 0x01
0780  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0782  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0784  EC46F000  	CALL FC_CAL_UAR_00089


		FCL_IDX = FCL_IDX + 1;
0788  0100      	MOVLB 0x00
078A  29FE      	INCF FCD_0f051__0005D_1_FCL_IDX, W, 1
078C  6FFE      	MOVWF FCD_0f051__0005D_1_FCL_IDX, 1



	}

FCC_Print_A:
;

	FC_CAL_UART_Send_1(0);
0790  0101      	MOVLB 0x01
0792  6B00      	CLRF FC_CAL_UAR_00089_arg_nChar, 1
0794  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0796  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Receive_1(255);
079A  0100      	MOVLB 0x00
079C  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
079E  EC50F000  	CALL FC_CAL_UAR_00088


}
07A2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x0c);

	FC_CAL_UART_Send_1(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
14C6  0100      	MOVLB 0x00
14C8  6BBB      	CLRF FCD_0f051__0006D_1_FCL_Y, 1
14CA  6BBC      	CLRF FCD_0f051__0006D_1_FCL_Y+D'1', 1

	MX_UINT16 FCL_X = (0x0);
14CC  6BBD      	CLRF FCD_0f051__0006D_1_FCL_X, 1
14CE  6BBE      	CLRF FCD_0f051__0006D_1_FCL_X+D'1', 1



	FC_CAL_UART_Send_1(0x42);
14D0  0E42      	MOVLW 0x42
14D2  0101      	MOVLB 0x01
14D4  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
14D6  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
14D8  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
14DC  0100      	MOVLB 0x00
14DE  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
14E0  0101      	MOVLB 0x01
14E2  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
14E4  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
14E6  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
14EA  0100      	MOVLB 0x00
14EC  5192      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W, 1
14EE  0101      	MOVLB 0x01
14F0  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
14F2  0100      	MOVLB 0x00
14F4  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
14F6  0101      	MOVLB 0x01
14F8  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
14FA  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Receive_1(255);
14FE  0100      	MOVLB 0x00
1500  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
1502  EC50F000  	CALL FC_CAL_UAR_00088


	FC_CAL_UART_Send_1(0x45);
1506  0E45      	MOVLW 0x45
1508  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
150A  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
150C  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Receive_1(255);
1510  0100      	MOVLB 0x00
1512  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
1514  EC50F000  	CALL FC_CAL_UAR_00088


}
1518  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x49);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)

{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
0346  33C9      	RRCF FCD_0f051__0007A_arg_FCL_RED, F, 1
0348  33C9      	RRCF FCD_0f051__0007A_arg_FCL_RED, F, 1
034A  33C9      	RRCF FCD_0f051__0007A_arg_FCL_RED, F, 1
034C  0E1F      	MOVLW 0x1F
034E  17C9      	ANDWF FCD_0f051__0007A_arg_FCL_RED, F, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
0350  33CA      	RRCF FCD_0f051__0007A_arg_FCL_GREEN, F, 1
0352  33CA      	RRCF FCD_0f051__0007A_arg_FCL_GREEN, F, 1
0354  0E3F      	MOVLW 0x3F
0356  17CA      	ANDWF FCD_0f051__0007A_arg_FCL_GREEN, F, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0358  33CB      	RRCF FCD_0f051__0007A_arg_FCL_BLUE, F, 1
035A  33CB      	RRCF FCD_0f051__0007A_arg_FCL_BLUE, F, 1
035C  33CB      	RRCF FCD_0f051__0007A_arg_FCL_BLUE, F, 1
035E  0E1F      	MOVLW 0x1F
0360  17CB      	ANDWF FCD_0f051__0007A_arg_FCL_BLUE, F, 1


	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
0362  51CA      	MOVF FCD_0f051__0007A_arg_FCL_GREEN, W, 1
0364  6FCC      	MOVWF CompTempVar2837, 1
0366  6B95      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', 1
0368  37CC      	RLCF CompTempVar2837, F, 1
036A  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
036C  37CC      	RLCF CompTempVar2837, F, 1
036E  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0370  37CC      	RLCF CompTempVar2837, F, 1
0372  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0374  37CC      	RLCF CompTempVar2837, F, 1
0376  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0378  37CC      	RLCF CompTempVar2837, F, 1
037A  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
037C  0EE0      	MOVLW 0xE0
037E  17CC      	ANDWF CompTempVar2837, F, 1
0380  51CC      	MOVF CompTempVar2837, W, 1
0382  11CB      	IORWF FCD_0f051__0007A_arg_FCL_BLUE, W, 1
0384  6F94      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
0386  6BCC      	CLRF CompTempVar2841, 1
0388  51C9      	MOVF FCD_0f051__0007A_arg_FCL_RED, W, 1
038A  6FCD      	MOVWF CompTempVar2842, 1
038C  90D8      	BCF STATUS,C
038E  37CD      	RLCF CompTempVar2842, F, 1
0390  90D8      	BCF STATUS,C
0392  37CD      	RLCF CompTempVar2842, F, 1
0394  90D8      	BCF STATUS,C
0396  37CD      	RLCF CompTempVar2842, F, 1
0398  51CC      	MOVF CompTempVar2841, W, 1
039A  1394      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F, 1
039C  51CD      	MOVF CompTempVar2842, W, 1
039E  1395      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1


}
03A0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x75);
0582  0E75      	MOVLW 0x75
0584  0101      	MOVLB 0x01
0586  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0588  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
058A  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
058E  0100      	MOVLB 0x00
0590  51BF      	MOVF FCD_0f051__0006E_arg_FCL_X1+D'1', W, 1
0592  0101      	MOVLB 0x01
0594  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0596  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0598  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X1);
059C  0100      	MOVLB 0x00
059E  51BE      	MOVF FCD_0f051__0006E_arg_FCL_X1, W, 1
05A0  0101      	MOVLB 0x01
05A2  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
05A4  0100      	MOVLB 0x00
05A6  51BF      	MOVF FCD_0f051__0006E_arg_FCL_X1+D'1', W, 1
05A8  0101      	MOVLB 0x01
05AA  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
05AC  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
05B0  0100      	MOVLB 0x00
05B2  51C1      	MOVF FCD_0f051__0006E_arg_FCL_Y1+D'1', W, 1
05B4  0101      	MOVLB 0x01
05B6  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
05B8  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
05BA  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y1);
05BE  0100      	MOVLB 0x00
05C0  51C0      	MOVF FCD_0f051__0006E_arg_FCL_Y1, W, 1
05C2  0101      	MOVLB 0x01
05C4  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
05C6  0100      	MOVLB 0x00
05C8  51C1      	MOVF FCD_0f051__0006E_arg_FCL_Y1+D'1', W, 1
05CA  0101      	MOVLB 0x01
05CC  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
05CE  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
05D2  0100      	MOVLB 0x00
05D4  51C3      	MOVF FCD_0f051__0006E_arg_FCL_X2+D'1', W, 1
05D6  0101      	MOVLB 0x01
05D8  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
05DA  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
05DC  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X2);
05E0  0100      	MOVLB 0x00
05E2  51C2      	MOVF FCD_0f051__0006E_arg_FCL_X2, W, 1
05E4  0101      	MOVLB 0x01
05E6  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
05E8  0100      	MOVLB 0x00
05EA  51C3      	MOVF FCD_0f051__0006E_arg_FCL_X2+D'1', W, 1
05EC  0101      	MOVLB 0x01
05EE  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
05F0  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
05F4  0100      	MOVLB 0x00
05F6  51C5      	MOVF FCD_0f051__0006E_arg_FCL_Y2+D'1', W, 1
05F8  0101      	MOVLB 0x01
05FA  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
05FC  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
05FE  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y2);
0602  0100      	MOVLB 0x00
0604  51C4      	MOVF FCD_0f051__0006E_arg_FCL_Y2, W, 1
0606  0101      	MOVLB 0x01
0608  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
060A  0100      	MOVLB 0x00
060C  51C5      	MOVF FCD_0f051__0006E_arg_FCL_Y2+D'1', W, 1
060E  0101      	MOVLB 0x01
0610  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0612  EC46F000  	CALL FC_CAL_UAR_00089


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0616  0100      	MOVLB 0x00
0618  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
061A  EC50F000  	CALL FC_CAL_UAR_00088
061E  5108      	MOVF CompTempVarRet2890, W, 1
0620  0100      	MOVLB 0x00
0622  6FC6      	MOVWF FCD_0f051__0006E_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
0624  0E06      	MOVLW 0x06
0626  63C6      	CPFSEQ FCD_0f051__0006E_1_FCR_RETVAL, 1
0628  D002      	BRA	label25
062E            label25

	{

		FCR_RETVAL = 0;
062A  6BC6      	CLRF FCD_0f051__0006E_1_FCR_RETVAL, 1


	} else {
062C  D001      	BRA	label26
0630            label26


		FCR_RETVAL = 255;
062E  69C6      	SETF FCD_0f051__0006E_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
0630  51C6      	MOVF FCD_0f051__0006E_1_FCR_RETVAL, W, 1
0632  6FC7      	MOVWF CompTempVarRet2765, 1


}
0634  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6C);

	FC_CAL_UART_Send_1(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)

{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
0176  53D1      	MOVF FCD_0f051__0007B_arg_FCL_T_0007C, F, 1
0178  E16E      	BNZ	label17
017A  53D2      	MOVF FCD_0f051__0007B_arg_FCL_SOLID, F, 1
017C  E16C      	BNZ	label17
0256            label17

	{

		FC_CAL_UART_Send_1(0x70);
017E  0E70      	MOVLW 0x70
0180  0101      	MOVLB 0x01
0182  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0184  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0186  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(0x00);
018A  6B00      	CLRF FC_CAL_UAR_00089_arg_nChar, 1
018C  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
018E  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Receive_1(255);
0192  0100      	MOVLB 0x00
0194  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
0196  EC50F000  	CALL FC_CAL_UAR_00088


		FC_CAL_UART_Send_1(0x72);
019A  0E72      	MOVLW 0x72
019C  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
019E  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
01A0  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(FCL_X1 >> 8);
01A4  0100      	MOVLB 0x00
01A6  51CA      	MOVF FCD_0f051__0007B_arg_FCL_X1+D'1', W, 1
01A8  0101      	MOVLB 0x01
01AA  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
01AC  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
01AE  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(FCL_X1);
01B2  0100      	MOVLB 0x00
01B4  51C9      	MOVF FCD_0f051__0007B_arg_FCL_X1, W, 1
01B6  0101      	MOVLB 0x01
01B8  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
01BA  0100      	MOVLB 0x00
01BC  51CA      	MOVF FCD_0f051__0007B_arg_FCL_X1+D'1', W, 1
01BE  0101      	MOVLB 0x01
01C0  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
01C2  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(FCL_Y1 >> 8);
01C6  0100      	MOVLB 0x00
01C8  51CC      	MOVF FCD_0f051__0007B_arg_FCL_Y1+D'1', W, 1
01CA  0101      	MOVLB 0x01
01CC  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
01CE  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
01D0  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(FCL_Y1);
01D4  0100      	MOVLB 0x00
01D6  51CB      	MOVF FCD_0f051__0007B_arg_FCL_Y1, W, 1
01D8  0101      	MOVLB 0x01
01DA  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
01DC  0100      	MOVLB 0x00
01DE  51CC      	MOVF FCD_0f051__0007B_arg_FCL_Y1+D'1', W, 1
01E0  0101      	MOVLB 0x01
01E2  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
01E4  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(FCL_X2 >> 8);
01E8  0100      	MOVLB 0x00
01EA  51CE      	MOVF FCD_0f051__0007B_arg_FCL_X2+D'1', W, 1
01EC  0101      	MOVLB 0x01
01EE  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
01F0  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
01F2  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(FCL_X2);
01F6  0100      	MOVLB 0x00
01F8  51CD      	MOVF FCD_0f051__0007B_arg_FCL_X2, W, 1
01FA  0101      	MOVLB 0x01
01FC  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
01FE  0100      	MOVLB 0x00
0200  51CE      	MOVF FCD_0f051__0007B_arg_FCL_X2+D'1', W, 1
0202  0101      	MOVLB 0x01
0204  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0206  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(FCL_Y2 >> 8);
020A  0100      	MOVLB 0x00
020C  51D0      	MOVF FCD_0f051__0007B_arg_FCL_Y2+D'1', W, 1
020E  0101      	MOVLB 0x01
0210  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0212  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0214  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(FCL_Y2);
0218  0100      	MOVLB 0x00
021A  51CF      	MOVF FCD_0f051__0007B_arg_FCL_Y2, W, 1
021C  0101      	MOVLB 0x01
021E  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0220  0100      	MOVLB 0x00
0222  51D0      	MOVF FCD_0f051__0007B_arg_FCL_Y2+D'1', W, 1
0224  0101      	MOVLB 0x01
0226  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0228  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
022C  0100      	MOVLB 0x00
022E  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
0230  0101      	MOVLB 0x01
0232  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0234  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0236  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
023A  0100      	MOVLB 0x00
023C  5192      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W, 1
023E  0101      	MOVLB 0x01
0240  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0242  0100      	MOVLB 0x00
0244  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
0246  0101      	MOVLB 0x01
0248  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
024A  EC46F000  	CALL FC_CAL_UAR_00089


		FC_CAL_UART_Receive_1(255);
024E  0100      	MOVLB 0x00
0250  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
0252  EC50F000  	CALL FC_CAL_UAR_00088


	// } else {

	}

	FC_CAL_UART_Send_1(0x70);
0256  0E70      	MOVLW 0x70
0258  0101      	MOVLB 0x01
025A  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
025C  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
025E  EC46F000  	CALL FC_CAL_UAR_00089


	if (FCL_SOLID)
0262  0100      	MOVLB 0x00
0264  53D2      	MOVF FCD_0f051__0007B_arg_FCL_SOLID, F, 1
0266  E006      	BZ	label18
0274            label18

	{

		FC_CAL_UART_Send_1(0x00);
0268  0101      	MOVLB 0x01
026A  6B00      	CLRF FC_CAL_UAR_00089_arg_nChar, 1
026C  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
026E  EC46F000  	CALL FC_CAL_UAR_00089


	} else {
0272  D006      	BRA	label19
0280            label19


		FC_CAL_UART_Send_1(0x01);
0274  0E01      	MOVLW 0x01
0276  0101      	MOVLB 0x01
0278  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
027A  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
027C  EC46F000  	CALL FC_CAL_UAR_00089


	}

	FC_CAL_UART_Receive_1(255);
0280  0100      	MOVLB 0x00
0282  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
0284  EC50F000  	CALL FC_CAL_UAR_00088


	FC_CAL_UART_Send_1(0x72);
0288  0E72      	MOVLW 0x72
028A  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
028C  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
028E  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0292  0100      	MOVLB 0x00
0294  51CA      	MOVF FCD_0f051__0007B_arg_FCL_X1+D'1', W, 1
0296  0101      	MOVLB 0x01
0298  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
029A  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
029C  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X1);
02A0  0100      	MOVLB 0x00
02A2  51C9      	MOVF FCD_0f051__0007B_arg_FCL_X1, W, 1
02A4  0101      	MOVLB 0x01
02A6  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
02A8  0100      	MOVLB 0x00
02AA  51CA      	MOVF FCD_0f051__0007B_arg_FCL_X1+D'1', W, 1
02AC  0101      	MOVLB 0x01
02AE  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
02B0  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
02B4  0100      	MOVLB 0x00
02B6  51CC      	MOVF FCD_0f051__0007B_arg_FCL_Y1+D'1', W, 1
02B8  0101      	MOVLB 0x01
02BA  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
02BC  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
02BE  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y1);
02C2  0100      	MOVLB 0x00
02C4  51CB      	MOVF FCD_0f051__0007B_arg_FCL_Y1, W, 1
02C6  0101      	MOVLB 0x01
02C8  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
02CA  0100      	MOVLB 0x00
02CC  51CC      	MOVF FCD_0f051__0007B_arg_FCL_Y1+D'1', W, 1
02CE  0101      	MOVLB 0x01
02D0  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
02D2  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
02D6  0100      	MOVLB 0x00
02D8  51CE      	MOVF FCD_0f051__0007B_arg_FCL_X2+D'1', W, 1
02DA  0101      	MOVLB 0x01
02DC  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
02DE  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
02E0  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_X2);
02E4  0100      	MOVLB 0x00
02E6  51CD      	MOVF FCD_0f051__0007B_arg_FCL_X2, W, 1
02E8  0101      	MOVLB 0x01
02EA  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
02EC  0100      	MOVLB 0x00
02EE  51CE      	MOVF FCD_0f051__0007B_arg_FCL_X2+D'1', W, 1
02F0  0101      	MOVLB 0x01
02F2  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
02F4  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
02F8  0100      	MOVLB 0x00
02FA  51D0      	MOVF FCD_0f051__0007B_arg_FCL_Y2+D'1', W, 1
02FC  0101      	MOVLB 0x01
02FE  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0300  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0302  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCL_Y2);
0306  0100      	MOVLB 0x00
0308  51CF      	MOVF FCD_0f051__0007B_arg_FCL_Y2, W, 1
030A  0101      	MOVLB 0x01
030C  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
030E  0100      	MOVLB 0x00
0310  51D0      	MOVF FCD_0f051__0007B_arg_FCL_Y2+D'1', W, 1
0312  0101      	MOVLB 0x01
0314  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0316  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
031A  0100      	MOVLB 0x00
031C  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
031E  0101      	MOVLB 0x01
0320  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0322  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0324  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0328  0100      	MOVLB 0x00
032A  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
032C  0101      	MOVLB 0x01
032E  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
0330  0100      	MOVLB 0x00
0332  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0334  0101      	MOVLB 0x01
0336  6F01      	MOVWF FC_CAL_UAR_00089_arg_nChar+D'1', 1
0338  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Receive_1(255);
033C  0100      	MOVLB 0x00
033E  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
0340  EC50F000  	CALL FC_CAL_UAR_00088


}
0344  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, C, 0x20, 0x5, 0);
19AE  0100      	MOVLB 0x00
19B0  6BBB      	CLRF FCD_0f051__0006C_2_ptmp, 1
19B2  9A94      	BCF gbl_trisc,5
19B4  53BB      	MOVF FCD_0f051__0006C_2_ptmp, F, 1
19B6  E004      	BZ	label140
19B8  0E20      	MOVLW 0x20
19BA  108B      	IORWF gbl_latc, W
19BC  6E82      	MOVWF gbl_portc
19BE  D003      	BRA	label141
19C0            label140
19C0  0EDF      	MOVLW 0xDF
19C2  148B      	ANDWF gbl_latc, W
19C4  6E82      	MOVWF gbl_portc
19C6            label141


	FC_CAL_UART_Init_1();
19C6  ECBFF005  	CALL FC_CAL_UAR_0008A


	FCI_DELAYBYTE_US(100);
19CA  0E64      	MOVLW 0x64
19CC  6FBB      	MOVWF delay_us_00000_arg_del, 1
19CE  EC2EF000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, C, 0x20, 0x5);
19D2  0E0F      	MOVLW HIGH(gbl_portc+D'0')
19D4  6FBC      	MOVWF FC_CAL_Por_00042_arg_Port+D'1', 1
19D6  0E82      	MOVLW LOW(gbl_portc+D'0')
19D8  6FBB      	MOVWF FC_CAL_Por_00042_arg_Port, 1
19DA  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
19DC  6FBE      	MOVWF FC_CAL_Por_00042_arg_Tris+D'1', 1
19DE  0E94      	MOVLW LOW(gbl_trisc+D'0')
19E0  6FBD      	MOVWF FC_CAL_Por_00042_arg_Tris, 1
19E2  0E20      	MOVLW 0x20
19E4  6FBF      	MOVWF FC_CAL_Por_00042_arg_InMask, 1
19E6  0E05      	MOVLW 0x05
19E8  6FC0      	MOVWF FC_CAL_Por_00042_arg_Shift, 1
19EA  EC10F006  	CALL FC_CAL_Por_00042
19EE  51C1      	MOVF CompTempVarRet1822, W, 1
19F0  6FBA      	MOVWF FCD_0f051__0006C_1_FCL_DUMMY, 1


	FCI_DELAYBYTE_S(3);
19F2  0E03      	MOVLW 0x03
19F4  6FBB      	MOVWF delay_s_00000_arg_del, 1
19F6  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_1(0);
19FA  6BFF      	CLRF FC_CAL_UAR_00088_arg_nTimeout, 1
19FC  EC50F000  	CALL FC_CAL_UAR_00088


	FC_CAL_UART_Receive_1(0);
1A00  0100      	MOVLB 0x00
1A02  6BFF      	CLRF FC_CAL_UAR_00088_arg_nTimeout, 1
1A04  EC50F000  	CALL FC_CAL_UAR_00088


	FC_CAL_UART_Receive_1(0);
1A08  0100      	MOVLB 0x00
1A0A  6BFF      	CLRF FC_CAL_UAR_00088_arg_nTimeout, 1
1A0C  EC50F000  	CALL FC_CAL_UAR_00088


	FC_CAL_UART_Send_1(0x55);
1A10  0E55      	MOVLW 0x55
1A12  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
1A14  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
1A16  EC46F000  	CALL FC_CAL_UAR_00089


	FC_CAL_UART_Receive_1(255);
1A1A  0100      	MOVLB 0x00
1A1C  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
1A1E  EC50F000  	CALL FC_CAL_UAR_00088


	#if (1) // 1 == 1

		#if (1) // 1 != 0

			FC_CAL_UART_Send_1(0x51);
1A22  0E51      	MOVLW 0x51
1A24  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
1A26  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
1A28  EC46F000  	CALL FC_CAL_UAR_00089


			FC_CAL_UART_Send_1(0x0C);
1A2C  0E0C      	MOVLW 0x0C
1A2E  6F00      	MOVWF FC_CAL_UAR_00089_arg_nChar, 1
1A30  6B01      	CLRF FC_CAL_UAR_00089_arg_nChar+D'1', 1
1A32  EC46F000  	CALL FC_CAL_UAR_00089


			FC_CAL_UART_Receive_1(255);
1A36  0100      	MOVLB 0x00
1A38  69FF      	SETF FC_CAL_UAR_00088_arg_nTimeout, 1
1A3A  EC50F000  	CALL FC_CAL_UAR_00088


			FC_CAL_UART_UpdateBaud_1(6);
1A3E  0E06      	MOVLW 0x06
1A40  0100      	MOVLB 0x00
1A42  6FBB      	MOVWF FC_CAL_UAR_00086_arg_new_baud, 1
1A44  ECC8F005  	CALL FC_CAL_UAR_00086



		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_1(10);
1A48  0E0A      	MOVLW 0x0A
1A4A  6FFF      	MOVWF FC_CAL_UAR_00088_arg_nTimeout, 1
1A4C  EC50F000  	CALL FC_CAL_UAR_00088


	FC_CAL_UART_Receive_1(10);
1A50  0E0A      	MOVLW 0x0A
1A52  0100      	MOVLB 0x00
1A54  6FFF      	MOVWF FC_CAL_UAR_00088_arg_nTimeout, 1
1A56  EC50F000  	CALL FC_CAL_UAR_00088


	FCL_RED = 0 & 0xFF;
1A5A  0100      	MOVLB 0x00
1A5C  6BB7      	CLRF FCD_0f051__0006C_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
1A5E  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
1A60  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
1A62  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
1A64  0E1F      	MOVLW 0x1F
1A66  17B7      	ANDWF FCD_0f051__0006C_1_FCL_RED, F, 1

	FCL_GREEN = (0 >> 8) & 0xFF;
1A68  6BB8      	CLRF FCD_0f051__0006C_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
1A6A  33B8      	RRCF FCD_0f051__0006C_1_FCL_GREEN, F, 1
1A6C  33B8      	RRCF FCD_0f051__0006C_1_FCL_GREEN, F, 1
1A6E  0E3F      	MOVLW 0x3F
1A70  17B8      	ANDWF FCD_0f051__0006C_1_FCL_GREEN, F, 1

	FCL_BLUE = (0 >> 16) & 0xFF;
1A72  6BB9      	CLRF FCD_0f051__0006C_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
1A74  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
1A76  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
1A78  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
1A7A  0E1F      	MOVLW 0x1F
1A7C  17B9      	ANDWF FCD_0f051__0006C_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
1A7E  51B8      	MOVF FCD_0f051__0006C_1_FCL_GREEN, W, 1
1A80  6FBB      	MOVWF CompTempVar2738, 1
1A82  6B95      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', 1
1A84  37BB      	RLCF CompTempVar2738, F, 1
1A86  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
1A88  37BB      	RLCF CompTempVar2738, F, 1
1A8A  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
1A8C  37BB      	RLCF CompTempVar2738, F, 1
1A8E  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
1A90  37BB      	RLCF CompTempVar2738, F, 1
1A92  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
1A94  37BB      	RLCF CompTempVar2738, F, 1
1A96  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
1A98  0EE0      	MOVLW 0xE0
1A9A  17BB      	ANDWF CompTempVar2738, F, 1
1A9C  51BB      	MOVF CompTempVar2738, W, 1
1A9E  11B9      	IORWF FCD_0f051__0006C_1_FCL_BLUE, W, 1
1AA0  6F94      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
1AA2  6BBB      	CLRF CompTempVar2742, 1
1AA4  51B7      	MOVF FCD_0f051__0006C_1_FCL_RED, W, 1
1AA6  6FBC      	MOVWF CompTempVar2743, 1
1AA8  90D8      	BCF STATUS,C
1AAA  37BC      	RLCF CompTempVar2743, F, 1
1AAC  90D8      	BCF STATUS,C
1AAE  37BC      	RLCF CompTempVar2743, F, 1
1AB0  90D8      	BCF STATUS,C
1AB2  37BC      	RLCF CompTempVar2743, F, 1
1AB4  51BB      	MOVF CompTempVar2742, W, 1
1AB6  1394      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F, 1
1AB8  51BC      	MOVF CompTempVar2743, W, 1
1ABA  1395      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1

	FCL_RED = 16777215 & 0xFF;
1ABC  69B7      	SETF FCD_0f051__0006C_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
1ABE  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
1AC0  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
1AC2  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
1AC4  0E1F      	MOVLW 0x1F
1AC6  17B7      	ANDWF FCD_0f051__0006C_1_FCL_RED, F, 1

	FCL_GREEN = (16777215 >> 8) & 0xFF;
1AC8  69B8      	SETF FCD_0f051__0006C_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
1ACA  33B8      	RRCF FCD_0f051__0006C_1_FCL_GREEN, F, 1
1ACC  33B8      	RRCF FCD_0f051__0006C_1_FCL_GREEN, F, 1
1ACE  0E3F      	MOVLW 0x3F
1AD0  17B8      	ANDWF FCD_0f051__0006C_1_FCL_GREEN, F, 1

	FCL_BLUE = (16777215 >> 16) & 0xFF;
1AD2  69B9      	SETF FCD_0f051__0006C_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
1AD4  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
1AD6  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
1AD8  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
1ADA  0E1F      	MOVLW 0x1F
1ADC  17B9      	ANDWF FCD_0f051__0006C_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
1ADE  51B8      	MOVF FCD_0f051__0006C_1_FCL_GREEN, W, 1
1AE0  6FBB      	MOVWF CompTempVar2749, 1
1AE2  6B93      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', 1
1AE4  37BB      	RLCF CompTempVar2749, F, 1
1AE6  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
1AE8  37BB      	RLCF CompTempVar2749, F, 1
1AEA  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
1AEC  37BB      	RLCF CompTempVar2749, F, 1
1AEE  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
1AF0  37BB      	RLCF CompTempVar2749, F, 1
1AF2  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
1AF4  37BB      	RLCF CompTempVar2749, F, 1
1AF6  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
1AF8  0EE0      	MOVLW 0xE0
1AFA  17BB      	ANDWF CompTempVar2749, F, 1
1AFC  51BB      	MOVF CompTempVar2749, W, 1
1AFE  11B9      	IORWF FCD_0f051__0006C_1_FCL_BLUE, W, 1
1B00  6F92      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
1B02  6BBB      	CLRF CompTempVar2753, 1
1B04  51B7      	MOVF FCD_0f051__0006C_1_FCL_RED, W, 1
1B06  6FBC      	MOVWF CompTempVar2754, 1
1B08  90D8      	BCF STATUS,C
1B0A  37BC      	RLCF CompTempVar2754, F, 1
1B0C  90D8      	BCF STATUS,C
1B0E  37BC      	RLCF CompTempVar2754, F, 1
1B10  90D8      	BCF STATUS,C
1B12  37BC      	RLCF CompTempVar2754, F, 1
1B14  51BB      	MOVF CompTempVar2753, W, 1
1B16  1392      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F, 1
1B18  51BC      	MOVF CompTempVar2754, W, 1
1B1A  1393      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
1B1C  EC63F00A  	CALL FCD_0f051__0006D


	FC_CAL_UART_Receive_1(10);
1B20  0E0A      	MOVLW 0x0A
1B22  0100      	MOVLB 0x00
1B24  6FFF      	MOVWF FC_CAL_UAR_00088_arg_nTimeout, 1
1B26  EC50F000  	CALL FC_CAL_UAR_00088


	FC_CAL_UART_Receive_1(10);
1B2A  0E0A      	MOVLW 0x0A
1B2C  0100      	MOVLB 0x00
1B2E  6FFF      	MOVWF FC_CAL_UAR_00088_arg_nTimeout, 1
1B30  EC50F000  	CALL FC_CAL_UAR_00088


}
1B34  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_Coule_TORP()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0F1E  0100      	MOVLB 0x00
0F20  518E      	MOVF gbl_FCV_X, W, 1
0F22  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
0F24  518F      	MOVF gbl_FCV_X+D'1', W, 1
0F26  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
0F28  0E18      	MOVLW 0x18
0F2A  5D8E      	SUBWF gbl_FCV_X, W, 1
0F2C  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
0F2E  598E      	SUBWFB gbl_FCV_X, W, 1
0F30  0818      	SUBLW 0x18
0F32  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0F34  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
0F36  518C      	MOVF gbl_FCV_Y, W, 1
0F38  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
0F3A  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0F3C  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
0F3E  0E18      	MOVLW 0x18
0F40  5D8C      	SUBWF gbl_FCV_Y, W, 1
0F42  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
0F44  598C      	SUBWFB gbl_FCV_Y, W, 1
0F46  0818      	SUBLW 0x18
0F48  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0F4A  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
0F4C  69C6      	SETF FCM_parame_0005C_arg_FCL_ROUGE, 1
0F4E  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
0F50  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
0F52  ECD1F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0F56  0E20      	MOVLW 0x20
0F58  0100      	MOVLB 0x00
0F5A  6FC0      	MOVWF CompTempVar2637, 1
0F5C  6FC1      	MOVWF CompTempVar2637+D'1', 1
0F5E  6FC2      	MOVWF CompTempVar2637+D'2', 1
0F60  6FC3      	MOVWF CompTempVar2637+D'3', 1
0F62  6FC4      	MOVWF CompTempVar2637+D'4', 1
0F64  6FC5      	MOVWF CompTempVar2637+D'5', 1
0F66  6FC6      	MOVWF CompTempVar2637+D'6', 1
0F68  6FC7      	MOVWF CompTempVar2637+D'7', 1
0F6A  6FC8      	MOVWF CompTempVar2637+D'8', 1
0F6C  6FC9      	MOVWF CompTempVar2637+D'9', 1
0F6E  6FCA      	MOVWF CompTempVar2637+D'10', 1
0F70  6FCB      	MOVWF CompTempVar2637+D'11', 1
0F72  6FD2      	MOVWF CompTempVar2637+D'18', 1
0F74  6FD3      	MOVWF CompTempVar2637+D'19', 1
0F76  6FD4      	MOVWF CompTempVar2637+D'20', 1
0F78  0E54      	MOVLW 0x54
0F7A  6FCC      	MOVWF CompTempVar2637+D'12', 1
0F7C  0E63      	MOVLW 0x63
0F7E  6FCF      	MOVWF CompTempVar2637+D'15', 1
0F80  0E65      	MOVLW 0x65
0F82  6FD1      	MOVWF CompTempVar2637+D'17', 1
0F84  0E68      	MOVLW 0x68
0F86  6FD0      	MOVWF CompTempVar2637+D'16', 1
0F88  0E6F      	MOVLW 0x6F
0F8A  6FCD      	MOVWF CompTempVar2637+D'13', 1
0F8C  0E75      	MOVLW 0x75
0F8E  6FCE      	MOVWF CompTempVar2637+D'14', 1
0F90  6BD5      	CLRF CompTempVar2637+D'21', 1
0F92  0E00      	MOVLW HIGH(CompTempVar2637+D'0')
0F94  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0F96  0EC0      	MOVLW LOW(CompTempVar2637+D'0')
0F98  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0F9A  0E16      	MOVLW 0x16
0F9C  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0F9E  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0FA0  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0FA2  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0FA4  0EF1      	MOVLW 0xF1
0FA6  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0FA8  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0FAA  0E02      	MOVLW 0x02
0FAC  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0FAE  0E01      	MOVLW 0x01
0FB0  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0FB2  EC3CF003  	CALL FCD_0f051__0005D


	// Calcul
	// Calcul:
	//  Tableau[hitbox] = tableau[hitbox] || 0b00000011
	//  Torpilleur = Torpilleur - 1
	FCV_TABLEAU[FCV_HITBOX] = FCV_TABLEAU[FCV_HITBOX] || 3;
0FB6  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0FBA  50E9      	MOVF FSR0L, W
0FBC  0100      	MOVLB 0x00
0FBE  51A6      	MOVF gbl_FCV_HITBOX, W, 1
0FC0  26E9      	ADDWF FSR0L, F
0FC2  6BB8      	CLRF CompTempVar2641, 1
0FC4  2BB8      	INCF CompTempVar2641, F, 1
0FC6  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0FC8  6EE9      	MOVWF FSR0L
0FCA  51A6      	MOVF gbl_FCV_HITBOX, W, 1
0FCC  26E9      	ADDWF FSR0L, F
0FCE  51B8      	MOVF CompTempVar2641, W, 1
0FD0  6EEF      	MOVWF INDF0

	FCV_TORPILLEUR = FCV_TORPILLEUR - 1;
0FD2  05A4      	DECF gbl_FCV_TORPILLEUR, W, 1
0FD4  6FA4      	MOVWF gbl_FCV_TORPILLEUR, 1


}
0FD6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Hitbox_v2()

{

	// Boucle
	// Boucle: While Appui_Ecran = 0
	while (1)
18C4            label123

	{

		// Boucle
		// Boucle: While Porte_avion = 5
		while (!(FCV_PORTE_AVION == 5))
18C4  0100      	MOVLB 0x00
18C6  6BB8      	CLRF CompTempVar2654, 1
18C8  0E05      	MOVLW 0x05
18CA  63AB      	CPFSEQ gbl_FCV_PORTE_AVION, 1
18CC  D001      	BRA	label124
18CE  2BB8      	INCF CompTempVar2654, F, 1
18D0            label124
18D0  67B8      	TSTFSZ CompTempVar2654, 1
18D2  D008      	BRA	label125
18E2  D7F0      	BRA	label123
18E4            label125

		{

			// Décision
			// Décision: Porte_avion < 5?
			if (FCV_PORTE_AVION < 5)
18D4  0E05      	MOVLW 0x05
18D6  61AB      	CPFSLT gbl_FCV_PORTE_AVION, 1
18D8  D7F5      	BRA	label123

			{

				// Appel d'une Macro
				// Appel d'une Macro: Choix_Bateaux()
				FCM_Choix_Bateaux();
18DA  ECE8F009  	CALL FCM_Choix__00060


				// Appel d'une Macro
				// Appel d'une Macro: Porte_avion()
				FCM_Porte_avion();
18DE  EC98F008  	CALL FCM_Porte__00061


			// } else {

			}


		}

		// Boucle
		// Boucle: While Croiseur = 4
		while (!(FCV_CROISEUR == 4))
18E4  6BB9      	CLRF CompTempVar2656, 1
18E6  0E04      	MOVLW 0x04
18E8  63A3      	CPFSEQ gbl_FCV_CROISEUR, 1
18EA  D001      	BRA	label126
18EC  2BB9      	INCF CompTempVar2656, F, 1
18EE            label126
18EE  67B9      	TSTFSZ CompTempVar2656, 1
18F0  D008      	BRA	label127
1900  D7F1      	BRA	label125
1902            label127

		{

			// Décision
			// Décision: Porte_avion = 5?
			if (FCV_PORTE_AVION == 5)
18F2  0E05      	MOVLW 0x05
18F4  63AB      	CPFSEQ gbl_FCV_PORTE_AVION, 1
18F6  D7F6      	BRA	label125

			{

				// Appel d'une Macro
				// Appel d'une Macro: Choix_Bateaux()
				FCM_Choix_Bateaux();
18F8  ECE8F009  	CALL FCM_Choix__00060


				// Appel d'une Macro
				// Appel d'une Macro: Croiseur()
				FCM_Croiseur();
18FC  EC3CF009  	CALL FCM_Croise_00062


			// } else {

			}


		}

		// Boucle
		// Boucle: While Contre_torpilleur = 3
		while (!(FCV_CONTRE_TORPILLEUR == 3))
1902  6BBA      	CLRF CompTempVar2658, 1
1904  0E03      	MOVLW 0x03
1906  63AD      	CPFSEQ gbl_FCV_CONTRE_TORPILLEUR, 1
1908  D001      	BRA	label128
190A  2BBA      	INCF CompTempVar2658, F, 1
190C            label128
190C  67BA      	TSTFSZ CompTempVar2658, 1
190E  D005      	BRA	label129
1918  D7F4      	BRA	label127
191A            label129

		{

			// Appel d'une Macro
			// Appel d'une Macro: Choix_Bateaux()
			FCM_Choix_Bateaux();
1910  ECE8F009  	CALL FCM_Choix__00060


			// Appel d'une Macro
			// Appel d'une Macro: Contre_torpilleur()
			FCM_Contre_torpilleur();
1914  EC92F009  	CALL FCM_Contre_00063



		}

		// Boucle
		// Boucle: While Sous_marin = 3
		while (!(FCV_SOUS_MARIN == 3))
191A  6BBB      	CLRF CompTempVar2660, 1
191C  0E03      	MOVLW 0x03
191E  63A7      	CPFSEQ gbl_FCV_SOUS_MARIN, 1
1920  D001      	BRA	label130
1922  2BBB      	INCF CompTempVar2660, F, 1
1924            label130
1924  67BB      	TSTFSZ CompTempVar2660, 1
1926  D005      	BRA	label131
1930  D7F4      	BRA	label129
1932            label131

		{

			// Appel d'une Macro
			// Appel d'une Macro: Choix_Bateaux()
			FCM_Choix_Bateaux();
1928  ECE8F009  	CALL FCM_Choix__00060


			// Appel d'une Macro
			// Appel d'une Macro: Sous_marin()
			FCM_Sous_marin();
192C  EC42F008  	CALL FCM_Sous_m_00064



		}

		// Boucle
		// Boucle: While Torpilleur = 2
		while (!(FCV_TORPILLEUR == 2))
1932  6BBC      	CLRF CompTempVar2662, 1
1934  0E02      	MOVLW 0x02
1936  63A4      	CPFSEQ gbl_FCV_TORPILLEUR, 1
1938  D001      	BRA	label132
193A  2BBC      	INCF CompTempVar2662, F, 1
193C            label132
193C  67BC      	TSTFSZ CompTempVar2662, 1
193E  D005      	BRA	label133
1948  D7F4      	BRA	label131
194A            label133

		{

			// Appel d'une Macro
			// Appel d'une Macro: Choix_Bateaux()
			FCM_Choix_Bateaux();
1940  ECE8F009  	CALL FCM_Choix__00060


			// Appel d'une Macro
			// Appel d'une Macro: Torpilleur()
			FCM_Torpilleur();
1944  ECECF007  	CALL FCM_Torpil_00065



		}


		if ((FCV_APPUI_ECRAN == 0) != 0) break;
194A  6BBD      	CLRF CompTempVar2663, 1
194C  2BBD      	INCF CompTempVar2663, F, 1
194E  67A8      	TSTFSZ gbl_FCV_APPUI_ECRAN, 1
1950  91BD      	BCF CompTempVar2663,0, 1
1952  53BD      	MOVF CompTempVar2663, F, 1
1954  E0B7      	BZ	label123

	}

}
1956  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_coule_PA()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0E64  0100      	MOVLB 0x00
0E66  518E      	MOVF gbl_FCV_X, W, 1
0E68  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
0E6A  518F      	MOVF gbl_FCV_X+D'1', W, 1
0E6C  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
0E6E  0E18      	MOVLW 0x18
0E70  5D8E      	SUBWF gbl_FCV_X, W, 1
0E72  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
0E74  598E      	SUBWFB gbl_FCV_X, W, 1
0E76  0818      	SUBLW 0x18
0E78  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0E7A  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
0E7C  518C      	MOVF gbl_FCV_Y, W, 1
0E7E  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
0E80  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0E82  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
0E84  0E18      	MOVLW 0x18
0E86  5D8C      	SUBWF gbl_FCV_Y, W, 1
0E88  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
0E8A  598C      	SUBWFB gbl_FCV_Y, W, 1
0E8C  0818      	SUBLW 0x18
0E8E  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0E90  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
0E92  69C6      	SETF FCM_parame_0005C_arg_FCL_ROUGE, 1
0E94  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
0E96  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
0E98  ECD1F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0E9C  0E20      	MOVLW 0x20
0E9E  0100      	MOVLB 0x00
0EA0  6FC0      	MOVWF CompTempVar2708, 1
0EA2  6FC1      	MOVWF CompTempVar2708+D'1', 1
0EA4  6FC2      	MOVWF CompTempVar2708+D'2', 1
0EA6  6FC3      	MOVWF CompTempVar2708+D'3', 1
0EA8  6FC4      	MOVWF CompTempVar2708+D'4', 1
0EAA  6FC5      	MOVWF CompTempVar2708+D'5', 1
0EAC  6FC6      	MOVWF CompTempVar2708+D'6', 1
0EAE  6FC7      	MOVWF CompTempVar2708+D'7', 1
0EB0  6FC8      	MOVWF CompTempVar2708+D'8', 1
0EB2  6FC9      	MOVWF CompTempVar2708+D'9', 1
0EB4  6FCA      	MOVWF CompTempVar2708+D'10', 1
0EB6  6FCB      	MOVWF CompTempVar2708+D'11', 1
0EB8  6FD2      	MOVWF CompTempVar2708+D'18', 1
0EBA  6FD3      	MOVWF CompTempVar2708+D'19', 1
0EBC  6FD4      	MOVWF CompTempVar2708+D'20', 1
0EBE  0E54      	MOVLW 0x54
0EC0  6FCC      	MOVWF CompTempVar2708+D'12', 1
0EC2  0E63      	MOVLW 0x63
0EC4  6FCF      	MOVWF CompTempVar2708+D'15', 1
0EC6  0E65      	MOVLW 0x65
0EC8  6FD1      	MOVWF CompTempVar2708+D'17', 1
0ECA  0E68      	MOVLW 0x68
0ECC  6FD0      	MOVWF CompTempVar2708+D'16', 1
0ECE  0E6F      	MOVLW 0x6F
0ED0  6FCD      	MOVWF CompTempVar2708+D'13', 1
0ED2  0E75      	MOVLW 0x75
0ED4  6FCE      	MOVWF CompTempVar2708+D'14', 1
0ED6  6BD5      	CLRF CompTempVar2708+D'21', 1
0ED8  0E00      	MOVLW HIGH(CompTempVar2708+D'0')
0EDA  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0EDC  0EC0      	MOVLW LOW(CompTempVar2708+D'0')
0EDE  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0EE0  0E16      	MOVLW 0x16
0EE2  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0EE4  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0EE6  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0EE8  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0EEA  0EF1      	MOVLW 0xF1
0EEC  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0EEE  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0EF0  0E02      	MOVLW 0x02
0EF2  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0EF4  0E01      	MOVLW 0x01
0EF6  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0EF8  EC3CF003  	CALL FCD_0f051__0005D


	// Calcul
	// Calcul:
	//  Tableau[hitbox] = tableau[hitbox] || 0b00000011
	//  Porte_avion = Porte_avion - 1
	FCV_TABLEAU[FCV_HITBOX] = FCV_TABLEAU[FCV_HITBOX] || 3;
0EFC  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0F00  50E9      	MOVF FSR0L, W
0F02  0100      	MOVLB 0x00
0F04  51A6      	MOVF gbl_FCV_HITBOX, W, 1
0F06  26E9      	ADDWF FSR0L, F
0F08  6BB8      	CLRF CompTempVar2712, 1
0F0A  2BB8      	INCF CompTempVar2712, F, 1
0F0C  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0F0E  6EE9      	MOVWF FSR0L
0F10  51A6      	MOVF gbl_FCV_HITBOX, W, 1
0F12  26E9      	ADDWF FSR0L, F
0F14  51B8      	MOVF CompTempVar2712, W, 1
0F16  6EEF      	MOVWF INDF0

	FCV_PORTE_AVION = FCV_PORTE_AVION - 1;
0F18  05AB      	DECF gbl_FCV_PORTE_AVION, W, 1
0F1A  6FAB      	MOVWF gbl_FCV_PORTE_AVION, 1


}
0F1C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Lecture_Coordonnes()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: X_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);
0B5C  0100      	MOVLB 0x00
0B5E  6BBE      	CLRF FCD_0f051__00068_arg_FCL_AXIS, 1
0B60  EC1BF003  	CALL FCD_0f051__00068
0B64  51C1      	MOVF CompTempVarRet2714, W, 1
0B66  6F90      	MOVWF gbl_FCV_X_TOUCH, 1
0B68  51C2      	MOVF CompTempVarRet2714+D'1', W, 1
0B6A  6F91      	MOVWF gbl_FCV_X_TOUCH+D'1', 1


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);
0B6C  0E01      	MOVLW 0x01
0B6E  6FBE      	MOVWF FCD_0f051__00068_arg_FCL_AXIS, 1
0B70  EC1BF003  	CALL FCD_0f051__00068
0B74  51C1      	MOVF CompTempVarRet2714, W, 1
0B76  6F88      	MOVWF gbl_FCV_Y_TOUCH, 1
0B78  51C2      	MOVF CompTempVarRet2714+D'1', W, 1
0B7A  6F89      	MOVWF gbl_FCV_Y_TOUCH+D'1', 1


}
0B7C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Croiseur()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
1278  0E01      	MOVLW 0x01
127A  0100      	MOVLB 0x00
127C  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
127E  0E18      	MOVLW 0x18
1280  6F8C      	MOVWF gbl_FCV_Y, 1
1282  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
1284  0E18      	MOVLW 0x18
1286  6F8E      	MOVWF gbl_FCV_X, 1
1288  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
128A            label84
128A  0E01      	MOVLW 0x01
128C  0100      	MOVLB 0x00
128E  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
1290  E236      	BC	label92
1292  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
1294  D034      	BRA	label92
12FC  D7C6      	BRA	label84
12FE            label92

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
1296  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1298  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
129A  E102      	BNZ	label85
129C  518C      	MOVF gbl_FCV_Y, W, 1
129E  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
12A0            label85
12A0  E223      	BC	label91
12A2            label86
12E8            label91

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
12A2  518F      	MOVF gbl_FCV_X+D'1', W, 1
12A4  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
12A6  E102      	BNZ	label87
12A8  518E      	MOVF gbl_FCV_X, W, 1
12AA  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
12AC            label87
12AC  E309      	BNC	label88

				{

				} else {
12C0            label88


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
12AE  29A6      	INCF gbl_FCV_HITBOX, W, 1
12B0  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
12B2  6BBF      	CLRF CompTempVar2674, 1
12B4  0E18      	MOVLW 0x18
12B6  278E      	ADDWF gbl_FCV_X, F, 1
12B8  518F      	MOVF gbl_FCV_X+D'1', W, 1
12BA  23BF      	ADDWFC CompTempVar2674, F, 1
12BC  51BF      	MOVF CompTempVar2674, W, 1
12BE  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
12C0  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
12C2  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
12C4  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
12C6  B4D8      	BTFSC STATUS,Z
12C8  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
12CA  6BBE      	CLRF CompTempVar2672, 1
12CC  518F      	MOVF gbl_FCV_X+D'1', W, 1
12CE  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
12D0  E104      	BNZ	label89
12D2  518E      	MOVF gbl_FCV_X, W, 1
12D4  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
12D6  D001      	BRA	label89
12D8  D001      	BRA	label90
12DA            label89
12DA  A0D8      	BTFSS STATUS,C
12DC  71BE      	BTG CompTempVar2672,0, 1
12DE  53BE      	MOVF CompTempVar2672, F, 1
12E0  E0E0      	BZ	label86

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
12E2  ECD5F003  	CALL FCM_affich_00069


		} else {
12E6  D7D1      	BRA	label84


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
12E8  0E0A      	MOVLW 0x0A
12EA  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
12EC  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
12EE  6BBE      	CLRF CompTempVar2678, 1
12F0  0E18      	MOVLW 0x18
12F2  278C      	ADDWF gbl_FCV_Y, F, 1
12F4  518D      	MOVF gbl_FCV_Y+D'1', W, 1
12F6  23BE      	ADDWFC CompTempVar2678, F, 1
12F8  51BE      	MOVF CompTempVar2678, W, 1
12FA  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000010
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Croiseur = Croiseur + 1
	FCV_TABLEAU[FCV_HITBOX] = 2;
12FE  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
1302  50E9      	MOVF FSR0L, W
1304  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1306  26E9      	ADDWF FSR0L, F
1308  0E02      	MOVLW 0x02
130A  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
130C  29AA      	INCF gbl_FCV_BATEAU, W, 1
130E  6FAA      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
1310  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1312  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
1314  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
1316  6B8E      	CLRF gbl_FCV_X, 1
1318  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
131A  6B8C      	CLRF gbl_FCV_Y, 1
131C  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_CROISEUR = FCV_CROISEUR + 1;
131E  29A3      	INCF gbl_FCV_CROISEUR, W, 1
1320  6FA3      	MOVWF gbl_FCV_CROISEUR, 1


}
1322  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Torpilleur()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
0FD8  0E01      	MOVLW 0x01
0FDA  0100      	MOVLB 0x00
0FDC  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
0FDE  0E18      	MOVLW 0x18
0FE0  6F8C      	MOVWF gbl_FCV_Y, 1
0FE2  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
0FE4  0E18      	MOVLW 0x18
0FE6  6F8E      	MOVWF gbl_FCV_X, 1
0FE8  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
0FEA            label57
0FEA  0E01      	MOVLW 0x01
0FEC  0100      	MOVLB 0x00
0FEE  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
0FF0  E236      	BC	label65
0FF2  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
0FF4  D034      	BRA	label65
105C  D7C6      	BRA	label57
105E            label65

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
0FF6  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0FF8  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
0FFA  E102      	BNZ	label58
0FFC  518C      	MOVF gbl_FCV_Y, W, 1
0FFE  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
1000            label58
1000  E223      	BC	label64
1002            label59
1048            label64

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
1002  518F      	MOVF gbl_FCV_X+D'1', W, 1
1004  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1006  E102      	BNZ	label60
1008  518E      	MOVF gbl_FCV_X, W, 1
100A  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
100C            label60
100C  E309      	BNC	label61

				{

				} else {
1020            label61


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
100E  29A6      	INCF gbl_FCV_HITBOX, W, 1
1010  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
1012  6BBF      	CLRF CompTempVar2698, 1
1014  0E18      	MOVLW 0x18
1016  278E      	ADDWF gbl_FCV_X, F, 1
1018  518F      	MOVF gbl_FCV_X+D'1', W, 1
101A  23BF      	ADDWFC CompTempVar2698, F, 1
101C  51BF      	MOVF CompTempVar2698, W, 1
101E  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
1020  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
1022  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
1024  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
1026  B4D8      	BTFSC STATUS,Z
1028  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
102A  6BBE      	CLRF CompTempVar2696, 1
102C  518F      	MOVF gbl_FCV_X+D'1', W, 1
102E  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1030  E104      	BNZ	label62
1032  518E      	MOVF gbl_FCV_X, W, 1
1034  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
1036  D001      	BRA	label62
1038  D001      	BRA	label63
103A            label62
103A  A0D8      	BTFSS STATUS,C
103C  71BE      	BTG CompTempVar2696,0, 1
103E  53BE      	MOVF CompTempVar2696, F, 1
1040  E0E0      	BZ	label59

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
1042  ECD5F003  	CALL FCM_affich_00069


		} else {
1046  D7D1      	BRA	label57


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
1048  0E0A      	MOVLW 0x0A
104A  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
104C  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
104E  6BBE      	CLRF CompTempVar2702, 1
1050  0E18      	MOVLW 0x18
1052  278C      	ADDWF gbl_FCV_Y, F, 1
1054  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1056  23BE      	ADDWFC CompTempVar2702, F, 1
1058  51BE      	MOVF CompTempVar2702, W, 1
105A  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000101
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Torpilleur = Torpilleur + 1
	FCV_TABLEAU[FCV_HITBOX] = 5;
105E  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
1062  50E9      	MOVF FSR0L, W
1064  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1066  26E9      	ADDWF FSR0L, F
1068  0E05      	MOVLW 0x05
106A  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
106C  29AA      	INCF gbl_FCV_BATEAU, W, 1
106E  6FAA      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
1070  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1072  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
1074  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
1076  6B8E      	CLRF gbl_FCV_X, 1
1078  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
107A  6B8C      	CLRF gbl_FCV_Y, 1
107C  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_TORPILLEUR = FCV_TORPILLEUR + 1;
107E  29A4      	INCF gbl_FCV_TORPILLEUR, W, 1
1080  6FA4      	MOVWF gbl_FCV_TORPILLEUR, 1


}
1082  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_Coule_SM()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0DAA  0100      	MOVLB 0x00
0DAC  518E      	MOVF gbl_FCV_X, W, 1
0DAE  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
0DB0  518F      	MOVF gbl_FCV_X+D'1', W, 1
0DB2  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
0DB4  0E18      	MOVLW 0x18
0DB6  5D8E      	SUBWF gbl_FCV_X, W, 1
0DB8  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
0DBA  598E      	SUBWFB gbl_FCV_X, W, 1
0DBC  0818      	SUBLW 0x18
0DBE  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0DC0  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
0DC2  518C      	MOVF gbl_FCV_Y, W, 1
0DC4  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
0DC6  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0DC8  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
0DCA  0E18      	MOVLW 0x18
0DCC  5D8C      	SUBWF gbl_FCV_Y, W, 1
0DCE  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
0DD0  598C      	SUBWFB gbl_FCV_Y, W, 1
0DD2  0818      	SUBLW 0x18
0DD4  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0DD6  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
0DD8  69C6      	SETF FCM_parame_0005C_arg_FCL_ROUGE, 1
0DDA  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
0DDC  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
0DDE  ECD1F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0DE2  0E20      	MOVLW 0x20
0DE4  0100      	MOVLB 0x00
0DE6  6FC0      	MOVWF CompTempVar2723, 1
0DE8  6FC1      	MOVWF CompTempVar2723+D'1', 1
0DEA  6FC2      	MOVWF CompTempVar2723+D'2', 1
0DEC  6FC3      	MOVWF CompTempVar2723+D'3', 1
0DEE  6FC4      	MOVWF CompTempVar2723+D'4', 1
0DF0  6FC5      	MOVWF CompTempVar2723+D'5', 1
0DF2  6FC6      	MOVWF CompTempVar2723+D'6', 1
0DF4  6FC7      	MOVWF CompTempVar2723+D'7', 1
0DF6  6FC8      	MOVWF CompTempVar2723+D'8', 1
0DF8  6FC9      	MOVWF CompTempVar2723+D'9', 1
0DFA  6FCA      	MOVWF CompTempVar2723+D'10', 1
0DFC  6FCB      	MOVWF CompTempVar2723+D'11', 1
0DFE  6FD2      	MOVWF CompTempVar2723+D'18', 1
0E00  6FD3      	MOVWF CompTempVar2723+D'19', 1
0E02  6FD4      	MOVWF CompTempVar2723+D'20', 1
0E04  0E54      	MOVLW 0x54
0E06  6FCC      	MOVWF CompTempVar2723+D'12', 1
0E08  0E63      	MOVLW 0x63
0E0A  6FCF      	MOVWF CompTempVar2723+D'15', 1
0E0C  0E65      	MOVLW 0x65
0E0E  6FD1      	MOVWF CompTempVar2723+D'17', 1
0E10  0E68      	MOVLW 0x68
0E12  6FD0      	MOVWF CompTempVar2723+D'16', 1
0E14  0E6F      	MOVLW 0x6F
0E16  6FCD      	MOVWF CompTempVar2723+D'13', 1
0E18  0E75      	MOVLW 0x75
0E1A  6FCE      	MOVWF CompTempVar2723+D'14', 1
0E1C  6BD5      	CLRF CompTempVar2723+D'21', 1
0E1E  0E00      	MOVLW HIGH(CompTempVar2723+D'0')
0E20  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0E22  0EC0      	MOVLW LOW(CompTempVar2723+D'0')
0E24  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0E26  0E16      	MOVLW 0x16
0E28  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0E2A  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0E2C  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0E2E  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0E30  0EF1      	MOVLW 0xF1
0E32  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0E34  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0E36  0E02      	MOVLW 0x02
0E38  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0E3A  0E01      	MOVLW 0x01
0E3C  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0E3E  EC3CF003  	CALL FCD_0f051__0005D


	// Calcul
	// Calcul:
	//  Tableau[hitbox] = tableau[hitbox] || 0b00000011
	//  Sous_marin = Sous_marin - 1
	FCV_TABLEAU[FCV_HITBOX] = FCV_TABLEAU[FCV_HITBOX] || 3;
0E42  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0E46  50E9      	MOVF FSR0L, W
0E48  0100      	MOVLB 0x00
0E4A  51A6      	MOVF gbl_FCV_HITBOX, W, 1
0E4C  26E9      	ADDWF FSR0L, F
0E4E  6BB8      	CLRF CompTempVar2727, 1
0E50  2BB8      	INCF CompTempVar2727, F, 1
0E52  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0E54  6EE9      	MOVWF FSR0L
0E56  51A6      	MOVF gbl_FCV_HITBOX, W, 1
0E58  26E9      	ADDWF FSR0L, F
0E5A  51B8      	MOVF CompTempVar2727, W, 1
0E5C  6EEF      	MOVWF INDF0

	FCV_SOUS_MARIN = FCV_SOUS_MARIN - 1;
0E5E  05A7      	DECF gbl_FCV_SOUS_MARIN, W, 1
0E60  6FA7      	MOVWF gbl_FCV_SOUS_MARIN, 1


}
0E62  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Initialisation()

{

	// Calcul
	// Calcul:

	// Boucle
	// Boucle: While hitbox = 101
	while (1)
1BFC            label146

	{

		// Calcul
		// Calcul:
		//  tableau[hitbox] = 0b00000000
		//  hitbox = hitbox + 1
		FCV_TABLEAU[FCV_HITBOX] = 0;
1BFC  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
1C00  50E9      	MOVF FSR0L, W
1C02  0100      	MOVLB 0x00
1C04  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1C06  26E9      	ADDWF FSR0L, F
1C08  0E00      	MOVLW 0x00
1C0A  6EEF      	MOVWF INDF0

		FCV_HITBOX = FCV_HITBOX + 1;
1C0C  29A6      	INCF gbl_FCV_HITBOX, W, 1
1C0E  6FA6      	MOVWF gbl_FCV_HITBOX, 1



		if ((FCV_HITBOX == 101) != 0) break;
1C10  6BB7      	CLRF CompTempVar2729, 1
1C12  0E65      	MOVLW 0x65
1C14  63A6      	CPFSEQ gbl_FCV_HITBOX, 1
1C16  D001      	BRA	label147
1C18  2BB7      	INCF CompTempVar2729, F, 1
1C1A            label147
1C1A  53B7      	MOVF CompTempVar2729, F, 1
1C1C  E0EF      	BZ	label146

	}

	#if 0 // Disabled code
	// Calcul
	// Calcul:
	//  tableau[Joueur1] = tableau[hitbox]
	FCV_TABLEAU[FCV_JOUEUR1] = FCV_TABLEAU[FCV_HITBOX];

	#endif // #if 0: Disabled code
	#if 0 // Disabled code
	// Calcul
	// Calcul:
	//  tableau[23] = 0b00000001
	//  tableau[24] = 0b00000001
	//  tableau[25] = 0b00000001
	FCV_TABLEAU[23] = 1;
	FCV_TABLEAU[24] = 1;
	FCV_TABLEAU[25] = 1;

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
1C1E  ECD7F00C  	CALL FCD_0f051__0006C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
1C22  EC63F00A  	CALL FCD_0f051__0006D


	// Appel d'une Macro
	// Appel d'une Macro: lignes()
	FCM_lignes();
1C26  EC8DF00A  	CALL FCM_lignes_00000


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_SetTouchRegionPicaso(0, 0, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(0, 0, 240, 240);
1C2A  6BBE      	CLRF FCD_0f051__0006E_arg_FCL_X1, 1
1C2C  6BBF      	CLRF FCD_0f051__0006E_arg_FCL_X1+D'1', 1
1C2E  6BC0      	CLRF FCD_0f051__0006E_arg_FCL_Y1, 1
1C30  6BC1      	CLRF FCD_0f051__0006E_arg_FCL_Y1+D'1', 1
1C32  0EF0      	MOVLW 0xF0
1C34  6FC2      	MOVWF FCD_0f051__0006E_arg_FCL_X2, 1
1C36  6BC3      	CLRF FCD_0f051__0006E_arg_FCL_X2+D'1', 1
1C38  0EF0      	MOVLW 0xF0
1C3A  6FC4      	MOVWF FCD_0f051__0006E_arg_FCL_Y2, 1
1C3C  6BC5      	CLRF FCD_0f051__0006E_arg_FCL_Y2+D'1', 1
1C3E  ECC1F002  	CALL FCD_0f051__0006E


}
1C42  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Message_bateau()

{

	// Décision
	// Décision: bateau >= 5?
	if (FCV_BATEAU >= 5)
0810  0E05      	MOVLW 0x05
0812  0100      	MOVLB 0x00
0814  61AA      	CPFSLT gbl_FCV_BATEAU, 1
0816  D001      	BRA	label37
0818  D153      	BRA	label44
081A            label37
0AC0            label44

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_texte()
		FCM_Reinitialisation_texte();
081A  ECEFF001  	CALL FCM_Reinit_00070


		// Décision
		// Décision: bateau >= 9?
		if (FCV_BATEAU >= 9)
081E  0E09      	MOVLW 0x09
0820  61AA      	CPFSLT gbl_FCV_BATEAU, 1
0822  D001      	BRA	label38
0824  D105      	BRA	label43
0826            label38
0A30            label43

		{

			// Appel d'une Macro
			// Appel d'une Macro: Reinitialisation_texte()
			FCM_Reinitialisation_texte();
0826  ECEFF001  	CALL FCM_Reinit_00070


			// Décision
			// Décision: bateau >= 12?
			if (FCV_BATEAU >= 12)
082A  0E0C      	MOVLW 0x0C
082C  61AA      	CPFSLT gbl_FCV_BATEAU, 1
082E  D001      	BRA	label39
0830  D0A5      	BRA	label42
0832            label39
097C            label42

			{

				// Appel d'une Macro
				// Appel d'une Macro: Reinitialisation_texte()
				FCM_Reinitialisation_texte();
0832  ECEFF001  	CALL FCM_Reinit_00070


				// Décision
				// Décision: bateau >= 15?
				if (FCV_BATEAU >= 15)
0836  0E0F      	MOVLW 0x0F
0838  61AA      	CPFSLT gbl_FCV_BATEAU, 1
083A  D001      	BRA	label40
083C  D051      	BRA	label41
083E            label40
08E0            label41

				{

					// Appel d'une Macro
					// Appel d'une Macro: Reinitialisation_texte()
					FCM_Reinitialisation_texte();
083E  ECEFF001  	CALL FCM_Reinit_00070


					// Décision
					// Décision: bateau >= 17?
					if (FCV_BATEAU >= 17)
0842  0E11      	MOVLW 0x11
0844  61AA      	CPFSLT gbl_FCV_BATEAU, 1

					{

					} else {

						// Appel de la Routine Composant
						// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le torpilleur (2 cases)", 0, 241, 2, 1)
						FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le torpilleur (2 cases)", 40, 0, 241, 2, 1);
0848  0E20      	MOVLW 0x20
084A  6FC8      	MOVWF CompTempVar2774+D'8', 1
084C  6FCF      	MOVWF CompTempVar2774+D'15', 1
084E  6FD2      	MOVWF CompTempVar2774+D'18', 1
0850  6FDD      	MOVWF CompTempVar2774+D'29', 1
0852  6FE0      	MOVWF CompTempVar2774+D'32', 1
0854  0E28      	MOVLW 0x28
0856  6FDE      	MOVWF CompTempVar2774+D'30', 1
0858  0E29      	MOVLW 0x29
085A  6FE6      	MOVWF CompTempVar2774+D'38', 1
085C  0E32      	MOVLW 0x32
085E  6FDF      	MOVWF CompTempVar2774+D'31', 1
0860  0E56      	MOVLW 0x56
0862  6FC0      	MOVWF CompTempVar2774, 1
0864  0E61      	MOVLW 0x61
0866  6FCB      	MOVWF CompTempVar2774+D'11', 1
0868  6FE2      	MOVWF CompTempVar2774+D'34', 1
086A  0E63      	MOVLW 0x63
086C  6FCC      	MOVWF CompTempVar2774+D'12', 1
086E  6FE1      	MOVWF CompTempVar2774+D'33', 1
0870  0E65      	MOVLW 0x65
0872  6FC1      	MOVWF CompTempVar2774+D'1', 1
0874  6FC6      	MOVWF CompTempVar2774+D'6', 1
0876  6FCD      	MOVWF CompTempVar2774+D'13', 1
0878  6FD1      	MOVWF CompTempVar2774+D'17', 1
087A  6FDA      	MOVWF CompTempVar2774+D'26', 1
087C  6FE4      	MOVWF CompTempVar2774+D'36', 1
087E  0E69      	MOVLW 0x69
0880  6FC3      	MOVWF CompTempVar2774+D'3', 1
0882  6FD7      	MOVWF CompTempVar2774+D'23', 1
0884  0E6C      	MOVLW 0x6C
0886  6FC4      	MOVWF CompTempVar2774+D'4', 1
0888  6FC5      	MOVWF CompTempVar2774+D'5', 1
088A  6FCA      	MOVWF CompTempVar2774+D'10', 1
088C  6FD0      	MOVWF CompTempVar2774+D'16', 1
088E  6FD8      	MOVWF CompTempVar2774+D'24', 1
0890  6FD9      	MOVWF CompTempVar2774+D'25', 1
0892  0E6F      	MOVLW 0x6F
0894  6FD4      	MOVWF CompTempVar2774+D'20', 1
0896  0E70      	MOVLW 0x70
0898  6FC9      	MOVWF CompTempVar2774+D'9', 1
089A  6FD6      	MOVWF CompTempVar2774+D'22', 1
089C  0E72      	MOVLW 0x72
089E  6FCE      	MOVWF CompTempVar2774+D'14', 1
08A0  6FD5      	MOVWF CompTempVar2774+D'21', 1
08A2  6FDC      	MOVWF CompTempVar2774+D'28', 1
08A4  0E73      	MOVLW 0x73
08A6  6FE3      	MOVWF CompTempVar2774+D'35', 1
08A8  6FE5      	MOVWF CompTempVar2774+D'37', 1
08AA  0E74      	MOVLW 0x74
08AC  6FD3      	MOVWF CompTempVar2774+D'19', 1
08AE  0E75      	MOVLW 0x75
08B0  6FC2      	MOVWF CompTempVar2774+D'2', 1
08B2  6FDB      	MOVWF CompTempVar2774+D'27', 1
08B4  0E7A      	MOVLW 0x7A
08B6  6FC7      	MOVWF CompTempVar2774+D'7', 1
08B8  6BE7      	CLRF CompTempVar2774+D'39', 1
08BA  0E00      	MOVLW HIGH(CompTempVar2774+D'0')
08BC  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
08BE  0EC0      	MOVLW LOW(CompTempVar2774+D'0')
08C0  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
08C2  0E28      	MOVLW 0x28
08C4  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
08C6  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
08C8  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
08CA  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
08CC  0EF1      	MOVLW 0xF1
08CE  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
08D0  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
08D2  0E02      	MOVLW 0x02
08D4  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
08D6  0E01      	MOVLW 0x01
08D8  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
08DA  EC3CF003  	CALL FCD_0f051__0005D


					}

				} else {

					// Appel de la Routine Composant
					// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le sous-marin (3 cases)", 0, 241, 2, 1)
					FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le sous-marin (3 cases)", 40, 0, 241, 2, 1);
08E0  0E20      	MOVLW 0x20
08E2  6FC8      	MOVWF CompTempVar2776+D'8', 1
08E4  6FCF      	MOVWF CompTempVar2776+D'15', 1
08E6  6FD2      	MOVWF CompTempVar2776+D'18', 1
08E8  6FDD      	MOVWF CompTempVar2776+D'29', 1
08EA  6FE0      	MOVWF CompTempVar2776+D'32', 1
08EC  0E28      	MOVLW 0x28
08EE  6FDE      	MOVWF CompTempVar2776+D'30', 1
08F0  0E29      	MOVLW 0x29
08F2  6FE6      	MOVWF CompTempVar2776+D'38', 1
08F4  0E2D      	MOVLW 0x2D
08F6  6FD7      	MOVWF CompTempVar2776+D'23', 1
08F8  0E33      	MOVLW 0x33
08FA  6FDF      	MOVWF CompTempVar2776+D'31', 1
08FC  0E56      	MOVLW 0x56
08FE  6FC0      	MOVWF CompTempVar2776, 1
0900  0E61      	MOVLW 0x61
0902  6FCB      	MOVWF CompTempVar2776+D'11', 1
0904  6FD9      	MOVWF CompTempVar2776+D'25', 1
0906  6FE2      	MOVWF CompTempVar2776+D'34', 1
0908  0E63      	MOVLW 0x63
090A  6FCC      	MOVWF CompTempVar2776+D'12', 1
090C  6FE1      	MOVWF CompTempVar2776+D'33', 1
090E  0E65      	MOVLW 0x65
0910  6FC1      	MOVWF CompTempVar2776+D'1', 1
0912  6FC6      	MOVWF CompTempVar2776+D'6', 1
0914  6FCD      	MOVWF CompTempVar2776+D'13', 1
0916  6FD1      	MOVWF CompTempVar2776+D'17', 1
0918  6FE4      	MOVWF CompTempVar2776+D'36', 1
091A  0E69      	MOVLW 0x69
091C  6FC3      	MOVWF CompTempVar2776+D'3', 1
091E  6FDB      	MOVWF CompTempVar2776+D'27', 1
0920  0E6C      	MOVLW 0x6C
0922  6FC4      	MOVWF CompTempVar2776+D'4', 1
0924  6FC5      	MOVWF CompTempVar2776+D'5', 1
0926  6FCA      	MOVWF CompTempVar2776+D'10', 1
0928  6FD0      	MOVWF CompTempVar2776+D'16', 1
092A  0E6D      	MOVLW 0x6D
092C  6FD8      	MOVWF CompTempVar2776+D'24', 1
092E  0E6E      	MOVLW 0x6E
0930  6FDC      	MOVWF CompTempVar2776+D'28', 1
0932  0E6F      	MOVLW 0x6F
0934  6FD4      	MOVWF CompTempVar2776+D'20', 1
0936  0E70      	MOVLW 0x70
0938  6FC9      	MOVWF CompTempVar2776+D'9', 1
093A  0E72      	MOVLW 0x72
093C  6FCE      	MOVWF CompTempVar2776+D'14', 1
093E  6FDA      	MOVWF CompTempVar2776+D'26', 1
0940  0E73      	MOVLW 0x73
0942  6FD3      	MOVWF CompTempVar2776+D'19', 1
0944  6FD6      	MOVWF CompTempVar2776+D'22', 1
0946  6FE3      	MOVWF CompTempVar2776+D'35', 1
0948  6FE5      	MOVWF CompTempVar2776+D'37', 1
094A  0E75      	MOVLW 0x75
094C  6FC2      	MOVWF CompTempVar2776+D'2', 1
094E  6FD5      	MOVWF CompTempVar2776+D'21', 1
0950  0E7A      	MOVLW 0x7A
0952  6FC7      	MOVWF CompTempVar2776+D'7', 1
0954  6BE7      	CLRF CompTempVar2776+D'39', 1
0956  0E00      	MOVLW HIGH(CompTempVar2776+D'0')
0958  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
095A  0EC0      	MOVLW LOW(CompTempVar2776+D'0')
095C  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
095E  0E28      	MOVLW 0x28
0960  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0962  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0964  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0966  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0968  0EF1      	MOVLW 0xF1
096A  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
096C  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
096E  0E02      	MOVLW 0x02
0970  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0972  0E01      	MOVLW 0x01
0974  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0976  EC3CF003  	CALL FCD_0f051__0005D


				}

			} else {

				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le contre        torpilleur(3 cases)", 0, 241, 2, 1)
				FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le contre        torpilleur(3 cases)", 53, 0, 241, 2, 1);
097C  0E20      	MOVLW 0x20
097E  6FC8      	MOVWF CompTempVar2778+D'8', 1
0980  6FCF      	MOVWF CompTempVar2778+D'15', 1
0982  6FD2      	MOVWF CompTempVar2778+D'18', 1
0984  6FD9      	MOVWF CompTempVar2778+D'25', 1
0986  6FDA      	MOVWF CompTempVar2778+D'26', 1
0988  6FDB      	MOVWF CompTempVar2778+D'27', 1
098A  6FDC      	MOVWF CompTempVar2778+D'28', 1
098C  6FDD      	MOVWF CompTempVar2778+D'29', 1
098E  6FDE      	MOVWF CompTempVar2778+D'30', 1
0990  6FDF      	MOVWF CompTempVar2778+D'31', 1
0992  6FE0      	MOVWF CompTempVar2778+D'32', 1
0994  6FED      	MOVWF CompTempVar2778+D'45', 1
0996  0E28      	MOVLW 0x28
0998  6FEB      	MOVWF CompTempVar2778+D'43', 1
099A  0E29      	MOVLW 0x29
099C  6FF3      	MOVWF CompTempVar2778+D'51', 1
099E  0E33      	MOVLW 0x33
09A0  6FEC      	MOVWF CompTempVar2778+D'44', 1
09A2  0E56      	MOVLW 0x56
09A4  6FC0      	MOVWF CompTempVar2778, 1
09A6  0E61      	MOVLW 0x61
09A8  6FCB      	MOVWF CompTempVar2778+D'11', 1
09AA  6FEF      	MOVWF CompTempVar2778+D'47', 1
09AC  0E63      	MOVLW 0x63
09AE  6FCC      	MOVWF CompTempVar2778+D'12', 1
09B0  6FD3      	MOVWF CompTempVar2778+D'19', 1
09B2  6FEE      	MOVWF CompTempVar2778+D'46', 1
09B4  0E65      	MOVLW 0x65
09B6  6FC1      	MOVWF CompTempVar2778+D'1', 1
09B8  6FC6      	MOVWF CompTempVar2778+D'6', 1
09BA  6FCD      	MOVWF CompTempVar2778+D'13', 1
09BC  6FD1      	MOVWF CompTempVar2778+D'17', 1
09BE  6FD8      	MOVWF CompTempVar2778+D'24', 1
09C0  6FE8      	MOVWF CompTempVar2778+D'40', 1
09C2  6FF1      	MOVWF CompTempVar2778+D'49', 1
09C4  0E69      	MOVLW 0x69
09C6  6FC3      	MOVWF CompTempVar2778+D'3', 1
09C8  6FE5      	MOVWF CompTempVar2778+D'37', 1
09CA  0E6C      	MOVLW 0x6C
09CC  6FC4      	MOVWF CompTempVar2778+D'4', 1
09CE  6FC5      	MOVWF CompTempVar2778+D'5', 1
09D0  6FCA      	MOVWF CompTempVar2778+D'10', 1
09D2  6FD0      	MOVWF CompTempVar2778+D'16', 1
09D4  6FE6      	MOVWF CompTempVar2778+D'38', 1
09D6  6FE7      	MOVWF CompTempVar2778+D'39', 1
09D8  0E6E      	MOVLW 0x6E
09DA  6FD5      	MOVWF CompTempVar2778+D'21', 1
09DC  0E6F      	MOVLW 0x6F
09DE  6FD4      	MOVWF CompTempVar2778+D'20', 1
09E0  6FE2      	MOVWF CompTempVar2778+D'34', 1
09E2  0E70      	MOVLW 0x70
09E4  6FC9      	MOVWF CompTempVar2778+D'9', 1
09E6  6FE4      	MOVWF CompTempVar2778+D'36', 1
09E8  0E72      	MOVLW 0x72
09EA  6FCE      	MOVWF CompTempVar2778+D'14', 1
09EC  6FD7      	MOVWF CompTempVar2778+D'23', 1
09EE  6FE3      	MOVWF CompTempVar2778+D'35', 1
09F0  6FEA      	MOVWF CompTempVar2778+D'42', 1
09F2  0E73      	MOVLW 0x73
09F4  6FF0      	MOVWF CompTempVar2778+D'48', 1
09F6  6FF2      	MOVWF CompTempVar2778+D'50', 1
09F8  0E74      	MOVLW 0x74
09FA  6FD6      	MOVWF CompTempVar2778+D'22', 1
09FC  6FE1      	MOVWF CompTempVar2778+D'33', 1
09FE  0E75      	MOVLW 0x75
0A00  6FC2      	MOVWF CompTempVar2778+D'2', 1
0A02  6FE9      	MOVWF CompTempVar2778+D'41', 1
0A04  0E7A      	MOVLW 0x7A
0A06  6FC7      	MOVWF CompTempVar2778+D'7', 1
0A08  6BF4      	CLRF CompTempVar2778+D'52', 1
0A0A  0E00      	MOVLW HIGH(CompTempVar2778+D'0')
0A0C  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0A0E  0EC0      	MOVLW LOW(CompTempVar2778+D'0')
0A10  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0A12  0E35      	MOVLW 0x35
0A14  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0A16  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0A18  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0A1A  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0A1C  0EF1      	MOVLW 0xF1
0A1E  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0A20  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0A22  0E02      	MOVLW 0x02
0A24  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0A26  0E01      	MOVLW 0x01
0A28  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0A2A  EC3CF003  	CALL FCD_0f051__0005D


			}

		} else {

			// Appel de la Routine Composant
			// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le croiseur(4 cases)", 0, 241, 2, 1)
			FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le croiseur(4 cases)", 37, 0, 241, 2, 1);
0A30  0E20      	MOVLW 0x20
0A32  6FC8      	MOVWF CompTempVar2780+D'8', 1
0A34  6FCF      	MOVWF CompTempVar2780+D'15', 1
0A36  6FD2      	MOVWF CompTempVar2780+D'18', 1
0A38  6FDD      	MOVWF CompTempVar2780+D'29', 1
0A3A  0E28      	MOVLW 0x28
0A3C  6FDB      	MOVWF CompTempVar2780+D'27', 1
0A3E  0E29      	MOVLW 0x29
0A40  6FE3      	MOVWF CompTempVar2780+D'35', 1
0A42  0E34      	MOVLW 0x34
0A44  6FDC      	MOVWF CompTempVar2780+D'28', 1
0A46  0E56      	MOVLW 0x56
0A48  6FC0      	MOVWF CompTempVar2780, 1
0A4A  0E61      	MOVLW 0x61
0A4C  6FCB      	MOVWF CompTempVar2780+D'11', 1
0A4E  6FDF      	MOVWF CompTempVar2780+D'31', 1
0A50  0E63      	MOVLW 0x63
0A52  6FCC      	MOVWF CompTempVar2780+D'12', 1
0A54  6FD3      	MOVWF CompTempVar2780+D'19', 1
0A56  6FDE      	MOVWF CompTempVar2780+D'30', 1
0A58  0E65      	MOVLW 0x65
0A5A  6FC1      	MOVWF CompTempVar2780+D'1', 1
0A5C  6FC6      	MOVWF CompTempVar2780+D'6', 1
0A5E  6FCD      	MOVWF CompTempVar2780+D'13', 1
0A60  6FD1      	MOVWF CompTempVar2780+D'17', 1
0A62  6FD8      	MOVWF CompTempVar2780+D'24', 1
0A64  6FE1      	MOVWF CompTempVar2780+D'33', 1
0A66  0E69      	MOVLW 0x69
0A68  6FC3      	MOVWF CompTempVar2780+D'3', 1
0A6A  6FD6      	MOVWF CompTempVar2780+D'22', 1
0A6C  0E6C      	MOVLW 0x6C
0A6E  6FC4      	MOVWF CompTempVar2780+D'4', 1
0A70  6FC5      	MOVWF CompTempVar2780+D'5', 1
0A72  6FCA      	MOVWF CompTempVar2780+D'10', 1
0A74  6FD0      	MOVWF CompTempVar2780+D'16', 1
0A76  0E6F      	MOVLW 0x6F
0A78  6FD5      	MOVWF CompTempVar2780+D'21', 1
0A7A  0E70      	MOVLW 0x70
0A7C  6FC9      	MOVWF CompTempVar2780+D'9', 1
0A7E  0E72      	MOVLW 0x72
0A80  6FCE      	MOVWF CompTempVar2780+D'14', 1
0A82  6FD4      	MOVWF CompTempVar2780+D'20', 1
0A84  6FDA      	MOVWF CompTempVar2780+D'26', 1
0A86  0E73      	MOVLW 0x73
0A88  6FD7      	MOVWF CompTempVar2780+D'23', 1
0A8A  6FE0      	MOVWF CompTempVar2780+D'32', 1
0A8C  6FE2      	MOVWF CompTempVar2780+D'34', 1
0A8E  0E75      	MOVLW 0x75
0A90  6FC2      	MOVWF CompTempVar2780+D'2', 1
0A92  6FD9      	MOVWF CompTempVar2780+D'25', 1
0A94  0E7A      	MOVLW 0x7A
0A96  6FC7      	MOVWF CompTempVar2780+D'7', 1
0A98  6BE4      	CLRF CompTempVar2780+D'36', 1
0A9A  0E00      	MOVLW HIGH(CompTempVar2780+D'0')
0A9C  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0A9E  0EC0      	MOVLW LOW(CompTempVar2780+D'0')
0AA0  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0AA2  0E25      	MOVLW 0x25
0AA4  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0AA6  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0AA8  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0AAA  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0AAC  0EF1      	MOVLW 0xF1
0AAE  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0AB0  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0AB2  0E02      	MOVLW 0x02
0AB4  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0AB6  0E01      	MOVLW 0x01
0AB8  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0ABA  EC3CF003  	CALL FCD_0f051__0005D


		}

	} else {

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le porte avion(5 cases)", 0, 241, 2, 1)
		FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le porte avion(5 cases)", 40, 0, 241, 2, 1);
0AC0  0E20      	MOVLW 0x20
0AC2  6FC8      	MOVWF CompTempVar2782+D'8', 1
0AC4  6FCF      	MOVWF CompTempVar2782+D'15', 1
0AC6  6FD2      	MOVWF CompTempVar2782+D'18', 1
0AC8  6FD8      	MOVWF CompTempVar2782+D'24', 1
0ACA  6FE0      	MOVWF CompTempVar2782+D'32', 1
0ACC  0E28      	MOVLW 0x28
0ACE  6FDE      	MOVWF CompTempVar2782+D'30', 1
0AD0  0E29      	MOVLW 0x29
0AD2  6FE6      	MOVWF CompTempVar2782+D'38', 1
0AD4  0E35      	MOVLW 0x35
0AD6  6FDF      	MOVWF CompTempVar2782+D'31', 1
0AD8  0E56      	MOVLW 0x56
0ADA  6FC0      	MOVWF CompTempVar2782, 1
0ADC  0E61      	MOVLW 0x61
0ADE  6FCB      	MOVWF CompTempVar2782+D'11', 1
0AE0  6FD9      	MOVWF CompTempVar2782+D'25', 1
0AE2  6FE2      	MOVWF CompTempVar2782+D'34', 1
0AE4  0E63      	MOVLW 0x63
0AE6  6FCC      	MOVWF CompTempVar2782+D'12', 1
0AE8  6FE1      	MOVWF CompTempVar2782+D'33', 1
0AEA  0E65      	MOVLW 0x65
0AEC  6FC1      	MOVWF CompTempVar2782+D'1', 1
0AEE  6FC6      	MOVWF CompTempVar2782+D'6', 1
0AF0  6FCD      	MOVWF CompTempVar2782+D'13', 1
0AF2  6FD1      	MOVWF CompTempVar2782+D'17', 1
0AF4  6FD7      	MOVWF CompTempVar2782+D'23', 1
0AF6  6FE4      	MOVWF CompTempVar2782+D'36', 1
0AF8  0E69      	MOVLW 0x69
0AFA  6FC3      	MOVWF CompTempVar2782+D'3', 1
0AFC  6FDB      	MOVWF CompTempVar2782+D'27', 1
0AFE  0E6C      	MOVLW 0x6C
0B00  6FC4      	MOVWF CompTempVar2782+D'4', 1
0B02  6FC5      	MOVWF CompTempVar2782+D'5', 1
0B04  6FCA      	MOVWF CompTempVar2782+D'10', 1
0B06  6FD0      	MOVWF CompTempVar2782+D'16', 1
0B08  0E6E      	MOVLW 0x6E
0B0A  6FDD      	MOVWF CompTempVar2782+D'29', 1
0B0C  0E6F      	MOVLW 0x6F
0B0E  6FD4      	MOVWF CompTempVar2782+D'20', 1
0B10  6FDC      	MOVWF CompTempVar2782+D'28', 1
0B12  0E70      	MOVLW 0x70
0B14  6FC9      	MOVWF CompTempVar2782+D'9', 1
0B16  6FD3      	MOVWF CompTempVar2782+D'19', 1
0B18  0E72      	MOVLW 0x72
0B1A  6FCE      	MOVWF CompTempVar2782+D'14', 1
0B1C  6FD5      	MOVWF CompTempVar2782+D'21', 1
0B1E  0E73      	MOVLW 0x73
0B20  6FE3      	MOVWF CompTempVar2782+D'35', 1
0B22  6FE5      	MOVWF CompTempVar2782+D'37', 1
0B24  0E74      	MOVLW 0x74
0B26  6FD6      	MOVWF CompTempVar2782+D'22', 1
0B28  0E75      	MOVLW 0x75
0B2A  6FC2      	MOVWF CompTempVar2782+D'2', 1
0B2C  0E76      	MOVLW 0x76
0B2E  6FDA      	MOVWF CompTempVar2782+D'26', 1
0B30  0E7A      	MOVLW 0x7A
0B32  6FC7      	MOVWF CompTempVar2782+D'7', 1
0B34  6BE7      	CLRF CompTempVar2782+D'39', 1
0B36  0E00      	MOVLW HIGH(CompTempVar2782+D'0')
0B38  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0B3A  0EC0      	MOVLW LOW(CompTempVar2782+D'0')
0B3C  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0B3E  0E28      	MOVLW 0x28
0B40  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0B42  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0B44  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0B46  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0B48  0EF1      	MOVLW 0xF1
0B4A  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0B4C  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0B4E  0E02      	MOVLW 0x02
0B50  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0B52  0E01      	MOVLW 0x01
0B54  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0B56  EC3CF003  	CALL FCD_0f051__0005D


	}

}
0846  0012      	RETURN
08DE  0012      	RETURN
097A  0012      	RETURN
0A2E  0012      	RETURN
0ABE  0012      	RETURN
0B5A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Toucher_Couler()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
15A8  0E01      	MOVLW 0x01
15AA  0100      	MOVLB 0x00
15AC  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
15AE  0E18      	MOVLW 0x18
15B0  6F8C      	MOVWF gbl_FCV_Y, 1
15B2  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
15B4  0E18      	MOVLW 0x18
15B6  6F8E      	MOVWF gbl_FCV_X, 1
15B8  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
15BA            label108
15BA  0E01      	MOVLW 0x01
15BC  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
15BE  E234      	BC	label116
15C0  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
15C2  D032      	BRA	label116
1626  D7C9      	BRA	label108
1628            label116

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
15C4  518D      	MOVF gbl_FCV_Y+D'1', W, 1
15C6  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
15C8  E102      	BNZ	label109
15CA  518C      	MOVF gbl_FCV_Y, W, 1
15CC  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
15CE            label109
15CE  E221      	BC	label115
15D0            label110
1612            label115

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
15D0  518F      	MOVF gbl_FCV_X+D'1', W, 1
15D2  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
15D4  E102      	BNZ	label111
15D6  518E      	MOVF gbl_FCV_X, W, 1
15D8  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
15DA            label111
15DA  E309      	BNC	label112

				{

				} else {
15EE            label112


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
15DC  29A6      	INCF gbl_FCV_HITBOX, W, 1
15DE  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
15E0  6BB9      	CLRF CompTempVar2788, 1
15E2  0E18      	MOVLW 0x18
15E4  278E      	ADDWF gbl_FCV_X, F, 1
15E6  518F      	MOVF gbl_FCV_X+D'1', W, 1
15E8  23B9      	ADDWFC CompTempVar2788, F, 1
15EA  51B9      	MOVF CompTempVar2788, W, 1
15EC  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
15EE  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
15F0  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
15F2  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
15F4  B4D8      	BTFSC STATUS,Z
15F6  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
15F8  6BB8      	CLRF CompTempVar2786, 1
15FA  518F      	MOVF gbl_FCV_X+D'1', W, 1
15FC  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
15FE  E104      	BNZ	label113
1600  518E      	MOVF gbl_FCV_X, W, 1
1602  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
1604  D001      	BRA	label113
1606  D001      	BRA	label114
1608            label113
1608  A0D8      	BTFSS STATUS,C
160A  71B8      	BTG CompTempVar2786,0, 1
160C  53B8      	MOVF CompTempVar2786, F, 1
160E  E0E0      	BZ	label110

			}

		} else {
1610  D7D4      	BRA	label108


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
1612  0E0A      	MOVLW 0x0A
1614  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
1616  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
1618  6BB8      	CLRF CompTempVar2792, 1
161A  0E18      	MOVLW 0x18
161C  278C      	ADDWF gbl_FCV_Y, F, 1
161E  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1620  23B8      	ADDWFC CompTempVar2792, F, 1
1622  51B8      	MOVF CompTempVar2792, W, 1
1624  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Porte-avion
	// Décision: tableau[hitbox] = 0b00000001?
	if (FCV_TABLEAU[FCV_HITBOX] == 1)
1628  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
162C  50E9      	MOVF FSR0L, W
162E  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1630  26E9      	ADDWF FSR0L, F
1632  04EF      	DECF INDF0, W
1634  E139      	BNZ	label117
16A8            label117

	{

		// Appel d'une Macro
		// Appel d'une Macro: Touche_coule_PA()
		FCM_Touche_coule_PA();
1636  EC32F007  	CALL FCM_Touche_00066


		// Décision
		// Décision: Porte_avion = 0?
		if (FCV_PORTE_AVION == 0)
163A  53AB      	MOVF gbl_FCV_PORTE_AVION, F, 1
163C  A4D8      	BTFSS STATUS,Z
163E  D128      	BRA	label122

		{

			// Appel d'une Macro
			// Appel d'une Macro: Reinitialisation_texte()
			FCM_Reinitialisation_texte();
1640  ECEFF001  	CALL FCM_Reinit_00070


			// Pause
			// Pause: 100 ms
			FCI_DELAYBYTE_MS(100);
1644  0E64      	MOVLW 0x64
1646  6FBE      	MOVWF delay_ms_00000_arg_del, 1
1648  EC06F000  	CALL delay_ms_00000


			// Appel de la Routine Composant
			// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
			FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
164C  0E20      	MOVLW 0x20
164E  6FC0      	MOVWF CompTempVar2793, 1
1650  6FC1      	MOVWF CompTempVar2793+D'1', 1
1652  6FC2      	MOVWF CompTempVar2793+D'2', 1
1654  6FC3      	MOVWF CompTempVar2793+D'3', 1
1656  6FC4      	MOVWF CompTempVar2793+D'4', 1
1658  6FC5      	MOVWF CompTempVar2793+D'5', 1
165A  6FC6      	MOVWF CompTempVar2793+D'6', 1
165C  6FC7      	MOVWF CompTempVar2793+D'7', 1
165E  6FC8      	MOVWF CompTempVar2793+D'8', 1
1660  6FC9      	MOVWF CompTempVar2793+D'9', 1
1662  6FCA      	MOVWF CompTempVar2793+D'10', 1
1664  6FCB      	MOVWF CompTempVar2793+D'11', 1
1666  6FD1      	MOVWF CompTempVar2793+D'17', 1
1668  6FD2      	MOVWF CompTempVar2793+D'18', 1
166A  6FD3      	MOVWF CompTempVar2793+D'19', 1
166C  0E43      	MOVLW 0x43
166E  6FCC      	MOVWF CompTempVar2793+D'12', 1
1670  0E65      	MOVLW 0x65
1672  6FD0      	MOVWF CompTempVar2793+D'16', 1
1674  0E6C      	MOVLW 0x6C
1676  6FCF      	MOVWF CompTempVar2793+D'15', 1
1678  0E6F      	MOVLW 0x6F
167A  6FCD      	MOVWF CompTempVar2793+D'13', 1
167C  0E75      	MOVLW 0x75
167E  6FCE      	MOVWF CompTempVar2793+D'14', 1
1680  6BD4      	CLRF CompTempVar2793+D'20', 1
1682  0E00      	MOVLW HIGH(CompTempVar2793+D'0')
1684  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1686  0EC0      	MOVLW LOW(CompTempVar2793+D'0')
1688  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
168A  0E15      	MOVLW 0x15
168C  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
168E  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
1690  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1692  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1694  0EF1      	MOVLW 0xF1
1696  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
1698  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
169A  0E02      	MOVLW 0x02
169C  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
169E  0E01      	MOVLW 0x01
16A0  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
16A2  EC3CF003  	CALL FCD_0f051__0005D


		// } else {

		}

	} else {
16A6  D0F4      	BRA	label122


		// Croiseur
		// Décision: tableau[hitbox] = 0b00000010?
		if (FCV_TABLEAU[FCV_HITBOX] == 2)
16A8  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
16AC  50E9      	MOVF FSR0L, W
16AE  51A6      	MOVF gbl_FCV_HITBOX, W, 1
16B0  26E9      	ADDWF FSR0L, F
16B2  0E02      	MOVLW 0x02
16B4  62EF      	CPFSEQ INDF0
16B6  D039      	BRA	label118
172A            label118

		{

			// Appel d'une Macro
			// Appel d'une Macro: Touche_coule_CR()
			FCM_Touche_coule_CR();
16B8  EC78F006  	CALL FCM_Touche_00072


			// Décision
			// Décision: Croiseur = 0?
			if (FCV_CROISEUR == 0)
16BC  53A3      	MOVF gbl_FCV_CROISEUR, F, 1
16BE  A4D8      	BTFSS STATUS,Z
16C0  D0E7      	BRA	label122

			{

				// Appel d'une Macro
				// Appel d'une Macro: Reinitialisation_texte()
				FCM_Reinitialisation_texte();
16C2  ECEFF001  	CALL FCM_Reinit_00070


				// Pause
				// Pause: 100 ms
				FCI_DELAYBYTE_MS(100);
16C6  0E64      	MOVLW 0x64
16C8  6FBE      	MOVWF delay_ms_00000_arg_del, 1
16CA  EC06F000  	CALL delay_ms_00000


				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
				FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
16CE  0E20      	MOVLW 0x20
16D0  6FC0      	MOVWF CompTempVar2796, 1
16D2  6FC1      	MOVWF CompTempVar2796+D'1', 1
16D4  6FC2      	MOVWF CompTempVar2796+D'2', 1
16D6  6FC3      	MOVWF CompTempVar2796+D'3', 1
16D8  6FC4      	MOVWF CompTempVar2796+D'4', 1
16DA  6FC5      	MOVWF CompTempVar2796+D'5', 1
16DC  6FC6      	MOVWF CompTempVar2796+D'6', 1
16DE  6FC7      	MOVWF CompTempVar2796+D'7', 1
16E0  6FC8      	MOVWF CompTempVar2796+D'8', 1
16E2  6FC9      	MOVWF CompTempVar2796+D'9', 1
16E4  6FCA      	MOVWF CompTempVar2796+D'10', 1
16E6  6FCB      	MOVWF CompTempVar2796+D'11', 1
16E8  6FD1      	MOVWF CompTempVar2796+D'17', 1
16EA  6FD2      	MOVWF CompTempVar2796+D'18', 1
16EC  6FD3      	MOVWF CompTempVar2796+D'19', 1
16EE  0E43      	MOVLW 0x43
16F0  6FCC      	MOVWF CompTempVar2796+D'12', 1
16F2  0E65      	MOVLW 0x65
16F4  6FD0      	MOVWF CompTempVar2796+D'16', 1
16F6  0E6C      	MOVLW 0x6C
16F8  6FCF      	MOVWF CompTempVar2796+D'15', 1
16FA  0E6F      	MOVLW 0x6F
16FC  6FCD      	MOVWF CompTempVar2796+D'13', 1
16FE  0E75      	MOVLW 0x75
1700  6FCE      	MOVWF CompTempVar2796+D'14', 1
1702  6BD4      	CLRF CompTempVar2796+D'20', 1
1704  0E00      	MOVLW HIGH(CompTempVar2796+D'0')
1706  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1708  0EC0      	MOVLW LOW(CompTempVar2796+D'0')
170A  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
170C  0E15      	MOVLW 0x15
170E  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1710  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
1712  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1714  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1716  0EF1      	MOVLW 0xF1
1718  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
171A  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
171C  0E02      	MOVLW 0x02
171E  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
1720  0E01      	MOVLW 0x01
1722  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1724  EC3CF003  	CALL FCD_0f051__0005D


			// } else {

			}

		} else {
1728  D0B3      	BRA	label122


			// Décision
			// Décision: tableau[hitbox] = 0b00000011?
			if (FCV_TABLEAU[FCV_HITBOX] == 3)
172A  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
172E  50E9      	MOVF FSR0L, W
1730  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1732  26E9      	ADDWF FSR0L, F
1734  0E03      	MOVLW 0x03
1736  62EF      	CPFSEQ INDF0
1738  D039      	BRA	label119
17AC            label119

			{

				// Appel d'une Macro
				// Appel d'une Macro: Touche_Coule_CT()
				FCM_Touche_Coule_CT();
173A  EC28F006  	CALL FCM_Touche_00073


				// Décision
				// Décision: Contre_torpilleur = 0?
				if (FCV_CONTRE_TORPILLEUR == 0)
173E  53AD      	MOVF gbl_FCV_CONTRE_TORPILLEUR, F, 1
1740  A4D8      	BTFSS STATUS,Z
1742  D0A6      	BRA	label122

				{

					// Appel d'une Macro
					// Appel d'une Macro: Reinitialisation_texte()
					FCM_Reinitialisation_texte();
1744  ECEFF001  	CALL FCM_Reinit_00070


					// Pause
					// Pause: 100 ms
					FCI_DELAYBYTE_MS(100);
1748  0E64      	MOVLW 0x64
174A  6FBE      	MOVWF delay_ms_00000_arg_del, 1
174C  EC06F000  	CALL delay_ms_00000


					// Appel de la Routine Composant
					// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
					FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
1750  0E20      	MOVLW 0x20
1752  6FC0      	MOVWF CompTempVar2799, 1
1754  6FC1      	MOVWF CompTempVar2799+D'1', 1
1756  6FC2      	MOVWF CompTempVar2799+D'2', 1
1758  6FC3      	MOVWF CompTempVar2799+D'3', 1
175A  6FC4      	MOVWF CompTempVar2799+D'4', 1
175C  6FC5      	MOVWF CompTempVar2799+D'5', 1
175E  6FC6      	MOVWF CompTempVar2799+D'6', 1
1760  6FC7      	MOVWF CompTempVar2799+D'7', 1
1762  6FC8      	MOVWF CompTempVar2799+D'8', 1
1764  6FC9      	MOVWF CompTempVar2799+D'9', 1
1766  6FCA      	MOVWF CompTempVar2799+D'10', 1
1768  6FCB      	MOVWF CompTempVar2799+D'11', 1
176A  6FD1      	MOVWF CompTempVar2799+D'17', 1
176C  6FD2      	MOVWF CompTempVar2799+D'18', 1
176E  6FD3      	MOVWF CompTempVar2799+D'19', 1
1770  0E43      	MOVLW 0x43
1772  6FCC      	MOVWF CompTempVar2799+D'12', 1
1774  0E65      	MOVLW 0x65
1776  6FD0      	MOVWF CompTempVar2799+D'16', 1
1778  0E6C      	MOVLW 0x6C
177A  6FCF      	MOVWF CompTempVar2799+D'15', 1
177C  0E6F      	MOVLW 0x6F
177E  6FCD      	MOVWF CompTempVar2799+D'13', 1
1780  0E75      	MOVLW 0x75
1782  6FCE      	MOVWF CompTempVar2799+D'14', 1
1784  6BD4      	CLRF CompTempVar2799+D'20', 1
1786  0E00      	MOVLW HIGH(CompTempVar2799+D'0')
1788  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
178A  0EC0      	MOVLW LOW(CompTempVar2799+D'0')
178C  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
178E  0E15      	MOVLW 0x15
1790  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1792  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
1794  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1796  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1798  0EF1      	MOVLW 0xF1
179A  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
179C  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
179E  0E02      	MOVLW 0x02
17A0  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
17A2  0E01      	MOVLW 0x01
17A4  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
17A6  EC3CF003  	CALL FCD_0f051__0005D


				// } else {

				}

			} else {
17AA  D072      	BRA	label122


				// Décision
				// Décision: tableau[hitbox] = 0b00000100?
				if (FCV_TABLEAU[FCV_HITBOX] == 4)
17AC  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
17B0  50E9      	MOVF FSR0L, W
17B2  51A6      	MOVF gbl_FCV_HITBOX, W, 1
17B4  26E9      	ADDWF FSR0L, F
17B6  0E04      	MOVLW 0x04
17B8  62EF      	CPFSEQ INDF0
17BA  D038      	BRA	label120
182C            label120

				{

					// Appel d'une Macro
					// Appel d'une Macro: Touche_Coule_SM()
					FCM_Touche_Coule_SM();
17BC  ECD5F006  	CALL FCM_Touche_0006A


					// Décision
					// Décision: Sous_marin = 0?
					if (FCV_SOUS_MARIN == 0)
17C0  53A7      	MOVF gbl_FCV_SOUS_MARIN, F, 1
17C2  E166      	BNZ	label122

					{

						// Appel d'une Macro
						// Appel d'une Macro: Reinitialisation_texte()
						FCM_Reinitialisation_texte();
17C4  ECEFF001  	CALL FCM_Reinit_00070


						// Pause
						// Pause: 100 ms
						FCI_DELAYBYTE_MS(100);
17C8  0E64      	MOVLW 0x64
17CA  6FBE      	MOVWF delay_ms_00000_arg_del, 1
17CC  EC06F000  	CALL delay_ms_00000


						// Appel de la Routine Composant
						// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
						FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
17D0  0E20      	MOVLW 0x20
17D2  6FC0      	MOVWF CompTempVar2802, 1
17D4  6FC1      	MOVWF CompTempVar2802+D'1', 1
17D6  6FC2      	MOVWF CompTempVar2802+D'2', 1
17D8  6FC3      	MOVWF CompTempVar2802+D'3', 1
17DA  6FC4      	MOVWF CompTempVar2802+D'4', 1
17DC  6FC5      	MOVWF CompTempVar2802+D'5', 1
17DE  6FC6      	MOVWF CompTempVar2802+D'6', 1
17E0  6FC7      	MOVWF CompTempVar2802+D'7', 1
17E2  6FC8      	MOVWF CompTempVar2802+D'8', 1
17E4  6FC9      	MOVWF CompTempVar2802+D'9', 1
17E6  6FCA      	MOVWF CompTempVar2802+D'10', 1
17E8  6FCB      	MOVWF CompTempVar2802+D'11', 1
17EA  6FD1      	MOVWF CompTempVar2802+D'17', 1
17EC  6FD2      	MOVWF CompTempVar2802+D'18', 1
17EE  6FD3      	MOVWF CompTempVar2802+D'19', 1
17F0  0E43      	MOVLW 0x43
17F2  6FCC      	MOVWF CompTempVar2802+D'12', 1
17F4  0E65      	MOVLW 0x65
17F6  6FD0      	MOVWF CompTempVar2802+D'16', 1
17F8  0E6C      	MOVLW 0x6C
17FA  6FCF      	MOVWF CompTempVar2802+D'15', 1
17FC  0E6F      	MOVLW 0x6F
17FE  6FCD      	MOVWF CompTempVar2802+D'13', 1
1800  0E75      	MOVLW 0x75
1802  6FCE      	MOVWF CompTempVar2802+D'14', 1
1804  6BD4      	CLRF CompTempVar2802+D'20', 1
1806  0E00      	MOVLW HIGH(CompTempVar2802+D'0')
1808  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
180A  0EC0      	MOVLW LOW(CompTempVar2802+D'0')
180C  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
180E  0E15      	MOVLW 0x15
1810  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1812  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
1814  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1816  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1818  0EF1      	MOVLW 0xF1
181A  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
181C  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
181E  0E02      	MOVLW 0x02
1820  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
1822  0E01      	MOVLW 0x01
1824  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1826  EC3CF003  	CALL FCD_0f051__0005D


					// } else {

					}

				} else {
182A  D032      	BRA	label122


					// Décision
					// Décision: tableau[hitbox] = 0b00000101?
					if (FCV_TABLEAU[FCV_HITBOX] == 5)
182C  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
1830  50E9      	MOVF FSR0L, W
1832  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1834  26E9      	ADDWF FSR0L, F
1836  0E05      	MOVLW 0x05
1838  62EF      	CPFSEQ INDF0
183A  D028      	BRA	label121
188C            label121

					{

						// Appel d'une Macro
						// Appel d'une Macro: Touche_Coule_TORP()
						FCM_Touche_Coule_TORP();
183C  EC8FF007  	CALL FCM_Touche_0005B


						// Décision
						// Décision: Torpilleur = 0?
						if (FCV_TORPILLEUR == 0)
1840  53A4      	MOVF gbl_FCV_TORPILLEUR, F, 1
1842  E126      	BNZ	label122

						{

							// Appel d'une Macro
							// Appel d'une Macro: Reinitialisation_texte()
							FCM_Reinitialisation_texte();
1844  ECEFF001  	CALL FCM_Reinit_00070


							// Pause
							// Pause: 100 ms
							FCI_DELAYBYTE_MS(100);
1848  0E64      	MOVLW 0x64
184A  6FBE      	MOVWF delay_ms_00000_arg_del, 1
184C  EC06F000  	CALL delay_ms_00000


							// Appel de la Routine Composant
							// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Coule", 0, 241, 2, 1)
							FCD_0f051_gLCD_EB076_4D1__Print("Coule", 6, 0, 241, 2, 1);
1850  0E43      	MOVLW 0x43
1852  6FC0      	MOVWF CompTempVar2805, 1
1854  0E6F      	MOVLW 0x6F
1856  6FC1      	MOVWF CompTempVar2805+D'1', 1
1858  0E75      	MOVLW 0x75
185A  6FC2      	MOVWF CompTempVar2805+D'2', 1
185C  0E6C      	MOVLW 0x6C
185E  6FC3      	MOVWF CompTempVar2805+D'3', 1
1860  0E65      	MOVLW 0x65
1862  6FC4      	MOVWF CompTempVar2805+D'4', 1
1864  6BC5      	CLRF CompTempVar2805+D'5', 1
1866  0E00      	MOVLW HIGH(CompTempVar2805+D'0')
1868  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
186A  0EC0      	MOVLW LOW(CompTempVar2805+D'0')
186C  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
186E  0E06      	MOVLW 0x06
1870  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1872  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
1874  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1876  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1878  0EF1      	MOVLW 0xF1
187A  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
187C  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
187E  0E02      	MOVLW 0x02
1880  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
1882  0E01      	MOVLW 0x01
1884  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1886  EC3CF003  	CALL FCD_0f051__0005D


						// } else {

						}

					} else {
188A  D002      	BRA	label122
1890            label122


						// Manque
						// Appel d'une Macro: Manque()
						FCM_Manque();
188C  ECEEF008  	CALL FCM_Manque_00000


					}

				}

			}

		}

	}

	// Calcul
	// Calcul:
	//  X_SORTIE = 0
	//  X = 0
	//  Y = 0
	//  Appui_Ecran = 0
	FCV_X_SORTIE = 0;
1890  0100      	MOVLB 0x00
1892  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1894  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_X = 0;
1896  6B8E      	CLRF gbl_FCV_X, 1
1898  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
189A  6B8C      	CLRF gbl_FCV_Y, 1
189C  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_APPUI_ECRAN = 0;
189E  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1


	// 
	// Décision: (Torpilleur & Croiseur & Porte_avion & Contre_torpilleur & Sous_marin) = 0?
	if ((FCV_TORPILLEUR & FCV_CROISEUR & FCV_PORTE_AVION & FCV_CONTRE_TORPILLEUR & FCV_SOUS_MARIN) == 0)
18A0  51A3      	MOVF gbl_FCV_CROISEUR, W, 1
18A2  15A4      	ANDWF gbl_FCV_TORPILLEUR, W, 1
18A4  6FB7      	MOVWF CompTempVar2785, 1
18A6  51AB      	MOVF gbl_FCV_PORTE_AVION, W, 1
18A8  17B7      	ANDWF CompTempVar2785, F, 1
18AA  51AD      	MOVF gbl_FCV_CONTRE_TORPILLEUR, W, 1
18AC  17B7      	ANDWF CompTempVar2785, F, 1
18AE  51A7      	MOVF gbl_FCV_SOUS_MARIN, W, 1
18B0  17B7      	ANDWF CompTempVar2785, F, 1
18B2  53B7      	MOVF CompTempVar2785, F, 1
18B4  B4D8      	BTFSC STATUS,Z

	{

		// Appel d'une Macro
		// Appel d'une Macro: Fin_Jeu()
		FCM_Fin_Jeu();
18B6  EC3BF009  	CALL FCM_Fin_Je_00074


	// } else {

	}

	// Pause
	// Pause: 100 ms
	FCI_DELAYBYTE_MS(100);
18BA  0E64      	MOVLW 0x64
18BC  6FBE      	MOVWF delay_ms_00000_arg_del, 1
18BE  EC06F000  	CALL delay_ms_00000


}
18C2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_tactile()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_DisableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
07E4  ECA1F002  	CALL FCD_0f051__00076


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_EnableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
07E8  EC6BF002  	CALL FCD_0f051__00077


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_SetTouchRegionPicaso(0, 0, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(0, 0, 240, 240);
07EC  6BBE      	CLRF FCD_0f051__0006E_arg_FCL_X1, 1
07EE  6BBF      	CLRF FCD_0f051__0006E_arg_FCL_X1+D'1', 1
07F0  6BC0      	CLRF FCD_0f051__0006E_arg_FCL_Y1, 1
07F2  6BC1      	CLRF FCD_0f051__0006E_arg_FCL_Y1+D'1', 1
07F4  0EF0      	MOVLW 0xF0
07F6  6FC2      	MOVWF FCD_0f051__0006E_arg_FCL_X2, 1
07F8  6BC3      	CLRF FCD_0f051__0006E_arg_FCL_X2+D'1', 1
07FA  0EF0      	MOVLW 0xF0
07FC  6FC4      	MOVWF FCD_0f051__0006E_arg_FCL_Y2, 1
07FE  6BC5      	CLRF FCD_0f051__0006E_arg_FCL_Y2+D'1', 1
0800  ECC1F002  	CALL FCD_0f051__0006E


}
0804  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Choix_Bateau_Toucher()

{

	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_texte()
	FCM_Reinitialisation_texte();
1958  ECEFF001  	CALL FCM_Reinit_00070


	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_tactile()
	FCM_Reinitialisation_tactile();
195C  ECF2F003  	CALL FCM_Reinit_00075


	// Boucle
	// Boucle: While Appui_Ecran = 0
	while (FCV_APPUI_ECRAN == 0)
1960            label134
1960  53A8      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
1962  E103      	BNZ	label135
1968  D7FB      	BRA	label134
196A            label135

	{

		// Appel d'une Macro
		// Appel d'une Macro: Recuperation_coordonees()
		FCM_Recuperation_coordonees();
1964  EC03F004  	CALL FCM_Recupe_00079



	}

	// Appel d'une Macro
	// Appel d'une Macro: Lecture_Coordonnes()
	FCM_Lecture_Coordonnes();
196A  ECAEF005  	CALL FCM_Lectur_00067


	// Pause
	// Pause: 100 ms
	FCI_DELAYBYTE_MS(100);
196E  0E64      	MOVLW 0x64
1970  6FBE      	MOVWF delay_ms_00000_arg_del, 1
1972  EC06F000  	CALL delay_ms_00000


}
1976  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Choix_Bateaux()

{

	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_texte()
	FCM_Reinitialisation_texte();
13D0  ECEFF001  	CALL FCM_Reinit_00070


	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_tactile()
	FCM_Reinitialisation_tactile();
13D4  ECF2F003  	CALL FCM_Reinit_00075


	// Appel d'une Macro
	// Appel d'une Macro: Message_bateau()
	FCM_Message_bateau();
13D8  EC08F004  	CALL FCM_Messag_0006F


	// Boucle
	// Boucle: While Appui_Ecran = 0
	while (FCV_APPUI_ECRAN == 0)
13DC            label102
13DC  0100      	MOVLB 0x00
13DE  53A8      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
13E0  E103      	BNZ	label103
13E6  D7FA      	BRA	label102
13E8            label103

	{

		// Appel d'une Macro
		// Appel d'une Macro: Recuperation_coordonees()
		FCM_Recuperation_coordonees();
13E2  EC03F004  	CALL FCM_Recupe_00079



	}

	// Appel d'une Macro
	// Appel d'une Macro: Lecture_Coordonnes()
	FCM_Lecture_Coordonnes();
13E8  ECAEF005  	CALL FCM_Lectur_00067


	#if 0 // Disabled code
	// Appel d'une Macro
	// Appel d'une Macro: Hitbox_v2()
	FCM_Hitbox_v2();

	#endif // #if 0: Disabled code
	// Pause
	// Pause: 100 ms
	FCI_DELAYBYTE_MS(100);
13EC  0E64      	MOVLW 0x64
13EE  6FBE      	MOVWF delay_ms_00000_arg_del, 1
13F0  EC06F000  	CALL delay_ms_00000


}
13F4  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_affichage_bateau()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 0, 0, 255)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 0, 0, 255);
07AA  0100      	MOVLB 0x00
07AC  518E      	MOVF gbl_FCV_X, W, 1
07AE  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
07B0  518F      	MOVF gbl_FCV_X+D'1', W, 1
07B2  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
07B4  0E18      	MOVLW 0x18
07B6  5D8E      	SUBWF gbl_FCV_X, W, 1
07B8  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
07BA  598E      	SUBWFB gbl_FCV_X, W, 1
07BC  0818      	SUBLW 0x18
07BE  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
07C0  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
07C2  518C      	MOVF gbl_FCV_Y, W, 1
07C4  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
07C6  518D      	MOVF gbl_FCV_Y+D'1', W, 1
07C8  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
07CA  0E18      	MOVLW 0x18
07CC  5D8C      	SUBWF gbl_FCV_Y, W, 1
07CE  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
07D0  598C      	SUBWFB gbl_FCV_Y, W, 1
07D2  0818      	SUBLW 0x18
07D4  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
07D6  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
07D8  6BC6      	CLRF FCM_parame_0005C_arg_FCL_ROUGE, 1
07DA  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
07DC  69C8      	SETF FCM_parame_0005C_arg_FCL_BLEU, 1
07DE  ECD1F001  	CALL FCM_parame_0005C


}
07E2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Sous_marin()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
1084  0E01      	MOVLW 0x01
1086  0100      	MOVLB 0x00
1088  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
108A  0E18      	MOVLW 0x18
108C  6F8C      	MOVWF gbl_FCV_Y, 1
108E  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
1090  0E18      	MOVLW 0x18
1092  6F8E      	MOVWF gbl_FCV_X, 1
1094  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
1096            label66
1096  0E01      	MOVLW 0x01
1098  0100      	MOVLB 0x00
109A  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
109C  E236      	BC	label74
109E  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
10A0  D034      	BRA	label74
1108  D7C6      	BRA	label66
110A            label74

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
10A2  518D      	MOVF gbl_FCV_Y+D'1', W, 1
10A4  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
10A6  E102      	BNZ	label67
10A8  518C      	MOVF gbl_FCV_Y, W, 1
10AA  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
10AC            label67
10AC  E223      	BC	label73
10AE            label68
10F4            label73

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
10AE  518F      	MOVF gbl_FCV_X+D'1', W, 1
10B0  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
10B2  E102      	BNZ	label69
10B4  518E      	MOVF gbl_FCV_X, W, 1
10B6  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
10B8            label69
10B8  E309      	BNC	label70

				{

				} else {
10CC            label70


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
10BA  29A6      	INCF gbl_FCV_HITBOX, W, 1
10BC  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
10BE  6BBF      	CLRF CompTempVar2690, 1
10C0  0E18      	MOVLW 0x18
10C2  278E      	ADDWF gbl_FCV_X, F, 1
10C4  518F      	MOVF gbl_FCV_X+D'1', W, 1
10C6  23BF      	ADDWFC CompTempVar2690, F, 1
10C8  51BF      	MOVF CompTempVar2690, W, 1
10CA  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
10CC  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
10CE  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
10D0  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
10D2  B4D8      	BTFSC STATUS,Z
10D4  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
10D6  6BBE      	CLRF CompTempVar2688, 1
10D8  518F      	MOVF gbl_FCV_X+D'1', W, 1
10DA  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
10DC  E104      	BNZ	label71
10DE  518E      	MOVF gbl_FCV_X, W, 1
10E0  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
10E2  D001      	BRA	label71
10E4  D001      	BRA	label72
10E6            label71
10E6  A0D8      	BTFSS STATUS,C
10E8  71BE      	BTG CompTempVar2688,0, 1
10EA  53BE      	MOVF CompTempVar2688, F, 1
10EC  E0E0      	BZ	label68

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
10EE  ECD5F003  	CALL FCM_affich_00069


		} else {
10F2  D7D1      	BRA	label66


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
10F4  0E0A      	MOVLW 0x0A
10F6  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
10F8  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
10FA  6BBE      	CLRF CompTempVar2694, 1
10FC  0E18      	MOVLW 0x18
10FE  278C      	ADDWF gbl_FCV_Y, F, 1
1100  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1102  23BE      	ADDWFC CompTempVar2694, F, 1
1104  51BE      	MOVF CompTempVar2694, W, 1
1106  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000100
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Sous_marin = Sous_marin + 1
	FCV_TABLEAU[FCV_HITBOX] = 4;
110A  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
110E  50E9      	MOVF FSR0L, W
1110  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1112  26E9      	ADDWF FSR0L, F
1114  0E04      	MOVLW 0x04
1116  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
1118  29AA      	INCF gbl_FCV_BATEAU, W, 1
111A  6FAA      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
111C  6B86      	CLRF gbl_FCV_X_SORTIE, 1
111E  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
1120  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
1122  6B8E      	CLRF gbl_FCV_X, 1
1124  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
1126  6B8C      	CLRF gbl_FCV_Y, 1
1128  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_SOUS_MARIN = FCV_SOUS_MARIN + 1;
112A  29A7      	INCF gbl_FCV_SOUS_MARIN, W, 1
112C  6FA7      	MOVWF gbl_FCV_SOUS_MARIN, 1


}
112E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro parametres_bateau :
       :  pos_x1 : MX_UINT16
       :  pos_x2 : MX_UINT16
       :  pos_y1 : MX_UINT16
       :  pos_y2 : MX_UINT16
       :  Rouge : MX_UINT8
       :  Vert : MX_UINT8
       :  Bleu : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2, MX_UINT8 FCL_ROUGE, MX_UINT8 FCL_VERT, MX_UINT8 FCL_BLEU)

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(.Rouge, .Vert, .Bleu)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(FCL_ROUGE, FCL_VERT, FCL_BLEU);
03A2  51C6      	MOVF FCM_parame_0005C_arg_FCL_ROUGE, W, 1
03A4  6FC9      	MOVWF FCD_0f051__0007A_arg_FCL_RED, 1
03A6  51C7      	MOVF FCM_parame_0005C_arg_FCL_VERT, W, 1
03A8  6FCA      	MOVWF FCD_0f051__0007A_arg_FCL_GREEN, 1
03AA  51C8      	MOVF FCM_parame_0005C_arg_FCL_BLEU, W, 1
03AC  6FCB      	MOVWF FCD_0f051__0007A_arg_FCL_BLUE, 1
03AE  ECA3F001  	CALL FCD_0f051__0007A


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(.pos_x1, .pos_y1, .pos_x2, .pos_y2, 0, 1)
	FCD_0f051_gLCD_EB076_4D1__DrawRectangle(FCL_POS_X1, FCL_POS_Y1, FCL_POS_X2, FCL_POS_Y2, 0, 1);
03B2  51BE      	MOVF FCM_parame_0005C_arg_FCL_POS_X1, W, 1
03B4  6FC9      	MOVWF FCD_0f051__0007B_arg_FCL_X1, 1
03B6  51BF      	MOVF FCM_parame_0005C_arg_FCL_POS_X1+D'1', W, 1
03B8  6FCA      	MOVWF FCD_0f051__0007B_arg_FCL_X1+D'1', 1
03BA  51C2      	MOVF FCM_parame_0005C_arg_FCL_POS_Y1, W, 1
03BC  6FCB      	MOVWF FCD_0f051__0007B_arg_FCL_Y1, 1
03BE  51C3      	MOVF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', W, 1
03C0  6FCC      	MOVWF FCD_0f051__0007B_arg_FCL_Y1+D'1', 1
03C2  51C0      	MOVF FCM_parame_0005C_arg_FCL_POS_X2, W, 1
03C4  6FCD      	MOVWF FCD_0f051__0007B_arg_FCL_X2, 1
03C6  51C1      	MOVF FCM_parame_0005C_arg_FCL_POS_X2+D'1', W, 1
03C8  6FCE      	MOVWF FCD_0f051__0007B_arg_FCL_X2+D'1', 1
03CA  51C4      	MOVF FCM_parame_0005C_arg_FCL_POS_Y2, W, 1
03CC  6FCF      	MOVWF FCD_0f051__0007B_arg_FCL_Y2, 1
03CE  51C5      	MOVF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', W, 1
03D0  6FD0      	MOVWF FCD_0f051__0007B_arg_FCL_Y2+D'1', 1
03D2  6BD1      	CLRF FCD_0f051__0007B_arg_FCL_T_0007C, 1
03D4  0E01      	MOVLW 0x01
03D6  6FD2      	MOVWF FCD_0f051__0007B_arg_FCL_SOLID, 1
03D8  ECBBF000  	CALL FCD_0f051__0007B


}
03DC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_texte()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(255, 255, 255)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(255, 255, 255);
03DE  0100      	MOVLB 0x00
03E0  69C9      	SETF FCD_0f051__0007A_arg_FCL_RED, 1
03E2  69CA      	SETF FCD_0f051__0007A_arg_FCL_GREEN, 1
03E4  69CB      	SETF FCD_0f051__0007A_arg_FCL_BLUE, 1
03E6  ECA3F001  	CALL FCD_0f051__0007A


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 241, 240, 320, 1, 1)
	FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 241, 240, 320, 1, 1);
03EA  6BC9      	CLRF FCD_0f051__0007B_arg_FCL_X1, 1
03EC  6BCA      	CLRF FCD_0f051__0007B_arg_FCL_X1+D'1', 1
03EE  0EF1      	MOVLW 0xF1
03F0  6FCB      	MOVWF FCD_0f051__0007B_arg_FCL_Y1, 1
03F2  6BCC      	CLRF FCD_0f051__0007B_arg_FCL_Y1+D'1', 1
03F4  0EF0      	MOVLW 0xF0
03F6  6FCD      	MOVWF FCD_0f051__0007B_arg_FCL_X2, 1
03F8  6BCE      	CLRF FCD_0f051__0007B_arg_FCL_X2+D'1', 1
03FA  0E40      	MOVLW 0x40
03FC  6FCF      	MOVWF FCD_0f051__0007B_arg_FCL_Y2, 1
03FE  0E01      	MOVLW 0x01
0400  6FD0      	MOVWF FCD_0f051__0007B_arg_FCL_Y2+D'1', 1
0402  6FD1      	MOVWF FCD_0f051__0007B_arg_FCL_T_0007C, 1
0404  6FD2      	MOVWF FCD_0f051__0007B_arg_FCL_SOLID, 1
0406  ECBBF000  	CALL FCD_0f051__0007B


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(0, 0, 0)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(0, 0, 0);
040A  0100      	MOVLB 0x00
040C  6BC9      	CLRF FCD_0f051__0007A_arg_FCL_RED, 1
040E  6BCA      	CLRF FCD_0f051__0007A_arg_FCL_GREEN, 1
0410  6BCB      	CLRF FCD_0f051__0007A_arg_FCL_BLUE, 1
0412  ECA3F001  	CALL FCD_0f051__0007A


}
0416  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Appui_tactile()
{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	#if 0 // Disabled code
	//Commentaire:
	//Coordonnée pour X

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: X=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);

	#if 0 // Disabled code
	//Commentaire:
	//Coordonée pour Y

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(X, 80, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_X, 80, 150, 2, 1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(Y, 120, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_Y, 120, 150, 2, 1);

	// Pause
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	// Calcul
	// Calcul:
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	FCV_APPUI_ECRAN = 0;
	FCV_X = 0;
	FCV_Y = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Manque()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 0, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 0, 0, 0);
11DC  0100      	MOVLB 0x00
11DE  518E      	MOVF gbl_FCV_X, W, 1
11E0  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
11E2  518F      	MOVF gbl_FCV_X+D'1', W, 1
11E4  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
11E6  0E18      	MOVLW 0x18
11E8  5D8E      	SUBWF gbl_FCV_X, W, 1
11EA  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
11EC  598E      	SUBWFB gbl_FCV_X, W, 1
11EE  0818      	SUBLW 0x18
11F0  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
11F2  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
11F4  518C      	MOVF gbl_FCV_Y, W, 1
11F6  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
11F8  518D      	MOVF gbl_FCV_Y+D'1', W, 1
11FA  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
11FC  0E18      	MOVLW 0x18
11FE  5D8C      	SUBWF gbl_FCV_Y, W, 1
1200  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
1202  598C      	SUBWFB gbl_FCV_Y, W, 1
1204  0818      	SUBLW 0x18
1206  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
1208  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
120A  6BC6      	CLRF FCM_parame_0005C_arg_FCL_ROUGE, 1
120C  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
120E  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
1210  ECD1F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Manque   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Manque   ", 22, 0, 241, 2, 1);
1214  0E20      	MOVLW 0x20
1216  0100      	MOVLB 0x00
1218  6FC0      	MOVWF CompTempVar2830, 1
121A  6FC1      	MOVWF CompTempVar2830+D'1', 1
121C  6FC2      	MOVWF CompTempVar2830+D'2', 1
121E  6FC3      	MOVWF CompTempVar2830+D'3', 1
1220  6FC4      	MOVWF CompTempVar2830+D'4', 1
1222  6FC5      	MOVWF CompTempVar2830+D'5', 1
1224  6FC6      	MOVWF CompTempVar2830+D'6', 1
1226  6FC7      	MOVWF CompTempVar2830+D'7', 1
1228  6FC8      	MOVWF CompTempVar2830+D'8', 1
122A  6FC9      	MOVWF CompTempVar2830+D'9', 1
122C  6FCA      	MOVWF CompTempVar2830+D'10', 1
122E  6FCB      	MOVWF CompTempVar2830+D'11', 1
1230  6FD2      	MOVWF CompTempVar2830+D'18', 1
1232  6FD3      	MOVWF CompTempVar2830+D'19', 1
1234  6FD4      	MOVWF CompTempVar2830+D'20', 1
1236  0E4D      	MOVLW 0x4D
1238  6FCC      	MOVWF CompTempVar2830+D'12', 1
123A  0E61      	MOVLW 0x61
123C  6FCD      	MOVWF CompTempVar2830+D'13', 1
123E  0E65      	MOVLW 0x65
1240  6FD1      	MOVWF CompTempVar2830+D'17', 1
1242  0E6E      	MOVLW 0x6E
1244  6FCE      	MOVWF CompTempVar2830+D'14', 1
1246  0E71      	MOVLW 0x71
1248  6FCF      	MOVWF CompTempVar2830+D'15', 1
124A  0E75      	MOVLW 0x75
124C  6FD0      	MOVWF CompTempVar2830+D'16', 1
124E  6BD5      	CLRF CompTempVar2830+D'21', 1
1250  0E00      	MOVLW HIGH(CompTempVar2830+D'0')
1252  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1254  0EC0      	MOVLW LOW(CompTempVar2830+D'0')
1256  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
1258  0E16      	MOVLW 0x16
125A  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
125C  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
125E  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1260  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1262  0EF1      	MOVLW 0xF1
1264  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
1266  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
1268  0E02      	MOVLW 0x02
126A  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
126C  0E01      	MOVLW 0x01
126E  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1270  EC3CF003  	CALL FCD_0f051__0005D


}
1274  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Recuperation_coordonees()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Appui_Ecran=gLCD_EB076_4D1::G4D_GetTouchCoordinatesPicaso()
	FCV_APPUI_ECRAN = FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
0806  EC0CF002  	CALL FCD_0f051__00080
080A  51C0      	MOVF CompTempVarRet2868, W, 1
080C  6FA8      	MOVWF gbl_FCV_APPUI_ECRAN, 1


}
080E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_phase_debut()

{

	// Boucle
	// Boucle: While bateau >= 17
	while (1)
1B36            label142

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_texte()
		FCM_Reinitialisation_texte();
1B36  ECEFF001  	CALL FCM_Reinit_00070


		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_tactile()
		FCM_Reinitialisation_tactile();
1B3A  ECF2F003  	CALL FCM_Reinit_00075


		// Appel d'une Macro
		// Appel d'une Macro: Message_bateau()
		FCM_Message_bateau();
1B3E  EC08F004  	CALL FCM_Messag_0006F


		// Boucle
		// Boucle: While Appui_Ecran = 0
		while (FCV_APPUI_ECRAN == 0)
1B42            label143
1B42  0100      	MOVLB 0x00
1B44  53A8      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
1B46  E103      	BNZ	label144
1B4C  D7FA      	BRA	label143
1B4E            label144

		{

			// Appel d'une Macro
			// Appel d'une Macro: Recuperation_coordonees()
			FCM_Recuperation_coordonees();
1B48  EC03F004  	CALL FCM_Recupe_00079



		}

		// Appel d'une Macro
		// Appel d'une Macro: Lecture_Coordonnes()
		FCM_Lecture_Coordonnes();
1B4E  ECAEF005  	CALL FCM_Lectur_00067


		// Appel d'une Macro
		// Appel d'une Macro: Hitbox_v2()
		FCM_Hitbox_v2();
1B52  EC62F00C  	CALL FCM_Hitbox_0005F


		// Pause
		// Pause: 100 ms
		FCI_DELAYBYTE_MS(100);
1B56  0E64      	MOVLW 0x64
1B58  6FBE      	MOVWF delay_ms_00000_arg_del, 1
1B5A  EC06F000  	CALL delay_ms_00000



		if ((FCV_BATEAU >= 17) != 0) break;
1B5E  6BB7      	CLRF CompTempVar2877, 1
1B60  0E11      	MOVLW 0x11
1B62  61AA      	CPFSLT gbl_FCV_BATEAU, 1
1B64  2BB7      	INCF CompTempVar2877, F, 1
1B66  53B7      	MOVF CompTempVar2877, F, 1
1B68  E0E6      	BZ	label142

	}

	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_texte()
	FCM_Reinitialisation_texte();
1B6A  ECEFF001  	CALL FCM_Reinit_00070


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("    En attente du joueur 2 ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("    En attente du joueur 2 ", 28, 0, 241, 2, 1);
1B6E  0E20      	MOVLW 0x20
1B70  6FC0      	MOVWF CompTempVar2878, 1
1B72  6FC1      	MOVWF CompTempVar2878+D'1', 1
1B74  6FC2      	MOVWF CompTempVar2878+D'2', 1
1B76  6FC3      	MOVWF CompTempVar2878+D'3', 1
1B78  6FC6      	MOVWF CompTempVar2878+D'6', 1
1B7A  6FCE      	MOVWF CompTempVar2878+D'14', 1
1B7C  6FD1      	MOVWF CompTempVar2878+D'17', 1
1B7E  6FD8      	MOVWF CompTempVar2878+D'24', 1
1B80  6FDA      	MOVWF CompTempVar2878+D'26', 1
1B82  0E32      	MOVLW 0x32
1B84  6FD9      	MOVWF CompTempVar2878+D'25', 1
1B86  0E45      	MOVLW 0x45
1B88  6FC4      	MOVWF CompTempVar2878+D'4', 1
1B8A  0E61      	MOVLW 0x61
1B8C  6FC7      	MOVWF CompTempVar2878+D'7', 1
1B8E  0E64      	MOVLW 0x64
1B90  6FCF      	MOVWF CompTempVar2878+D'15', 1
1B92  0E65      	MOVLW 0x65
1B94  6FCA      	MOVWF CompTempVar2878+D'10', 1
1B96  6FCD      	MOVWF CompTempVar2878+D'13', 1
1B98  6FD5      	MOVWF CompTempVar2878+D'21', 1
1B9A  0E6A      	MOVLW 0x6A
1B9C  6FD2      	MOVWF CompTempVar2878+D'18', 1
1B9E  0E6E      	MOVLW 0x6E
1BA0  6FC5      	MOVWF CompTempVar2878+D'5', 1
1BA2  6FCB      	MOVWF CompTempVar2878+D'11', 1
1BA4  0E6F      	MOVLW 0x6F
1BA6  6FD3      	MOVWF CompTempVar2878+D'19', 1
1BA8  0E72      	MOVLW 0x72
1BAA  6FD7      	MOVWF CompTempVar2878+D'23', 1
1BAC  0E74      	MOVLW 0x74
1BAE  6FC8      	MOVWF CompTempVar2878+D'8', 1
1BB0  6FC9      	MOVWF CompTempVar2878+D'9', 1
1BB2  6FCC      	MOVWF CompTempVar2878+D'12', 1
1BB4  0E75      	MOVLW 0x75
1BB6  6FD0      	MOVWF CompTempVar2878+D'16', 1
1BB8  6FD4      	MOVWF CompTempVar2878+D'20', 1
1BBA  6FD6      	MOVWF CompTempVar2878+D'22', 1
1BBC  6BDB      	CLRF CompTempVar2878+D'27', 1
1BBE  0E00      	MOVLW HIGH(CompTempVar2878+D'0')
1BC0  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1BC2  0EC0      	MOVLW LOW(CompTempVar2878+D'0')
1BC4  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
1BC6  0E1C      	MOVLW 0x1C
1BC8  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1BCA  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
1BCC  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1BCE  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1BD0  0EF1      	MOVLW 0xF1
1BD2  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
1BD4  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
1BD6  0E02      	MOVLW 0x02
1BD8  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
1BDA  0E01      	MOVLW 0x01
1BDC  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1BDE  EC3CF003  	CALL FCD_0f051__0005D


}
1BE2  EF29F00E  	GOTO	label148


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Fin_Jeu()

{

}
1276  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_Coule_CT()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0C50  0100      	MOVLB 0x00
0C52  518E      	MOVF gbl_FCV_X, W, 1
0C54  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
0C56  518F      	MOVF gbl_FCV_X+D'1', W, 1
0C58  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
0C5A  0E18      	MOVLW 0x18
0C5C  5D8E      	SUBWF gbl_FCV_X, W, 1
0C5E  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
0C60  598E      	SUBWFB gbl_FCV_X, W, 1
0C62  0818      	SUBLW 0x18
0C64  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0C66  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
0C68  518C      	MOVF gbl_FCV_Y, W, 1
0C6A  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
0C6C  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0C6E  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
0C70  0E18      	MOVLW 0x18
0C72  5D8C      	SUBWF gbl_FCV_Y, W, 1
0C74  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
0C76  598C      	SUBWFB gbl_FCV_Y, W, 1
0C78  0818      	SUBLW 0x18
0C7A  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0C7C  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
0C7E  69C6      	SETF FCM_parame_0005C_arg_FCL_ROUGE, 1
0C80  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
0C82  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
0C84  ECD1F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0C88  0E20      	MOVLW 0x20
0C8A  0100      	MOVLB 0x00
0C8C  6FC0      	MOVWF CompTempVar2824, 1
0C8E  6FC1      	MOVWF CompTempVar2824+D'1', 1
0C90  6FC2      	MOVWF CompTempVar2824+D'2', 1
0C92  6FC3      	MOVWF CompTempVar2824+D'3', 1
0C94  6FC4      	MOVWF CompTempVar2824+D'4', 1
0C96  6FC5      	MOVWF CompTempVar2824+D'5', 1
0C98  6FC6      	MOVWF CompTempVar2824+D'6', 1
0C9A  6FC7      	MOVWF CompTempVar2824+D'7', 1
0C9C  6FC8      	MOVWF CompTempVar2824+D'8', 1
0C9E  6FC9      	MOVWF CompTempVar2824+D'9', 1
0CA0  6FCA      	MOVWF CompTempVar2824+D'10', 1
0CA2  6FCB      	MOVWF CompTempVar2824+D'11', 1
0CA4  6FD2      	MOVWF CompTempVar2824+D'18', 1
0CA6  6FD3      	MOVWF CompTempVar2824+D'19', 1
0CA8  6FD4      	MOVWF CompTempVar2824+D'20', 1
0CAA  0E54      	MOVLW 0x54
0CAC  6FCC      	MOVWF CompTempVar2824+D'12', 1
0CAE  0E63      	MOVLW 0x63
0CB0  6FCF      	MOVWF CompTempVar2824+D'15', 1
0CB2  0E65      	MOVLW 0x65
0CB4  6FD1      	MOVWF CompTempVar2824+D'17', 1
0CB6  0E68      	MOVLW 0x68
0CB8  6FD0      	MOVWF CompTempVar2824+D'16', 1
0CBA  0E6F      	MOVLW 0x6F
0CBC  6FCD      	MOVWF CompTempVar2824+D'13', 1
0CBE  0E75      	MOVLW 0x75
0CC0  6FCE      	MOVWF CompTempVar2824+D'14', 1
0CC2  6BD5      	CLRF CompTempVar2824+D'21', 1
0CC4  0E00      	MOVLW HIGH(CompTempVar2824+D'0')
0CC6  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0CC8  0EC0      	MOVLW LOW(CompTempVar2824+D'0')
0CCA  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0CCC  0E16      	MOVLW 0x16
0CCE  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0CD0  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0CD2  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0CD4  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0CD6  0EF1      	MOVLW 0xF1
0CD8  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0CDA  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0CDC  0E02      	MOVLW 0x02
0CDE  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0CE0  0E01      	MOVLW 0x01
0CE2  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0CE4  EC3CF003  	CALL FCD_0f051__0005D


	// Calcul
	// Calcul:
	//  Contre_torpilleur = Contre_torpilleur - 1
	FCV_CONTRE_TORPILLEUR = FCV_CONTRE_TORPILLEUR - 1;
0CE8  0100      	MOVLB 0x00
0CEA  05AD      	DECF gbl_FCV_CONTRE_TORPILLEUR, W, 1
0CEC  6FAD      	MOVWF gbl_FCV_CONTRE_TORPILLEUR, 1


}
0CEE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_affichage_bateau_touche()
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Porte_avion()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
1130  0E01      	MOVLW 0x01
1132  0100      	MOVLB 0x00
1134  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
1136  0E18      	MOVLW 0x18
1138  6F8C      	MOVWF gbl_FCV_Y, 1
113A  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
113C  0E18      	MOVLW 0x18
113E  6F8E      	MOVWF gbl_FCV_X, 1
1140  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
1142            label75
1142  0E01      	MOVLW 0x01
1144  0100      	MOVLB 0x00
1146  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
1148  E236      	BC	label83
114A  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
114C  D034      	BRA	label83
11B4  D7C6      	BRA	label75
11B6            label83

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
114E  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1150  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
1152  E102      	BNZ	label76
1154  518C      	MOVF gbl_FCV_Y, W, 1
1156  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
1158            label76
1158  E223      	BC	label82
115A            label77
11A0            label82

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
115A  518F      	MOVF gbl_FCV_X+D'1', W, 1
115C  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
115E  E102      	BNZ	label78
1160  518E      	MOVF gbl_FCV_X, W, 1
1162  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
1164            label78
1164  E309      	BNC	label79

				{

				} else {
1178            label79


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
1166  29A6      	INCF gbl_FCV_HITBOX, W, 1
1168  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
116A  6BBF      	CLRF CompTempVar2666, 1
116C  0E18      	MOVLW 0x18
116E  278E      	ADDWF gbl_FCV_X, F, 1
1170  518F      	MOVF gbl_FCV_X+D'1', W, 1
1172  23BF      	ADDWFC CompTempVar2666, F, 1
1174  51BF      	MOVF CompTempVar2666, W, 1
1176  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
1178  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
117A  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
117C  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
117E  B4D8      	BTFSC STATUS,Z
1180  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
1182  6BBE      	CLRF CompTempVar2664, 1
1184  518F      	MOVF gbl_FCV_X+D'1', W, 1
1186  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1188  E104      	BNZ	label80
118A  518E      	MOVF gbl_FCV_X, W, 1
118C  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
118E  D001      	BRA	label80
1190  D001      	BRA	label81
1192            label80
1192  A0D8      	BTFSS STATUS,C
1194  71BE      	BTG CompTempVar2664,0, 1
1196  53BE      	MOVF CompTempVar2664, F, 1
1198  E0E0      	BZ	label77

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
119A  ECD5F003  	CALL FCM_affich_00069


		} else {
119E  D7D1      	BRA	label75


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
11A0  0E0A      	MOVLW 0x0A
11A2  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
11A4  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
11A6  6BBE      	CLRF CompTempVar2670, 1
11A8  0E18      	MOVLW 0x18
11AA  278C      	ADDWF gbl_FCV_Y, F, 1
11AC  518D      	MOVF gbl_FCV_Y+D'1', W, 1
11AE  23BE      	ADDWFC CompTempVar2670, F, 1
11B0  51BE      	MOVF CompTempVar2670, W, 1
11B2  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000001
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Porte_avion = Porte_avion + 1
	FCV_TABLEAU[FCV_HITBOX] = 1;
11B6  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
11BA  50E9      	MOVF FSR0L, W
11BC  51A6      	MOVF gbl_FCV_HITBOX, W, 1
11BE  26E9      	ADDWF FSR0L, F
11C0  0E01      	MOVLW 0x01
11C2  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
11C4  29AA      	INCF gbl_FCV_BATEAU, W, 1
11C6  6FAA      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
11C8  6B86      	CLRF gbl_FCV_X_SORTIE, 1
11CA  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
11CC  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
11CE  6B8E      	CLRF gbl_FCV_X, 1
11D0  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
11D2  6B8C      	CLRF gbl_FCV_Y, 1
11D4  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_PORTE_AVION = FCV_PORTE_AVION + 1;
11D6  29AB      	INCF gbl_FCV_PORTE_AVION, W, 1
11D8  6FAB      	MOVWF gbl_FCV_PORTE_AVION, 1


}
11DA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_coule_CR()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0CF0  0100      	MOVLB 0x00
0CF2  518E      	MOVF gbl_FCV_X, W, 1
0CF4  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
0CF6  518F      	MOVF gbl_FCV_X+D'1', W, 1
0CF8  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
0CFA  0E18      	MOVLW 0x18
0CFC  5D8E      	SUBWF gbl_FCV_X, W, 1
0CFE  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
0D00  598E      	SUBWFB gbl_FCV_X, W, 1
0D02  0818      	SUBLW 0x18
0D04  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0D06  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
0D08  518C      	MOVF gbl_FCV_Y, W, 1
0D0A  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
0D0C  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0D0E  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
0D10  0E18      	MOVLW 0x18
0D12  5D8C      	SUBWF gbl_FCV_Y, W, 1
0D14  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
0D16  598C      	SUBWFB gbl_FCV_Y, W, 1
0D18  0818      	SUBLW 0x18
0D1A  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0D1C  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
0D1E  69C6      	SETF FCM_parame_0005C_arg_FCL_ROUGE, 1
0D20  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
0D22  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
0D24  ECD1F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0D28  0E20      	MOVLW 0x20
0D2A  0100      	MOVLB 0x00
0D2C  6FC0      	MOVWF CompTempVar2814, 1
0D2E  6FC1      	MOVWF CompTempVar2814+D'1', 1
0D30  6FC2      	MOVWF CompTempVar2814+D'2', 1
0D32  6FC3      	MOVWF CompTempVar2814+D'3', 1
0D34  6FC4      	MOVWF CompTempVar2814+D'4', 1
0D36  6FC5      	MOVWF CompTempVar2814+D'5', 1
0D38  6FC6      	MOVWF CompTempVar2814+D'6', 1
0D3A  6FC7      	MOVWF CompTempVar2814+D'7', 1
0D3C  6FC8      	MOVWF CompTempVar2814+D'8', 1
0D3E  6FC9      	MOVWF CompTempVar2814+D'9', 1
0D40  6FCA      	MOVWF CompTempVar2814+D'10', 1
0D42  6FCB      	MOVWF CompTempVar2814+D'11', 1
0D44  6FD2      	MOVWF CompTempVar2814+D'18', 1
0D46  6FD3      	MOVWF CompTempVar2814+D'19', 1
0D48  6FD4      	MOVWF CompTempVar2814+D'20', 1
0D4A  0E54      	MOVLW 0x54
0D4C  6FCC      	MOVWF CompTempVar2814+D'12', 1
0D4E  0E63      	MOVLW 0x63
0D50  6FCF      	MOVWF CompTempVar2814+D'15', 1
0D52  0E65      	MOVLW 0x65
0D54  6FD1      	MOVWF CompTempVar2814+D'17', 1
0D56  0E68      	MOVLW 0x68
0D58  6FD0      	MOVWF CompTempVar2814+D'16', 1
0D5A  0E6F      	MOVLW 0x6F
0D5C  6FCD      	MOVWF CompTempVar2814+D'13', 1
0D5E  0E75      	MOVLW 0x75
0D60  6FCE      	MOVWF CompTempVar2814+D'14', 1
0D62  6BD5      	CLRF CompTempVar2814+D'21', 1
0D64  0E00      	MOVLW HIGH(CompTempVar2814+D'0')
0D66  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0D68  0EC0      	MOVLW LOW(CompTempVar2814+D'0')
0D6A  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0D6C  0E16      	MOVLW 0x16
0D6E  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0D70  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0D72  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0D74  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0D76  0EF1      	MOVLW 0xF1
0D78  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0D7A  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0D7C  0E02      	MOVLW 0x02
0D7E  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0D80  0E01      	MOVLW 0x01
0D82  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0D84  EC3CF003  	CALL FCD_0f051__0005D


	// Calcul
	// Calcul:
	//  Tableau[hitbox] = tableau[hitbox] || 0b00000011
	//  Croiseur = Croiseur - 1
	FCV_TABLEAU[FCV_HITBOX] = FCV_TABLEAU[FCV_HITBOX] || 3;
0D88  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0D8C  50E9      	MOVF FSR0L, W
0D8E  0100      	MOVLB 0x00
0D90  51A6      	MOVF gbl_FCV_HITBOX, W, 1
0D92  26E9      	ADDWF FSR0L, F
0D94  6BB8      	CLRF CompTempVar2818, 1
0D96  2BB8      	INCF CompTempVar2818, F, 1
0D98  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0D9A  6EE9      	MOVWF FSR0L
0D9C  51A6      	MOVF gbl_FCV_HITBOX, W, 1
0D9E  26E9      	ADDWF FSR0L, F
0DA0  51B8      	MOVF CompTempVar2818, W, 1
0DA2  6EEF      	MOVWF INDF0

	FCV_CROISEUR = FCV_CROISEUR - 1;
0DA4  05A3      	DECF gbl_FCV_CROISEUR, W, 1
0DA6  6FA3      	MOVWF gbl_FCV_CROISEUR, 1


}
0DA8  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Phase_jeu()

{

	// Boucle
	// Boucle: While 1
	while (1)
1BE6            label145
1BFA  D7F5      	BRA	label145

	{

		// 
		// Appel d'une Macro: Choix_Bateau_Toucher()
		FCM_Choix_Bateau_Toucher();
1BE6  ECACF00C  	CALL FCM_Choix__00078


		// Appel d'une Macro
		// Appel d'une Macro: Toucher_Couler()
		FCM_Toucher_Couler();
1BEA  ECD4F00A  	CALL FCM_Touche_00071


		// Pause
		// Pause: 500 ms
		FCI_DELAYINT_MS(500);
1BEE  0EF4      	MOVLW 0xF4
1BF0  6FB7      	MOVWF FCI_DELAYI_00046_arg_Delay, 1
1BF2  0E01      	MOVLW 0x01
1BF4  6FB8      	MOVWF FCI_DELAYI_00046_arg_Delay+D'1', 1
1BF6  ECBCF00C  	CALL FCI_DELAYI_00046



	}

}


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_lignes()

{

	// Calcul
	// Calcul:
	//  X_ligne = 24
	//  Y_ligne = 24
	FCV_X_LIGNE = 24;
151A  0E18      	MOVLW 0x18
151C  0100      	MOVLB 0x00
151E  6F8A      	MOVWF gbl_FCV_X_LIGNE, 1
1520  6B8B      	CLRF gbl_FCV_X_LIGNE+D'1', 1

	FCV_Y_LIGNE = 24;
1522  0E18      	MOVLW 0x18
1524  6F84      	MOVWF gbl_FCV_Y_LIGNE, 1
1526  6B85      	CLRF gbl_FCV_Y_LIGNE+D'1', 1


	// tracé des verticales
	// Boucle: While X_ligne = 240
	while (1)
1528            label104

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(X_ligne, 0, X_ligne, 240)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(FCV_X_LIGNE, 0, FCV_X_LIGNE, 240);
1528  518A      	MOVF gbl_FCV_X_LIGNE, W, 1
152A  6FB8      	MOVWF FCD_0f051__00084_arg_FCL_X1, 1
152C  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
152E  6FB9      	MOVWF FCD_0f051__00084_arg_FCL_X1+D'1', 1
1530  6BBA      	CLRF FCD_0f051__00084_arg_FCL_Y1, 1
1532  6BBB      	CLRF FCD_0f051__00084_arg_FCL_Y1+D'1', 1
1534  518A      	MOVF gbl_FCV_X_LIGNE, W, 1
1536  6FBC      	MOVWF FCD_0f051__00084_arg_FCL_X2, 1
1538  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
153A  6FBD      	MOVWF FCD_0f051__00084_arg_FCL_X2+D'1', 1
153C  0EF0      	MOVLW 0xF0
153E  6FBE      	MOVWF FCD_0f051__00084_arg_FCL_Y2, 1
1540  6BBF      	CLRF FCD_0f051__00084_arg_FCL_Y2+D'1', 1
1542  ECFBF009  	CALL FCD_0f051__00084


		// Calcul
		// Calcul:
		//  X_ligne = X_ligne + 24
		FCV_X_LIGNE = FCV_X_LIGNE + 24;
1546  0100      	MOVLB 0x00
1548  6BB8      	CLRF CompTempVar2761, 1
154A  0E18      	MOVLW 0x18
154C  278A      	ADDWF gbl_FCV_X_LIGNE, F, 1
154E  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
1550  23B8      	ADDWFC CompTempVar2761, F, 1
1552  51B8      	MOVF CompTempVar2761, W, 1
1554  6F8B      	MOVWF gbl_FCV_X_LIGNE+D'1', 1



		if ((FCV_X_LIGNE == 240) != 0) break;
1556  6BB7      	CLRF CompTempVar2759, 1
1558  0EF0      	MOVLW 0xF0
155A  638A      	CPFSEQ gbl_FCV_X_LIGNE, 1
155C  D003      	BRA	label105
155E  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
1560  B4D8      	BTFSC STATUS,Z
1562  2BB7      	INCF CompTempVar2759, F, 1
1564            label105
1564  53B7      	MOVF CompTempVar2759, F, 1
1566  E0E0      	BZ	label104

	}

	// tracé des horizontales
	// Boucle: While Y_ligne <= 240
	while (1)
	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, Y_ligne, 240, Y_ligne)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(0, FCV_Y_LIGNE, 240, FCV_Y_LIGNE);
1568  6BB8      	CLRF FCD_0f051__00084_arg_FCL_X1, 1
156A  6BB9      	CLRF FCD_0f051__00084_arg_FCL_X1+D'1', 1
156C  5184      	MOVF gbl_FCV_Y_LIGNE, W, 1
156E  6FBA      	MOVWF FCD_0f051__00084_arg_FCL_Y1, 1
1570  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
1572  6FBB      	MOVWF FCD_0f051__00084_arg_FCL_Y1+D'1', 1
1574  0EF0      	MOVLW 0xF0
1576  6FBC      	MOVWF FCD_0f051__00084_arg_FCL_X2, 1
1578  6BBD      	CLRF FCD_0f051__00084_arg_FCL_X2+D'1', 1
157A  5184      	MOVF gbl_FCV_Y_LIGNE, W, 1
157C  6FBE      	MOVWF FCD_0f051__00084_arg_FCL_Y2, 1
157E  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
1580  6FBF      	MOVWF FCD_0f051__00084_arg_FCL_Y2+D'1', 1
1582  ECFBF009  	CALL FCD_0f051__00084


		// Calcul
		// Calcul:
		//  Y_ligne = Y_ligne + 24
		FCV_Y_LIGNE = FCV_Y_LIGNE + 24;
1586  0100      	MOVLB 0x00
1588  6BB8      	CLRF CompTempVar2764, 1
158A  0E18      	MOVLW 0x18
158C  2784      	ADDWF gbl_FCV_Y_LIGNE, F, 1
158E  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
1590  23B8      	ADDWFC CompTempVar2764, F, 1
1592  51B8      	MOVF CompTempVar2764, W, 1
1594  6F85      	MOVWF gbl_FCV_Y_LIGNE+D'1', 1



		if ((FCV_Y_LIGNE <= 240) == 0) break;
1596  6BB7      	CLRF CompTempVar2762, 1
1598  0EF0      	MOVLW 0xF0
159A  6584      	CPFSGT gbl_FCV_Y_LIGNE, 1
159C  6785      	TSTFSZ gbl_FCV_Y_LIGNE+D'1', 1
159E  D001      	BRA	label107
15A0  2BB7      	INCF CompTempVar2762, F, 1
15A2            label107
15A2  53B7      	MOVF CompTempVar2762, F, 1
15A4  E1E1      	BNZ	label106

	}

}
15A6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Contre_torpilleur()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
1324  0E01      	MOVLW 0x01
1326  0100      	MOVLB 0x00
1328  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
132A  0E18      	MOVLW 0x18
132C  6F8C      	MOVWF gbl_FCV_Y, 1
132E  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
1330  0E18      	MOVLW 0x18
1332  6F8E      	MOVWF gbl_FCV_X, 1
1334  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
1336            label93
1336  0E01      	MOVLW 0x01
1338  0100      	MOVLB 0x00
133A  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
133C  E236      	BC	label101
133E  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
1340  D034      	BRA	label101
13A8  D7C6      	BRA	label93
13AA            label101

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
1342  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1344  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
1346  E102      	BNZ	label94
1348  518C      	MOVF gbl_FCV_Y, W, 1
134A  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
134C            label94
134C  E223      	BC	label100
134E            label95
1394            label100

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
134E  518F      	MOVF gbl_FCV_X+D'1', W, 1
1350  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1352  E102      	BNZ	label96
1354  518E      	MOVF gbl_FCV_X, W, 1
1356  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
1358            label96
1358  E309      	BNC	label97

				{

				} else {
136C            label97


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
135A  29A6      	INCF gbl_FCV_HITBOX, W, 1
135C  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
135E  6BBF      	CLRF CompTempVar2682, 1
1360  0E18      	MOVLW 0x18
1362  278E      	ADDWF gbl_FCV_X, F, 1
1364  518F      	MOVF gbl_FCV_X+D'1', W, 1
1366  23BF      	ADDWFC CompTempVar2682, F, 1
1368  51BF      	MOVF CompTempVar2682, W, 1
136A  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
136C  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
136E  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
1370  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
1372  B4D8      	BTFSC STATUS,Z
1374  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
1376  6BBE      	CLRF CompTempVar2680, 1
1378  518F      	MOVF gbl_FCV_X+D'1', W, 1
137A  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
137C  E104      	BNZ	label98
137E  518E      	MOVF gbl_FCV_X, W, 1
1380  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
1382  D001      	BRA	label98
1384  D001      	BRA	label99
1386            label98
1386  A0D8      	BTFSS STATUS,C
1388  71BE      	BTG CompTempVar2680,0, 1
138A  53BE      	MOVF CompTempVar2680, F, 1
138C  E0E0      	BZ	label95

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
138E  ECD5F003  	CALL FCM_affich_00069


		} else {
1392  D7D1      	BRA	label93


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
1394  0E0A      	MOVLW 0x0A
1396  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
1398  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
139A  6BBE      	CLRF CompTempVar2686, 1
139C  0E18      	MOVLW 0x18
139E  278C      	ADDWF gbl_FCV_Y, F, 1
13A0  518D      	MOVF gbl_FCV_Y+D'1', W, 1
13A2  23BE      	ADDWFC CompTempVar2686, F, 1
13A4  51BE      	MOVF CompTempVar2686, W, 1
13A6  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000011
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Contre_torpilleur = Contre_torpilleur + 1
	FCV_TABLEAU[FCV_HITBOX] = 3;
13AA  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
13AE  50E9      	MOVF FSR0L, W
13B0  51A6      	MOVF gbl_FCV_HITBOX, W, 1
13B2  26E9      	ADDWF FSR0L, F
13B4  0E03      	MOVLW 0x03
13B6  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
13B8  29AA      	INCF gbl_FCV_BATEAU, W, 1
13BA  6FAA      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
13BC  6B86      	CLRF gbl_FCV_X_SORTIE, 1
13BE  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
13C0  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
13C2  6B8E      	CLRF gbl_FCV_X, 1
13C4  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
13C6  6B8C      	CLRF gbl_FCV_Y, 1
13C8  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_CONTRE_TORPILLEUR = FCV_CONTRE_TORPILLEUR + 1;
13CA  29AD      	INCF gbl_FCV_CONTRE_TORPILLEUR, W, 1
13CC  6FAD      	MOVWF gbl_FCV_CONTRE_TORPILLEUR, 1


}
13CE  0012      	RETURN




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
1C44  0E0F      	MOVLW 0x0F
1C46  6EC1      	MOVWF gbl_adcon1





	// Appel d'une Macro
	// Appel d'une Macro: Initialisation()
	FCM_Initialisation();
1C48  ECFEF00D  	CALL FCM_Initia_0006B


	// Appel d'une Macro
	// Appel d'une Macro: phase_debut()
	FCM_phase_debut();
1C4C  0E99      	MOVLW 0x99
1C4E  EF9BF00D  	GOTO	FCM_phase__00081
1C52            label148


	// mettre attente donnes joueur 2
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);
1C52  0E02      	MOVLW 0x02
1C54  0100      	MOVLB 0x00
1C56  6FBB      	MOVWF delay_s_00000_arg_del, 1
1C58  EC33F000  	CALL delay_s_00000


	// Appel d'une Macro
	// Appel d'une Macro: Phase_jeu()
	FCM_Phase_jeu();
1C5C  ECF3F00D  	CALL FCM_Phase__00083


	mainendloop: goto mainendloop;
1C60            label149
1C60  D7FF      	BRA	label149

}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

}
1D14  CFEAF001  	MOVFF FSR0H,  Int1Context
1D18  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1D1C  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
1D20  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
1D24  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
1D28  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
1D2C  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
1D30  C001FFEA  	MOVFF Int1Context,  FSR0H
1D34  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0B7E  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0B80  0E7F      	MOVLW 0x7F
0B82  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0B84  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0B86  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
0B88  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
0B8A  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0B8C  9A9D      	BCF gbl_pie1,5

			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0B8E  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
07A4  6AAB      	CLRF gbl_rcsta

			txsta = 0;
07A6  6AAC      	CLRF gbl_txsta

		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}
07A8  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
008C            label5
008C  0E10      	MOVLW 0x10
008E  149E      	ANDWF gbl_pir1, W
0090  0100      	MOVLB 0x00
0092  6FFF      	MOVWF CompTempVar2894, 1
0094  53FF      	MOVF CompTempVar2894, F, 1
0096  E0FA      	BZ	label5


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0098  0101      	MOVLB 0x01
009A  5100      	MOVF FC_CAL_UAR_00089_arg_nChar, W, 1
009C  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
009E  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
00A0  0101      	MOVLB 0x01
00A2  6900      	SETF FC_CAL_UAR_00088_1_retVal, 1

  #endif

	MX_UINT8 delay1 = 0;
00A4  6B01      	CLRF FC_CAL_UAR_00088_1_delay1, 1

	MX_UINT8 regcheck = 0;
00A6  6B02      	CLRF FC_CAL_UAR_00088_1_regcheck, 1

	MX_UINT8 bWaitForever = 0;
00A8  6B03      	CLRF FC_CAL_UAR_00088_1_bWaitForever, 1

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
00AA  6B04      	CLRF FC_CAL_UAR_00088_1_rxStatus, 1

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
00AC  6B07      	CLRF FC_CAL_UAR_00088_1_dummy, 1

  #endif

	if (nTimeout == 255)
00AE  0100      	MOVLB 0x00
00B0  29FF      	INCF FC_CAL_UAR_00088_arg_nTimeout, W, 1
00B2  E103      	BNZ	label6
00BA            label6

		bWaitForever = 1;
00B4  0E01      	MOVLW 0x01
00B6  0101      	MOVLB 0x01
00B8  6F03      	MOVWF FC_CAL_UAR_00088_1_bWaitForever, 1


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00BA  0101      	MOVLB 0x01
00BC  5304      	MOVF FC_CAL_UAR_00088_1_rxStatus, F, 1
00BE  E129      	BNZ	label11
0110  D7D4      	BRA	label6
0112            label11

	{
		if (bWaitForever == 0)
00C0  5303      	MOVF FC_CAL_UAR_00088_1_bWaitForever, F, 1
00C2  E11D      	BNZ	label10

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00C4  0100      	MOVLB 0x00
00C6  53FF      	MOVF FC_CAL_UAR_00088_arg_nTimeout, F, 1
00C8  E104      	BNZ	label7
00D2            label7

			{
				rxStatus = UART_STATUS_TIMEOUT;
00CA  0E01      	MOVLW 0x01
00CC  0101      	MOVLB 0x01
00CE  6F04      	MOVWF FC_CAL_UAR_00088_1_rxStatus, 1

			}
			else
00D0  D016      	BRA	label10

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00D2  0101      	MOVLB 0x01
00D4  6B05      	CLRF FC_CAL_UAR_00088_1_delaycnt, 1
00D6  6B06      	CLRF FC_CAL_UAR_00088_1_delaycnt+D'1', 1
00D8            label8
00D8  0E31      	MOVLW 0x31
00DA  5D05      	SUBWF FC_CAL_UAR_00088_1_delaycnt, W, 1
00DC  E205      	BC	label9
00DE  6706      	TSTFSZ FC_CAL_UAR_00088_1_delaycnt+D'1', 1
00E0  D003      	BRA	label9
00E2  4B05      	INFSNZ FC_CAL_UAR_00088_1_delaycnt, F, 1
00E4  2B06      	INCF FC_CAL_UAR_00088_1_delaycnt+D'1', F, 1
00E6  D7F8      	BRA	label8
00E8            label9

				delay1 = delay1 + 1;
00E8  2901      	INCF FC_CAL_UAR_00088_1_delay1, W, 1
00EA  6F01      	MOVWF FC_CAL_UAR_00088_1_delay1, 1

				if(delay1 == 100)
00EC  0E64      	MOVLW 0x64
00EE  6301      	CPFSEQ FC_CAL_UAR_00088_1_delay1, 1
00F0  D006      	BRA	label10
00FE            label10

				{
					nTimeout = nTimeout - 1;
00F2  0100      	MOVLB 0x00
00F4  05FF      	DECF FC_CAL_UAR_00088_arg_nTimeout, W, 1
00F6  6FFF      	MOVWF FC_CAL_UAR_00088_arg_nTimeout, 1

					MX_CLEAR_WATCHDOG;
00F8  0004      	CLRWDT

					delay1 = 0;
00FA  0101      	MOVLB 0x01
00FC  6B01      	CLRF FC_CAL_UAR_00088_1_delay1, 1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00FE  0E20      	MOVLW 0x20
0100  149E      	ANDWF gbl_pir1, W
0102  6F08      	MOVWF CompTempVar2891, 1
0104  5108      	MOVF CompTempVar2891, W, 1
0106  6F02      	MOVWF FC_CAL_UAR_00088_1_regcheck, 1

			if (regcheck != 0)
0108  5302      	MOVF FC_CAL_UAR_00088_1_regcheck, F, 1
010A  E0D7      	BZ	label6

				rxStatus = UART_STATUS_RXBYTE;
010C  0E02      	MOVLW 0x02
010E  6F04      	MOVWF FC_CAL_UAR_00088_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
0112  0E02      	MOVLW 0x02
0114  6304      	CPFSEQ FC_CAL_UAR_00088_1_rxStatus, 1
0116  D018      	BRA	label14

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0118  0E04      	MOVLW 0x04
011A  14AB      	ANDWF gbl_rcsta, W
011C  6F08      	MOVWF CompTempVar2892, 1
011E  5108      	MOVF CompTempVar2892, W, 1
0120  6F02      	MOVWF FC_CAL_UAR_00088_1_regcheck, 1

			if (regcheck != 0)
0122  5302      	MOVF FC_CAL_UAR_00088_1_regcheck, F, 1
0124  E003      	BZ	label12
012C            label12

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0126  50AE      	MOVF gbl_rcreg, W
0128  6F07      	MOVWF FC_CAL_UAR_00088_1_dummy, 1

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
012A  D00E      	BRA	label14

			{
				regcheck = ts_bit(rcsta, OERR);
012C  0E02      	MOVLW 0x02
012E  14AB      	ANDWF gbl_rcsta, W
0130  6F08      	MOVWF CompTempVar2893, 1
0132  5108      	MOVF CompTempVar2893, W, 1
0134  6F02      	MOVWF FC_CAL_UAR_00088_1_regcheck, 1

				if (regcheck != 0)
0136  5302      	MOVF FC_CAL_UAR_00088_1_regcheck, F, 1
0138  E003      	BZ	label13
0140            label13

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
013A  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
013C  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
013E  D004      	BRA	label14
0148            label14

				{
					retVal = 0;
0140  6B00      	CLRF FC_CAL_UAR_00088_1_retVal, 1


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
0142  50AE      	MOVF gbl_rcreg, W
0144  1100      	IORWF FC_CAL_UAR_00088_1_retVal, W, 1
0146  6F00      	MOVWF FC_CAL_UAR_00088_1_retVal, 1

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0148  5100      	MOVF FC_CAL_UAR_00088_1_retVal, W, 1
014A  6F08      	MOVWF CompTempVarRet2890, 1
014C  6B09      	CLRF CompTempVarRet2890+D'1', 1

}
014E  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))

{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
0B90  0E07      	MOVLW 0x07
0B92  65BB      	CPFSGT FC_CAL_UAR_00086_arg_new_baud, 1
0B94  D001      	BRA	label45
0B98            label45

		return;

	if (new_baud == 0)
0B98  53BB      	MOVF FC_CAL_UAR_00086_arg_new_baud, F, 1
0B9A  E104      	BNZ	label46
0BA4            label46

	{
		baudrate = MX_HARD_BAUD_1200;
0B9C  69BC      	SETF FC_CAL_UAR_00086_1_baudrate, 1

		baudmode = MX_HARD_SLOW_1200;
0B9E  0E01      	MOVLW 0x01
0BA0  6FBD      	MOVWF FC_CAL_UAR_00086_1_baudmode, 1

	}
	else if (new_baud == 1)
0BA2  D02F      	BRA	label53
0BA4  05BB      	DECF FC_CAL_UAR_00086_arg_new_baud, W, 1
0BA6  E105      	BNZ	label47
0BB2            label47

	{
		baudrate = MX_HARD_BAUD_2400;
0BA8  0E7F      	MOVLW 0x7F
0BAA  6FBC      	MOVWF FC_CAL_UAR_00086_1_baudrate, 1

		baudmode = MX_HARD_SLOW_2400;
0BAC  0E01      	MOVLW 0x01
0BAE  6FBD      	MOVWF FC_CAL_UAR_00086_1_baudmode, 1

	}
	else if (new_baud == 2)
0BB0  D028      	BRA	label53
0BB2  0E02      	MOVLW 0x02
0BB4  63BB      	CPFSEQ FC_CAL_UAR_00086_arg_new_baud, 1
0BB6  D003      	BRA	label48
0BBE            label48

	{
		baudrate = MX_HARD_BAUD_4800;
0BB8  69BC      	SETF FC_CAL_UAR_00086_1_baudrate, 1

		baudmode = MX_HARD_SLOW_4800;
0BBA  6BBD      	CLRF FC_CAL_UAR_00086_1_baudmode, 1

	}
	else if (new_baud == 3)
0BBC  D022      	BRA	label53
0BBE  0E03      	MOVLW 0x03
0BC0  63BB      	CPFSEQ FC_CAL_UAR_00086_arg_new_baud, 1
0BC2  D004      	BRA	label49
0BCC            label49

	{
		baudrate = MX_HARD_BAUD_9600;
0BC4  0E7F      	MOVLW 0x7F
0BC6  6FBC      	MOVWF FC_CAL_UAR_00086_1_baudrate, 1

		baudmode = MX_HARD_SLOW_9600;
0BC8  6BBD      	CLRF FC_CAL_UAR_00086_1_baudmode, 1

	}
	else if (new_baud == 4)
0BCA  D01B      	BRA	label53
0BCC  0E04      	MOVLW 0x04
0BCE  63BB      	CPFSEQ FC_CAL_UAR_00086_arg_new_baud, 1
0BD0  D004      	BRA	label50
0BDA            label50

	{
		baudrate = MX_HARD_BAUD_19200;
0BD2  0E3F      	MOVLW 0x3F
0BD4  6FBC      	MOVWF FC_CAL_UAR_00086_1_baudrate, 1

		baudmode = MX_HARD_SLOW_19200;
0BD6  6BBD      	CLRF FC_CAL_UAR_00086_1_baudmode, 1

	}
	else if (new_baud == 5)
0BD8  D014      	BRA	label53
0BDA  0E05      	MOVLW 0x05
0BDC  63BB      	CPFSEQ FC_CAL_UAR_00086_arg_new_baud, 1
0BDE  D004      	BRA	label51
0BE8            label51

	{
		baudrate = MX_HARD_BAUD_38400;
0BE0  0E1F      	MOVLW 0x1F
0BE2  6FBC      	MOVWF FC_CAL_UAR_00086_1_baudrate, 1

		baudmode = MX_HARD_SLOW_38400;
0BE4  6BBD      	CLRF FC_CAL_UAR_00086_1_baudmode, 1

	}
	else if (new_baud == 6)
0BE6  D00D      	BRA	label53
0BE8  0E06      	MOVLW 0x06
0BEA  63BB      	CPFSEQ FC_CAL_UAR_00086_arg_new_baud, 1
0BEC  D004      	BRA	label52
0BF6            label52

	{
		baudrate = MX_HARD_BAUD_57600;
0BEE  0E14      	MOVLW 0x14
0BF0  6FBC      	MOVWF FC_CAL_UAR_00086_1_baudrate, 1

		baudmode = MX_HARD_SLOW_57600;
0BF2  6BBD      	CLRF FC_CAL_UAR_00086_1_baudmode, 1

	}
	else if (new_baud == 7)
0BF4  D006      	BRA	label53
0BF6  0E07      	MOVLW 0x07
0BF8  63BB      	CPFSEQ FC_CAL_UAR_00086_arg_new_baud, 1
0BFA  D003      	BRA	label53
0C02            label53

	{
		baudrate = MX_HARD_BAUD_115200;
0BFC  0E0A      	MOVLW 0x0A
0BFE  6FBC      	MOVWF FC_CAL_UAR_00086_1_baudrate, 1

		baudmode = MX_HARD_SLOW_115200;
0C00  6BBD      	CLRF FC_CAL_UAR_00086_1_baudmode, 1

	}

	UART_Uninit();
0C02  ECD2F003  	CALL FC_CAL_UAR_00087


	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
0C06  05BD      	DECF FC_CAL_UAR_00086_1_baudmode, W, 1
0C08  E102      	BNZ	label54
0C0E            label54

			cr_bit(txsta, BRGH);					//Low Speed
0C0A  94AC      	BCF gbl_txsta,2

	    else
0C0C  D001      	BRA	label55
0C10            label55

			st_bit(txsta, BRGH);					//High Speed
0C0E  84AC      	BSF gbl_txsta,2


		spbrg = baudrate;   						// set the baud rate
0C10  51BC      	MOVF FC_CAL_UAR_00086_1_baudrate, W, 1
0C12  6EAF      	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
0C14  6AAB      	CLRF gbl_rcsta


		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
0C16  8EAB      	BSF gbl_rcsta,7

		st_bit(txsta, TXEN);
0C18  8AAC      	BSF gbl_txsta,5

		st_bit(rcsta, CREN);
0C1A  88AB      	BSF gbl_rcsta,4


		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
0C1C  9A9D      	BCF gbl_pie1,5

		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0B96  0012      	RETURN
0C1E  0012      	RETURN


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF31F00E  	GOTO	_startup

0008  EF8AF00E  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  53BE      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF5      	MOVLW 0xF5
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0FFF      	ADDLW 0xFF
0038  A4D8      	BTFSS STATUS,Z
003A  D7ED      	BRA	label2
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  2FBE      	DECFSZ delay_ms_00000_arg_del, F, 1
0058  D7DD      	BRA	label1
005A  0012      	RETURN
005C            ; } delay_ms function end

005C            delay_us_00000
005C            ; { delay_us ; function begin
005C            label3
005C  0000      	NOP
005E  0000      	NOP
0060  2FBB      	DECFSZ delay_us_00000_arg_del, F, 1
0062  D7FC      	BRA	label3
0064  0012      	RETURN
0066            ; } delay_us function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6FBE      	MOVWF delay_ms_00000_arg_del, 1
006A  EC06F000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6FBE      	MOVWF delay_ms_00000_arg_del, 1
0072  EC06F000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6FBE      	MOVWF delay_ms_00000_arg_del, 1
007A  EC06F000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6FBE      	MOVWF delay_ms_00000_arg_del, 1
0082  EC06F000  	CALL delay_ms_00000
0086  2FBB      	DECFSZ delay_s_00000_arg_del, F, 1
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end




































































1C62            _startup
1C62  0ED5      	MOVLW 0xD5
1C64  6E6A      	MOVWF gbl_14_LSR
1C66  0EC4      	MOVLW 0xC4
1C68  6E6B      	MOVWF gbl_14_LSR+D'1'
1C6A  0EBB      	MOVLW 0xBB
1C6C  6E6C      	MOVWF gbl_14_LSR+D'2'
1C6E  0EDC      	MOVLW 0xDC
1C70  6E6D      	MOVWF gbl_14_LSR+D'3'
1C72  6A6E      	CLRF gbl_15_gbl_aSig
1C74  6A6F      	CLRF gbl_15_gbl_aSig+D'1'
1C76  6A70      	CLRF gbl_15_gbl_aSig+D'2'
1C78  6A71      	CLRF gbl_15_gbl_aSig+D'3'
1C7A  6A72      	CLRF gbl_15_gbl_bSig
1C7C  6A73      	CLRF gbl_15_gbl_bSig+D'1'
1C7E  6A74      	CLRF gbl_15_gbl_bSig+D'2'
1C80  6A75      	CLRF gbl_15_gbl_bSig+D'3'
1C82  6A76      	CLRF gbl_15_gbl_zSig
1C84  6A77      	CLRF gbl_15_gbl_zSig+D'1'
1C86  6A78      	CLRF gbl_15_gbl_zSig+D'2'
1C88  6A79      	CLRF gbl_15_gbl_zSig+D'3'
1C8A  0100      	MOVLB 0x00
1C8C  6B9D      	CLRF gbl_15_gbl_aExp, 1
1C8E  6B9E      	CLRF gbl_15_gbl_bExp, 1
1C90  6A7E      	CLRF gbl_15_gbl_zExp
1C92  6A7F      	CLRF gbl_15_gbl_zExp+D'1'
1C94  6B9F      	CLRF gbl_15_gbl_aSign, 1
1C96  6BA0      	CLRF gbl_15_gbl_bSign, 1
1C98  6BA1      	CLRF gbl_15_gbl_zSign, 1
1C9A  6BA2      	CLRF gbl_15_gbl_zSigZero, 1
1C9C  6A7A      	CLRF gbl_15_gbl_ret
1C9E  6A7B      	CLRF gbl_15_gbl_ret+D'1'
1CA0  6A7C      	CLRF gbl_15_gbl_ret+D'2'
1CA2  6A7D      	CLRF gbl_15_gbl_ret+D'3'
1CA4  6B9B      	CLRF gbl_float_rounding_mode, 1
1CA6  6B9C      	CLRF gbl_float_exception_flags, 1
1CA8  6B9A      	CLRF gbl_float_detect_tininess, 1




















1D10  EF22F00E  	GOTO	main

300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  79FF      	DW 0x79FF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
