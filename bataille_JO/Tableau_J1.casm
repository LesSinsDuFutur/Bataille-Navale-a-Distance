;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
0D16  51BF      	MOVF FC_CAL_Por_00042_arg_Tris+D'1', W, 1
0D18  6EEA      	MOVWF FSR0H
0D1A  51BE      	MOVF FC_CAL_Por_00042_arg_Tris, W, 1
0D1C  6EE9      	MOVWF FSR0L
0D1E  51C0      	MOVF FC_CAL_Por_00042_arg_InMask, W, 1
0D20  10EF      	IORWF INDF0, W
0D22  6FC2      	MOVWF CompTempVar1825, 1
0D24  51C2      	MOVF CompTempVar1825, W, 1
0D26  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
0D28  51BD      	MOVF FC_CAL_Por_00042_arg_Port+D'1', W, 1
0D2A  6EEA      	MOVWF FSR0H
0D2C  51BC      	MOVF FC_CAL_Por_00042_arg_Port, W, 1
0D2E  6EE9      	MOVWF FSR0L
0D30  51C0      	MOVF FC_CAL_Por_00042_arg_InMask, W, 1
0D32  14EF      	ANDWF INDF0, W
0D34  6FC2      	MOVWF CompTempVarRet1822, 1
0D36  51C1      	MOVF FC_CAL_Por_00042_arg_Shift, W, 1
0D38  6FC3      	MOVWF CompTempVar1827, 1
0D3A            label64
0D3A  B4D8      	BTFSC STATUS,Z
0D3E  90D8      	BCF STATUS,C
0D40  33C2      	RRCF CompTempVarRet1822, F, 1
0D42  07C3      	DECF CompTempVar1827, F, 1
0D44  D7FA      	BRA	label64

		}
0D3C  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

// Delay by bytes
#define FCI_DELAYBYTE_S(count)     delay_s((count))
#define FCI_DELAYBYTE_MS(count)    delay_ms((count))
#define FCI_DELAYBYTE_US(count)    delay_us((count))
// With watchdog timer
#define FCI_DELAYBYTEWDT_S(count)  Wdt_Delay_S((count))
#define FCI_DELAYBYTEWDT_MS(count) Wdt_Delay_Ms((count))
#define FCI_DELAYBYTEWDT_US(count) delay_us((count))

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)
{
    char i;
    for (i=0; i<delay; i++)
    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
        delay_ms(1);
    }
}


void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)

{
  	while (Delay > 255)
1042            label67
1042  0EFF      	MOVLW 0xFF
1044  65BF      	CPFSGT FCI_DELAYI_00046_arg_Delay, 1
1046  67C0      	TSTFSZ FCI_DELAYI_00046_arg_Delay+D'1', 1
1048  D001      	BRA	label68
104A  D00C      	BRA	label69
104C            label68
1062  D7EF      	BRA	label67
1064            label69

  	{
	  	delay_ms(255);
104C  69C1      	SETF delay_ms_00000_arg_del, 1
104E  EC06F000  	CALL delay_ms_00000

	  	Delay = Delay - 255;
1052  0EFF      	MOVLW 0xFF
1054  5DBF      	SUBWF FCI_DELAYI_00046_arg_Delay, W, 1
1056  6FC1      	MOVWF CompTempVar1838, 1
1058  59BF      	SUBWFB FCI_DELAYI_00046_arg_Delay, W, 1
105A  08FF      	SUBLW 0xFF
105C  5FC0      	SUBWF FCI_DELAYI_00046_arg_Delay+D'1', F, 1
105E  51C1      	MOVF CompTempVar1838, W, 1
1060  6FBF      	MOVWF FCI_DELAYI_00046_arg_Delay, 1

  	}
  	if (Delay > 0)
1064  0E00      	MOVLW 0x00
1066  65BF      	CPFSGT FCI_DELAYI_00046_arg_Delay, 1
1068  67C0      	TSTFSZ FCI_DELAYI_00046_arg_Delay+D'1', 1
106A  D001      	BRA	label70
106E            label70

  		delay_ms(Delay & 0xFF);
106E  51BF      	MOVF FCI_DELAYI_00046_arg_Delay, W, 1
1070  6FC1      	MOVWF delay_ms_00000_arg_del, 1
1072  EC06F000  	CALL delay_ms_00000

}
106C  0012      	RETURN
1076  0012      	RETURN


void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
039A  6B03      	CLRF FCI_GETLEN_0004B_1_tmp, 1
039C            label18
039C  5102      	MOVF FCI_GETLEN_0004B_arg_iStr1_len, W, 1
039E  6103      	CPFSLT FCI_GETLEN_0004B_1_tmp, 1
03A0  D009      	BRA	label19
03A2  5101      	MOVF FCI_GETLEN_0004B_arg_sStr1+D'1', W, 1
03A4  6EEA      	MOVWF FSR0H
03A6  5100      	MOVF FCI_GETLEN_0004B_arg_sStr1, W, 1
03A8  2503      	ADDWF FCI_GETLEN_0004B_1_tmp, W, 1
03AA  6EE9      	MOVWF FSR0L
03AC  52EF      	MOVF INDF0, F
03AE  E002      	BZ	label19
03B0  2B03      	INCF FCI_GETLEN_0004B_1_tmp, F, 1
03B2  D7F4      	BRA	label18
03B4            label19

	return (tmp);
03B4  5103      	MOVF FCI_GETLEN_0004B_1_tmp, W, 1
03B6  6F04      	MOVWF CompTempVarRet1850, 1

}
03B8  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	if (iDst_len == 0) return sDst;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (sDst);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BatailleNavale\Tableau_J1.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Tuesday, March 21, 2017 16:24:55
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x79
#endif
#ifdef HI_TECH_C
__CONFIG(0x79);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_TABLEAU 101
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_HITBOX_JOUEUR_1 = (0x1);
1A4C  0E01      	MOVLW 0x01
1A4E  6FA3      	MOVWF gbl_FCV_HITBOX_JOUEUR_1, 1

MX_GLOBAL MX_UINT8 FCV_CROISEUR = (0x0);
1A50  6BA4      	CLRF gbl_FCV_CROISEUR, 1

MX_GLOBAL MX_UINT8 FCV_TORPILLEUR = (0x0);
1A52  6BA5      	CLRF gbl_FCV_TORPILLEUR, 1

MX_GLOBAL MX_UINT16 FCV_Y_LIGNE = (0x18);
1A54  0E18      	MOVLW 0x18
1A56  6F84      	MOVWF gbl_FCV_Y_LIGNE, 1
1A58  6B85      	CLRF gbl_FCV_Y_LIGNE+D'1', 1

MX_GLOBAL MX_UINT8 FCV_NUM_CASE = (0x0);
1A5A  6BA6      	CLRF gbl_FCV_NUM_CASE, 1

MX_GLOBAL MX_UINT16 FCV_X_SORTIE = (0x0);
1A5C  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1A5E  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

MX_GLOBAL MX_UINT16 FCV_Y_TOUCH = (0x0);
1A60  6B88      	CLRF gbl_FCV_Y_TOUCH, 1
1A62  6B89      	CLRF gbl_FCV_Y_TOUCH+D'1', 1

MX_GLOBAL MX_UINT16 FCV_X_LIGNE = (0x18);
1A64  0E18      	MOVLW 0x18
1A66  6F8A      	MOVWF gbl_FCV_X_LIGNE, 1
1A68  6B8B      	CLRF gbl_FCV_X_LIGNE+D'1', 1

MX_GLOBAL MX_UINT16 FCV_Y = (0x18);
1A6A  0E18      	MOVLW 0x18
1A6C  6F8C      	MOVWF gbl_FCV_Y, 1
1A6E  6B8D      	CLRF gbl_FCV_Y+D'1', 1

MX_GLOBAL MX_UINT16 FCV_X = (0x18);
1A70  0E18      	MOVLW 0x18
1A72  6F8E      	MOVWF gbl_FCV_X, 1
1A74  6B8F      	CLRF gbl_FCV_X+D'1', 1

MX_GLOBAL MX_UINT8 FCV_SOUS_MARIN = (0x0);
1A76  6BA7      	CLRF gbl_FCV_SOUS_MARIN, 1

MX_GLOBAL MX_UINT16 FCV_X_TOUCH = (0x0);
1A78  6B90      	CLRF gbl_FCV_X_TOUCH, 1
1A7A  6B91      	CLRF gbl_FCV_X_TOUCH+D'1', 1

MX_GLOBAL MX_UINT8 FCV_TOUR = (0x0);
1A7C  6BA8      	CLRF gbl_FCV_TOUR, 1

MX_GLOBAL MX_UINT8 FCV_APPUI_ECRAN = (0x0);
1A7E  6BA9      	CLRF gbl_FCV_APPUI_ECRAN, 1

MX_GLOBAL MX_UINT8 FCV_HITBOX_2 = (0x0);
1A80  6BAA      	CLRF gbl_FCV_HITBOX_2, 1

MX_GLOBAL MX_UINT8 FCV_BATEAU = (0x0);
1A82  6BAB      	CLRF gbl_FCV_BATEAU, 1

MX_GLOBAL MX_UINT8 FCV_PORTE_AVION = (0x0);
1A84  6BAC      	CLRF gbl_FCV_PORTE_AVION, 1

MX_GLOBAL MX_UINT8 FCV_JOUEUR1 = (0x0);
1A86  6BAD      	CLRF gbl_FCV_JOUEUR1, 1

MX_GLOBAL MX_CHAR FCV_TABLEAU[FCVsz_TABLEAU];
MX_GLOBAL MX_UINT8 FCV_CONTRE_TORPILLEUR = (0x0);
1A88  6BAE      	CLRF gbl_FCV_CONTRE_TORPILLEUR, 1


void FCM_Touche_Coule_TORP();
void FCM_Hitbox_v2();
void FCM_Touche_coule_PA();
void FCM_Message_Touche();
void FCM_Lecture_Coordonnes();
void FCM_Croiseur();
void FCM_Torpilleur();
void FCM_Touche_Coule_SM();
void FCM_Initialisation();
void FCM_Message_bateau();
void FCM_Toucher_Couler();
void FCM_Reinitialisation_tactile();
void FCM_Choix_Bateau_Toucher();
void FCM_phase_Fin();
void FCM_Choix_Bateaux();
void FCM_affichage_bateau();
void FCM_Sous_marin();
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2, MX_UINT8 FCL_ROUGE, MX_UINT8 FCL_VERT, MX_UINT8 FCL_BLEU);
void FCM_Reinitialisation_texte();
void FCM_Appui_tactile();
void FCM_Manque();
void FCM_Recuperation_coordonees();
void FCM_phase_debut();
void FCM_Fin_Jeu();
void FCM_Touche_Coule_CT();
void FCM_hitbox_phase_jeu();
void FCM_affichage_bateau_touche();
void FCM_Porte_avion();
void FCM_Touche_coule_CR();
void FCM_Phase_jeu();
void FCM_lignes();
void FCM_Contre_torpilleur();

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 porta
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 porta
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisa
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisa
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (2)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
1A8A  0E00      	MOVLW 0x00
1A8C  6FAF      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000, 1

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
1A8E  0E01      	MOVLW 0x01
1A90  6FB0      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001, 1

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
1A92  0E02      	MOVLW 0x02
1A94  6FB1      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002, 1

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
1A96  0E03      	MOVLW 0x03
1A98  6FB2      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003, 1

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
1A9A  0E04      	MOVLW 0x04
1A9C  6FB3      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004, 1

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
1A9E  0E05      	MOVLW 0x05
1AA0  6FB4      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005, 1

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
1AA2  0E06      	MOVLW 0x06
1AA4  6FB5      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006, 1

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
1AA6  0E07      	MOVLW 0x07
1AA8  6FB6      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007, 1

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
1AAA  6B80      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009, 1
1AAC  6B81      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1', 1
1AAE  6B82      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2', 1
1AB0  6B83      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3', 1

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
1AB2  6BB7      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B, 1


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x63);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)

{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;
0646  6BC0      	CLRF FCD_0f051__00069_1_FCR_RETVAL, 1
0648  6BC1      	CLRF FCD_0f051__00069_1_FCR_RETVAL+D'1', 1


	if (FCL_AXIS == 0)
064A  53BF      	MOVF FCD_0f051__00069_arg_FCL_AXIS, F, 1
064C  E007      	BZ	label28

	{

	} else {

		if (FCL_AXIS == 'x')
064E  0E78      	MOVLW 0x78
0650  63BF      	CPFSEQ FCD_0f051__00069_arg_FCL_AXIS, 1
0652  D001      	BRA	label27
0656            label27

		{

		} else {
0654  D003      	BRA	label28


			if (FCL_AXIS == 'X')
0656  0E58      	MOVLW 0x58
0658  63BF      	CPFSEQ FCD_0f051__00069_arg_FCL_AXIS, 1
065A  D004      	BRA	label29
065C            label28

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;
065C  5198      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W, 1
065E  6FC0      	MOVWF FCD_0f051__00069_1_FCR_RETVAL, 1
0660  5199      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', W, 1
0662  6FC1      	MOVWF FCD_0f051__00069_1_FCR_RETVAL+D'1', 1


FCC_G4D_ReadTouchCoordinatesPicaso_A:
0664            label29

;

	if (FCL_AXIS == 1)
0664  05BF      	DECF FCD_0f051__00069_arg_FCL_AXIS, W, 1
0666  E007      	BZ	label31

	{

	} else {

		if (FCL_AXIS == 'y')
0668  0E79      	MOVLW 0x79
066A  63BF      	CPFSEQ FCD_0f051__00069_arg_FCL_AXIS, 1
066C  D001      	BRA	label30
0670            label30

		{

		} else {
066E  D003      	BRA	label31


			if (FCL_AXIS == 'Y')
0670  0E59      	MOVLW 0x59
0672  63BF      	CPFSEQ FCD_0f051__00069_arg_FCL_AXIS, 1
0674  D004      	BRA	label32
0676            label31

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;
0676  5196      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W, 1
0678  6FC0      	MOVWF FCD_0f051__00069_1_FCR_RETVAL, 1
067A  5197      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', W, 1
067C  6FC1      	MOVWF FCD_0f051__00069_1_FCR_RETVAL+D'1', 1


FCC_G4D_ReadTouchCoordinatesPicaso_B:
067E            label32

;

	return (FCR_RETVAL);
067E  51C0      	MOVF FCD_0f051__00069_1_FCR_RETVAL, W, 1
0680  6FC2      	MOVWF CompTempVarRet2673, 1
0682  51C1      	MOVF FCD_0f051__00069_1_FCR_RETVAL+D'1', W, 1
0684  6FC3      	MOVWF CompTempVarRet2673+D'1', 1


}
0686  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x6F);
0430  0E6F      	MOVLW 0x6F
0432  0101      	MOVLB 0x01
0434  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0436  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0438  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(4);
043C  0E04      	MOVLW 0x04
043E  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0440  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0442  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Receive_1(255);
0446  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
0448  EC4EF000  	CALL FC_CAL_UAR_0008B


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
044C  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
044E  EC4EF000  	CALL FC_CAL_UAR_0008B
0452  5109      	MOVF CompTempVarRet2860, W, 1
0454  0100      	MOVLB 0x00
0456  6FC0      	MOVWF FCD_0f051__00083_1_FCR_RETVAL, 1


	FC_CAL_UART_Receive_1(255);
0458  0101      	MOVLB 0x01
045A  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
045C  EC4EF000  	CALL FC_CAL_UAR_0008B


	FC_CAL_UART_Receive_1(255);
0460  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
0462  EC4EF000  	CALL FC_CAL_UAR_0008B


	if (FCR_RETVAL)
0466  0100      	MOVLB 0x00
0468  53C0      	MOVF FCD_0f051__00083_1_FCR_RETVAL, F, 1
046A  E03E      	BZ	label20
04E8            label20

	{

		FC_CAL_UART_Send_1(0x6F);
046C  0E6F      	MOVLW 0x6F
046E  0101      	MOVLB 0x01
0470  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0472  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0474  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(5);
0478  0E05      	MOVLW 0x05
047A  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
047C  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
047E  EC46F000  	CALL FC_CAL_UAR_0008C


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_1(255);
0482  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
0484  EC4EF000  	CALL FC_CAL_UAR_0008B
0488  5109      	MOVF CompTempVarRet2860, W, 1
048A  0100      	MOVLB 0x00
048C  6F98      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F, 1
048E  0101      	MOVLB 0x01
0490  510A      	MOVF CompTempVarRet2860+D'1', W, 1
0492  0100      	MOVLB 0x00
0494  6F99      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', 1


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
0496  0101      	MOVLB 0x01
0498  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
049A  EC4EF000  	CALL FC_CAL_UAR_0008B
049E  5109      	MOVF CompTempVarRet2860, W, 1
04A0  0100      	MOVLB 0x00
04A2  6FBF      	MOVWF FCD_0f051__00083_1_FCL_TEMP, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
04A4  6BC1      	CLRF CompTempVar2839, 1
04A6  5198      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W, 1
04A8  6F99      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', 1
04AA  51C1      	MOVF CompTempVar2839, W, 1
04AC  6F98      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F, 1

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;
04AE  51BF      	MOVF FCD_0f051__00083_1_FCL_TEMP, W, 1
04B0  1398      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000F, F, 1
04B2  5399      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', F, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_1(255);
04B4  0101      	MOVLB 0x01
04B6  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
04B8  EC4EF000  	CALL FC_CAL_UAR_0008B
04BC  5109      	MOVF CompTempVarRet2860, W, 1
04BE  0100      	MOVLB 0x00
04C0  6F96      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E, 1
04C2  0101      	MOVLB 0x01
04C4  510A      	MOVF CompTempVarRet2860+D'1', W, 1
04C6  0100      	MOVLB 0x00
04C8  6F97      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', 1


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
04CA  0101      	MOVLB 0x01
04CC  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
04CE  EC4EF000  	CALL FC_CAL_UAR_0008B
04D2  5109      	MOVF CompTempVarRet2860, W, 1
04D4  0100      	MOVLB 0x00
04D6  6FBF      	MOVWF FCD_0f051__00083_1_FCL_TEMP, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
04D8  6BC1      	CLRF CompTempVar2843, 1
04DA  5196      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W, 1
04DC  6F97      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', 1
04DE  51C1      	MOVF CompTempVar2843, W, 1
04E0  6F96      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E, 1

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;
04E2  51BF      	MOVF FCD_0f051__00083_1_FCL_TEMP, W, 1
04E4  1396      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000E, F, 1
04E6  5397      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', F, 1


	// } else {

	}

	return (FCR_RETVAL);
04E8  51C0      	MOVF FCD_0f051__00083_1_FCR_RETVAL, W, 1
04EA  6FC1      	MOVWF CompTempVarRet2838, 1


}
04EC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_1(FCL_RADIUS);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
1078  6BC1      	CLRF FCD_0f051__00087_1_FCL_D1, 1
107A  6BC2      	CLRF FCD_0f051__00087_1_FCL_D1+D'1', 1

	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
107C  0E01      	MOVLW 0x01
107E  6FC3      	MOVWF FCD_0f051__00087_1_FCL_YINC, 1
1080  6BC4      	CLRF FCD_0f051__00087_1_FCL_YINC+D'1', 1

	MX_SINT16 FCL_XINC = (1);
1082  0E01      	MOVLW 0x01
1084  6FC5      	MOVWF FCD_0f051__00087_1_FCL_XINC, 1
1086  6BC6      	CLRF FCD_0f051__00087_1_FCL_XINC+D'1', 1



	FC_CAL_UART_Send_1(0x4C);
1088  0E4C      	MOVLW 0x4C
108A  0101      	MOVLB 0x01
108C  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
108E  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
1090  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
1094  0100      	MOVLB 0x00
1096  51BA      	MOVF FCD_0f051__00087_arg_FCL_X1+D'1', W, 1
1098  0101      	MOVLB 0x01
109A  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
109C  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
109E  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X1);
10A2  0100      	MOVLB 0x00
10A4  51B9      	MOVF FCD_0f051__00087_arg_FCL_X1, W, 1
10A6  0101      	MOVLB 0x01
10A8  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
10AA  0100      	MOVLB 0x00
10AC  51BA      	MOVF FCD_0f051__00087_arg_FCL_X1+D'1', W, 1
10AE  0101      	MOVLB 0x01
10B0  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
10B2  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
10B6  0100      	MOVLB 0x00
10B8  51BC      	MOVF FCD_0f051__00087_arg_FCL_Y1+D'1', W, 1
10BA  0101      	MOVLB 0x01
10BC  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
10BE  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
10C0  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y1);
10C4  0100      	MOVLB 0x00
10C6  51BB      	MOVF FCD_0f051__00087_arg_FCL_Y1, W, 1
10C8  0101      	MOVLB 0x01
10CA  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
10CC  0100      	MOVLB 0x00
10CE  51BC      	MOVF FCD_0f051__00087_arg_FCL_Y1+D'1', W, 1
10D0  0101      	MOVLB 0x01
10D2  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
10D4  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
10D8  0100      	MOVLB 0x00
10DA  51BE      	MOVF FCD_0f051__00087_arg_FCL_X2+D'1', W, 1
10DC  0101      	MOVLB 0x01
10DE  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
10E0  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
10E2  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X2);
10E6  0100      	MOVLB 0x00
10E8  51BD      	MOVF FCD_0f051__00087_arg_FCL_X2, W, 1
10EA  0101      	MOVLB 0x01
10EC  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
10EE  0100      	MOVLB 0x00
10F0  51BE      	MOVF FCD_0f051__00087_arg_FCL_X2+D'1', W, 1
10F2  0101      	MOVLB 0x01
10F4  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
10F6  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
10FA  0100      	MOVLB 0x00
10FC  51C0      	MOVF FCD_0f051__00087_arg_FCL_Y2+D'1', W, 1
10FE  0101      	MOVLB 0x01
1100  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1102  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
1104  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y2);
1108  0100      	MOVLB 0x00
110A  51BF      	MOVF FCD_0f051__00087_arg_FCL_Y2, W, 1
110C  0101      	MOVLB 0x01
110E  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1110  0100      	MOVLB 0x00
1112  51C0      	MOVF FCD_0f051__00087_arg_FCL_Y2+D'1', W, 1
1114  0101      	MOVLB 0x01
1116  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
1118  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
111C  0100      	MOVLB 0x00
111E  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
1120  0101      	MOVLB 0x01
1122  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1124  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
1126  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
112A  0100      	MOVLB 0x00
112C  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
112E  0101      	MOVLB 0x01
1130  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1132  0100      	MOVLB 0x00
1134  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
1136  0101      	MOVLB 0x01
1138  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
113A  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Receive_1(255);
113E  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
1140  EC4EF000  	CALL FC_CAL_UAR_0008B


}
1144  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_POSH >> 8);

	FC_CAL_UART_Send_1(FCL_POSH);

	FC_CAL_UART_Send_1(FCL_POSL >> 8);

	FC_CAL_UART_Send_1(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
0556  0E59      	MOVLW 0x59
0558  0101      	MOVLB 0x01
055A  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
055C  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
055E  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(0x05);
0562  0E05      	MOVLW 0x05
0564  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0566  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0568  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(0x01);
056C  0E01      	MOVLW 0x01
056E  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0570  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0572  EC46F000  	CALL FC_CAL_UAR_0008C


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0576  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
0578  EC4EF000  	CALL FC_CAL_UAR_0008B
057C  5109      	MOVF CompTempVarRet2860, W, 1
057E  0100      	MOVLB 0x00
0580  6FBF      	MOVWF FCD_0f051__00076_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
0582  0E06      	MOVLW 0x06
0584  63BF      	CPFSEQ FCD_0f051__00076_1_FCR_RETVAL, 1
0586  D002      	BRA	label23
058C            label23

	{

		FCR_RETVAL = 0;
0588  6BBF      	CLRF FCD_0f051__00076_1_FCR_RETVAL, 1


	} else {
058A  D001      	BRA	label24
058E            label24


		FCR_RETVAL = 255;
058C  69BF      	SETF FCD_0f051__00076_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
058E  51BF      	MOVF FCD_0f051__00076_1_FCR_RETVAL, W, 1
0590  6FC0      	MOVWF CompTempVarRet2786, 1


}
0592  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x00);

	FC_CAL_UART_Send_1(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x01);

	FC_CAL_UART_Send_1(FCL_DISPLAY);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x02);

	FC_CAL_UART_Send_1(FCL_CONTRAST);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
04EE  0E59      	MOVLW 0x59
04F0  0101      	MOVLB 0x01
04F2  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
04F4  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
04F6  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(0x05);
04FA  0E05      	MOVLW 0x05
04FC  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
04FE  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0500  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(0x00);
0504  6B00      	CLRF FC_CAL_UAR_0008C_arg_nChar, 1
0506  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0508  EC46F000  	CALL FC_CAL_UAR_0008C


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
050C  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
050E  EC4EF000  	CALL FC_CAL_UAR_0008B
0512  5109      	MOVF CompTempVarRet2860, W, 1
0514  0100      	MOVLB 0x00
0516  6FBF      	MOVWF FCD_0f051__00077_1_FCR_RETVAL, 1


	FC_CAL_UART_Send_1(0x59);
0518  0E59      	MOVLW 0x59
051A  0101      	MOVLB 0x01
051C  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
051E  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0520  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(0x05);
0524  0E05      	MOVLW 0x05
0526  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0528  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
052A  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(0x02);
052E  0E02      	MOVLW 0x02
0530  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0532  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0534  EC46F000  	CALL FC_CAL_UAR_0008C


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0538  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
053A  EC4EF000  	CALL FC_CAL_UAR_0008B
053E  5109      	MOVF CompTempVarRet2860, W, 1
0540  0100      	MOVLB 0x00
0542  6FBF      	MOVWF FCD_0f051__00077_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
0544  0E06      	MOVLW 0x06
0546  63BF      	CPFSEQ FCD_0f051__00077_1_FCR_RETVAL, 1
0548  D002      	BRA	label21
054E            label21

	{

		FCR_RETVAL = 0;
054A  6BBF      	CLRF FCD_0f051__00077_1_FCR_RETVAL, 1


	} else {
054C  D001      	BRA	label22
0550            label22


		FCR_RETVAL = 255;
054E  69BF      	SETF FCD_0f051__00077_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
0550  51BF      	MOVF FCD_0f051__00077_1_FCR_RETVAL, W, 1
0552  6FC0      	MOVWF CompTempVarRet2787, 1


}
0554  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x56);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_1(0x10);

	} else {

		FC_CAL_UART_Send_1(0x08);

	}

	FC_CAL_UART_Send_1(FCL_DELAY);

	FC_CAL_UART_Send_1(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_1(FCL_FRAMES);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x76);

	FC_CAL_UART_Send_1(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_1(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_1(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_1(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_1(0x03);

		}
	}

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x65);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RX >> 8);

	FC_CAL_UART_Send_1(FCL_RX);

	FC_CAL_UART_Send_1(FCL_RY >> 8);

	FC_CAL_UART_Send_1(FCL_RY);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);
0688  6BFF      	CLRF FCD_0f051__00066_1_FCL_IDX, 1



	FC_CAL_UART_Send_1(0x4F);
068A  0E4F      	MOVLW 0x4F
068C  0101      	MOVLB 0x01
068E  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0690  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0692  EC46F000  	CALL FC_CAL_UAR_0008C


	if (FCL_TRANSPARENT)
0696  0100      	MOVLB 0x00
0698  53FD      	MOVF FCD_0f051__00066_arg_FCL_T_00067, F, 1
069A  E006      	BZ	label33
06A8            label33

	{

		FC_CAL_UART_Send_1(0x00);
069C  0101      	MOVLB 0x01
069E  6B00      	CLRF FC_CAL_UAR_0008C_arg_nChar, 1
06A0  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
06A2  EC46F000  	CALL FC_CAL_UAR_0008C


	} else {
06A6  D006      	BRA	label34
06B4            label34


		FC_CAL_UART_Send_1(0x01);
06A8  0E01      	MOVLW 0x01
06AA  0101      	MOVLB 0x01
06AC  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
06AE  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
06B0  EC46F000  	CALL FC_CAL_UAR_0008C


	}

	FC_CAL_UART_Receive_1(255);
06B4  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
06B6  EC4EF000  	CALL FC_CAL_UAR_0008B


	FC_CAL_UART_Send_1(0x53);
06BA  0E53      	MOVLW 0x53
06BC  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
06BE  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
06C0  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
06C4  0100      	MOVLB 0x00
06C6  51F9      	MOVF FCD_0f051__00066_arg_FCL_X1+D'1', W, 1
06C8  0101      	MOVLB 0x01
06CA  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
06CC  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
06CE  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X1);
06D2  0100      	MOVLB 0x00
06D4  51F8      	MOVF FCD_0f051__00066_arg_FCL_X1, W, 1
06D6  0101      	MOVLB 0x01
06D8  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
06DA  0100      	MOVLB 0x00
06DC  51F9      	MOVF FCD_0f051__00066_arg_FCL_X1+D'1', W, 1
06DE  0101      	MOVLB 0x01
06E0  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
06E2  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
06E6  0100      	MOVLB 0x00
06E8  51FB      	MOVF FCD_0f051__00066_arg_FCL_Y1+D'1', W, 1
06EA  0101      	MOVLB 0x01
06EC  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
06EE  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
06F0  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y1);
06F4  0100      	MOVLB 0x00
06F6  51FA      	MOVF FCD_0f051__00066_arg_FCL_Y1, W, 1
06F8  0101      	MOVLB 0x01
06FA  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
06FC  0100      	MOVLB 0x00
06FE  51FB      	MOVF FCD_0f051__00066_arg_FCL_Y1+D'1', W, 1
0700  0101      	MOVLB 0x01
0702  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0704  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_FONT);
0708  0100      	MOVLB 0x00
070A  51FC      	MOVF FCD_0f051__00066_arg_FCL_FONT, W, 1
070C  0101      	MOVLB 0x01
070E  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0710  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0712  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
0716  0100      	MOVLB 0x00
0718  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
071A  0101      	MOVLB 0x01
071C  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
071E  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0720  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0724  0100      	MOVLB 0x00
0726  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
0728  0101      	MOVLB 0x01
072A  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
072C  0100      	MOVLB 0x00
072E  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0730  0101      	MOVLB 0x01
0732  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0734  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(1);
0738  0E01      	MOVLW 0x01
073A  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
073C  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
073E  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(1);
0742  0E01      	MOVLW 0x01
0744  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0746  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0748  EC46F000  	CALL FC_CAL_UAR_0008C


	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);
074C  0100      	MOVLB 0x00
074E  51BF      	MOVF FCD_0f051__00066_arg_FCL_STR, W, 1
0750  0101      	MOVLB 0x01
0752  6F00      	MOVWF FCI_GETLEN_0004B_arg_sStr1, 1
0754  0100      	MOVLB 0x00
0756  51C0      	MOVF FCD_0f051__00066_arg_FCL_STR+D'1', W, 1
0758  0101      	MOVLB 0x01
075A  6F01      	MOVWF FCI_GETLEN_0004B_arg_sStr1+D'1', 1
075C  0100      	MOVLB 0x00
075E  51F6      	MOVF FCD_0f051__00066_arg_FCLsz_STR, W, 1
0760  0101      	MOVLB 0x01
0762  6F02      	MOVWF FCI_GETLEN_0004B_arg_iStr1_len, 1
0764  ECCDF001  	CALL FCI_GETLEN_0004B
0768  5104      	MOVF CompTempVarRet1850, W, 1
076A  0100      	MOVLB 0x00
076C  6FFE      	MOVWF FCD_0f051__00066_1_FCL_LEN_STR, 1


	while (FCL_IDX < FCL_LEN_STR)
076E            label35
076E  51FE      	MOVF FCD_0f051__00066_1_FCL_LEN_STR, W, 1
0770  61FF      	CPFSLT FCD_0f051__00066_1_FCL_IDX, 1
0772  D016      	BRA	label36
079E  D7E7      	BRA	label35
07A0            label36

	{

		if (FCL_STR[FCL_IDX] == 0)
0774  51C0      	MOVF FCD_0f051__00066_arg_FCL_STR+D'1', W, 1
0776  6EEA      	MOVWF FSR0H
0778  51BF      	MOVF FCD_0f051__00066_arg_FCL_STR, W, 1
077A  25FF      	ADDWF FCD_0f051__00066_1_FCL_IDX, W, 1
077C  6EE9      	MOVWF FSR0L
077E  52EF      	MOVF INDF0, F
0780  E00F      	BZ	label36

		{

			goto FCC_Print_A;


		// } else {

		}

		FC_CAL_UART_Send_1(FCL_STR[FCL_IDX]);
0782  51C0      	MOVF FCD_0f051__00066_arg_FCL_STR+D'1', W, 1
0784  6EEA      	MOVWF FSR0H
0786  51BF      	MOVF FCD_0f051__00066_arg_FCL_STR, W, 1
0788  25FF      	ADDWF FCD_0f051__00066_1_FCL_IDX, W, 1
078A  6EE9      	MOVWF FSR0L
078C  50EF      	MOVF INDF0, W
078E  0101      	MOVLB 0x01
0790  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0792  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0794  EC46F000  	CALL FC_CAL_UAR_0008C


		FCL_IDX = FCL_IDX + 1;
0798  0100      	MOVLB 0x00
079A  29FF      	INCF FCD_0f051__00066_1_FCL_IDX, W, 1
079C  6FFF      	MOVWF FCD_0f051__00066_1_FCL_IDX, 1



	}

FCC_Print_A:
;

	FC_CAL_UART_Send_1(0);
07A0  0101      	MOVLB 0x01
07A2  6B00      	CLRF FC_CAL_UAR_0008C_arg_nChar, 1
07A4  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
07A6  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Receive_1(255);
07AA  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
07AC  EC4EF000  	CALL FC_CAL_UAR_0008B


}
07B0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x0c);

	FC_CAL_UART_Send_1(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
1146  0100      	MOVLB 0x00
1148  6BBC      	CLRF FCD_0f051__0006E_1_FCL_Y, 1
114A  6BBD      	CLRF FCD_0f051__0006E_1_FCL_Y+D'1', 1

	MX_UINT16 FCL_X = (0x0);
114C  6BBE      	CLRF FCD_0f051__0006E_1_FCL_X, 1
114E  6BBF      	CLRF FCD_0f051__0006E_1_FCL_X+D'1', 1



	FC_CAL_UART_Send_1(0x42);
1150  0E42      	MOVLW 0x42
1152  0101      	MOVLB 0x01
1154  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1156  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
1158  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
115C  0100      	MOVLB 0x00
115E  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
1160  0101      	MOVLB 0x01
1162  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1164  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
1166  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
116A  0100      	MOVLB 0x00
116C  5192      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W, 1
116E  0101      	MOVLB 0x01
1170  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1172  0100      	MOVLB 0x00
1174  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
1176  0101      	MOVLB 0x01
1178  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
117A  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Receive_1(255);
117E  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
1180  EC4EF000  	CALL FC_CAL_UAR_0008B


	FC_CAL_UART_Send_1(0x45);
1184  0E45      	MOVLW 0x45
1186  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1188  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
118A  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Receive_1(255);
118E  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
1190  EC4EF000  	CALL FC_CAL_UAR_0008B


}
1194  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x49);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)

{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
0302  33CA      	RRCF FCD_0f051__0007D_arg_FCL_RED, F, 1
0304  33CA      	RRCF FCD_0f051__0007D_arg_FCL_RED, F, 1
0306  33CA      	RRCF FCD_0f051__0007D_arg_FCL_RED, F, 1
0308  0E1F      	MOVLW 0x1F
030A  17CA      	ANDWF FCD_0f051__0007D_arg_FCL_RED, F, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
030C  33CB      	RRCF FCD_0f051__0007D_arg_FCL_GREEN, F, 1
030E  33CB      	RRCF FCD_0f051__0007D_arg_FCL_GREEN, F, 1
0310  0E3F      	MOVLW 0x3F
0312  17CB      	ANDWF FCD_0f051__0007D_arg_FCL_GREEN, F, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0314  33CC      	RRCF FCD_0f051__0007D_arg_FCL_BLUE, F, 1
0316  33CC      	RRCF FCD_0f051__0007D_arg_FCL_BLUE, F, 1
0318  33CC      	RRCF FCD_0f051__0007D_arg_FCL_BLUE, F, 1
031A  0E1F      	MOVLW 0x1F
031C  17CC      	ANDWF FCD_0f051__0007D_arg_FCL_BLUE, F, 1


	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
031E  51CB      	MOVF FCD_0f051__0007D_arg_FCL_GREEN, W, 1
0320  6FCD      	MOVWF CompTempVar2807, 1
0322  6B95      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', 1
0324  37CD      	RLCF CompTempVar2807, F, 1
0326  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0328  37CD      	RLCF CompTempVar2807, F, 1
032A  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
032C  37CD      	RLCF CompTempVar2807, F, 1
032E  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0330  37CD      	RLCF CompTempVar2807, F, 1
0332  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0334  37CD      	RLCF CompTempVar2807, F, 1
0336  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0338  0EE0      	MOVLW 0xE0
033A  17CD      	ANDWF CompTempVar2807, F, 1
033C  51CD      	MOVF CompTempVar2807, W, 1
033E  11CC      	IORWF FCD_0f051__0007D_arg_FCL_BLUE, W, 1
0340  6F94      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
0342  6BCD      	CLRF CompTempVar2811, 1
0344  51CA      	MOVF FCD_0f051__0007D_arg_FCL_RED, W, 1
0346  6FCE      	MOVWF CompTempVar2812, 1
0348  90D8      	BCF STATUS,C
034A  37CE      	RLCF CompTempVar2812, F, 1
034C  90D8      	BCF STATUS,C
034E  37CE      	RLCF CompTempVar2812, F, 1
0350  90D8      	BCF STATUS,C
0352  37CE      	RLCF CompTempVar2812, F, 1
0354  51CD      	MOVF CompTempVar2811, W, 1
0356  1394      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F, 1
0358  51CE      	MOVF CompTempVar2812, W, 1
035A  1395      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1


}
035C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x75);
0594  0E75      	MOVLW 0x75
0596  0101      	MOVLB 0x01
0598  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
059A  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
059C  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
05A0  0100      	MOVLB 0x00
05A2  51C0      	MOVF FCD_0f051__0006F_arg_FCL_X1+D'1', W, 1
05A4  0101      	MOVLB 0x01
05A6  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
05A8  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
05AA  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X1);
05AE  0100      	MOVLB 0x00
05B0  51BF      	MOVF FCD_0f051__0006F_arg_FCL_X1, W, 1
05B2  0101      	MOVLB 0x01
05B4  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
05B6  0100      	MOVLB 0x00
05B8  51C0      	MOVF FCD_0f051__0006F_arg_FCL_X1+D'1', W, 1
05BA  0101      	MOVLB 0x01
05BC  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
05BE  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
05C2  0100      	MOVLB 0x00
05C4  51C2      	MOVF FCD_0f051__0006F_arg_FCL_Y1+D'1', W, 1
05C6  0101      	MOVLB 0x01
05C8  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
05CA  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
05CC  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y1);
05D0  0100      	MOVLB 0x00
05D2  51C1      	MOVF FCD_0f051__0006F_arg_FCL_Y1, W, 1
05D4  0101      	MOVLB 0x01
05D6  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
05D8  0100      	MOVLB 0x00
05DA  51C2      	MOVF FCD_0f051__0006F_arg_FCL_Y1+D'1', W, 1
05DC  0101      	MOVLB 0x01
05DE  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
05E0  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
05E4  0100      	MOVLB 0x00
05E6  51C4      	MOVF FCD_0f051__0006F_arg_FCL_X2+D'1', W, 1
05E8  0101      	MOVLB 0x01
05EA  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
05EC  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
05EE  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X2);
05F2  0100      	MOVLB 0x00
05F4  51C3      	MOVF FCD_0f051__0006F_arg_FCL_X2, W, 1
05F6  0101      	MOVLB 0x01
05F8  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
05FA  0100      	MOVLB 0x00
05FC  51C4      	MOVF FCD_0f051__0006F_arg_FCL_X2+D'1', W, 1
05FE  0101      	MOVLB 0x01
0600  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0602  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
0606  0100      	MOVLB 0x00
0608  51C6      	MOVF FCD_0f051__0006F_arg_FCL_Y2+D'1', W, 1
060A  0101      	MOVLB 0x01
060C  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
060E  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0610  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y2);
0614  0100      	MOVLB 0x00
0616  51C5      	MOVF FCD_0f051__0006F_arg_FCL_Y2, W, 1
0618  0101      	MOVLB 0x01
061A  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
061C  0100      	MOVLB 0x00
061E  51C6      	MOVF FCD_0f051__0006F_arg_FCL_Y2+D'1', W, 1
0620  0101      	MOVLB 0x01
0622  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0624  EC46F000  	CALL FC_CAL_UAR_0008C


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0628  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
062A  EC4EF000  	CALL FC_CAL_UAR_0008B
062E  5109      	MOVF CompTempVarRet2860, W, 1
0630  0100      	MOVLB 0x00
0632  6FC7      	MOVWF FCD_0f051__0006F_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
0634  0E06      	MOVLW 0x06
0636  63C7      	CPFSEQ FCD_0f051__0006F_1_FCR_RETVAL, 1
0638  D002      	BRA	label25
063E            label25

	{

		FCR_RETVAL = 0;
063A  6BC7      	CLRF FCD_0f051__0006F_1_FCR_RETVAL, 1


	} else {
063C  D001      	BRA	label26
0640            label26


		FCR_RETVAL = 255;
063E  69C7      	SETF FCD_0f051__0006F_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
0640  51C7      	MOVF FCD_0f051__0006F_1_FCR_RETVAL, W, 1
0642  6FC8      	MOVWF CompTempVarRet2731, 1


}
0644  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6C);

	FC_CAL_UART_Send_1(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)

{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
013A  53D2      	MOVF FCD_0f051__0007E_arg_FCL_T_0007F, F, 1
013C  E16C      	BNZ	label15
013E  53D3      	MOVF FCD_0f051__0007E_arg_FCL_SOLID, F, 1
0140  E16A      	BNZ	label15
0216            label15

	{

		FC_CAL_UART_Send_1(0x70);
0142  0E70      	MOVLW 0x70
0144  0101      	MOVLB 0x01
0146  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0148  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
014A  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(0x00);
014E  6B00      	CLRF FC_CAL_UAR_0008C_arg_nChar, 1
0150  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0152  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Receive_1(255);
0156  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
0158  EC4EF000  	CALL FC_CAL_UAR_0008B


		FC_CAL_UART_Send_1(0x72);
015C  0E72      	MOVLW 0x72
015E  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0160  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0162  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(FCL_X1 >> 8);
0166  0100      	MOVLB 0x00
0168  51CB      	MOVF FCD_0f051__0007E_arg_FCL_X1+D'1', W, 1
016A  0101      	MOVLB 0x01
016C  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
016E  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0170  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(FCL_X1);
0174  0100      	MOVLB 0x00
0176  51CA      	MOVF FCD_0f051__0007E_arg_FCL_X1, W, 1
0178  0101      	MOVLB 0x01
017A  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
017C  0100      	MOVLB 0x00
017E  51CB      	MOVF FCD_0f051__0007E_arg_FCL_X1+D'1', W, 1
0180  0101      	MOVLB 0x01
0182  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0184  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0188  0100      	MOVLB 0x00
018A  51CD      	MOVF FCD_0f051__0007E_arg_FCL_Y1+D'1', W, 1
018C  0101      	MOVLB 0x01
018E  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0190  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0192  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(FCL_Y1);
0196  0100      	MOVLB 0x00
0198  51CC      	MOVF FCD_0f051__0007E_arg_FCL_Y1, W, 1
019A  0101      	MOVLB 0x01
019C  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
019E  0100      	MOVLB 0x00
01A0  51CD      	MOVF FCD_0f051__0007E_arg_FCL_Y1+D'1', W, 1
01A2  0101      	MOVLB 0x01
01A4  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
01A6  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(FCL_X2 >> 8);
01AA  0100      	MOVLB 0x00
01AC  51CF      	MOVF FCD_0f051__0007E_arg_FCL_X2+D'1', W, 1
01AE  0101      	MOVLB 0x01
01B0  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
01B2  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
01B4  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(FCL_X2);
01B8  0100      	MOVLB 0x00
01BA  51CE      	MOVF FCD_0f051__0007E_arg_FCL_X2, W, 1
01BC  0101      	MOVLB 0x01
01BE  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
01C0  0100      	MOVLB 0x00
01C2  51CF      	MOVF FCD_0f051__0007E_arg_FCL_X2+D'1', W, 1
01C4  0101      	MOVLB 0x01
01C6  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
01C8  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(FCL_Y2 >> 8);
01CC  0100      	MOVLB 0x00
01CE  51D1      	MOVF FCD_0f051__0007E_arg_FCL_Y2+D'1', W, 1
01D0  0101      	MOVLB 0x01
01D2  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
01D4  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
01D6  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(FCL_Y2);
01DA  0100      	MOVLB 0x00
01DC  51D0      	MOVF FCD_0f051__0007E_arg_FCL_Y2, W, 1
01DE  0101      	MOVLB 0x01
01E0  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
01E2  0100      	MOVLB 0x00
01E4  51D1      	MOVF FCD_0f051__0007E_arg_FCL_Y2+D'1', W, 1
01E6  0101      	MOVLB 0x01
01E8  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
01EA  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
01EE  0100      	MOVLB 0x00
01F0  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
01F2  0101      	MOVLB 0x01
01F4  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
01F6  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
01F8  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
01FC  0100      	MOVLB 0x00
01FE  5192      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W, 1
0200  0101      	MOVLB 0x01
0202  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0204  0100      	MOVLB 0x00
0206  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
0208  0101      	MOVLB 0x01
020A  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
020C  EC46F000  	CALL FC_CAL_UAR_0008C


		FC_CAL_UART_Receive_1(255);
0210  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
0212  EC4EF000  	CALL FC_CAL_UAR_0008B


	// } else {

	}

	FC_CAL_UART_Send_1(0x70);
0216  0E70      	MOVLW 0x70
0218  0101      	MOVLB 0x01
021A  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
021C  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
021E  EC46F000  	CALL FC_CAL_UAR_0008C


	if (FCL_SOLID)
0222  0100      	MOVLB 0x00
0224  53D3      	MOVF FCD_0f051__0007E_arg_FCL_SOLID, F, 1
0226  E006      	BZ	label16
0234            label16

	{

		FC_CAL_UART_Send_1(0x00);
0228  0101      	MOVLB 0x01
022A  6B00      	CLRF FC_CAL_UAR_0008C_arg_nChar, 1
022C  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
022E  EC46F000  	CALL FC_CAL_UAR_0008C


	} else {
0232  D006      	BRA	label17
0240            label17


		FC_CAL_UART_Send_1(0x01);
0234  0E01      	MOVLW 0x01
0236  0101      	MOVLB 0x01
0238  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
023A  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
023C  EC46F000  	CALL FC_CAL_UAR_0008C


	}

	FC_CAL_UART_Receive_1(255);
0240  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
0242  EC4EF000  	CALL FC_CAL_UAR_0008B


	FC_CAL_UART_Send_1(0x72);
0246  0E72      	MOVLW 0x72
0248  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
024A  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
024C  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0250  0100      	MOVLB 0x00
0252  51CB      	MOVF FCD_0f051__0007E_arg_FCL_X1+D'1', W, 1
0254  0101      	MOVLB 0x01
0256  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0258  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
025A  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X1);
025E  0100      	MOVLB 0x00
0260  51CA      	MOVF FCD_0f051__0007E_arg_FCL_X1, W, 1
0262  0101      	MOVLB 0x01
0264  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0266  0100      	MOVLB 0x00
0268  51CB      	MOVF FCD_0f051__0007E_arg_FCL_X1+D'1', W, 1
026A  0101      	MOVLB 0x01
026C  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
026E  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0272  0100      	MOVLB 0x00
0274  51CD      	MOVF FCD_0f051__0007E_arg_FCL_Y1+D'1', W, 1
0276  0101      	MOVLB 0x01
0278  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
027A  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
027C  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y1);
0280  0100      	MOVLB 0x00
0282  51CC      	MOVF FCD_0f051__0007E_arg_FCL_Y1, W, 1
0284  0101      	MOVLB 0x01
0286  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
0288  0100      	MOVLB 0x00
028A  51CD      	MOVF FCD_0f051__0007E_arg_FCL_Y1+D'1', W, 1
028C  0101      	MOVLB 0x01
028E  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
0290  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
0294  0100      	MOVLB 0x00
0296  51CF      	MOVF FCD_0f051__0007E_arg_FCL_X2+D'1', W, 1
0298  0101      	MOVLB 0x01
029A  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
029C  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
029E  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_X2);
02A2  0100      	MOVLB 0x00
02A4  51CE      	MOVF FCD_0f051__0007E_arg_FCL_X2, W, 1
02A6  0101      	MOVLB 0x01
02A8  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
02AA  0100      	MOVLB 0x00
02AC  51CF      	MOVF FCD_0f051__0007E_arg_FCL_X2+D'1', W, 1
02AE  0101      	MOVLB 0x01
02B0  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
02B2  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
02B6  0100      	MOVLB 0x00
02B8  51D1      	MOVF FCD_0f051__0007E_arg_FCL_Y2+D'1', W, 1
02BA  0101      	MOVLB 0x01
02BC  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
02BE  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
02C0  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCL_Y2);
02C4  0100      	MOVLB 0x00
02C6  51D0      	MOVF FCD_0f051__0007E_arg_FCL_Y2, W, 1
02C8  0101      	MOVLB 0x01
02CA  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
02CC  0100      	MOVLB 0x00
02CE  51D1      	MOVF FCD_0f051__0007E_arg_FCL_Y2+D'1', W, 1
02D0  0101      	MOVLB 0x01
02D2  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
02D4  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
02D8  0100      	MOVLB 0x00
02DA  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
02DC  0101      	MOVLB 0x01
02DE  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
02E0  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
02E2  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
02E6  0100      	MOVLB 0x00
02E8  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
02EA  0101      	MOVLB 0x01
02EC  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
02EE  0100      	MOVLB 0x00
02F0  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
02F2  0101      	MOVLB 0x01
02F4  6F01      	MOVWF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
02F6  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Receive_1(255);
02FA  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
02FC  EC4EF000  	CALL FC_CAL_UAR_0008B


}
0300  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, C, 0x20, 0x5, 0);
16F2  0100      	MOVLB 0x00
16F4  6BBC      	CLRF FCD_0f051__0006D_2_ptmp, 1
16F6  9A94      	BCF gbl_trisc,5
16F8  53BC      	MOVF FCD_0f051__0006D_2_ptmp, F, 1
16FA  E004      	BZ	label104
16FC  0E20      	MOVLW 0x20
16FE  108B      	IORWF gbl_latc, W
1700  6E82      	MOVWF gbl_portc
1702  D003      	BRA	label105
1704            label104
1704  0EDF      	MOVLW 0xDF
1706  148B      	ANDWF gbl_latc, W
1708  6E82      	MOVWF gbl_portc
170A            label105


	FC_CAL_UART_Init_1();
170A  EC3AF006  	CALL FC_CAL_UAR_0008D


	FCI_DELAYBYTE_US(100);
170E  0E64      	MOVLW 0x64
1710  6FBC      	MOVWF delay_us_00000_arg_del, 1
1712  EC2EF000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, C, 0x20, 0x5);
1716  0E0F      	MOVLW HIGH(gbl_portc+D'0')
1718  6FBD      	MOVWF FC_CAL_Por_00042_arg_Port+D'1', 1
171A  0E82      	MOVLW LOW(gbl_portc+D'0')
171C  6FBC      	MOVWF FC_CAL_Por_00042_arg_Port, 1
171E  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
1720  6FBF      	MOVWF FC_CAL_Por_00042_arg_Tris+D'1', 1
1722  0E94      	MOVLW LOW(gbl_trisc+D'0')
1724  6FBE      	MOVWF FC_CAL_Por_00042_arg_Tris, 1
1726  0E20      	MOVLW 0x20
1728  6FC0      	MOVWF FC_CAL_Por_00042_arg_InMask, 1
172A  0E05      	MOVLW 0x05
172C  6FC1      	MOVWF FC_CAL_Por_00042_arg_Shift, 1
172E  EC8BF006  	CALL FC_CAL_Por_00042
1732  51C2      	MOVF CompTempVarRet1822, W, 1
1734  6FBB      	MOVWF FCD_0f051__0006D_1_FCL_DUMMY, 1


	FCI_DELAYBYTE_S(3);
1736  0E03      	MOVLW 0x03
1738  6FBC      	MOVWF delay_s_00000_arg_del, 1
173A  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_1(0);
173E  0101      	MOVLB 0x01
1740  6B00      	CLRF FC_CAL_UAR_0008B_arg_nTimeout, 1
1742  EC4EF000  	CALL FC_CAL_UAR_0008B


	FC_CAL_UART_Receive_1(0);
1746  6B00      	CLRF FC_CAL_UAR_0008B_arg_nTimeout, 1
1748  EC4EF000  	CALL FC_CAL_UAR_0008B


	FC_CAL_UART_Receive_1(0);
174C  6B00      	CLRF FC_CAL_UAR_0008B_arg_nTimeout, 1
174E  EC4EF000  	CALL FC_CAL_UAR_0008B


	FC_CAL_UART_Send_1(0x55);
1752  0E55      	MOVLW 0x55
1754  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1756  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
1758  EC46F000  	CALL FC_CAL_UAR_0008C


	FC_CAL_UART_Receive_1(255);
175C  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
175E  EC4EF000  	CALL FC_CAL_UAR_0008B


	#if (1) // 1 == 1

		#if (1) // 1 != 0

			FC_CAL_UART_Send_1(0x51);
1762  0E51      	MOVLW 0x51
1764  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1766  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
1768  EC46F000  	CALL FC_CAL_UAR_0008C


			FC_CAL_UART_Send_1(0x0C);
176C  0E0C      	MOVLW 0x0C
176E  6F00      	MOVWF FC_CAL_UAR_0008C_arg_nChar, 1
1770  6B01      	CLRF FC_CAL_UAR_0008C_arg_nChar+D'1', 1
1772  EC46F000  	CALL FC_CAL_UAR_0008C


			FC_CAL_UART_Receive_1(255);
1776  6900      	SETF FC_CAL_UAR_0008B_arg_nTimeout, 1
1778  EC4EF000  	CALL FC_CAL_UAR_0008B


			FC_CAL_UART_UpdateBaud_1(6);
177C  0E06      	MOVLW 0x06
177E  0100      	MOVLB 0x00
1780  6FBC      	MOVWF FC_CAL_UAR_00089_arg_new_baud, 1
1782  EC43F006  	CALL FC_CAL_UAR_00089



		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_1(10);
1786  0E0A      	MOVLW 0x0A
1788  0101      	MOVLB 0x01
178A  6F00      	MOVWF FC_CAL_UAR_0008B_arg_nTimeout, 1
178C  EC4EF000  	CALL FC_CAL_UAR_0008B


	FC_CAL_UART_Receive_1(10);
1790  0E0A      	MOVLW 0x0A
1792  6F00      	MOVWF FC_CAL_UAR_0008B_arg_nTimeout, 1
1794  EC4EF000  	CALL FC_CAL_UAR_0008B


	FCL_RED = 0 & 0xFF;
1798  0100      	MOVLB 0x00
179A  6BB8      	CLRF FCD_0f051__0006D_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
179C  33B8      	RRCF FCD_0f051__0006D_1_FCL_RED, F, 1
179E  33B8      	RRCF FCD_0f051__0006D_1_FCL_RED, F, 1
17A0  33B8      	RRCF FCD_0f051__0006D_1_FCL_RED, F, 1
17A2  0E1F      	MOVLW 0x1F
17A4  17B8      	ANDWF FCD_0f051__0006D_1_FCL_RED, F, 1

	FCL_GREEN = (0 >> 8) & 0xFF;
17A6  6BB9      	CLRF FCD_0f051__0006D_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
17A8  33B9      	RRCF FCD_0f051__0006D_1_FCL_GREEN, F, 1
17AA  33B9      	RRCF FCD_0f051__0006D_1_FCL_GREEN, F, 1
17AC  0E3F      	MOVLW 0x3F
17AE  17B9      	ANDWF FCD_0f051__0006D_1_FCL_GREEN, F, 1

	FCL_BLUE = (0 >> 16) & 0xFF;
17B0  6BBA      	CLRF FCD_0f051__0006D_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
17B2  33BA      	RRCF FCD_0f051__0006D_1_FCL_BLUE, F, 1
17B4  33BA      	RRCF FCD_0f051__0006D_1_FCL_BLUE, F, 1
17B6  33BA      	RRCF FCD_0f051__0006D_1_FCL_BLUE, F, 1
17B8  0E1F      	MOVLW 0x1F
17BA  17BA      	ANDWF FCD_0f051__0006D_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
17BC  51B9      	MOVF FCD_0f051__0006D_1_FCL_GREEN, W, 1
17BE  6FBC      	MOVWF CompTempVar2704, 1
17C0  6B95      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', 1
17C2  37BC      	RLCF CompTempVar2704, F, 1
17C4  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
17C6  37BC      	RLCF CompTempVar2704, F, 1
17C8  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
17CA  37BC      	RLCF CompTempVar2704, F, 1
17CC  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
17CE  37BC      	RLCF CompTempVar2704, F, 1
17D0  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
17D2  37BC      	RLCF CompTempVar2704, F, 1
17D4  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
17D6  0EE0      	MOVLW 0xE0
17D8  17BC      	ANDWF CompTempVar2704, F, 1
17DA  51BC      	MOVF CompTempVar2704, W, 1
17DC  11BA      	IORWF FCD_0f051__0006D_1_FCL_BLUE, W, 1
17DE  6F94      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
17E0  6BBC      	CLRF CompTempVar2708, 1
17E2  51B8      	MOVF FCD_0f051__0006D_1_FCL_RED, W, 1
17E4  6FBD      	MOVWF CompTempVar2709, 1
17E6  90D8      	BCF STATUS,C
17E8  37BD      	RLCF CompTempVar2709, F, 1
17EA  90D8      	BCF STATUS,C
17EC  37BD      	RLCF CompTempVar2709, F, 1
17EE  90D8      	BCF STATUS,C
17F0  37BD      	RLCF CompTempVar2709, F, 1
17F2  51BC      	MOVF CompTempVar2708, W, 1
17F4  1394      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F, 1
17F6  51BD      	MOVF CompTempVar2709, W, 1
17F8  1395      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1

	FCL_RED = 16777215 & 0xFF;
17FA  69B8      	SETF FCD_0f051__0006D_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
17FC  33B8      	RRCF FCD_0f051__0006D_1_FCL_RED, F, 1
17FE  33B8      	RRCF FCD_0f051__0006D_1_FCL_RED, F, 1
1800  33B8      	RRCF FCD_0f051__0006D_1_FCL_RED, F, 1
1802  0E1F      	MOVLW 0x1F
1804  17B8      	ANDWF FCD_0f051__0006D_1_FCL_RED, F, 1

	FCL_GREEN = (16777215 >> 8) & 0xFF;
1806  69B9      	SETF FCD_0f051__0006D_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
1808  33B9      	RRCF FCD_0f051__0006D_1_FCL_GREEN, F, 1
180A  33B9      	RRCF FCD_0f051__0006D_1_FCL_GREEN, F, 1
180C  0E3F      	MOVLW 0x3F
180E  17B9      	ANDWF FCD_0f051__0006D_1_FCL_GREEN, F, 1

	FCL_BLUE = (16777215 >> 16) & 0xFF;
1810  69BA      	SETF FCD_0f051__0006D_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
1812  33BA      	RRCF FCD_0f051__0006D_1_FCL_BLUE, F, 1
1814  33BA      	RRCF FCD_0f051__0006D_1_FCL_BLUE, F, 1
1816  33BA      	RRCF FCD_0f051__0006D_1_FCL_BLUE, F, 1
1818  0E1F      	MOVLW 0x1F
181A  17BA      	ANDWF FCD_0f051__0006D_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
181C  51B9      	MOVF FCD_0f051__0006D_1_FCL_GREEN, W, 1
181E  6FBC      	MOVWF CompTempVar2715, 1
1820  6B93      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', 1
1822  37BC      	RLCF CompTempVar2715, F, 1
1824  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
1826  37BC      	RLCF CompTempVar2715, F, 1
1828  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
182A  37BC      	RLCF CompTempVar2715, F, 1
182C  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
182E  37BC      	RLCF CompTempVar2715, F, 1
1830  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
1832  37BC      	RLCF CompTempVar2715, F, 1
1834  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
1836  0EE0      	MOVLW 0xE0
1838  17BC      	ANDWF CompTempVar2715, F, 1
183A  51BC      	MOVF CompTempVar2715, W, 1
183C  11BA      	IORWF FCD_0f051__0006D_1_FCL_BLUE, W, 1
183E  6F92      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
1840  6BBC      	CLRF CompTempVar2719, 1
1842  51B8      	MOVF FCD_0f051__0006D_1_FCL_RED, W, 1
1844  6FBD      	MOVWF CompTempVar2720, 1
1846  90D8      	BCF STATUS,C
1848  37BD      	RLCF CompTempVar2720, F, 1
184A  90D8      	BCF STATUS,C
184C  37BD      	RLCF CompTempVar2720, F, 1
184E  90D8      	BCF STATUS,C
1850  37BD      	RLCF CompTempVar2720, F, 1
1852  51BC      	MOVF CompTempVar2719, W, 1
1854  1392      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F, 1
1856  51BD      	MOVF CompTempVar2720, W, 1
1858  1393      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
185A  ECA3F008  	CALL FCD_0f051__0006E


	FC_CAL_UART_Receive_1(10);
185E  0E0A      	MOVLW 0x0A
1860  6F00      	MOVWF FC_CAL_UAR_0008B_arg_nTimeout, 1
1862  EC4EF000  	CALL FC_CAL_UAR_0008B


	FC_CAL_UART_Receive_1(10);
1866  0E0A      	MOVLW 0x0A
1868  6F00      	MOVWF FC_CAL_UAR_0008B_arg_nTimeout, 1
186A  EC4EF000  	CALL FC_CAL_UAR_0008B


}
186E  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_Coule_TORP()

{

	// Appel d'une Macro
	// Appel d'une Macro: Message_Touche()
	FCM_Message_Touche();
0E72  ECDCF005  	CALL FCM_Messag_0005C


	// Calcul
	// Calcul:
	//  Tableau[hitbox_Joueur_1] = tableau[hitbox_Joueur_1] || 0b10000000
	//  Torpilleur = Torpilleur - 1
	FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] || 128;
0E76  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0E7A  50E9      	MOVF FSR0L, W
0E7C  0100      	MOVLB 0x00
0E7E  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0E80  26E9      	ADDWF FSR0L, F
0E82  6BB8      	CLRF CompTempVar2635, 1
0E84  2BB8      	INCF CompTempVar2635, F, 1
0E86  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0E88  6EE9      	MOVWF FSR0L
0E8A  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0E8C  26E9      	ADDWF FSR0L, F
0E8E  51B8      	MOVF CompTempVar2635, W, 1
0E90  6EEF      	MOVWF INDF0

	FCV_TORPILLEUR = FCV_TORPILLEUR - 1;
0E92  05A5      	DECF gbl_FCV_TORPILLEUR, W, 1
0E94  6FA5      	MOVWF gbl_FCV_TORPILLEUR, 1


}
0E96  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Hitbox_v2()

{

	// Boucle
	// Boucle: While Appui_Ecran = 0
	while (1)
1526            label90

	{

		// Boucle
		// Boucle: While Porte_avion = 5
		while (!(FCV_PORTE_AVION == 5))
1526  0100      	MOVLB 0x00
1528  6BB9      	CLRF CompTempVar2644, 1
152A  0E05      	MOVLW 0x05
152C  63AC      	CPFSEQ gbl_FCV_PORTE_AVION, 1
152E  D001      	BRA	label91
1530  2BB9      	INCF CompTempVar2644, F, 1
1532            label91
1532  67B9      	TSTFSZ CompTempVar2644, 1
1534  D010      	BRA	label92
1554  D7E8      	BRA	label90
1556            label92

		{

			// Décision
			// Décision: Porte_avion < 5?
			if (FCV_PORTE_AVION < 5)
1536  0E05      	MOVLW 0x05
1538  61AC      	CPFSLT gbl_FCV_PORTE_AVION, 1
153A  D7F5      	BRA	label90

			{

				// Décision
				// Décision: Appui_Ecran = 0?
				if (FCV_APPUI_ECRAN == 0)
153C  53A9      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
153E  B4D8      	BTFSC STATUS,Z

				{

					// Appel d'une Macro
					// Appel d'une Macro: Choix_Bateaux()
					FCM_Choix_Bateaux();
1540  EC0EF008  	CALL FCM_Choix__0005E


				// } else {

				}

				// Appel d'une Macro
				// Appel d'une Macro: Porte_avion()
				FCM_Porte_avion();
1544  EC76F007  	CALL FCM_Porte__0005F


				// Pause
				// Pause: 500 ms
				FCI_DELAYINT_MS(500);
1548  0EF4      	MOVLW 0xF4
154A  6FBF      	MOVWF FCI_DELAYI_00046_arg_Delay, 1
154C  0E01      	MOVLW 0x01
154E  6FC0      	MOVWF FCI_DELAYI_00046_arg_Delay+D'1', 1
1550  EC21F008  	CALL FCI_DELAYI_00046


			// } else {

			}


		}

		// Boucle
		// Boucle: While Croiseur = 4
		while (!(FCV_CROISEUR == 4))
1556  6BBA      	CLRF CompTempVar2646, 1
1558  0E04      	MOVLW 0x04
155A  63A4      	CPFSEQ gbl_FCV_CROISEUR, 1
155C  D001      	BRA	label93
155E  2BBA      	INCF CompTempVar2646, F, 1
1560            label93
1560  67BA      	TSTFSZ CompTempVar2646, 1
1562  D00E      	BRA	label94
157E  D7EB      	BRA	label92
1580            label94

		{

			// Décision
			// Décision: Porte_avion = 5?
			if (FCV_PORTE_AVION == 5)
1564  0E05      	MOVLW 0x05
1566  63AC      	CPFSEQ gbl_FCV_PORTE_AVION, 1
1568  D7F6      	BRA	label92

			{

				// Appel d'une Macro
				// Appel d'une Macro: Choix_Bateaux()
				FCM_Choix_Bateaux();
156A  EC0EF008  	CALL FCM_Choix__0005E


				// Appel d'une Macro
				// Appel d'une Macro: Croiseur()
				FCM_Croiseur();
156E  ECDBF007  	CALL FCM_Croise_00060


				// Pause
				// Pause: 500 ms
				FCI_DELAYINT_MS(500);
1572  0EF4      	MOVLW 0xF4
1574  6FBF      	MOVWF FCI_DELAYI_00046_arg_Delay, 1
1576  0E01      	MOVLW 0x01
1578  6FC0      	MOVWF FCI_DELAYI_00046_arg_Delay+D'1', 1
157A  EC21F008  	CALL FCI_DELAYI_00046


			// } else {

			}


		}

		// Boucle
		// Boucle: While Contre_torpilleur = 3
		while (!(FCV_CONTRE_TORPILLEUR == 3))
1580  6BBB      	CLRF CompTempVar2648, 1
1582  0E03      	MOVLW 0x03
1584  63AE      	CPFSEQ gbl_FCV_CONTRE_TORPILLEUR, 1
1586  D001      	BRA	label95
1588  2BBB      	INCF CompTempVar2648, F, 1
158A            label95
158A  67BB      	TSTFSZ CompTempVar2648, 1
158C  D00B      	BRA	label96
15A2  D7EE      	BRA	label94
15A4            label96

		{

			// Appel d'une Macro
			// Appel d'une Macro: Choix_Bateaux()
			FCM_Choix_Bateaux();
158E  EC0EF008  	CALL FCM_Choix__0005E


			// Appel d'une Macro
			// Appel d'une Macro: Contre_torpilleur()
			FCM_Contre_torpilleur();
1592  ECF9F007  	CALL FCM_Contre_00061


			// Pause
			// Pause: 500 ms
			FCI_DELAYINT_MS(500);
1596  0EF4      	MOVLW 0xF4
1598  6FBF      	MOVWF FCI_DELAYI_00046_arg_Delay, 1
159A  0E01      	MOVLW 0x01
159C  6FC0      	MOVWF FCI_DELAYI_00046_arg_Delay+D'1', 1
159E  EC21F008  	CALL FCI_DELAYI_00046



		}

		// Boucle
		// Boucle: While Sous_marin = 3
		while (!(FCV_SOUS_MARIN == 3))
15A4  6BBC      	CLRF CompTempVar2650, 1
15A6  0E03      	MOVLW 0x03
15A8  63A7      	CPFSEQ gbl_FCV_SOUS_MARIN, 1
15AA  D001      	BRA	label97
15AC  2BBC      	INCF CompTempVar2650, F, 1
15AE            label97
15AE  67BC      	TSTFSZ CompTempVar2650, 1
15B0  D00B      	BRA	label98
15C6  D7EE      	BRA	label96
15C8            label98

		{

			// Appel d'une Macro
			// Appel d'une Macro: Choix_Bateaux()
			FCM_Choix_Bateaux();
15B2  EC0EF008  	CALL FCM_Choix__0005E


			// Appel d'une Macro
			// Appel d'une Macro: Sous_marin()
			FCM_Sous_marin();
15B6  EC61F007  	CALL FCM_Sous_m_00062


			// Pause
			// Pause: 500 ms
			FCI_DELAYINT_MS(500);
15BA  0EF4      	MOVLW 0xF4
15BC  6FBF      	MOVWF FCI_DELAYI_00046_arg_Delay, 1
15BE  0E01      	MOVLW 0x01
15C0  6FC0      	MOVWF FCI_DELAYI_00046_arg_Delay+D'1', 1
15C2  EC21F008  	CALL FCI_DELAYI_00046



		}

		// Boucle
		// Boucle: While Torpilleur = 2
		while (!(FCV_TORPILLEUR == 2))
15C8  6BBD      	CLRF CompTempVar2652, 1
15CA  0E02      	MOVLW 0x02
15CC  63A5      	CPFSEQ gbl_FCV_TORPILLEUR, 1
15CE  D001      	BRA	label99
15D0  2BBD      	INCF CompTempVar2652, F, 1
15D2            label99
15D2  67BD      	TSTFSZ CompTempVar2652, 1
15D4  D00B      	BRA	label100
15EA  D7EE      	BRA	label98
15EC            label100

		{

			// Appel d'une Macro
			// Appel d'une Macro: Choix_Bateaux()
			FCM_Choix_Bateaux();
15D6  EC0EF008  	CALL FCM_Choix__0005E


			// Appel d'une Macro
			// Appel d'une Macro: Torpilleur()
			FCM_Torpilleur();
15DA  EC4CF007  	CALL FCM_Torpil_00063


			// Pause
			// Pause: 500 ms
			FCI_DELAYINT_MS(500);
15DE  0EF4      	MOVLW 0xF4
15E0  6FBF      	MOVWF FCI_DELAYI_00046_arg_Delay, 1
15E2  0E01      	MOVLW 0x01
15E4  6FC0      	MOVWF FCI_DELAYI_00046_arg_Delay+D'1', 1
15E6  EC21F008  	CALL FCI_DELAYI_00046



		}


		if ((FCV_APPUI_ECRAN == 0) != 0) break;
15EC  6BBE      	CLRF CompTempVar2653, 1
15EE  2BBE      	INCF CompTempVar2653, F, 1
15F0  67A9      	TSTFSZ gbl_FCV_APPUI_ECRAN, 1
15F2  91BE      	BCF CompTempVar2653,0, 1
15F4  53BE      	MOVF CompTempVar2653, F, 1
15F6  E097      	BZ	label90

	}

}
15F8  EF49F00C  	GOTO	label109


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_coule_PA()

{

	// Appel d'une Macro
	// Appel d'une Macro: Message_Touche()
	FCM_Message_Touche();
0E4C  ECDCF005  	CALL FCM_Messag_0005C


	// Calcul
	// Calcul:
	//  Tableau[hitbox_Joueur_1] = tableau[hitbox_Joueur_1] || 0b10000000
	//  Porte_avion = Porte_avion - 1
	FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] || 128;
0E50  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0E54  50E9      	MOVF FSR0L, W
0E56  0100      	MOVLB 0x00
0E58  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0E5A  26E9      	ADDWF FSR0L, F
0E5C  6BB8      	CLRF CompTempVar2661, 1
0E5E  2BB8      	INCF CompTempVar2661, F, 1
0E60  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0E62  6EE9      	MOVWF FSR0L
0E64  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0E66  26E9      	ADDWF FSR0L, F
0E68  51B8      	MOVF CompTempVar2661, W, 1
0E6A  6EEF      	MOVWF INDF0

	FCV_PORTE_AVION = FCV_PORTE_AVION - 1;
0E6C  05AC      	DECF gbl_FCV_PORTE_AVION, W, 1
0E6E  6FAC      	MOVWF gbl_FCV_PORTE_AVION, 1


}
0E70  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Message_Touche()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0BB8  0100      	MOVLB 0x00
0BBA  518E      	MOVF gbl_FCV_X, W, 1
0BBC  6FBF      	MOVWF FCM_parame_00065_arg_FCL_POS_X1, 1
0BBE  518F      	MOVF gbl_FCV_X+D'1', W, 1
0BC0  6FC0      	MOVWF FCM_parame_00065_arg_FCL_POS_X1+D'1', 1
0BC2  0E18      	MOVLW 0x18
0BC4  5D8E      	SUBWF gbl_FCV_X, W, 1
0BC6  6FC1      	MOVWF FCM_parame_00065_arg_FCL_POS_X2, 1
0BC8  598E      	SUBWFB gbl_FCV_X, W, 1
0BCA  0818      	SUBLW 0x18
0BCC  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0BCE  6FC2      	MOVWF FCM_parame_00065_arg_FCL_POS_X2+D'1', 1
0BD0  518C      	MOVF gbl_FCV_Y, W, 1
0BD2  6FC3      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1, 1
0BD4  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0BD6  6FC4      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1+D'1', 1
0BD8  0E18      	MOVLW 0x18
0BDA  5D8C      	SUBWF gbl_FCV_Y, W, 1
0BDC  6FC5      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2, 1
0BDE  598C      	SUBWFB gbl_FCV_Y, W, 1
0BE0  0818      	SUBLW 0x18
0BE2  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0BE4  6FC6      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2+D'1', 1
0BE6  69C7      	SETF FCM_parame_00065_arg_FCL_ROUGE, 1
0BE8  6BC8      	CLRF FCM_parame_00065_arg_FCL_VERT, 1
0BEA  6BC9      	CLRF FCM_parame_00065_arg_FCL_BLEU, 1
0BEC  ECAFF001  	CALL FCM_parame_00065


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0BF0  0E20      	MOVLW 0x20
0BF2  0100      	MOVLB 0x00
0BF4  6FC1      	MOVWF CompTempVar2641, 1
0BF6  6FC2      	MOVWF CompTempVar2641+D'1', 1
0BF8  6FC3      	MOVWF CompTempVar2641+D'2', 1
0BFA  6FC4      	MOVWF CompTempVar2641+D'3', 1
0BFC  6FC5      	MOVWF CompTempVar2641+D'4', 1
0BFE  6FC6      	MOVWF CompTempVar2641+D'5', 1
0C00  6FC7      	MOVWF CompTempVar2641+D'6', 1
0C02  6FC8      	MOVWF CompTempVar2641+D'7', 1
0C04  6FC9      	MOVWF CompTempVar2641+D'8', 1
0C06  6FCA      	MOVWF CompTempVar2641+D'9', 1
0C08  6FCB      	MOVWF CompTempVar2641+D'10', 1
0C0A  6FCC      	MOVWF CompTempVar2641+D'11', 1
0C0C  6FD3      	MOVWF CompTempVar2641+D'18', 1
0C0E  6FD4      	MOVWF CompTempVar2641+D'19', 1
0C10  6FD5      	MOVWF CompTempVar2641+D'20', 1
0C12  0E54      	MOVLW 0x54
0C14  6FCD      	MOVWF CompTempVar2641+D'12', 1
0C16  0E63      	MOVLW 0x63
0C18  6FD0      	MOVWF CompTempVar2641+D'15', 1
0C1A  0E65      	MOVLW 0x65
0C1C  6FD2      	MOVWF CompTempVar2641+D'17', 1
0C1E  0E68      	MOVLW 0x68
0C20  6FD1      	MOVWF CompTempVar2641+D'16', 1
0C22  0E6F      	MOVLW 0x6F
0C24  6FCE      	MOVWF CompTempVar2641+D'13', 1
0C26  0E75      	MOVLW 0x75
0C28  6FCF      	MOVWF CompTempVar2641+D'14', 1
0C2A  6BD6      	CLRF CompTempVar2641+D'21', 1
0C2C  0E00      	MOVLW HIGH(CompTempVar2641+D'0')
0C2E  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
0C30  0EC1      	MOVLW LOW(CompTempVar2641+D'0')
0C32  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
0C34  0E16      	MOVLW 0x16
0C36  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
0C38  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
0C3A  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
0C3C  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
0C3E  0EF1      	MOVLW 0xF1
0C40  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
0C42  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
0C44  0E02      	MOVLW 0x02
0C46  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
0C48  0E01      	MOVLW 0x01
0C4A  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
0C4C  EC44F003  	CALL FCD_0f051__00066


}
0C50  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Lecture_Coordonnes()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: X_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);
0C52  0100      	MOVLB 0x00
0C54  6BBF      	CLRF FCD_0f051__00069_arg_FCL_AXIS, 1
0C56  EC23F003  	CALL FCD_0f051__00069
0C5A  51C2      	MOVF CompTempVarRet2673, W, 1
0C5C  6F90      	MOVWF gbl_FCV_X_TOUCH, 1
0C5E  51C3      	MOVF CompTempVarRet2673+D'1', W, 1
0C60  6F91      	MOVWF gbl_FCV_X_TOUCH+D'1', 1


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);
0C62  0E01      	MOVLW 0x01
0C64  6FBF      	MOVWF FCD_0f051__00069_arg_FCL_AXIS, 1
0C66  EC23F003  	CALL FCD_0f051__00069
0C6A  51C2      	MOVF CompTempVarRet2673, W, 1
0C6C  6F88      	MOVWF gbl_FCV_Y_TOUCH, 1
0C6E  51C3      	MOVF CompTempVarRet2673+D'1', W, 1
0C70  6F89      	MOVWF gbl_FCV_Y_TOUCH+D'1', 1


}
0C72  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Croiseur()

{

	// Calcul
	// Calcul:
	//  hitbox_Joueur_1 = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX_JOUEUR_1 = 1;
0FB6  0E01      	MOVLW 0x01
0FB8  0100      	MOVLB 0x00
0FBA  6FA3      	MOVWF gbl_FCV_HITBOX_JOUEUR_1, 1

	FCV_Y = 24;
0FBC  0E18      	MOVLW 0x18
0FBE  6F8C      	MOVWF gbl_FCV_Y, 1
0FC0  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
0FC2  0E18      	MOVLW 0x18
0FC4  6F8E      	MOVWF gbl_FCV_X, 1
0FC6  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Appel d'une Macro
	// Appel d'une Macro: hitbox_phase_jeu()
	FCM_hitbox_phase_jeu();
0FC8  ECDCF003  	CALL FCM_hitbox_0006A


	// Calcul
	// Calcul:
	//  Tableau[hitbox_Joueur_1] = 0b00000010
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Croiseur = Croiseur + 1
	FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = 2;
0FCC  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0FD0  50E9      	MOVF FSR0L, W
0FD2  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0FD4  26E9      	ADDWF FSR0L, F
0FD6  0E02      	MOVLW 0x02
0FD8  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
0FDA  29AB      	INCF gbl_FCV_BATEAU, W, 1
0FDC  6FAB      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
0FDE  6B86      	CLRF gbl_FCV_X_SORTIE, 1
0FE0  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
0FE2  6BA9      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
0FE4  6B8E      	CLRF gbl_FCV_X, 1
0FE6  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
0FE8  6B8C      	CLRF gbl_FCV_Y, 1
0FEA  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_CROISEUR = FCV_CROISEUR + 1;
0FEC  29A4      	INCF gbl_FCV_CROISEUR, W, 1
0FEE  6FA4      	MOVWF gbl_FCV_CROISEUR, 1


}
0FF0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Torpilleur()

{

	// Appel d'une Macro
	// Appel d'une Macro: hitbox_phase_jeu()
	FCM_hitbox_phase_jeu();
0E98  ECDCF003  	CALL FCM_hitbox_0006A


	// Calcul
	// Calcul:
	//  Tableau[hitbox_Joueur_1] = 0b00000101
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Torpilleur = Torpilleur + 1
	FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = 5;
0E9C  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0EA0  50E9      	MOVF FSR0L, W
0EA2  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0EA4  26E9      	ADDWF FSR0L, F
0EA6  0E05      	MOVLW 0x05
0EA8  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
0EAA  29AB      	INCF gbl_FCV_BATEAU, W, 1
0EAC  6FAB      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
0EAE  6B86      	CLRF gbl_FCV_X_SORTIE, 1
0EB0  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
0EB2  6BA9      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
0EB4  6B8E      	CLRF gbl_FCV_X, 1
0EB6  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
0EB8  6B8C      	CLRF gbl_FCV_Y, 1
0EBA  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_TORPILLEUR = FCV_TORPILLEUR + 1;
0EBC  29A5      	INCF gbl_FCV_TORPILLEUR, W, 1
0EBE  6FA5      	MOVWF gbl_FCV_TORPILLEUR, 1


}
0EC0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_Coule_SM()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0D92  0100      	MOVLB 0x00
0D94  518E      	MOVF gbl_FCV_X, W, 1
0D96  6FBF      	MOVWF FCM_parame_00065_arg_FCL_POS_X1, 1
0D98  518F      	MOVF gbl_FCV_X+D'1', W, 1
0D9A  6FC0      	MOVWF FCM_parame_00065_arg_FCL_POS_X1+D'1', 1
0D9C  0E18      	MOVLW 0x18
0D9E  5D8E      	SUBWF gbl_FCV_X, W, 1
0DA0  6FC1      	MOVWF FCM_parame_00065_arg_FCL_POS_X2, 1
0DA2  598E      	SUBWFB gbl_FCV_X, W, 1
0DA4  0818      	SUBLW 0x18
0DA6  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0DA8  6FC2      	MOVWF FCM_parame_00065_arg_FCL_POS_X2+D'1', 1
0DAA  518C      	MOVF gbl_FCV_Y, W, 1
0DAC  6FC3      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1, 1
0DAE  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0DB0  6FC4      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1+D'1', 1
0DB2  0E18      	MOVLW 0x18
0DB4  5D8C      	SUBWF gbl_FCV_Y, W, 1
0DB6  6FC5      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2, 1
0DB8  598C      	SUBWFB gbl_FCV_Y, W, 1
0DBA  0818      	SUBLW 0x18
0DBC  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0DBE  6FC6      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2+D'1', 1
0DC0  69C7      	SETF FCM_parame_00065_arg_FCL_ROUGE, 1
0DC2  6BC8      	CLRF FCM_parame_00065_arg_FCL_VERT, 1
0DC4  6BC9      	CLRF FCM_parame_00065_arg_FCL_BLEU, 1
0DC6  ECAFF001  	CALL FCM_parame_00065


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0DCA  0E20      	MOVLW 0x20
0DCC  0100      	MOVLB 0x00
0DCE  6FC1      	MOVWF CompTempVar2685, 1
0DD0  6FC2      	MOVWF CompTempVar2685+D'1', 1
0DD2  6FC3      	MOVWF CompTempVar2685+D'2', 1
0DD4  6FC4      	MOVWF CompTempVar2685+D'3', 1
0DD6  6FC5      	MOVWF CompTempVar2685+D'4', 1
0DD8  6FC6      	MOVWF CompTempVar2685+D'5', 1
0DDA  6FC7      	MOVWF CompTempVar2685+D'6', 1
0DDC  6FC8      	MOVWF CompTempVar2685+D'7', 1
0DDE  6FC9      	MOVWF CompTempVar2685+D'8', 1
0DE0  6FCA      	MOVWF CompTempVar2685+D'9', 1
0DE2  6FCB      	MOVWF CompTempVar2685+D'10', 1
0DE4  6FCC      	MOVWF CompTempVar2685+D'11', 1
0DE6  6FD3      	MOVWF CompTempVar2685+D'18', 1
0DE8  6FD4      	MOVWF CompTempVar2685+D'19', 1
0DEA  6FD5      	MOVWF CompTempVar2685+D'20', 1
0DEC  0E54      	MOVLW 0x54
0DEE  6FCD      	MOVWF CompTempVar2685+D'12', 1
0DF0  0E63      	MOVLW 0x63
0DF2  6FD0      	MOVWF CompTempVar2685+D'15', 1
0DF4  0E65      	MOVLW 0x65
0DF6  6FD2      	MOVWF CompTempVar2685+D'17', 1
0DF8  0E68      	MOVLW 0x68
0DFA  6FD1      	MOVWF CompTempVar2685+D'16', 1
0DFC  0E6F      	MOVLW 0x6F
0DFE  6FCE      	MOVWF CompTempVar2685+D'13', 1
0E00  0E75      	MOVLW 0x75
0E02  6FCF      	MOVWF CompTempVar2685+D'14', 1
0E04  6BD6      	CLRF CompTempVar2685+D'21', 1
0E06  0E00      	MOVLW HIGH(CompTempVar2685+D'0')
0E08  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
0E0A  0EC1      	MOVLW LOW(CompTempVar2685+D'0')
0E0C  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
0E0E  0E16      	MOVLW 0x16
0E10  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
0E12  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
0E14  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
0E16  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
0E18  0EF1      	MOVLW 0xF1
0E1A  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
0E1C  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
0E1E  0E02      	MOVLW 0x02
0E20  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
0E22  0E01      	MOVLW 0x01
0E24  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
0E26  EC44F003  	CALL FCD_0f051__00066


	// Calcul
	// Calcul:
	//  Tableau[hitbox_Joueur_1] = tableau[hitbox_Joueur_1] || 0b00000011
	//  Sous_marin = Sous_marin - 1
	FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] || 3;
0E2A  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0E2E  50E9      	MOVF FSR0L, W
0E30  0100      	MOVLB 0x00
0E32  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0E34  26E9      	ADDWF FSR0L, F
0E36  6BB8      	CLRF CompTempVar2689, 1
0E38  2BB8      	INCF CompTempVar2689, F, 1
0E3A  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0E3C  6EE9      	MOVWF FSR0L
0E3E  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0E40  26E9      	ADDWF FSR0L, F
0E42  51B8      	MOVF CompTempVar2689, W, 1
0E44  6EEF      	MOVWF INDF0

	FCV_SOUS_MARIN = FCV_SOUS_MARIN - 1;
0E46  05A7      	DECF gbl_FCV_SOUS_MARIN, W, 1
0E48  6FA7      	MOVWF gbl_FCV_SOUS_MARIN, 1


}
0E4A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Initialisation()

{

	// Calcul
	// Calcul:

	// Boucle
	// Boucle: While hitbox_Joueur_1 = 101
	while (1)
197A            label111

	{

		// Calcul
		// Calcul:
		//  tableau[hitbox_Joueur_1] = 0b00000000
		//  hitbox_Joueur_1 = hitbox_Joueur_1 + 1
		FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = 0;
197A  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
197E  50E9      	MOVF FSR0L, W
1980  0100      	MOVLB 0x00
1982  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
1984  26E9      	ADDWF FSR0L, F
1986  0E00      	MOVLW 0x00
1988  6EEF      	MOVWF INDF0

		FCV_HITBOX_JOUEUR_1 = FCV_HITBOX_JOUEUR_1 + 1;
198A  29A3      	INCF gbl_FCV_HITBOX_JOUEUR_1, W, 1
198C  6FA3      	MOVWF gbl_FCV_HITBOX_JOUEUR_1, 1



		if ((FCV_HITBOX_JOUEUR_1 == 101) != 0) break;
198E  6BB8      	CLRF CompTempVar2691, 1
1990  0E65      	MOVLW 0x65
1992  63A3      	CPFSEQ gbl_FCV_HITBOX_JOUEUR_1, 1
1994  D001      	BRA	label112
1996  2BB8      	INCF CompTempVar2691, F, 1
1998            label112
1998  53B8      	MOVF CompTempVar2691, F, 1
199A  E0EF      	BZ	label111

	}

	// Calcul
	// Calcul:
	//  tableau[Joueur1] = tableau[hitbox_Joueur_1]
	FCV_TABLEAU[FCV_JOUEUR1] = FCV_TABLEAU[FCV_HITBOX_JOUEUR_1];
199C  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
19A0  50E9      	MOVF FSR0L, W
19A2  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
19A4  6FB8      	MOVWF CompTempVar2695, 1
19A6  51B8      	MOVF CompTempVar2695, W, 1
19A8  26E9      	ADDWF FSR0L, F
19AA  50EF      	MOVF INDF0, W
19AC  6FB9      	MOVWF CompTempVar2696, 1
19AE  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
19B0  6EE9      	MOVWF FSR0L
19B2  51AD      	MOVF gbl_FCV_JOUEUR1, W, 1
19B4  26E9      	ADDWF FSR0L, F
19B6  51B9      	MOVF CompTempVar2696, W, 1
19B8  6EEF      	MOVWF INDF0


	#if 0 // Disabled code
	// Calcul
	// Calcul:
	//  tableau[23] = 0b00000001
	//  tableau[24] = 0b00000001
	//  tableau[25] = 0b00000001
	FCV_TABLEAU[23] = 1;
	FCV_TABLEAU[24] = 1;
	FCV_TABLEAU[25] = 1;

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
19BA  EC79F00B  	CALL FCD_0f051__0006D


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
19BE  ECA3F008  	CALL FCD_0f051__0006E


	// Appel d'une Macro
	// Appel d'une Macro: lignes()
	FCM_lignes();
19C2  ECCBF008  	CALL FCM_lignes_00000


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_SetTouchRegionPicaso(0, 0, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(0, 0, 240, 240);
19C6  6BBF      	CLRF FCD_0f051__0006F_arg_FCL_X1, 1
19C8  6BC0      	CLRF FCD_0f051__0006F_arg_FCL_X1+D'1', 1
19CA  6BC1      	CLRF FCD_0f051__0006F_arg_FCL_Y1, 1
19CC  6BC2      	CLRF FCD_0f051__0006F_arg_FCL_Y1+D'1', 1
19CE  0EF0      	MOVLW 0xF0
19D0  6FC3      	MOVWF FCD_0f051__0006F_arg_FCL_X2, 1
19D2  6BC4      	CLRF FCD_0f051__0006F_arg_FCL_X2+D'1', 1
19D4  0EF0      	MOVLW 0xF0
19D6  6FC5      	MOVWF FCD_0f051__0006F_arg_FCL_Y2, 1
19D8  6BC6      	CLRF FCD_0f051__0006F_arg_FCL_Y2+D'1', 1
19DA  ECCAF002  	CALL FCD_0f051__0006F


}
19DE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Message_bateau()

{

	// Décision
	// Décision: bateau >= 5?
	if (FCV_BATEAU >= 5)
086C  0E05      	MOVLW 0x05
086E  0100      	MOVLB 0x00
0870  61AB      	CPFSLT gbl_FCV_BATEAU, 1
0872  D001      	BRA	label45
0874  D153      	BRA	label52
0876            label45
0B1C            label52

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_texte()
		FCM_Reinitialisation_texte();
0876  ECFBF001  	CALL FCM_Reinit_00071


		// Décision
		// Décision: bateau >= 9?
		if (FCV_BATEAU >= 9)
087A  0E09      	MOVLW 0x09
087C  61AB      	CPFSLT gbl_FCV_BATEAU, 1
087E  D001      	BRA	label46
0880  D105      	BRA	label51
0882            label46
0A8C            label51

		{

			// Appel d'une Macro
			// Appel d'une Macro: Reinitialisation_texte()
			FCM_Reinitialisation_texte();
0882  ECFBF001  	CALL FCM_Reinit_00071


			// Décision
			// Décision: bateau >= 12?
			if (FCV_BATEAU >= 12)
0886  0E0C      	MOVLW 0x0C
0888  61AB      	CPFSLT gbl_FCV_BATEAU, 1
088A  D001      	BRA	label47
088C  D0A5      	BRA	label50
088E            label47
09D8            label50

			{

				// Appel d'une Macro
				// Appel d'une Macro: Reinitialisation_texte()
				FCM_Reinitialisation_texte();
088E  ECFBF001  	CALL FCM_Reinit_00071


				// Décision
				// Décision: bateau >= 15?
				if (FCV_BATEAU >= 15)
0892  0E0F      	MOVLW 0x0F
0894  61AB      	CPFSLT gbl_FCV_BATEAU, 1
0896  D001      	BRA	label48
0898  D051      	BRA	label49
089A            label48
093C            label49

				{

					// Appel d'une Macro
					// Appel d'une Macro: Reinitialisation_texte()
					FCM_Reinitialisation_texte();
089A  ECFBF001  	CALL FCM_Reinit_00071


					// Décision
					// Décision: bateau >= 17?
					if (FCV_BATEAU >= 17)
089E  0E11      	MOVLW 0x11
08A0  61AB      	CPFSLT gbl_FCV_BATEAU, 1

					{

					} else {

						// Appel de la Routine Composant
						// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le torpilleur (2 cases)", 0, 241, 2, 1)
						FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le torpilleur (2 cases)", 40, 0, 241, 2, 1);
08A4  0E20      	MOVLW 0x20
08A6  6FC9      	MOVWF CompTempVar2740+D'8', 1
08A8  6FD0      	MOVWF CompTempVar2740+D'15', 1
08AA  6FD3      	MOVWF CompTempVar2740+D'18', 1
08AC  6FDE      	MOVWF CompTempVar2740+D'29', 1
08AE  6FE1      	MOVWF CompTempVar2740+D'32', 1
08B0  0E28      	MOVLW 0x28
08B2  6FDF      	MOVWF CompTempVar2740+D'30', 1
08B4  0E29      	MOVLW 0x29
08B6  6FE7      	MOVWF CompTempVar2740+D'38', 1
08B8  0E32      	MOVLW 0x32
08BA  6FE0      	MOVWF CompTempVar2740+D'31', 1
08BC  0E56      	MOVLW 0x56
08BE  6FC1      	MOVWF CompTempVar2740, 1
08C0  0E61      	MOVLW 0x61
08C2  6FCC      	MOVWF CompTempVar2740+D'11', 1
08C4  6FE3      	MOVWF CompTempVar2740+D'34', 1
08C6  0E63      	MOVLW 0x63
08C8  6FCD      	MOVWF CompTempVar2740+D'12', 1
08CA  6FE2      	MOVWF CompTempVar2740+D'33', 1
08CC  0E65      	MOVLW 0x65
08CE  6FC2      	MOVWF CompTempVar2740+D'1', 1
08D0  6FC7      	MOVWF CompTempVar2740+D'6', 1
08D2  6FCE      	MOVWF CompTempVar2740+D'13', 1
08D4  6FD2      	MOVWF CompTempVar2740+D'17', 1
08D6  6FDB      	MOVWF CompTempVar2740+D'26', 1
08D8  6FE5      	MOVWF CompTempVar2740+D'36', 1
08DA  0E69      	MOVLW 0x69
08DC  6FC4      	MOVWF CompTempVar2740+D'3', 1
08DE  6FD8      	MOVWF CompTempVar2740+D'23', 1
08E0  0E6C      	MOVLW 0x6C
08E2  6FC5      	MOVWF CompTempVar2740+D'4', 1
08E4  6FC6      	MOVWF CompTempVar2740+D'5', 1
08E6  6FCB      	MOVWF CompTempVar2740+D'10', 1
08E8  6FD1      	MOVWF CompTempVar2740+D'16', 1
08EA  6FD9      	MOVWF CompTempVar2740+D'24', 1
08EC  6FDA      	MOVWF CompTempVar2740+D'25', 1
08EE  0E6F      	MOVLW 0x6F
08F0  6FD5      	MOVWF CompTempVar2740+D'20', 1
08F2  0E70      	MOVLW 0x70
08F4  6FCA      	MOVWF CompTempVar2740+D'9', 1
08F6  6FD7      	MOVWF CompTempVar2740+D'22', 1
08F8  0E72      	MOVLW 0x72
08FA  6FCF      	MOVWF CompTempVar2740+D'14', 1
08FC  6FD6      	MOVWF CompTempVar2740+D'21', 1
08FE  6FDD      	MOVWF CompTempVar2740+D'28', 1
0900  0E73      	MOVLW 0x73
0902  6FE4      	MOVWF CompTempVar2740+D'35', 1
0904  6FE6      	MOVWF CompTempVar2740+D'37', 1
0906  0E74      	MOVLW 0x74
0908  6FD4      	MOVWF CompTempVar2740+D'19', 1
090A  0E75      	MOVLW 0x75
090C  6FC3      	MOVWF CompTempVar2740+D'2', 1
090E  6FDC      	MOVWF CompTempVar2740+D'27', 1
0910  0E7A      	MOVLW 0x7A
0912  6FC8      	MOVWF CompTempVar2740+D'7', 1
0914  6BE8      	CLRF CompTempVar2740+D'39', 1
0916  0E00      	MOVLW HIGH(CompTempVar2740+D'0')
0918  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
091A  0EC1      	MOVLW LOW(CompTempVar2740+D'0')
091C  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
091E  0E28      	MOVLW 0x28
0920  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
0922  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
0924  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
0926  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
0928  0EF1      	MOVLW 0xF1
092A  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
092C  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
092E  0E02      	MOVLW 0x02
0930  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
0932  0E01      	MOVLW 0x01
0934  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
0936  EC44F003  	CALL FCD_0f051__00066


					}

				} else {

					// Appel de la Routine Composant
					// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le sous-marin (3 cases)", 0, 241, 2, 1)
					FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le sous-marin (3 cases)", 40, 0, 241, 2, 1);
093C  0E20      	MOVLW 0x20
093E  6FC9      	MOVWF CompTempVar2742+D'8', 1
0940  6FD0      	MOVWF CompTempVar2742+D'15', 1
0942  6FD3      	MOVWF CompTempVar2742+D'18', 1
0944  6FDE      	MOVWF CompTempVar2742+D'29', 1
0946  6FE1      	MOVWF CompTempVar2742+D'32', 1
0948  0E28      	MOVLW 0x28
094A  6FDF      	MOVWF CompTempVar2742+D'30', 1
094C  0E29      	MOVLW 0x29
094E  6FE7      	MOVWF CompTempVar2742+D'38', 1
0950  0E2D      	MOVLW 0x2D
0952  6FD8      	MOVWF CompTempVar2742+D'23', 1
0954  0E33      	MOVLW 0x33
0956  6FE0      	MOVWF CompTempVar2742+D'31', 1
0958  0E56      	MOVLW 0x56
095A  6FC1      	MOVWF CompTempVar2742, 1
095C  0E61      	MOVLW 0x61
095E  6FCC      	MOVWF CompTempVar2742+D'11', 1
0960  6FDA      	MOVWF CompTempVar2742+D'25', 1
0962  6FE3      	MOVWF CompTempVar2742+D'34', 1
0964  0E63      	MOVLW 0x63
0966  6FCD      	MOVWF CompTempVar2742+D'12', 1
0968  6FE2      	MOVWF CompTempVar2742+D'33', 1
096A  0E65      	MOVLW 0x65
096C  6FC2      	MOVWF CompTempVar2742+D'1', 1
096E  6FC7      	MOVWF CompTempVar2742+D'6', 1
0970  6FCE      	MOVWF CompTempVar2742+D'13', 1
0972  6FD2      	MOVWF CompTempVar2742+D'17', 1
0974  6FE5      	MOVWF CompTempVar2742+D'36', 1
0976  0E69      	MOVLW 0x69
0978  6FC4      	MOVWF CompTempVar2742+D'3', 1
097A  6FDC      	MOVWF CompTempVar2742+D'27', 1
097C  0E6C      	MOVLW 0x6C
097E  6FC5      	MOVWF CompTempVar2742+D'4', 1
0980  6FC6      	MOVWF CompTempVar2742+D'5', 1
0982  6FCB      	MOVWF CompTempVar2742+D'10', 1
0984  6FD1      	MOVWF CompTempVar2742+D'16', 1
0986  0E6D      	MOVLW 0x6D
0988  6FD9      	MOVWF CompTempVar2742+D'24', 1
098A  0E6E      	MOVLW 0x6E
098C  6FDD      	MOVWF CompTempVar2742+D'28', 1
098E  0E6F      	MOVLW 0x6F
0990  6FD5      	MOVWF CompTempVar2742+D'20', 1
0992  0E70      	MOVLW 0x70
0994  6FCA      	MOVWF CompTempVar2742+D'9', 1
0996  0E72      	MOVLW 0x72
0998  6FCF      	MOVWF CompTempVar2742+D'14', 1
099A  6FDB      	MOVWF CompTempVar2742+D'26', 1
099C  0E73      	MOVLW 0x73
099E  6FD4      	MOVWF CompTempVar2742+D'19', 1
09A0  6FD7      	MOVWF CompTempVar2742+D'22', 1
09A2  6FE4      	MOVWF CompTempVar2742+D'35', 1
09A4  6FE6      	MOVWF CompTempVar2742+D'37', 1
09A6  0E75      	MOVLW 0x75
09A8  6FC3      	MOVWF CompTempVar2742+D'2', 1
09AA  6FD6      	MOVWF CompTempVar2742+D'21', 1
09AC  0E7A      	MOVLW 0x7A
09AE  6FC8      	MOVWF CompTempVar2742+D'7', 1
09B0  6BE8      	CLRF CompTempVar2742+D'39', 1
09B2  0E00      	MOVLW HIGH(CompTempVar2742+D'0')
09B4  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
09B6  0EC1      	MOVLW LOW(CompTempVar2742+D'0')
09B8  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
09BA  0E28      	MOVLW 0x28
09BC  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
09BE  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
09C0  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
09C2  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
09C4  0EF1      	MOVLW 0xF1
09C6  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
09C8  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
09CA  0E02      	MOVLW 0x02
09CC  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
09CE  0E01      	MOVLW 0x01
09D0  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
09D2  EC44F003  	CALL FCD_0f051__00066


				}

			} else {

				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le contre        torpilleur(3 cases)", 0, 241, 2, 1)
				FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le contre        torpilleur(3 cases)", 53, 0, 241, 2, 1);
09D8  0E20      	MOVLW 0x20
09DA  6FC9      	MOVWF CompTempVar2744+D'8', 1
09DC  6FD0      	MOVWF CompTempVar2744+D'15', 1
09DE  6FD3      	MOVWF CompTempVar2744+D'18', 1
09E0  6FDA      	MOVWF CompTempVar2744+D'25', 1
09E2  6FDB      	MOVWF CompTempVar2744+D'26', 1
09E4  6FDC      	MOVWF CompTempVar2744+D'27', 1
09E6  6FDD      	MOVWF CompTempVar2744+D'28', 1
09E8  6FDE      	MOVWF CompTempVar2744+D'29', 1
09EA  6FDF      	MOVWF CompTempVar2744+D'30', 1
09EC  6FE0      	MOVWF CompTempVar2744+D'31', 1
09EE  6FE1      	MOVWF CompTempVar2744+D'32', 1
09F0  6FEE      	MOVWF CompTempVar2744+D'45', 1
09F2  0E28      	MOVLW 0x28
09F4  6FEC      	MOVWF CompTempVar2744+D'43', 1
09F6  0E29      	MOVLW 0x29
09F8  6FF4      	MOVWF CompTempVar2744+D'51', 1
09FA  0E33      	MOVLW 0x33
09FC  6FED      	MOVWF CompTempVar2744+D'44', 1
09FE  0E56      	MOVLW 0x56
0A00  6FC1      	MOVWF CompTempVar2744, 1
0A02  0E61      	MOVLW 0x61
0A04  6FCC      	MOVWF CompTempVar2744+D'11', 1
0A06  6FF0      	MOVWF CompTempVar2744+D'47', 1
0A08  0E63      	MOVLW 0x63
0A0A  6FCD      	MOVWF CompTempVar2744+D'12', 1
0A0C  6FD4      	MOVWF CompTempVar2744+D'19', 1
0A0E  6FEF      	MOVWF CompTempVar2744+D'46', 1
0A10  0E65      	MOVLW 0x65
0A12  6FC2      	MOVWF CompTempVar2744+D'1', 1
0A14  6FC7      	MOVWF CompTempVar2744+D'6', 1
0A16  6FCE      	MOVWF CompTempVar2744+D'13', 1
0A18  6FD2      	MOVWF CompTempVar2744+D'17', 1
0A1A  6FD9      	MOVWF CompTempVar2744+D'24', 1
0A1C  6FE9      	MOVWF CompTempVar2744+D'40', 1
0A1E  6FF2      	MOVWF CompTempVar2744+D'49', 1
0A20  0E69      	MOVLW 0x69
0A22  6FC4      	MOVWF CompTempVar2744+D'3', 1
0A24  6FE6      	MOVWF CompTempVar2744+D'37', 1
0A26  0E6C      	MOVLW 0x6C
0A28  6FC5      	MOVWF CompTempVar2744+D'4', 1
0A2A  6FC6      	MOVWF CompTempVar2744+D'5', 1
0A2C  6FCB      	MOVWF CompTempVar2744+D'10', 1
0A2E  6FD1      	MOVWF CompTempVar2744+D'16', 1
0A30  6FE7      	MOVWF CompTempVar2744+D'38', 1
0A32  6FE8      	MOVWF CompTempVar2744+D'39', 1
0A34  0E6E      	MOVLW 0x6E
0A36  6FD6      	MOVWF CompTempVar2744+D'21', 1
0A38  0E6F      	MOVLW 0x6F
0A3A  6FD5      	MOVWF CompTempVar2744+D'20', 1
0A3C  6FE3      	MOVWF CompTempVar2744+D'34', 1
0A3E  0E70      	MOVLW 0x70
0A40  6FCA      	MOVWF CompTempVar2744+D'9', 1
0A42  6FE5      	MOVWF CompTempVar2744+D'36', 1
0A44  0E72      	MOVLW 0x72
0A46  6FCF      	MOVWF CompTempVar2744+D'14', 1
0A48  6FD8      	MOVWF CompTempVar2744+D'23', 1
0A4A  6FE4      	MOVWF CompTempVar2744+D'35', 1
0A4C  6FEB      	MOVWF CompTempVar2744+D'42', 1
0A4E  0E73      	MOVLW 0x73
0A50  6FF1      	MOVWF CompTempVar2744+D'48', 1
0A52  6FF3      	MOVWF CompTempVar2744+D'50', 1
0A54  0E74      	MOVLW 0x74
0A56  6FD7      	MOVWF CompTempVar2744+D'22', 1
0A58  6FE2      	MOVWF CompTempVar2744+D'33', 1
0A5A  0E75      	MOVLW 0x75
0A5C  6FC3      	MOVWF CompTempVar2744+D'2', 1
0A5E  6FEA      	MOVWF CompTempVar2744+D'41', 1
0A60  0E7A      	MOVLW 0x7A
0A62  6FC8      	MOVWF CompTempVar2744+D'7', 1
0A64  6BF5      	CLRF CompTempVar2744+D'52', 1
0A66  0E00      	MOVLW HIGH(CompTempVar2744+D'0')
0A68  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
0A6A  0EC1      	MOVLW LOW(CompTempVar2744+D'0')
0A6C  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
0A6E  0E35      	MOVLW 0x35
0A70  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
0A72  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
0A74  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
0A76  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
0A78  0EF1      	MOVLW 0xF1
0A7A  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
0A7C  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
0A7E  0E02      	MOVLW 0x02
0A80  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
0A82  0E01      	MOVLW 0x01
0A84  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
0A86  EC44F003  	CALL FCD_0f051__00066


			}

		} else {

			// Appel de la Routine Composant
			// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le croiseur(4 cases)", 0, 241, 2, 1)
			FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le croiseur(4 cases)", 37, 0, 241, 2, 1);
0A8C  0E20      	MOVLW 0x20
0A8E  6FC9      	MOVWF CompTempVar2746+D'8', 1
0A90  6FD0      	MOVWF CompTempVar2746+D'15', 1
0A92  6FD3      	MOVWF CompTempVar2746+D'18', 1
0A94  6FDE      	MOVWF CompTempVar2746+D'29', 1
0A96  0E28      	MOVLW 0x28
0A98  6FDC      	MOVWF CompTempVar2746+D'27', 1
0A9A  0E29      	MOVLW 0x29
0A9C  6FE4      	MOVWF CompTempVar2746+D'35', 1
0A9E  0E34      	MOVLW 0x34
0AA0  6FDD      	MOVWF CompTempVar2746+D'28', 1
0AA2  0E56      	MOVLW 0x56
0AA4  6FC1      	MOVWF CompTempVar2746, 1
0AA6  0E61      	MOVLW 0x61
0AA8  6FCC      	MOVWF CompTempVar2746+D'11', 1
0AAA  6FE0      	MOVWF CompTempVar2746+D'31', 1
0AAC  0E63      	MOVLW 0x63
0AAE  6FCD      	MOVWF CompTempVar2746+D'12', 1
0AB0  6FD4      	MOVWF CompTempVar2746+D'19', 1
0AB2  6FDF      	MOVWF CompTempVar2746+D'30', 1
0AB4  0E65      	MOVLW 0x65
0AB6  6FC2      	MOVWF CompTempVar2746+D'1', 1
0AB8  6FC7      	MOVWF CompTempVar2746+D'6', 1
0ABA  6FCE      	MOVWF CompTempVar2746+D'13', 1
0ABC  6FD2      	MOVWF CompTempVar2746+D'17', 1
0ABE  6FD9      	MOVWF CompTempVar2746+D'24', 1
0AC0  6FE2      	MOVWF CompTempVar2746+D'33', 1
0AC2  0E69      	MOVLW 0x69
0AC4  6FC4      	MOVWF CompTempVar2746+D'3', 1
0AC6  6FD7      	MOVWF CompTempVar2746+D'22', 1
0AC8  0E6C      	MOVLW 0x6C
0ACA  6FC5      	MOVWF CompTempVar2746+D'4', 1
0ACC  6FC6      	MOVWF CompTempVar2746+D'5', 1
0ACE  6FCB      	MOVWF CompTempVar2746+D'10', 1
0AD0  6FD1      	MOVWF CompTempVar2746+D'16', 1
0AD2  0E6F      	MOVLW 0x6F
0AD4  6FD6      	MOVWF CompTempVar2746+D'21', 1
0AD6  0E70      	MOVLW 0x70
0AD8  6FCA      	MOVWF CompTempVar2746+D'9', 1
0ADA  0E72      	MOVLW 0x72
0ADC  6FCF      	MOVWF CompTempVar2746+D'14', 1
0ADE  6FD5      	MOVWF CompTempVar2746+D'20', 1
0AE0  6FDB      	MOVWF CompTempVar2746+D'26', 1
0AE2  0E73      	MOVLW 0x73
0AE4  6FD8      	MOVWF CompTempVar2746+D'23', 1
0AE6  6FE1      	MOVWF CompTempVar2746+D'32', 1
0AE8  6FE3      	MOVWF CompTempVar2746+D'34', 1
0AEA  0E75      	MOVLW 0x75
0AEC  6FC3      	MOVWF CompTempVar2746+D'2', 1
0AEE  6FDA      	MOVWF CompTempVar2746+D'25', 1
0AF0  0E7A      	MOVLW 0x7A
0AF2  6FC8      	MOVWF CompTempVar2746+D'7', 1
0AF4  6BE5      	CLRF CompTempVar2746+D'36', 1
0AF6  0E00      	MOVLW HIGH(CompTempVar2746+D'0')
0AF8  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
0AFA  0EC1      	MOVLW LOW(CompTempVar2746+D'0')
0AFC  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
0AFE  0E25      	MOVLW 0x25
0B00  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
0B02  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
0B04  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
0B06  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
0B08  0EF1      	MOVLW 0xF1
0B0A  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
0B0C  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
0B0E  0E02      	MOVLW 0x02
0B10  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
0B12  0E01      	MOVLW 0x01
0B14  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
0B16  EC44F003  	CALL FCD_0f051__00066


		}

	} else {

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le porte avion(5 cases)", 0, 241, 2, 1)
		FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le porte avion(5 cases)", 40, 0, 241, 2, 1);
0B1C  0E20      	MOVLW 0x20
0B1E  6FC9      	MOVWF CompTempVar2748+D'8', 1
0B20  6FD0      	MOVWF CompTempVar2748+D'15', 1
0B22  6FD3      	MOVWF CompTempVar2748+D'18', 1
0B24  6FD9      	MOVWF CompTempVar2748+D'24', 1
0B26  6FE1      	MOVWF CompTempVar2748+D'32', 1
0B28  0E28      	MOVLW 0x28
0B2A  6FDF      	MOVWF CompTempVar2748+D'30', 1
0B2C  0E29      	MOVLW 0x29
0B2E  6FE7      	MOVWF CompTempVar2748+D'38', 1
0B30  0E35      	MOVLW 0x35
0B32  6FE0      	MOVWF CompTempVar2748+D'31', 1
0B34  0E56      	MOVLW 0x56
0B36  6FC1      	MOVWF CompTempVar2748, 1
0B38  0E61      	MOVLW 0x61
0B3A  6FCC      	MOVWF CompTempVar2748+D'11', 1
0B3C  6FDA      	MOVWF CompTempVar2748+D'25', 1
0B3E  6FE3      	MOVWF CompTempVar2748+D'34', 1
0B40  0E63      	MOVLW 0x63
0B42  6FCD      	MOVWF CompTempVar2748+D'12', 1
0B44  6FE2      	MOVWF CompTempVar2748+D'33', 1
0B46  0E65      	MOVLW 0x65
0B48  6FC2      	MOVWF CompTempVar2748+D'1', 1
0B4A  6FC7      	MOVWF CompTempVar2748+D'6', 1
0B4C  6FCE      	MOVWF CompTempVar2748+D'13', 1
0B4E  6FD2      	MOVWF CompTempVar2748+D'17', 1
0B50  6FD8      	MOVWF CompTempVar2748+D'23', 1
0B52  6FE5      	MOVWF CompTempVar2748+D'36', 1
0B54  0E69      	MOVLW 0x69
0B56  6FC4      	MOVWF CompTempVar2748+D'3', 1
0B58  6FDC      	MOVWF CompTempVar2748+D'27', 1
0B5A  0E6C      	MOVLW 0x6C
0B5C  6FC5      	MOVWF CompTempVar2748+D'4', 1
0B5E  6FC6      	MOVWF CompTempVar2748+D'5', 1
0B60  6FCB      	MOVWF CompTempVar2748+D'10', 1
0B62  6FD1      	MOVWF CompTempVar2748+D'16', 1
0B64  0E6E      	MOVLW 0x6E
0B66  6FDE      	MOVWF CompTempVar2748+D'29', 1
0B68  0E6F      	MOVLW 0x6F
0B6A  6FD5      	MOVWF CompTempVar2748+D'20', 1
0B6C  6FDD      	MOVWF CompTempVar2748+D'28', 1
0B6E  0E70      	MOVLW 0x70
0B70  6FCA      	MOVWF CompTempVar2748+D'9', 1
0B72  6FD4      	MOVWF CompTempVar2748+D'19', 1
0B74  0E72      	MOVLW 0x72
0B76  6FCF      	MOVWF CompTempVar2748+D'14', 1
0B78  6FD6      	MOVWF CompTempVar2748+D'21', 1
0B7A  0E73      	MOVLW 0x73
0B7C  6FE4      	MOVWF CompTempVar2748+D'35', 1
0B7E  6FE6      	MOVWF CompTempVar2748+D'37', 1
0B80  0E74      	MOVLW 0x74
0B82  6FD7      	MOVWF CompTempVar2748+D'22', 1
0B84  0E75      	MOVLW 0x75
0B86  6FC3      	MOVWF CompTempVar2748+D'2', 1
0B88  0E76      	MOVLW 0x76
0B8A  6FDB      	MOVWF CompTempVar2748+D'26', 1
0B8C  0E7A      	MOVLW 0x7A
0B8E  6FC8      	MOVWF CompTempVar2748+D'7', 1
0B90  6BE8      	CLRF CompTempVar2748+D'39', 1
0B92  0E00      	MOVLW HIGH(CompTempVar2748+D'0')
0B94  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
0B96  0EC1      	MOVLW LOW(CompTempVar2748+D'0')
0B98  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
0B9A  0E28      	MOVLW 0x28
0B9C  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
0B9E  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
0BA0  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
0BA2  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
0BA4  0EF1      	MOVLW 0xF1
0BA6  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
0BA8  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
0BAA  0E02      	MOVLW 0x02
0BAC  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
0BAE  0E01      	MOVLW 0x01
0BB0  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
0BB2  EC44F003  	CALL FCD_0f051__00066


	}

}
08A2  0012      	RETURN
093A  0012      	RETURN
09D6  0012      	RETURN
0A8A  0012      	RETURN
0B1A  0012      	RETURN
0BB6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Toucher_Couler()

{

	// Calcul
	// Calcul:
	//  hitbox_Joueur_1 = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX_JOUEUR_1 = 1;
1224  0E01      	MOVLW 0x01
1226  0100      	MOVLB 0x00
1228  6FA3      	MOVWF gbl_FCV_HITBOX_JOUEUR_1, 1

	FCV_Y = 24;
122A  0E18      	MOVLW 0x18
122C  6F8C      	MOVWF gbl_FCV_Y, 1
122E  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
1230  0E18      	MOVLW 0x18
1232  6F8E      	MOVWF gbl_FCV_X, 1
1234  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
1236            label75
1236  0E01      	MOVLW 0x01
1238  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
123A  E234      	BC	label83
123C  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
123E  D032      	BRA	label83
12A2  D7C9      	BRA	label75
12A4            label83

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
1240  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1242  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
1244  E102      	BNZ	label76
1246  518C      	MOVF gbl_FCV_Y, W, 1
1248  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
124A            label76
124A  E221      	BC	label82
124C            label77
128E            label82

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
124C  518F      	MOVF gbl_FCV_X+D'1', W, 1
124E  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1250  E102      	BNZ	label78
1252  518E      	MOVF gbl_FCV_X, W, 1
1254  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
1256            label78
1256  E309      	BNC	label79

				{

				} else {
126A            label79


					// Calcul
					// Calcul:
					//  hitbox_Joueur_1 = hitbox_Joueur_1 + 1
					//  X = X + 24
					FCV_HITBOX_JOUEUR_1 = FCV_HITBOX_JOUEUR_1 + 1;
1258  29A3      	INCF gbl_FCV_HITBOX_JOUEUR_1, W, 1
125A  6FA3      	MOVWF gbl_FCV_HITBOX_JOUEUR_1, 1

					FCV_X = FCV_X + 24;
125C  6BB9      	CLRF CompTempVar2753, 1
125E  0E18      	MOVLW 0x18
1260  278E      	ADDWF gbl_FCV_X, F, 1
1262  518F      	MOVF gbl_FCV_X+D'1', W, 1
1264  23B9      	ADDWFC CompTempVar2753, F, 1
1266  51B9      	MOVF CompTempVar2753, W, 1
1268  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
126A  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
126C  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
126E  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
1270  B4D8      	BTFSC STATUS,Z
1272  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
1274  6BB8      	CLRF CompTempVar2751, 1
1276  518F      	MOVF gbl_FCV_X+D'1', W, 1
1278  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
127A  E104      	BNZ	label80
127C  518E      	MOVF gbl_FCV_X, W, 1
127E  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
1280  D001      	BRA	label80
1282  D001      	BRA	label81
1284            label80
1284  A0D8      	BTFSS STATUS,C
1286  71B8      	BTG CompTempVar2751,0, 1
1288  53B8      	MOVF CompTempVar2751, F, 1
128A  E0E0      	BZ	label77

			}

		} else {
128C  D7D4      	BRA	label75


			// Calcul
			// Calcul:
			//  hitbox_Joueur_1 = hitbox_Joueur_1 + 10
			//  Y = Y + 24
			FCV_HITBOX_JOUEUR_1 = FCV_HITBOX_JOUEUR_1 + 10;
128E  0E0A      	MOVLW 0x0A
1290  25A3      	ADDWF gbl_FCV_HITBOX_JOUEUR_1, W, 1
1292  6FA3      	MOVWF gbl_FCV_HITBOX_JOUEUR_1, 1

			FCV_Y = FCV_Y + 24;
1294  6BB8      	CLRF CompTempVar2757, 1
1296  0E18      	MOVLW 0x18
1298  278C      	ADDWF gbl_FCV_Y, F, 1
129A  518D      	MOVF gbl_FCV_Y+D'1', W, 1
129C  23B8      	ADDWFC CompTempVar2757, F, 1
129E  51B8      	MOVF CompTempVar2757, W, 1
12A0  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Porte-avion
	// Décision: tableau[hitbox_Joueur_1] = 0b00000001?
	if (FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] == 1)
12A4  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
12A8  50E9      	MOVF FSR0L, W
12AA  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
12AC  26E9      	ADDWF FSR0L, F
12AE  04EF      	DECF INDF0, W
12B0  E139      	BNZ	label84
1324            label84

	{

		// Appel d'une Macro
		// Appel d'une Macro: Touche_coule_PA()
		FCM_Touche_coule_PA();
12B2  EC26F007  	CALL FCM_Touche_00064


		// Décision
		// Décision: Porte_avion = 0?
		if (FCV_PORTE_AVION == 0)
12B6  53AC      	MOVF gbl_FCV_PORTE_AVION, F, 1
12B8  A4D8      	BTFSS STATUS,Z
12BA  D128      	BRA	label89

		{

			// Appel d'une Macro
			// Appel d'une Macro: Reinitialisation_texte()
			FCM_Reinitialisation_texte();
12BC  ECFBF001  	CALL FCM_Reinit_00071


			// Pause
			// Pause: 100 ms
			FCI_DELAYBYTE_MS(100);
12C0  0E64      	MOVLW 0x64
12C2  6FC1      	MOVWF delay_ms_00000_arg_del, 1
12C4  EC06F000  	CALL delay_ms_00000


			// Appel de la Routine Composant
			// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
			FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
12C8  0E20      	MOVLW 0x20
12CA  6FC1      	MOVWF CompTempVar2758, 1
12CC  6FC2      	MOVWF CompTempVar2758+D'1', 1
12CE  6FC3      	MOVWF CompTempVar2758+D'2', 1
12D0  6FC4      	MOVWF CompTempVar2758+D'3', 1
12D2  6FC5      	MOVWF CompTempVar2758+D'4', 1
12D4  6FC6      	MOVWF CompTempVar2758+D'5', 1
12D6  6FC7      	MOVWF CompTempVar2758+D'6', 1
12D8  6FC8      	MOVWF CompTempVar2758+D'7', 1
12DA  6FC9      	MOVWF CompTempVar2758+D'8', 1
12DC  6FCA      	MOVWF CompTempVar2758+D'9', 1
12DE  6FCB      	MOVWF CompTempVar2758+D'10', 1
12E0  6FCC      	MOVWF CompTempVar2758+D'11', 1
12E2  6FD2      	MOVWF CompTempVar2758+D'17', 1
12E4  6FD3      	MOVWF CompTempVar2758+D'18', 1
12E6  6FD4      	MOVWF CompTempVar2758+D'19', 1
12E8  0E43      	MOVLW 0x43
12EA  6FCD      	MOVWF CompTempVar2758+D'12', 1
12EC  0E65      	MOVLW 0x65
12EE  6FD1      	MOVWF CompTempVar2758+D'16', 1
12F0  0E6C      	MOVLW 0x6C
12F2  6FD0      	MOVWF CompTempVar2758+D'15', 1
12F4  0E6F      	MOVLW 0x6F
12F6  6FCE      	MOVWF CompTempVar2758+D'13', 1
12F8  0E75      	MOVLW 0x75
12FA  6FCF      	MOVWF CompTempVar2758+D'14', 1
12FC  6BD5      	CLRF CompTempVar2758+D'20', 1
12FE  0E00      	MOVLW HIGH(CompTempVar2758+D'0')
1300  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
1302  0EC1      	MOVLW LOW(CompTempVar2758+D'0')
1304  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
1306  0E15      	MOVLW 0x15
1308  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
130A  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
130C  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
130E  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
1310  0EF1      	MOVLW 0xF1
1312  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
1314  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
1316  0E02      	MOVLW 0x02
1318  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
131A  0E01      	MOVLW 0x01
131C  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
131E  EC44F003  	CALL FCD_0f051__00066


		// } else {

		}

	} else {
1322  D0F4      	BRA	label89


		// Croiseur
		// Décision: tableau[hitbox_Joueur_1] = 0b00000010?
		if (FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] == 2)
1324  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
1328  50E9      	MOVF FSR0L, W
132A  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
132C  26E9      	ADDWF FSR0L, F
132E  0E02      	MOVLW 0x02
1330  62EF      	CPFSEQ INDF0
1332  D039      	BRA	label85
13A6            label85

		{

			// Appel d'une Macro
			// Appel d'une Macro: Touche_coule_CR()
			FCM_Touche_coule_CR();
1334  ECB6F006  	CALL FCM_Touche_00073


			// Décision
			// Décision: Croiseur = 0?
			if (FCV_CROISEUR == 0)
1338  53A4      	MOVF gbl_FCV_CROISEUR, F, 1
133A  A4D8      	BTFSS STATUS,Z
133C  D0E7      	BRA	label89

			{

				// Appel d'une Macro
				// Appel d'une Macro: Reinitialisation_texte()
				FCM_Reinitialisation_texte();
133E  ECFBF001  	CALL FCM_Reinit_00071


				// Pause
				// Pause: 100 ms
				FCI_DELAYBYTE_MS(100);
1342  0E64      	MOVLW 0x64
1344  6FC1      	MOVWF delay_ms_00000_arg_del, 1
1346  EC06F000  	CALL delay_ms_00000


				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
				FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
134A  0E20      	MOVLW 0x20
134C  6FC1      	MOVWF CompTempVar2761, 1
134E  6FC2      	MOVWF CompTempVar2761+D'1', 1
1350  6FC3      	MOVWF CompTempVar2761+D'2', 1
1352  6FC4      	MOVWF CompTempVar2761+D'3', 1
1354  6FC5      	MOVWF CompTempVar2761+D'4', 1
1356  6FC6      	MOVWF CompTempVar2761+D'5', 1
1358  6FC7      	MOVWF CompTempVar2761+D'6', 1
135A  6FC8      	MOVWF CompTempVar2761+D'7', 1
135C  6FC9      	MOVWF CompTempVar2761+D'8', 1
135E  6FCA      	MOVWF CompTempVar2761+D'9', 1
1360  6FCB      	MOVWF CompTempVar2761+D'10', 1
1362  6FCC      	MOVWF CompTempVar2761+D'11', 1
1364  6FD2      	MOVWF CompTempVar2761+D'17', 1
1366  6FD3      	MOVWF CompTempVar2761+D'18', 1
1368  6FD4      	MOVWF CompTempVar2761+D'19', 1
136A  0E43      	MOVLW 0x43
136C  6FCD      	MOVWF CompTempVar2761+D'12', 1
136E  0E65      	MOVLW 0x65
1370  6FD1      	MOVWF CompTempVar2761+D'16', 1
1372  0E6C      	MOVLW 0x6C
1374  6FD0      	MOVWF CompTempVar2761+D'15', 1
1376  0E6F      	MOVLW 0x6F
1378  6FCE      	MOVWF CompTempVar2761+D'13', 1
137A  0E75      	MOVLW 0x75
137C  6FCF      	MOVWF CompTempVar2761+D'14', 1
137E  6BD5      	CLRF CompTempVar2761+D'20', 1
1380  0E00      	MOVLW HIGH(CompTempVar2761+D'0')
1382  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
1384  0EC1      	MOVLW LOW(CompTempVar2761+D'0')
1386  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
1388  0E15      	MOVLW 0x15
138A  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
138C  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
138E  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
1390  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
1392  0EF1      	MOVLW 0xF1
1394  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
1396  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
1398  0E02      	MOVLW 0x02
139A  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
139C  0E01      	MOVLW 0x01
139E  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
13A0  EC44F003  	CALL FCD_0f051__00066


			// } else {

			}

		} else {
13A4  D0B3      	BRA	label89


			// Décision
			// Décision: tableau[hitbox_Joueur_1] = 0b00000011?
			if (FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] == 3)
13A6  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
13AA  50E9      	MOVF FSR0L, W
13AC  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
13AE  26E9      	ADDWF FSR0L, F
13B0  0E03      	MOVLW 0x03
13B2  62EF      	CPFSEQ INDF0
13B4  D039      	BRA	label86
1428            label86

			{

				// Appel d'une Macro
				// Appel d'une Macro: Touche_Coule_CT()
				FCM_Touche_Coule_CT();
13B6  ECA3F006  	CALL FCM_Touche_00074


				// Décision
				// Décision: Contre_torpilleur = 0?
				if (FCV_CONTRE_TORPILLEUR == 0)
13BA  53AE      	MOVF gbl_FCV_CONTRE_TORPILLEUR, F, 1
13BC  A4D8      	BTFSS STATUS,Z
13BE  D0A6      	BRA	label89

				{

					// Appel d'une Macro
					// Appel d'une Macro: Reinitialisation_texte()
					FCM_Reinitialisation_texte();
13C0  ECFBF001  	CALL FCM_Reinit_00071


					// Pause
					// Pause: 100 ms
					FCI_DELAYBYTE_MS(100);
13C4  0E64      	MOVLW 0x64
13C6  6FC1      	MOVWF delay_ms_00000_arg_del, 1
13C8  EC06F000  	CALL delay_ms_00000


					// Appel de la Routine Composant
					// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
					FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
13CC  0E20      	MOVLW 0x20
13CE  6FC1      	MOVWF CompTempVar2764, 1
13D0  6FC2      	MOVWF CompTempVar2764+D'1', 1
13D2  6FC3      	MOVWF CompTempVar2764+D'2', 1
13D4  6FC4      	MOVWF CompTempVar2764+D'3', 1
13D6  6FC5      	MOVWF CompTempVar2764+D'4', 1
13D8  6FC6      	MOVWF CompTempVar2764+D'5', 1
13DA  6FC7      	MOVWF CompTempVar2764+D'6', 1
13DC  6FC8      	MOVWF CompTempVar2764+D'7', 1
13DE  6FC9      	MOVWF CompTempVar2764+D'8', 1
13E0  6FCA      	MOVWF CompTempVar2764+D'9', 1
13E2  6FCB      	MOVWF CompTempVar2764+D'10', 1
13E4  6FCC      	MOVWF CompTempVar2764+D'11', 1
13E6  6FD2      	MOVWF CompTempVar2764+D'17', 1
13E8  6FD3      	MOVWF CompTempVar2764+D'18', 1
13EA  6FD4      	MOVWF CompTempVar2764+D'19', 1
13EC  0E43      	MOVLW 0x43
13EE  6FCD      	MOVWF CompTempVar2764+D'12', 1
13F0  0E65      	MOVLW 0x65
13F2  6FD1      	MOVWF CompTempVar2764+D'16', 1
13F4  0E6C      	MOVLW 0x6C
13F6  6FD0      	MOVWF CompTempVar2764+D'15', 1
13F8  0E6F      	MOVLW 0x6F
13FA  6FCE      	MOVWF CompTempVar2764+D'13', 1
13FC  0E75      	MOVLW 0x75
13FE  6FCF      	MOVWF CompTempVar2764+D'14', 1
1400  6BD5      	CLRF CompTempVar2764+D'20', 1
1402  0E00      	MOVLW HIGH(CompTempVar2764+D'0')
1404  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
1406  0EC1      	MOVLW LOW(CompTempVar2764+D'0')
1408  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
140A  0E15      	MOVLW 0x15
140C  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
140E  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
1410  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
1412  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
1414  0EF1      	MOVLW 0xF1
1416  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
1418  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
141A  0E02      	MOVLW 0x02
141C  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
141E  0E01      	MOVLW 0x01
1420  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
1422  EC44F003  	CALL FCD_0f051__00066


				// } else {

				}

			} else {
1426  D072      	BRA	label89


				// Décision
				// Décision: tableau[hitbox_Joueur_1] = 0b00000100?
				if (FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] == 4)
1428  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
142C  50E9      	MOVF FSR0L, W
142E  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
1430  26E9      	ADDWF FSR0L, F
1432  0E04      	MOVLW 0x04
1434  62EF      	CPFSEQ INDF0
1436  D038      	BRA	label87
14A8            label87

				{

					// Appel d'une Macro
					// Appel d'une Macro: Touche_Coule_SM()
					FCM_Touche_Coule_SM();
1438  ECC9F006  	CALL FCM_Touche_0006B


					// Décision
					// Décision: Sous_marin = 0?
					if (FCV_SOUS_MARIN == 0)
143C  53A7      	MOVF gbl_FCV_SOUS_MARIN, F, 1
143E  E166      	BNZ	label89

					{

						// Appel d'une Macro
						// Appel d'une Macro: Reinitialisation_texte()
						FCM_Reinitialisation_texte();
1440  ECFBF001  	CALL FCM_Reinit_00071


						// Pause
						// Pause: 100 ms
						FCI_DELAYBYTE_MS(100);
1444  0E64      	MOVLW 0x64
1446  6FC1      	MOVWF delay_ms_00000_arg_del, 1
1448  EC06F000  	CALL delay_ms_00000


						// Appel de la Routine Composant
						// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
						FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
144C  0E20      	MOVLW 0x20
144E  6FC1      	MOVWF CompTempVar2767, 1
1450  6FC2      	MOVWF CompTempVar2767+D'1', 1
1452  6FC3      	MOVWF CompTempVar2767+D'2', 1
1454  6FC4      	MOVWF CompTempVar2767+D'3', 1
1456  6FC5      	MOVWF CompTempVar2767+D'4', 1
1458  6FC6      	MOVWF CompTempVar2767+D'5', 1
145A  6FC7      	MOVWF CompTempVar2767+D'6', 1
145C  6FC8      	MOVWF CompTempVar2767+D'7', 1
145E  6FC9      	MOVWF CompTempVar2767+D'8', 1
1460  6FCA      	MOVWF CompTempVar2767+D'9', 1
1462  6FCB      	MOVWF CompTempVar2767+D'10', 1
1464  6FCC      	MOVWF CompTempVar2767+D'11', 1
1466  6FD2      	MOVWF CompTempVar2767+D'17', 1
1468  6FD3      	MOVWF CompTempVar2767+D'18', 1
146A  6FD4      	MOVWF CompTempVar2767+D'19', 1
146C  0E43      	MOVLW 0x43
146E  6FCD      	MOVWF CompTempVar2767+D'12', 1
1470  0E65      	MOVLW 0x65
1472  6FD1      	MOVWF CompTempVar2767+D'16', 1
1474  0E6C      	MOVLW 0x6C
1476  6FD0      	MOVWF CompTempVar2767+D'15', 1
1478  0E6F      	MOVLW 0x6F
147A  6FCE      	MOVWF CompTempVar2767+D'13', 1
147C  0E75      	MOVLW 0x75
147E  6FCF      	MOVWF CompTempVar2767+D'14', 1
1480  6BD5      	CLRF CompTempVar2767+D'20', 1
1482  0E00      	MOVLW HIGH(CompTempVar2767+D'0')
1484  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
1486  0EC1      	MOVLW LOW(CompTempVar2767+D'0')
1488  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
148A  0E15      	MOVLW 0x15
148C  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
148E  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
1490  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
1492  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
1494  0EF1      	MOVLW 0xF1
1496  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
1498  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
149A  0E02      	MOVLW 0x02
149C  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
149E  0E01      	MOVLW 0x01
14A0  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
14A2  EC44F003  	CALL FCD_0f051__00066


					// } else {

					}

				} else {
14A6  D032      	BRA	label89


					// Décision
					// Décision: tableau[hitbox_Joueur_1] = 0b00000101?
					if (FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] == 5)
14A8  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
14AC  50E9      	MOVF FSR0L, W
14AE  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
14B0  26E9      	ADDWF FSR0L, F
14B2  0E05      	MOVLW 0x05
14B4  62EF      	CPFSEQ INDF0
14B6  D028      	BRA	label88
1508            label88

					{

						// Appel d'une Macro
						// Appel d'une Macro: Touche_Coule_TORP()
						FCM_Touche_Coule_TORP();
14B8  EC39F007  	CALL FCM_Touche_0005B


						// Décision
						// Décision: Torpilleur = 0?
						if (FCV_TORPILLEUR == 0)
14BC  53A5      	MOVF gbl_FCV_TORPILLEUR, F, 1
14BE  E126      	BNZ	label89

						{

							// Appel d'une Macro
							// Appel d'une Macro: Reinitialisation_texte()
							FCM_Reinitialisation_texte();
14C0  ECFBF001  	CALL FCM_Reinit_00071


							// Pause
							// Pause: 100 ms
							FCI_DELAYBYTE_MS(100);
14C4  0E64      	MOVLW 0x64
14C6  6FC1      	MOVWF delay_ms_00000_arg_del, 1
14C8  EC06F000  	CALL delay_ms_00000


							// Appel de la Routine Composant
							// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Coule", 0, 241, 2, 1)
							FCD_0f051_gLCD_EB076_4D1__Print("Coule", 6, 0, 241, 2, 1);
14CC  0E43      	MOVLW 0x43
14CE  6FC1      	MOVWF CompTempVar2770, 1
14D0  0E6F      	MOVLW 0x6F
14D2  6FC2      	MOVWF CompTempVar2770+D'1', 1
14D4  0E75      	MOVLW 0x75
14D6  6FC3      	MOVWF CompTempVar2770+D'2', 1
14D8  0E6C      	MOVLW 0x6C
14DA  6FC4      	MOVWF CompTempVar2770+D'3', 1
14DC  0E65      	MOVLW 0x65
14DE  6FC5      	MOVWF CompTempVar2770+D'4', 1
14E0  6BC6      	CLRF CompTempVar2770+D'5', 1
14E2  0E00      	MOVLW HIGH(CompTempVar2770+D'0')
14E4  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
14E6  0EC1      	MOVLW LOW(CompTempVar2770+D'0')
14E8  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
14EA  0E06      	MOVLW 0x06
14EC  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
14EE  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
14F0  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
14F2  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
14F4  0EF1      	MOVLW 0xF1
14F6  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
14F8  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
14FA  0E02      	MOVLW 0x02
14FC  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
14FE  0E01      	MOVLW 0x01
1500  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
1502  EC44F003  	CALL FCD_0f051__00066


						// } else {

						}

					} else {
1506  D002      	BRA	label89
150C            label89


						// Manque
						// Appel d'une Macro: Manque()
						FCM_Manque();
1508  EC8BF007  	CALL FCM_Manque_00000


					}

				}

			}

		}

	}

	// Calcul
	// Calcul:
	//  X_SORTIE = 0
	//  X = 0
	//  Y = 0
	//  Appui_Ecran = 0
	FCV_X_SORTIE = 0;
150C  0100      	MOVLB 0x00
150E  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1510  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_X = 0;
1512  6B8E      	CLRF gbl_FCV_X, 1
1514  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
1516  6B8C      	CLRF gbl_FCV_Y, 1
1518  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_APPUI_ECRAN = 0;
151A  6BA9      	CLRF gbl_FCV_APPUI_ECRAN, 1


	// Pause
	// Pause: 100 ms
	FCI_DELAYBYTE_MS(100);
151C  0E64      	MOVLW 0x64
151E  6FC1      	MOVWF delay_ms_00000_arg_del, 1
1520  EC06F000  	CALL delay_ms_00000


}
1524  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_tactile()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_DisableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
0840  ECABF002  	CALL FCD_0f051__00076


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_EnableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
0844  EC77F002  	CALL FCD_0f051__00077


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_SetTouchRegionPicaso(0, 0, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(0, 0, 240, 240);
0848  6BBF      	CLRF FCD_0f051__0006F_arg_FCL_X1, 1
084A  6BC0      	CLRF FCD_0f051__0006F_arg_FCL_X1+D'1', 1
084C  6BC1      	CLRF FCD_0f051__0006F_arg_FCL_Y1, 1
084E  6BC2      	CLRF FCD_0f051__0006F_arg_FCL_Y1+D'1', 1
0850  0EF0      	MOVLW 0xF0
0852  6FC3      	MOVWF FCD_0f051__0006F_arg_FCL_X2, 1
0854  6BC4      	CLRF FCD_0f051__0006F_arg_FCL_X2+D'1', 1
0856  0EF0      	MOVLW 0xF0
0858  6FC5      	MOVWF FCD_0f051__0006F_arg_FCL_Y2, 1
085A  6BC6      	CLRF FCD_0f051__0006F_arg_FCL_Y2+D'1', 1
085C  ECCAF002  	CALL FCD_0f051__0006F


}
0860  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Choix_Bateau_Toucher()

{

	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_texte()
	FCM_Reinitialisation_texte();
16D2  ECFBF001  	CALL FCM_Reinit_00071


	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_tactile()
	FCM_Reinitialisation_tactile();
16D6  EC20F004  	CALL FCM_Reinit_00075


	// Boucle
	// Boucle: While Appui_Ecran = 0
	while (FCV_APPUI_ECRAN == 0)
16DA            label102
16DA  53A9      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
16DC  E103      	BNZ	label103
16E2  D7FB      	BRA	label102
16E4            label103

	{

		// Appel d'une Macro
		// Appel d'une Macro: Recuperation_coordonees()
		FCM_Recuperation_coordonees();
16DE  EC31F004  	CALL FCM_Recupe_00079



	}

	// Appel d'une Macro
	// Appel d'une Macro: Lecture_Coordonnes()
	FCM_Lecture_Coordonnes();
16E4  EC29F006  	CALL FCM_Lectur_00068


	// Pause
	// Pause: 100 ms
	FCI_DELAYBYTE_MS(100);
16E8  0E64      	MOVLW 0x64
16EA  6FC1      	MOVWF delay_ms_00000_arg_del, 1
16EC  EC06F000  	CALL delay_ms_00000


}
16F0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_phase_Fin()

{

	// 
	// Décision: Torpilleur = 0 & Croiseur = 0 & Porte_avion = 0 & Contre_torpilleur = 0 & Sous_marin = 0?
	if (FCV_TORPILLEUR == 0 & FCV_CROISEUR == 0 & FCV_PORTE_AVION == 0 & FCV_CONTRE_TORPILLEUR == 0 & FCV_SOUS_MARIN == 0)
1922  0100      	MOVLB 0x00
1924  6BBC      	CLRF CompTempVar2795, 1
1926  2BBC      	INCF CompTempVar2795, F, 1
1928  67A5      	TSTFSZ gbl_FCV_TORPILLEUR, 1
192A  91BC      	BCF CompTempVar2795,0, 1
192C  6BB8      	CLRF CompTempVar2788, 1
192E  2BB8      	INCF CompTempVar2788, F, 1
1930  67A4      	TSTFSZ gbl_FCV_CROISEUR, 1
1932  91B8      	BCF CompTempVar2788,0, 1
1934  51B8      	MOVF CompTempVar2788, W, 1
1936  17BC      	ANDWF CompTempVar2795, F, 1
1938  6BB9      	CLRF CompTempVar2790, 1
193A  2BB9      	INCF CompTempVar2790, F, 1
193C  67AC      	TSTFSZ gbl_FCV_PORTE_AVION, 1
193E  91B9      	BCF CompTempVar2790,0, 1
1940  51B9      	MOVF CompTempVar2790, W, 1
1942  17BC      	ANDWF CompTempVar2795, F, 1
1944  6BBA      	CLRF CompTempVar2792, 1
1946  2BBA      	INCF CompTempVar2792, F, 1
1948  67AE      	TSTFSZ gbl_FCV_CONTRE_TORPILLEUR, 1
194A  91BA      	BCF CompTempVar2792,0, 1
194C  51BA      	MOVF CompTempVar2792, W, 1
194E  17BC      	ANDWF CompTempVar2795, F, 1
1950  6BBB      	CLRF CompTempVar2794, 1
1952  2BBB      	INCF CompTempVar2794, F, 1
1954  67A7      	TSTFSZ gbl_FCV_SOUS_MARIN, 1
1956  91BB      	BCF CompTempVar2794,0, 1
1958  51BB      	MOVF CompTempVar2794, W, 1
195A  15BC      	ANDWF CompTempVar2795, W, 1
195C  A4D8      	BTFSS STATUS,Z

	{

		// Appel d'une Macro
		// Appel d'une Macro: Fin_Jeu()
		FCM_Fin_Jeu();
195E  ECFEF00A  	CALL FCM_Fin_Je_0007B


	// } else {

	}

}
1962  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Choix_Bateaux()

{

	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_texte()
	FCM_Reinitialisation_texte();
101C  ECFBF001  	CALL FCM_Reinit_00071


	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_tactile()
	FCM_Reinitialisation_tactile();
1020  EC20F004  	CALL FCM_Reinit_00075


	// Appel d'une Macro
	// Appel d'une Macro: Message_bateau()
	FCM_Message_bateau();
1024  EC36F004  	CALL FCM_Messag_00070


	// Boucle
	// Boucle: While Appui_Ecran = 0
	while (FCV_APPUI_ECRAN == 0)
1028            label65
1028  0100      	MOVLB 0x00
102A  53A9      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
102C  E103      	BNZ	label66
1032  D7FA      	BRA	label65
1034            label66

	{

		// Appel d'une Macro
		// Appel d'une Macro: Recuperation_coordonees()
		FCM_Recuperation_coordonees();
102E  EC31F004  	CALL FCM_Recupe_00079



	}

	// Appel d'une Macro
	// Appel d'une Macro: Lecture_Coordonnes()
	FCM_Lecture_Coordonnes();
1034  EC29F006  	CALL FCM_Lectur_00068


	#if 0 // Disabled code
	// Appel d'une Macro
	// Appel d'une Macro: Hitbox_v2()
	FCM_Hitbox_v2();

	#endif // #if 0: Disabled code
	// Pause
	// Pause: 100 ms
	FCI_DELAYBYTE_MS(100);
1038  0E64      	MOVLW 0x64
103A  6FC1      	MOVWF delay_ms_00000_arg_del, 1
103C  EC06F000  	CALL delay_ms_00000


}
1040  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_affichage_bateau()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 70, 70, 70)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 70, 70, 70);
03BA  0100      	MOVLB 0x00
03BC  518E      	MOVF gbl_FCV_X, W, 1
03BE  6FBF      	MOVWF FCM_parame_00065_arg_FCL_POS_X1, 1
03C0  518F      	MOVF gbl_FCV_X+D'1', W, 1
03C2  6FC0      	MOVWF FCM_parame_00065_arg_FCL_POS_X1+D'1', 1
03C4  0E18      	MOVLW 0x18
03C6  5D8E      	SUBWF gbl_FCV_X, W, 1
03C8  6FC1      	MOVWF FCM_parame_00065_arg_FCL_POS_X2, 1
03CA  598E      	SUBWFB gbl_FCV_X, W, 1
03CC  0818      	SUBLW 0x18
03CE  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
03D0  6FC2      	MOVWF FCM_parame_00065_arg_FCL_POS_X2+D'1', 1
03D2  518C      	MOVF gbl_FCV_Y, W, 1
03D4  6FC3      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1, 1
03D6  518D      	MOVF gbl_FCV_Y+D'1', W, 1
03D8  6FC4      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1+D'1', 1
03DA  0E18      	MOVLW 0x18
03DC  5D8C      	SUBWF gbl_FCV_Y, W, 1
03DE  6FC5      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2, 1
03E0  598C      	SUBWFB gbl_FCV_Y, W, 1
03E2  0818      	SUBLW 0x18
03E4  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
03E6  6FC6      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2+D'1', 1
03E8  0E46      	MOVLW 0x46
03EA  6FC7      	MOVWF FCM_parame_00065_arg_FCL_ROUGE, 1
03EC  6FC8      	MOVWF FCM_parame_00065_arg_FCL_VERT, 1
03EE  6FC9      	MOVWF FCM_parame_00065_arg_FCL_BLEU, 1
03F0  ECAFF001  	CALL FCM_parame_00065


}
03F4  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Sous_marin()

{

	// Appel d'une Macro
	// Appel d'une Macro: hitbox_phase_jeu()
	FCM_hitbox_phase_jeu();
0EC2  ECDCF003  	CALL FCM_hitbox_0006A


	// Calcul
	// Calcul:
	//  Tableau[hitbox_Joueur_1] = 0b00000100
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Sous_marin = Sous_marin + 1
	FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = 4;
0EC6  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0ECA  50E9      	MOVF FSR0L, W
0ECC  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0ECE  26E9      	ADDWF FSR0L, F
0ED0  0E04      	MOVLW 0x04
0ED2  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
0ED4  29AB      	INCF gbl_FCV_BATEAU, W, 1
0ED6  6FAB      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
0ED8  6B86      	CLRF gbl_FCV_X_SORTIE, 1
0EDA  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
0EDC  6BA9      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
0EDE  6B8E      	CLRF gbl_FCV_X, 1
0EE0  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
0EE2  6B8C      	CLRF gbl_FCV_Y, 1
0EE4  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_SOUS_MARIN = FCV_SOUS_MARIN + 1;
0EE6  29A7      	INCF gbl_FCV_SOUS_MARIN, W, 1
0EE8  6FA7      	MOVWF gbl_FCV_SOUS_MARIN, 1


}
0EEA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro parametres_bateau :
       :  pos_x1 : MX_UINT16
       :  pos_x2 : MX_UINT16
       :  pos_y1 : MX_UINT16
       :  pos_y2 : MX_UINT16
       :  Rouge : MX_UINT8
       :  Vert : MX_UINT8
       :  Bleu : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2, MX_UINT8 FCL_ROUGE, MX_UINT8 FCL_VERT, MX_UINT8 FCL_BLEU)

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(.Rouge, .Vert, .Bleu)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(FCL_ROUGE, FCL_VERT, FCL_BLEU);
035E  51C7      	MOVF FCM_parame_00065_arg_FCL_ROUGE, W, 1
0360  6FCA      	MOVWF FCD_0f051__0007D_arg_FCL_RED, 1
0362  51C8      	MOVF FCM_parame_00065_arg_FCL_VERT, W, 1
0364  6FCB      	MOVWF FCD_0f051__0007D_arg_FCL_GREEN, 1
0366  51C9      	MOVF FCM_parame_00065_arg_FCL_BLEU, W, 1
0368  6FCC      	MOVWF FCD_0f051__0007D_arg_FCL_BLUE, 1
036A  EC81F001  	CALL FCD_0f051__0007D


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(.pos_x1, .pos_y1, .pos_x2, .pos_y2, 0, 1)
	FCD_0f051_gLCD_EB076_4D1__DrawRectangle(FCL_POS_X1, FCL_POS_Y1, FCL_POS_X2, FCL_POS_Y2, 0, 1);
036E  51BF      	MOVF FCM_parame_00065_arg_FCL_POS_X1, W, 1
0370  6FCA      	MOVWF FCD_0f051__0007E_arg_FCL_X1, 1
0372  51C0      	MOVF FCM_parame_00065_arg_FCL_POS_X1+D'1', W, 1
0374  6FCB      	MOVWF FCD_0f051__0007E_arg_FCL_X1+D'1', 1
0376  51C3      	MOVF FCM_parame_00065_arg_FCL_POS_Y1, W, 1
0378  6FCC      	MOVWF FCD_0f051__0007E_arg_FCL_Y1, 1
037A  51C4      	MOVF FCM_parame_00065_arg_FCL_POS_Y1+D'1', W, 1
037C  6FCD      	MOVWF FCD_0f051__0007E_arg_FCL_Y1+D'1', 1
037E  51C1      	MOVF FCM_parame_00065_arg_FCL_POS_X2, W, 1
0380  6FCE      	MOVWF FCD_0f051__0007E_arg_FCL_X2, 1
0382  51C2      	MOVF FCM_parame_00065_arg_FCL_POS_X2+D'1', W, 1
0384  6FCF      	MOVWF FCD_0f051__0007E_arg_FCL_X2+D'1', 1
0386  51C5      	MOVF FCM_parame_00065_arg_FCL_POS_Y2, W, 1
0388  6FD0      	MOVWF FCD_0f051__0007E_arg_FCL_Y2, 1
038A  51C6      	MOVF FCM_parame_00065_arg_FCL_POS_Y2+D'1', W, 1
038C  6FD1      	MOVWF FCD_0f051__0007E_arg_FCL_Y2+D'1', 1
038E  6BD2      	CLRF FCD_0f051__0007E_arg_FCL_T_0007F, 1
0390  0E01      	MOVLW 0x01
0392  6FD3      	MOVWF FCD_0f051__0007E_arg_FCL_SOLID, 1
0394  EC9DF000  	CALL FCD_0f051__0007E


}
0398  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_texte()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(255, 255, 255)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(255, 255, 255);
03F6  0100      	MOVLB 0x00
03F8  69CA      	SETF FCD_0f051__0007D_arg_FCL_RED, 1
03FA  69CB      	SETF FCD_0f051__0007D_arg_FCL_GREEN, 1
03FC  69CC      	SETF FCD_0f051__0007D_arg_FCL_BLUE, 1
03FE  EC81F001  	CALL FCD_0f051__0007D


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 241, 240, 320, 1, 1)
	FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 241, 240, 320, 1, 1);
0402  6BCA      	CLRF FCD_0f051__0007E_arg_FCL_X1, 1
0404  6BCB      	CLRF FCD_0f051__0007E_arg_FCL_X1+D'1', 1
0406  0EF1      	MOVLW 0xF1
0408  6FCC      	MOVWF FCD_0f051__0007E_arg_FCL_Y1, 1
040A  6BCD      	CLRF FCD_0f051__0007E_arg_FCL_Y1+D'1', 1
040C  0EF0      	MOVLW 0xF0
040E  6FCE      	MOVWF FCD_0f051__0007E_arg_FCL_X2, 1
0410  6BCF      	CLRF FCD_0f051__0007E_arg_FCL_X2+D'1', 1
0412  0E40      	MOVLW 0x40
0414  6FD0      	MOVWF FCD_0f051__0007E_arg_FCL_Y2, 1
0416  0E01      	MOVLW 0x01
0418  6FD1      	MOVWF FCD_0f051__0007E_arg_FCL_Y2+D'1', 1
041A  6FD2      	MOVWF FCD_0f051__0007E_arg_FCL_T_0007F, 1
041C  6FD3      	MOVWF FCD_0f051__0007E_arg_FCL_SOLID, 1
041E  EC9DF000  	CALL FCD_0f051__0007E


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(0, 0, 0)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(0, 0, 0);
0422  0100      	MOVLB 0x00
0424  6BCA      	CLRF FCD_0f051__0007D_arg_FCL_RED, 1
0426  6BCB      	CLRF FCD_0f051__0007D_arg_FCL_GREEN, 1
0428  6BCC      	CLRF FCD_0f051__0007D_arg_FCL_BLUE, 1
042A  EC81F001  	CALL FCD_0f051__0007D


}
042E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Appui_tactile()
{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	#if 0 // Disabled code
	//Commentaire:
	//Coordonnée pour X

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: X=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);

	#if 0 // Disabled code
	//Commentaire:
	//Coordonée pour Y

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(X, 80, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_X, 80, 150, 2, 1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(Y, 120, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_Y, 120, 150, 2, 1);

	// Pause
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	// Calcul
	// Calcul:
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	FCV_APPUI_ECRAN = 0;
	FCV_X = 0;
	FCV_Y = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Manque()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 56, 153, 243)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 56, 153, 243);
0F16  0100      	MOVLB 0x00
0F18  518E      	MOVF gbl_FCV_X, W, 1
0F1A  6FBF      	MOVWF FCM_parame_00065_arg_FCL_POS_X1, 1
0F1C  518F      	MOVF gbl_FCV_X+D'1', W, 1
0F1E  6FC0      	MOVWF FCM_parame_00065_arg_FCL_POS_X1+D'1', 1
0F20  0E18      	MOVLW 0x18
0F22  5D8E      	SUBWF gbl_FCV_X, W, 1
0F24  6FC1      	MOVWF FCM_parame_00065_arg_FCL_POS_X2, 1
0F26  598E      	SUBWFB gbl_FCV_X, W, 1
0F28  0818      	SUBLW 0x18
0F2A  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0F2C  6FC2      	MOVWF FCM_parame_00065_arg_FCL_POS_X2+D'1', 1
0F2E  518C      	MOVF gbl_FCV_Y, W, 1
0F30  6FC3      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1, 1
0F32  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0F34  6FC4      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1+D'1', 1
0F36  0E18      	MOVLW 0x18
0F38  5D8C      	SUBWF gbl_FCV_Y, W, 1
0F3A  6FC5      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2, 1
0F3C  598C      	SUBWFB gbl_FCV_Y, W, 1
0F3E  0818      	SUBLW 0x18
0F40  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0F42  6FC6      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2+D'1', 1
0F44  0E38      	MOVLW 0x38
0F46  6FC7      	MOVWF FCM_parame_00065_arg_FCL_ROUGE, 1
0F48  0E99      	MOVLW 0x99
0F4A  6FC8      	MOVWF FCM_parame_00065_arg_FCL_VERT, 1
0F4C  0EF3      	MOVLW 0xF3
0F4E  6FC9      	MOVWF FCM_parame_00065_arg_FCL_BLEU, 1
0F50  ECAFF001  	CALL FCM_parame_00065


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Manque   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Manque   ", 22, 0, 241, 2, 1);
0F54  0E20      	MOVLW 0x20
0F56  0100      	MOVLB 0x00
0F58  6FC1      	MOVWF CompTempVar2784, 1
0F5A  6FC2      	MOVWF CompTempVar2784+D'1', 1
0F5C  6FC3      	MOVWF CompTempVar2784+D'2', 1
0F5E  6FC4      	MOVWF CompTempVar2784+D'3', 1
0F60  6FC5      	MOVWF CompTempVar2784+D'4', 1
0F62  6FC6      	MOVWF CompTempVar2784+D'5', 1
0F64  6FC7      	MOVWF CompTempVar2784+D'6', 1
0F66  6FC8      	MOVWF CompTempVar2784+D'7', 1
0F68  6FC9      	MOVWF CompTempVar2784+D'8', 1
0F6A  6FCA      	MOVWF CompTempVar2784+D'9', 1
0F6C  6FCB      	MOVWF CompTempVar2784+D'10', 1
0F6E  6FCC      	MOVWF CompTempVar2784+D'11', 1
0F70  6FD3      	MOVWF CompTempVar2784+D'18', 1
0F72  6FD4      	MOVWF CompTempVar2784+D'19', 1
0F74  6FD5      	MOVWF CompTempVar2784+D'20', 1
0F76  0E4D      	MOVLW 0x4D
0F78  6FCD      	MOVWF CompTempVar2784+D'12', 1
0F7A  0E61      	MOVLW 0x61
0F7C  6FCE      	MOVWF CompTempVar2784+D'13', 1
0F7E  0E65      	MOVLW 0x65
0F80  6FD2      	MOVWF CompTempVar2784+D'17', 1
0F82  0E6E      	MOVLW 0x6E
0F84  6FCF      	MOVWF CompTempVar2784+D'14', 1
0F86  0E71      	MOVLW 0x71
0F88  6FD0      	MOVWF CompTempVar2784+D'15', 1
0F8A  0E75      	MOVLW 0x75
0F8C  6FD1      	MOVWF CompTempVar2784+D'16', 1
0F8E  6BD6      	CLRF CompTempVar2784+D'21', 1
0F90  0E00      	MOVLW HIGH(CompTempVar2784+D'0')
0F92  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
0F94  0EC1      	MOVLW LOW(CompTempVar2784+D'0')
0F96  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
0F98  0E16      	MOVLW 0x16
0F9A  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
0F9C  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
0F9E  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
0FA0  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
0FA2  0EF1      	MOVLW 0xF1
0FA4  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
0FA6  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
0FA8  0E02      	MOVLW 0x02
0FAA  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
0FAC  0E01      	MOVLW 0x01
0FAE  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
0FB0  EC44F003  	CALL FCD_0f051__00066


}
0FB4  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Recuperation_coordonees()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Appui_Ecran=gLCD_EB076_4D1::G4D_GetTouchCoordinatesPicaso()
	FCV_APPUI_ECRAN = FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
0862  EC18F002  	CALL FCD_0f051__00083
0866  51C1      	MOVF CompTempVarRet2838, W, 1
0868  6FA9      	MOVWF gbl_FCV_APPUI_ECRAN, 1


}
086A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_phase_debut()

{

	// Boucle
	// Boucle: While bateau >= 17
	while (1)
1870            label106

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_texte()
		FCM_Reinitialisation_texte();
1870  ECFBF001  	CALL FCM_Reinit_00071


		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_tactile()
		FCM_Reinitialisation_tactile();
1874  EC20F004  	CALL FCM_Reinit_00075


		// Appel d'une Macro
		// Appel d'une Macro: Message_bateau()
		FCM_Message_bateau();
1878  EC36F004  	CALL FCM_Messag_00070


		// Boucle
		// Boucle: While Appui_Ecran = 0
		while (FCV_APPUI_ECRAN == 0)
187C            label107
187C  0100      	MOVLB 0x00
187E  53A9      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
1880  E103      	BNZ	label108
1886  D7FA      	BRA	label107
1888            label108

		{

			// Appel d'une Macro
			// Appel d'une Macro: Recuperation_coordonees()
			FCM_Recuperation_coordonees();
1882  EC31F004  	CALL FCM_Recupe_00079



		}

		// Appel d'une Macro
		// Appel d'une Macro: Lecture_Coordonnes()
		FCM_Lecture_Coordonnes();
1888  EC29F006  	CALL FCM_Lectur_00068


		// Appel d'une Macro
		// Appel d'une Macro: Hitbox_v2()
		FCM_Hitbox_v2();
188C  0E99      	MOVLW 0x99
188E  EF93F00A  	GOTO	FCM_Hitbox_0005D
1892            label109


		// Pause
		// Pause: 100 ms
		FCI_DELAYBYTE_MS(100);
1892  0E64      	MOVLW 0x64
1894  6FC1      	MOVWF delay_ms_00000_arg_del, 1
1896  EC06F000  	CALL delay_ms_00000



		if ((FCV_BATEAU >= 17) != 0) break;
189A  6BB8      	CLRF CompTempVar2847, 1
189C  0E11      	MOVLW 0x11
189E  61AB      	CPFSLT gbl_FCV_BATEAU, 1
18A0  2BB8      	INCF CompTempVar2847, F, 1
18A2  53B8      	MOVF CompTempVar2847, F, 1
18A4  E0E5      	BZ	label106

	}

	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_texte()
	FCM_Reinitialisation_texte();
18A6  ECFBF001  	CALL FCM_Reinit_00071


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("    En attente du joueur 2 ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("    En attente du joueur 2 ", 28, 0, 241, 2, 1);
18AA  0E20      	MOVLW 0x20
18AC  6FC1      	MOVWF CompTempVar2848, 1
18AE  6FC2      	MOVWF CompTempVar2848+D'1', 1
18B0  6FC3      	MOVWF CompTempVar2848+D'2', 1
18B2  6FC4      	MOVWF CompTempVar2848+D'3', 1
18B4  6FC7      	MOVWF CompTempVar2848+D'6', 1
18B6  6FCF      	MOVWF CompTempVar2848+D'14', 1
18B8  6FD2      	MOVWF CompTempVar2848+D'17', 1
18BA  6FD9      	MOVWF CompTempVar2848+D'24', 1
18BC  6FDB      	MOVWF CompTempVar2848+D'26', 1
18BE  0E32      	MOVLW 0x32
18C0  6FDA      	MOVWF CompTempVar2848+D'25', 1
18C2  0E45      	MOVLW 0x45
18C4  6FC5      	MOVWF CompTempVar2848+D'4', 1
18C6  0E61      	MOVLW 0x61
18C8  6FC8      	MOVWF CompTempVar2848+D'7', 1
18CA  0E64      	MOVLW 0x64
18CC  6FD0      	MOVWF CompTempVar2848+D'15', 1
18CE  0E65      	MOVLW 0x65
18D0  6FCB      	MOVWF CompTempVar2848+D'10', 1
18D2  6FCE      	MOVWF CompTempVar2848+D'13', 1
18D4  6FD6      	MOVWF CompTempVar2848+D'21', 1
18D6  0E6A      	MOVLW 0x6A
18D8  6FD3      	MOVWF CompTempVar2848+D'18', 1
18DA  0E6E      	MOVLW 0x6E
18DC  6FC6      	MOVWF CompTempVar2848+D'5', 1
18DE  6FCC      	MOVWF CompTempVar2848+D'11', 1
18E0  0E6F      	MOVLW 0x6F
18E2  6FD4      	MOVWF CompTempVar2848+D'19', 1
18E4  0E72      	MOVLW 0x72
18E6  6FD8      	MOVWF CompTempVar2848+D'23', 1
18E8  0E74      	MOVLW 0x74
18EA  6FC9      	MOVWF CompTempVar2848+D'8', 1
18EC  6FCA      	MOVWF CompTempVar2848+D'9', 1
18EE  6FCD      	MOVWF CompTempVar2848+D'12', 1
18F0  0E75      	MOVLW 0x75
18F2  6FD1      	MOVWF CompTempVar2848+D'16', 1
18F4  6FD5      	MOVWF CompTempVar2848+D'20', 1
18F6  6FD7      	MOVWF CompTempVar2848+D'22', 1
18F8  6BDC      	CLRF CompTempVar2848+D'27', 1
18FA  0E00      	MOVLW HIGH(CompTempVar2848+D'0')
18FC  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
18FE  0EC1      	MOVLW LOW(CompTempVar2848+D'0')
1900  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
1902  0E1C      	MOVLW 0x1C
1904  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
1906  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
1908  6BF8      	CLRF FCD_0f051__00066_arg_FCL_X1, 1
190A  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
190C  0EF1      	MOVLW 0xF1
190E  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
1910  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
1912  0E02      	MOVLW 0x02
1914  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
1916  0E01      	MOVLW 0x01
1918  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
191A  EC44F003  	CALL FCD_0f051__00066


}
191E  EFF7F00C  	GOTO	label113


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Fin_Jeu()

{

	// Décision
	// Décision: Tour = 0?
	if (FCV_TOUR == 0)
15FC  0100      	MOVLB 0x00
15FE  53A8      	MOVF gbl_FCV_TOUR, F, 1
1600  E134      	BNZ	label101
166A            label101

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Vous avez gagné ! ", 100, 241, 2, 1)
		FCD_0f051_gLCD_EB076_4D1__Print("Vous avez gagné ! ", 19, 100, 241, 2, 1);
1602  0E20      	MOVLW 0x20
1604  6FC5      	MOVWF CompTempVar2796+D'4', 1
1606  6FCA      	MOVWF CompTempVar2796+D'9', 1
1608  6FD0      	MOVWF CompTempVar2796+D'15', 1
160A  6FD2      	MOVWF CompTempVar2796+D'17', 1
160C  0E21      	MOVLW 0x21
160E  6FD1      	MOVWF CompTempVar2796+D'16', 1
1610  0E56      	MOVLW 0x56
1612  6FC1      	MOVWF CompTempVar2796, 1
1614  0E61      	MOVLW 0x61
1616  6FC6      	MOVWF CompTempVar2796+D'5', 1
1618  6FCC      	MOVWF CompTempVar2796+D'11', 1
161A  0E65      	MOVLW 0x65
161C  6FC8      	MOVWF CompTempVar2796+D'7', 1
161E  0E67      	MOVLW 0x67
1620  6FCB      	MOVWF CompTempVar2796+D'10', 1
1622  6FCD      	MOVWF CompTempVar2796+D'12', 1
1624  0E6E      	MOVLW 0x6E
1626  6FCE      	MOVWF CompTempVar2796+D'13', 1
1628  0E6F      	MOVLW 0x6F
162A  6FC2      	MOVWF CompTempVar2796+D'1', 1
162C  0E73      	MOVLW 0x73
162E  6FC4      	MOVWF CompTempVar2796+D'3', 1
1630  0E75      	MOVLW 0x75
1632  6FC3      	MOVWF CompTempVar2796+D'2', 1
1634  0E76      	MOVLW 0x76
1636  6FC7      	MOVWF CompTempVar2796+D'6', 1
1638  0E7A      	MOVLW 0x7A
163A  6FC9      	MOVWF CompTempVar2796+D'8', 1
163C  0EE9      	MOVLW 0xE9
163E  6FCF      	MOVWF CompTempVar2796+D'14', 1
1640  6BD3      	CLRF CompTempVar2796+D'18', 1
1642  0E00      	MOVLW HIGH(CompTempVar2796+D'0')
1644  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
1646  0EC1      	MOVLW LOW(CompTempVar2796+D'0')
1648  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
164A  0E13      	MOVLW 0x13
164C  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
164E  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
1650  0E64      	MOVLW 0x64
1652  6FF8      	MOVWF FCD_0f051__00066_arg_FCL_X1, 1
1654  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
1656  0EF1      	MOVLW 0xF1
1658  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
165A  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
165C  0E02      	MOVLW 0x02
165E  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
1660  0E01      	MOVLW 0x01
1662  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
1664  EC44F003  	CALL FCD_0f051__00066


	} else {

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Vous avez perdu ! ", 100, 241, 2, 1)
		FCD_0f051_gLCD_EB076_4D1__Print("Vous avez perdu ! ", 19, 100, 241, 2, 1);
166A  0E20      	MOVLW 0x20
166C  6FC5      	MOVWF CompTempVar2798+D'4', 1
166E  6FCA      	MOVWF CompTempVar2798+D'9', 1
1670  6FD0      	MOVWF CompTempVar2798+D'15', 1
1672  6FD2      	MOVWF CompTempVar2798+D'17', 1
1674  0E21      	MOVLW 0x21
1676  6FD1      	MOVWF CompTempVar2798+D'16', 1
1678  0E56      	MOVLW 0x56
167A  6FC1      	MOVWF CompTempVar2798, 1
167C  0E61      	MOVLW 0x61
167E  6FC6      	MOVWF CompTempVar2798+D'5', 1
1680  0E64      	MOVLW 0x64
1682  6FCE      	MOVWF CompTempVar2798+D'13', 1
1684  0E65      	MOVLW 0x65
1686  6FC8      	MOVWF CompTempVar2798+D'7', 1
1688  6FCC      	MOVWF CompTempVar2798+D'11', 1
168A  0E6F      	MOVLW 0x6F
168C  6FC2      	MOVWF CompTempVar2798+D'1', 1
168E  0E70      	MOVLW 0x70
1690  6FCB      	MOVWF CompTempVar2798+D'10', 1
1692  0E72      	MOVLW 0x72
1694  6FCD      	MOVWF CompTempVar2798+D'12', 1
1696  0E73      	MOVLW 0x73
1698  6FC4      	MOVWF CompTempVar2798+D'3', 1
169A  0E75      	MOVLW 0x75
169C  6FC3      	MOVWF CompTempVar2798+D'2', 1
169E  6FCF      	MOVWF CompTempVar2798+D'14', 1
16A0  0E76      	MOVLW 0x76
16A2  6FC7      	MOVWF CompTempVar2798+D'6', 1
16A4  0E7A      	MOVLW 0x7A
16A6  6FC9      	MOVWF CompTempVar2798+D'8', 1
16A8  6BD3      	CLRF CompTempVar2798+D'18', 1
16AA  0E00      	MOVLW HIGH(CompTempVar2798+D'0')
16AC  6FC0      	MOVWF FCD_0f051__00066_arg_FCL_STR+D'1', 1
16AE  0EC1      	MOVLW LOW(CompTempVar2798+D'0')
16B0  6FBF      	MOVWF FCD_0f051__00066_arg_FCL_STR, 1
16B2  0E13      	MOVLW 0x13
16B4  6FF6      	MOVWF FCD_0f051__00066_arg_FCLsz_STR, 1
16B6  6BF7      	CLRF FCD_0f051__00066_arg_FCLsz_STR+D'1', 1
16B8  0E64      	MOVLW 0x64
16BA  6FF8      	MOVWF FCD_0f051__00066_arg_FCL_X1, 1
16BC  6BF9      	CLRF FCD_0f051__00066_arg_FCL_X1+D'1', 1
16BE  0EF1      	MOVLW 0xF1
16C0  6FFA      	MOVWF FCD_0f051__00066_arg_FCL_Y1, 1
16C2  6BFB      	CLRF FCD_0f051__00066_arg_FCL_Y1+D'1', 1
16C4  0E02      	MOVLW 0x02
16C6  6FFC      	MOVWF FCD_0f051__00066_arg_FCL_FONT, 1
16C8  0E01      	MOVLW 0x01
16CA  6FFD      	MOVWF FCD_0f051__00066_arg_FCL_T_00067, 1
16CC  EC44F003  	CALL FCD_0f051__00066


	}

}
1668  0012      	RETURN
16D0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_Coule_CT()

{

	// Appel d'une Macro
	// Appel d'une Macro: Message_Touche()
	FCM_Message_Touche();
0D46  ECDCF005  	CALL FCM_Messag_0005C


	// Calcul
	// Calcul:
	//  Contre_torpilleur = Contre_torpilleur - 1
	//  Tableau[hitbox_Joueur_1] = tableau[hitbox_Joueur_1] || 0b10000000
	FCV_CONTRE_TORPILLEUR = FCV_CONTRE_TORPILLEUR - 1;
0D4A  0100      	MOVLB 0x00
0D4C  05AE      	DECF gbl_FCV_CONTRE_TORPILLEUR, W, 1
0D4E  6FAE      	MOVWF gbl_FCV_CONTRE_TORPILLEUR, 1

	FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] || 128;
0D50  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0D54  50E9      	MOVF FSR0L, W
0D56  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0D58  26E9      	ADDWF FSR0L, F
0D5A  6BB8      	CLRF CompTempVar2778, 1
0D5C  2BB8      	INCF CompTempVar2778, F, 1
0D5E  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0D60  6EE9      	MOVWF FSR0L
0D62  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0D64  26E9      	ADDWF FSR0L, F
0D66  51B8      	MOVF CompTempVar2778, W, 1
0D68  6EEF      	MOVWF INDF0


}
0D6A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_hitbox_phase_jeu()

{

	// Calcul
	// Calcul:
	//  hitbox_Joueur_1 = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX_JOUEUR_1 = 1;
07B8  0E01      	MOVLW 0x01
07BA  0100      	MOVLB 0x00
07BC  6FA3      	MOVWF gbl_FCV_HITBOX_JOUEUR_1, 1

	FCV_Y = 24;
07BE  0E18      	MOVLW 0x18
07C0  6F8C      	MOVWF gbl_FCV_Y, 1
07C2  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
07C4  0E18      	MOVLW 0x18
07C6  6F8E      	MOVWF gbl_FCV_X, 1
07C8  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
07CA            label37
07CA  0E01      	MOVLW 0x01
07CC  0100      	MOVLB 0x00
07CE  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
07D0  B0D8      	BTFSC STATUS,C
07D4  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
083E  D7C5      	BRA	label37

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
07D8  518D      	MOVF gbl_FCV_Y+D'1', W, 1
07DA  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
07DC  E102      	BNZ	label38
07DE  518C      	MOVF gbl_FCV_Y, W, 1
07E0  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
07E2            label38
07E2  E223      	BC	label44
07E4            label39
082A            label44

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
07E4  518F      	MOVF gbl_FCV_X+D'1', W, 1
07E6  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
07E8  E102      	BNZ	label40
07EA  518E      	MOVF gbl_FCV_X, W, 1
07EC  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
07EE            label40
07EE  E309      	BNC	label41

				{

				} else {
0802            label41


					// Calcul
					// Calcul:
					//  hitbox_Joueur_1 = hitbox_Joueur_1 + 1
					//  X = X + 24
					FCV_HITBOX_JOUEUR_1 = FCV_HITBOX_JOUEUR_1 + 1;
07F0  29A3      	INCF gbl_FCV_HITBOX_JOUEUR_1, W, 1
07F2  6FA3      	MOVWF gbl_FCV_HITBOX_JOUEUR_1, 1

					FCV_X = FCV_X + 24;
07F4  6BC0      	CLRF CompTempVar2676, 1
07F6  0E18      	MOVLW 0x18
07F8  278E      	ADDWF gbl_FCV_X, F, 1
07FA  518F      	MOVF gbl_FCV_X+D'1', W, 1
07FC  23C0      	ADDWFC CompTempVar2676, F, 1
07FE  51C0      	MOVF CompTempVar2676, W, 1
0800  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
0802  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
0804  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
0806  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
0808  B4D8      	BTFSC STATUS,Z
080A  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
080C  6BBF      	CLRF CompTempVar2674, 1
080E  518F      	MOVF gbl_FCV_X+D'1', W, 1
0810  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
0812  E104      	BNZ	label42
0814  518E      	MOVF gbl_FCV_X, W, 1
0816  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
0818  D001      	BRA	label42
081A  D001      	BRA	label43
081C            label42
081C  A0D8      	BTFSS STATUS,C
081E  71BF      	BTG CompTempVar2674,0, 1
0820  53BF      	MOVF CompTempVar2674, F, 1
0822  E0E0      	BZ	label39

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
0824  ECDDF001  	CALL FCM_affich_0007C


		} else {
0828  D7D0      	BRA	label37


			// Calcul
			// Calcul:
			//  hitbox_Joueur_1 = hitbox_Joueur_1 + 10
			//  Y = Y + 24
			FCV_HITBOX_JOUEUR_1 = FCV_HITBOX_JOUEUR_1 + 10;
082A  0E0A      	MOVLW 0x0A
082C  25A3      	ADDWF gbl_FCV_HITBOX_JOUEUR_1, W, 1
082E  6FA3      	MOVWF gbl_FCV_HITBOX_JOUEUR_1, 1

			FCV_Y = FCV_Y + 24;
0830  6BBF      	CLRF CompTempVar2680, 1
0832  0E18      	MOVLW 0x18
0834  278C      	ADDWF gbl_FCV_Y, F, 1
0836  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0838  23BF      	ADDWFC CompTempVar2680, F, 1
083A  51BF      	MOVF CompTempVar2680, W, 1
083C  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

}
07D2  0012      	RETURN
07D6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_affichage_bateau_touche()
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Porte_avion()

{

	// Appel d'une Macro
	// Appel d'une Macro: hitbox_phase_jeu()
	FCM_hitbox_phase_jeu();
0EEC  ECDCF003  	CALL FCM_hitbox_0006A


	// Calcul
	// Calcul:
	//  Tableau[hitbox_Joueur_1] = 0b00000001
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Porte_avion = Porte_avion + 1
	FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = 1;
0EF0  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0EF4  50E9      	MOVF FSR0L, W
0EF6  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0EF8  26E9      	ADDWF FSR0L, F
0EFA  0E01      	MOVLW 0x01
0EFC  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
0EFE  29AB      	INCF gbl_FCV_BATEAU, W, 1
0F00  6FAB      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
0F02  6B86      	CLRF gbl_FCV_X_SORTIE, 1
0F04  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
0F06  6BA9      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
0F08  6B8E      	CLRF gbl_FCV_X, 1
0F0A  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
0F0C  6B8C      	CLRF gbl_FCV_Y, 1
0F0E  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_PORTE_AVION = FCV_PORTE_AVION + 1;
0F10  29AC      	INCF gbl_FCV_PORTE_AVION, W, 1
0F12  6FAC      	MOVWF gbl_FCV_PORTE_AVION, 1


}
0F14  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_coule_CR()

{

	// Appel d'une Macro
	// Appel d'une Macro: Message_Touche()
	FCM_Message_Touche();
0D6C  ECDCF005  	CALL FCM_Messag_0005C


	// Calcul
	// Calcul:
	//  Tableau[hitbox_Joueur_1] = tableau[hitbox_Joueur_1] || 0b10000000
	//  Croiseur = Croiseur - 1
	FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] || 128;
0D70  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0D74  50E9      	MOVF FSR0L, W
0D76  0100      	MOVLB 0x00
0D78  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0D7A  26E9      	ADDWF FSR0L, F
0D7C  6BB8      	CLRF CompTempVar2774, 1
0D7E  2BB8      	INCF CompTempVar2774, F, 1
0D80  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0D82  6EE9      	MOVWF FSR0L
0D84  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0D86  26E9      	ADDWF FSR0L, F
0D88  51B8      	MOVF CompTempVar2774, W, 1
0D8A  6EEF      	MOVWF INDF0

	FCV_CROISEUR = FCV_CROISEUR - 1;
0D8C  05A4      	DECF gbl_FCV_CROISEUR, W, 1
0D8E  6FA4      	MOVWF gbl_FCV_CROISEUR, 1


}
0D90  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Phase_jeu()

{

	// Boucle
	// Boucle: While 1
	while (1)
1964            label110
1978  D7F5      	BRA	label110

	{

		// 
		// Appel d'une Macro: Choix_Bateau_Toucher()
		FCM_Choix_Bateau_Toucher();
1964  EC69F00B  	CALL FCM_Choix__00078


		// Appel d'une Macro
		// Appel d'une Macro: Toucher_Couler()
		FCM_Toucher_Couler();
1968  EC12F009  	CALL FCM_Touche_00072


		// Pause
		// Pause: 500 ms
		FCI_DELAYINT_MS(500);
196C  0EF4      	MOVLW 0xF4
196E  6FBF      	MOVWF FCI_DELAYI_00046_arg_Delay, 1
1970  0E01      	MOVLW 0x01
1972  6FC0      	MOVWF FCI_DELAYI_00046_arg_Delay+D'1', 1
1974  EC21F008  	CALL FCI_DELAYI_00046



	}

}


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_lignes()

{

	// Calcul
	// Calcul:
	//  X_ligne = 24
	//  Y_ligne = 24
	FCV_X_LIGNE = 24;
1196  0E18      	MOVLW 0x18
1198  0100      	MOVLB 0x00
119A  6F8A      	MOVWF gbl_FCV_X_LIGNE, 1
119C  6B8B      	CLRF gbl_FCV_X_LIGNE+D'1', 1

	FCV_Y_LIGNE = 24;
119E  0E18      	MOVLW 0x18
11A0  6F84      	MOVWF gbl_FCV_Y_LIGNE, 1
11A2  6B85      	CLRF gbl_FCV_Y_LIGNE+D'1', 1


	// tracé des verticales
	// Boucle: While X_ligne = 240
	while (1)
11A4            label71

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(X_ligne, 0, X_ligne, 240)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(FCV_X_LIGNE, 0, FCV_X_LIGNE, 240);
11A4  518A      	MOVF gbl_FCV_X_LIGNE, W, 1
11A6  6FB9      	MOVWF FCD_0f051__00087_arg_FCL_X1, 1
11A8  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
11AA  6FBA      	MOVWF FCD_0f051__00087_arg_FCL_X1+D'1', 1
11AC  6BBB      	CLRF FCD_0f051__00087_arg_FCL_Y1, 1
11AE  6BBC      	CLRF FCD_0f051__00087_arg_FCL_Y1+D'1', 1
11B0  518A      	MOVF gbl_FCV_X_LIGNE, W, 1
11B2  6FBD      	MOVWF FCD_0f051__00087_arg_FCL_X2, 1
11B4  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
11B6  6FBE      	MOVWF FCD_0f051__00087_arg_FCL_X2+D'1', 1
11B8  0EF0      	MOVLW 0xF0
11BA  6FBF      	MOVWF FCD_0f051__00087_arg_FCL_Y2, 1
11BC  6BC0      	CLRF FCD_0f051__00087_arg_FCL_Y2+D'1', 1
11BE  EC3CF008  	CALL FCD_0f051__00087


		// Calcul
		// Calcul:
		//  X_ligne = X_ligne + 24
		FCV_X_LIGNE = FCV_X_LIGNE + 24;
11C2  0100      	MOVLB 0x00
11C4  6BB9      	CLRF CompTempVar2727, 1
11C6  0E18      	MOVLW 0x18
11C8  278A      	ADDWF gbl_FCV_X_LIGNE, F, 1
11CA  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
11CC  23B9      	ADDWFC CompTempVar2727, F, 1
11CE  51B9      	MOVF CompTempVar2727, W, 1
11D0  6F8B      	MOVWF gbl_FCV_X_LIGNE+D'1', 1



		if ((FCV_X_LIGNE == 240) != 0) break;
11D2  6BB8      	CLRF CompTempVar2725, 1
11D4  0EF0      	MOVLW 0xF0
11D6  638A      	CPFSEQ gbl_FCV_X_LIGNE, 1
11D8  D003      	BRA	label72
11DA  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
11DC  B4D8      	BTFSC STATUS,Z
11DE  2BB8      	INCF CompTempVar2725, F, 1
11E0            label72
11E0  53B8      	MOVF CompTempVar2725, F, 1
11E2  E0E0      	BZ	label71

	}

	// tracé des horizontales
	// Boucle: While Y_ligne <= 240
	while (1)
	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, Y_ligne, 240, Y_ligne)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(0, FCV_Y_LIGNE, 240, FCV_Y_LIGNE);
11E4  6BB9      	CLRF FCD_0f051__00087_arg_FCL_X1, 1
11E6  6BBA      	CLRF FCD_0f051__00087_arg_FCL_X1+D'1', 1
11E8  5184      	MOVF gbl_FCV_Y_LIGNE, W, 1
11EA  6FBB      	MOVWF FCD_0f051__00087_arg_FCL_Y1, 1
11EC  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
11EE  6FBC      	MOVWF FCD_0f051__00087_arg_FCL_Y1+D'1', 1
11F0  0EF0      	MOVLW 0xF0
11F2  6FBD      	MOVWF FCD_0f051__00087_arg_FCL_X2, 1
11F4  6BBE      	CLRF FCD_0f051__00087_arg_FCL_X2+D'1', 1
11F6  5184      	MOVF gbl_FCV_Y_LIGNE, W, 1
11F8  6FBF      	MOVWF FCD_0f051__00087_arg_FCL_Y2, 1
11FA  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
11FC  6FC0      	MOVWF FCD_0f051__00087_arg_FCL_Y2+D'1', 1
11FE  EC3CF008  	CALL FCD_0f051__00087


		// Calcul
		// Calcul:
		//  Y_ligne = Y_ligne + 24
		FCV_Y_LIGNE = FCV_Y_LIGNE + 24;
1202  0100      	MOVLB 0x00
1204  6BB9      	CLRF CompTempVar2730, 1
1206  0E18      	MOVLW 0x18
1208  2784      	ADDWF gbl_FCV_Y_LIGNE, F, 1
120A  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
120C  23B9      	ADDWFC CompTempVar2730, F, 1
120E  51B9      	MOVF CompTempVar2730, W, 1
1210  6F85      	MOVWF gbl_FCV_Y_LIGNE+D'1', 1



		if ((FCV_Y_LIGNE <= 240) == 0) break;
1212  6BB8      	CLRF CompTempVar2728, 1
1214  0EF0      	MOVLW 0xF0
1216  6584      	CPFSGT gbl_FCV_Y_LIGNE, 1
1218  6785      	TSTFSZ gbl_FCV_Y_LIGNE+D'1', 1
121A  D001      	BRA	label74
121C  2BB8      	INCF CompTempVar2728, F, 1
121E            label74
121E  53B8      	MOVF CompTempVar2728, F, 1
1220  E1E1      	BNZ	label73

	}

}
1222  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Contre_torpilleur()

{

	// Appel d'une Macro
	// Appel d'une Macro: hitbox_phase_jeu()
	FCM_hitbox_phase_jeu();
0FF2  ECDCF003  	CALL FCM_hitbox_0006A


	// Calcul
	// Calcul:
	//  Tableau[hitbox_Joueur_1] = 0b00000011
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Contre_torpilleur = Contre_torpilleur + 1
	FCV_TABLEAU[FCV_HITBOX_JOUEUR_1] = 3;
0FF6  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0FFA  50E9      	MOVF FSR0L, W
0FFC  51A3      	MOVF gbl_FCV_HITBOX_JOUEUR_1, W, 1
0FFE  26E9      	ADDWF FSR0L, F
1000  0E03      	MOVLW 0x03
1002  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
1004  29AB      	INCF gbl_FCV_BATEAU, W, 1
1006  6FAB      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
1008  6B86      	CLRF gbl_FCV_X_SORTIE, 1
100A  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
100C  6BA9      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
100E  6B8E      	CLRF gbl_FCV_X, 1
1010  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
1012  6B8C      	CLRF gbl_FCV_Y, 1
1014  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_CONTRE_TORPILLEUR = FCV_CONTRE_TORPILLEUR + 1;
1016  29AE      	INCF gbl_FCV_CONTRE_TORPILLEUR, W, 1
1018  6FAE      	MOVWF gbl_FCV_CONTRE_TORPILLEUR, 1


}
101A  0012      	RETURN




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
19E0  0E0F      	MOVLW 0x0F
19E2  6EC1      	MOVWF gbl_adcon1





	// Appel d'une Macro
	// Appel d'une Macro: Initialisation()
	FCM_Initialisation();
19E4  ECBDF00C  	CALL FCM_Initia_0006C


	// Appel d'une Macro
	// Appel d'une Macro: phase_debut()
	FCM_phase_debut();
19E8  0E99      	MOVLW 0x99
19EA  EF38F00C  	GOTO	FCM_phase__00084
19EE            label113


	// mettre attente donnes joueur 2
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);
19EE  0E02      	MOVLW 0x02
19F0  0100      	MOVLB 0x00
19F2  6FBC      	MOVWF delay_s_00000_arg_del, 1
19F4  EC33F000  	CALL delay_s_00000


	// Appel d'une Macro
	// Appel d'une Macro: Phase_jeu()
	FCM_Phase_jeu();
19F8  0E99      	MOVLW 0x99
19FA  EFB2F00C  	GOTO	FCM_Phase__00086
19FE            label114


	// Appel d'une Macro
	// Appel d'une Macro: phase_Fin()
	FCM_phase_Fin();
19FE  EC91F00C  	CALL FCM_phase__0007A


	mainendloop: goto mainendloop;
1A02            label115
1A02  D7FF      	BRA	label115

}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

}
1AB8  CFEAF001  	MOVFF FSR0H,  Int1Context
1ABC  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1AC0  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
1AC4  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
1AC8  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
1ACC  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
1AD0  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
1AD4  C001FFEA  	MOVFF Int1Context,  FSR0H
1AD8  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0C74  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0C76  0E7F      	MOVLW 0x7F
0C78  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0C7A  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0C7C  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
0C7E  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
0C80  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
0C82  9A9D      	BCF gbl_pie1,5

			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0C84  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
07B2  6AAB      	CLRF gbl_rcsta

			txsta = 0;
07B4  6AAC      	CLRF gbl_txsta

		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}
07B6  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
008C            label5
008C  0E10      	MOVLW 0x10
008E  149E      	ANDWF gbl_pir1, W
0090  6F02      	MOVWF CompTempVar2864, 1
0092  5302      	MOVF CompTempVar2864, F, 1
0094  E0FB      	BZ	label5


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0096  5100      	MOVF FC_CAL_UAR_0008C_arg_nChar, W, 1
0098  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
009A  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
009C  6901      	SETF FC_CAL_UAR_0008B_1_retVal, 1

  #endif

	MX_UINT8 delay1 = 0;
009E  6B02      	CLRF FC_CAL_UAR_0008B_1_delay1, 1

	MX_UINT8 regcheck = 0;
00A0  6B03      	CLRF FC_CAL_UAR_0008B_1_regcheck, 1

	MX_UINT8 bWaitForever = 0;
00A2  6B04      	CLRF FC_CAL_UAR_0008B_1_bWaitForever, 1

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
00A4  6B05      	CLRF FC_CAL_UAR_0008B_1_rxStatus, 1

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
00A6  6B08      	CLRF FC_CAL_UAR_0008B_1_dummy, 1

  #endif

	if (nTimeout == 255)
00A8  2900      	INCF FC_CAL_UAR_0008B_arg_nTimeout, W, 1
00AA  E102      	BNZ	label6
00B0            label6

		bWaitForever = 1;
00AC  0E01      	MOVLW 0x01
00AE  6F04      	MOVWF FC_CAL_UAR_0008B_1_bWaitForever, 1


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00B0  5305      	MOVF FC_CAL_UAR_0008B_1_rxStatus, F, 1
00B2  E124      	BNZ	label11
00FA  D7DA      	BRA	label6
00FC            label11

	{
		if (bWaitForever == 0)
00B4  5304      	MOVF FC_CAL_UAR_0008B_1_bWaitForever, F, 1
00B6  E118      	BNZ	label10

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00B8  5300      	MOVF FC_CAL_UAR_0008B_arg_nTimeout, F, 1
00BA  E103      	BNZ	label7
00C2            label7

			{
				rxStatus = UART_STATUS_TIMEOUT;
00BC  0E01      	MOVLW 0x01
00BE  6F05      	MOVWF FC_CAL_UAR_0008B_1_rxStatus, 1

			}
			else
00C0  D013      	BRA	label10

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00C2  6B06      	CLRF FC_CAL_UAR_0008B_1_delaycnt, 1
00C4  6B07      	CLRF FC_CAL_UAR_0008B_1_delaycnt+D'1', 1
00C6            label8
00C6  0E31      	MOVLW 0x31
00C8  5D06      	SUBWF FC_CAL_UAR_0008B_1_delaycnt, W, 1
00CA  E205      	BC	label9
00CC  6707      	TSTFSZ FC_CAL_UAR_0008B_1_delaycnt+D'1', 1
00CE  D003      	BRA	label9
00D0  4B06      	INFSNZ FC_CAL_UAR_0008B_1_delaycnt, F, 1
00D2  2B07      	INCF FC_CAL_UAR_0008B_1_delaycnt+D'1', F, 1
00D4  D7F8      	BRA	label8
00D6            label9

				delay1 = delay1 + 1;
00D6  2902      	INCF FC_CAL_UAR_0008B_1_delay1, W, 1
00D8  6F02      	MOVWF FC_CAL_UAR_0008B_1_delay1, 1

				if(delay1 == 100)
00DA  0E64      	MOVLW 0x64
00DC  6302      	CPFSEQ FC_CAL_UAR_0008B_1_delay1, 1
00DE  D004      	BRA	label10
00E8            label10

				{
					nTimeout = nTimeout - 1;
00E0  0500      	DECF FC_CAL_UAR_0008B_arg_nTimeout, W, 1
00E2  6F00      	MOVWF FC_CAL_UAR_0008B_arg_nTimeout, 1

					MX_CLEAR_WATCHDOG;
00E4  0004      	CLRWDT

					delay1 = 0;
00E6  6B02      	CLRF FC_CAL_UAR_0008B_1_delay1, 1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00E8  0E20      	MOVLW 0x20
00EA  149E      	ANDWF gbl_pir1, W
00EC  6F09      	MOVWF CompTempVar2861, 1
00EE  5109      	MOVF CompTempVar2861, W, 1
00F0  6F03      	MOVWF FC_CAL_UAR_0008B_1_regcheck, 1

			if (regcheck != 0)
00F2  5303      	MOVF FC_CAL_UAR_0008B_1_regcheck, F, 1
00F4  E0DD      	BZ	label6

				rxStatus = UART_STATUS_RXBYTE;
00F6  0E02      	MOVLW 0x02
00F8  6F05      	MOVWF FC_CAL_UAR_0008B_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00FC  0E02      	MOVLW 0x02
00FE  6305      	CPFSEQ FC_CAL_UAR_0008B_1_rxStatus, 1
0100  D018      	BRA	label14

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0102  0E04      	MOVLW 0x04
0104  14AB      	ANDWF gbl_rcsta, W
0106  6F09      	MOVWF CompTempVar2862, 1
0108  5109      	MOVF CompTempVar2862, W, 1
010A  6F03      	MOVWF FC_CAL_UAR_0008B_1_regcheck, 1

			if (regcheck != 0)
010C  5303      	MOVF FC_CAL_UAR_0008B_1_regcheck, F, 1
010E  E003      	BZ	label12
0116            label12

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0110  50AE      	MOVF gbl_rcreg, W
0112  6F08      	MOVWF FC_CAL_UAR_0008B_1_dummy, 1

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0114  D00E      	BRA	label14

			{
				regcheck = ts_bit(rcsta, OERR);
0116  0E02      	MOVLW 0x02
0118  14AB      	ANDWF gbl_rcsta, W
011A  6F09      	MOVWF CompTempVar2863, 1
011C  5109      	MOVF CompTempVar2863, W, 1
011E  6F03      	MOVWF FC_CAL_UAR_0008B_1_regcheck, 1

				if (regcheck != 0)
0120  5303      	MOVF FC_CAL_UAR_0008B_1_regcheck, F, 1
0122  E003      	BZ	label13
012A            label13

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0124  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0126  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0128  D004      	BRA	label14
0132            label14

				{
					retVal = 0;
012A  6B01      	CLRF FC_CAL_UAR_0008B_1_retVal, 1


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
012C  50AE      	MOVF gbl_rcreg, W
012E  1101      	IORWF FC_CAL_UAR_0008B_1_retVal, W, 1
0130  6F01      	MOVWF FC_CAL_UAR_0008B_1_retVal, 1

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0132  5101      	MOVF FC_CAL_UAR_0008B_1_retVal, W, 1
0134  6F09      	MOVWF CompTempVarRet2860, 1
0136  6B0A      	CLRF CompTempVarRet2860+D'1', 1

}
0138  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))

{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
0C86  0E07      	MOVLW 0x07
0C88  65BC      	CPFSGT FC_CAL_UAR_00089_arg_new_baud, 1
0C8A  D001      	BRA	label53
0C8E            label53

		return;

	if (new_baud == 0)
0C8E  53BC      	MOVF FC_CAL_UAR_00089_arg_new_baud, F, 1
0C90  E104      	BNZ	label54
0C9A            label54

	{
		baudrate = MX_HARD_BAUD_1200;
0C92  69BD      	SETF FC_CAL_UAR_00089_1_baudrate, 1

		baudmode = MX_HARD_SLOW_1200;
0C94  0E01      	MOVLW 0x01
0C96  6FBE      	MOVWF FC_CAL_UAR_00089_1_baudmode, 1

	}
	else if (new_baud == 1)
0C98  D02F      	BRA	label61
0C9A  05BC      	DECF FC_CAL_UAR_00089_arg_new_baud, W, 1
0C9C  E105      	BNZ	label55
0CA8            label55

	{
		baudrate = MX_HARD_BAUD_2400;
0C9E  0E7F      	MOVLW 0x7F
0CA0  6FBD      	MOVWF FC_CAL_UAR_00089_1_baudrate, 1

		baudmode = MX_HARD_SLOW_2400;
0CA2  0E01      	MOVLW 0x01
0CA4  6FBE      	MOVWF FC_CAL_UAR_00089_1_baudmode, 1

	}
	else if (new_baud == 2)
0CA6  D028      	BRA	label61
0CA8  0E02      	MOVLW 0x02
0CAA  63BC      	CPFSEQ FC_CAL_UAR_00089_arg_new_baud, 1
0CAC  D003      	BRA	label56
0CB4            label56

	{
		baudrate = MX_HARD_BAUD_4800;
0CAE  69BD      	SETF FC_CAL_UAR_00089_1_baudrate, 1

		baudmode = MX_HARD_SLOW_4800;
0CB0  6BBE      	CLRF FC_CAL_UAR_00089_1_baudmode, 1

	}
	else if (new_baud == 3)
0CB2  D022      	BRA	label61
0CB4  0E03      	MOVLW 0x03
0CB6  63BC      	CPFSEQ FC_CAL_UAR_00089_arg_new_baud, 1
0CB8  D004      	BRA	label57
0CC2            label57

	{
		baudrate = MX_HARD_BAUD_9600;
0CBA  0E7F      	MOVLW 0x7F
0CBC  6FBD      	MOVWF FC_CAL_UAR_00089_1_baudrate, 1

		baudmode = MX_HARD_SLOW_9600;
0CBE  6BBE      	CLRF FC_CAL_UAR_00089_1_baudmode, 1

	}
	else if (new_baud == 4)
0CC0  D01B      	BRA	label61
0CC2  0E04      	MOVLW 0x04
0CC4  63BC      	CPFSEQ FC_CAL_UAR_00089_arg_new_baud, 1
0CC6  D004      	BRA	label58
0CD0            label58

	{
		baudrate = MX_HARD_BAUD_19200;
0CC8  0E3F      	MOVLW 0x3F
0CCA  6FBD      	MOVWF FC_CAL_UAR_00089_1_baudrate, 1

		baudmode = MX_HARD_SLOW_19200;
0CCC  6BBE      	CLRF FC_CAL_UAR_00089_1_baudmode, 1

	}
	else if (new_baud == 5)
0CCE  D014      	BRA	label61
0CD0  0E05      	MOVLW 0x05
0CD2  63BC      	CPFSEQ FC_CAL_UAR_00089_arg_new_baud, 1
0CD4  D004      	BRA	label59
0CDE            label59

	{
		baudrate = MX_HARD_BAUD_38400;
0CD6  0E1F      	MOVLW 0x1F
0CD8  6FBD      	MOVWF FC_CAL_UAR_00089_1_baudrate, 1

		baudmode = MX_HARD_SLOW_38400;
0CDA  6BBE      	CLRF FC_CAL_UAR_00089_1_baudmode, 1

	}
	else if (new_baud == 6)
0CDC  D00D      	BRA	label61
0CDE  0E06      	MOVLW 0x06
0CE0  63BC      	CPFSEQ FC_CAL_UAR_00089_arg_new_baud, 1
0CE2  D004      	BRA	label60
0CEC            label60

	{
		baudrate = MX_HARD_BAUD_57600;
0CE4  0E14      	MOVLW 0x14
0CE6  6FBD      	MOVWF FC_CAL_UAR_00089_1_baudrate, 1

		baudmode = MX_HARD_SLOW_57600;
0CE8  6BBE      	CLRF FC_CAL_UAR_00089_1_baudmode, 1

	}
	else if (new_baud == 7)
0CEA  D006      	BRA	label61
0CEC  0E07      	MOVLW 0x07
0CEE  63BC      	CPFSEQ FC_CAL_UAR_00089_arg_new_baud, 1
0CF0  D003      	BRA	label61
0CF8            label61

	{
		baudrate = MX_HARD_BAUD_115200;
0CF2  0E0A      	MOVLW 0x0A
0CF4  6FBD      	MOVWF FC_CAL_UAR_00089_1_baudrate, 1

		baudmode = MX_HARD_SLOW_115200;
0CF6  6BBE      	CLRF FC_CAL_UAR_00089_1_baudmode, 1

	}

	UART_Uninit();
0CF8  ECD9F003  	CALL FC_CAL_UAR_0008A


	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
0CFC  05BE      	DECF FC_CAL_UAR_00089_1_baudmode, W, 1
0CFE  E102      	BNZ	label62
0D04            label62

			cr_bit(txsta, BRGH);					//Low Speed
0D00  94AC      	BCF gbl_txsta,2

	    else
0D02  D001      	BRA	label63
0D06            label63

			st_bit(txsta, BRGH);					//High Speed
0D04  84AC      	BSF gbl_txsta,2


		spbrg = baudrate;   						// set the baud rate
0D06  51BD      	MOVF FC_CAL_UAR_00089_1_baudrate, W, 1
0D08  6EAF      	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
0D0A  6AAB      	CLRF gbl_rcsta


		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
0D0C  8EAB      	BSF gbl_rcsta,7

		st_bit(txsta, TXEN);
0D0E  8AAC      	BSF gbl_txsta,5

		st_bit(rcsta, CREN);
0D10  88AB      	BSF gbl_rcsta,4


		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
0D12  9A9D      	BCF gbl_pie1,5

		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0C8C  0012      	RETURN
0D14  0012      	RETURN


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF02F00D  	GOTO	_startup

0008  EF5CF00D  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  53C1      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF5      	MOVLW 0xF5
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0FFF      	ADDLW 0xFF
0038  A4D8      	BTFSS STATUS,Z
003A  D7ED      	BRA	label2
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  2FC1      	DECFSZ delay_ms_00000_arg_del, F, 1
0058  D7DD      	BRA	label1
005A  0012      	RETURN
005C            ; } delay_ms function end

005C            delay_us_00000
005C            ; { delay_us ; function begin
005C            label3
005C  0000      	NOP
005E  0000      	NOP
0060  2FBC      	DECFSZ delay_us_00000_arg_del, F, 1
0062  D7FC      	BRA	label3
0064  0012      	RETURN
0066            ; } delay_us function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6FC1      	MOVWF delay_ms_00000_arg_del, 1
006A  EC06F000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6FC1      	MOVWF delay_ms_00000_arg_del, 1
0072  EC06F000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6FC1      	MOVWF delay_ms_00000_arg_del, 1
007A  EC06F000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6FC1      	MOVWF delay_ms_00000_arg_del, 1
0082  EC06F000  	CALL delay_ms_00000
0086  2FBC      	DECFSZ delay_s_00000_arg_del, F, 1
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end




































































1A04            _startup
1A04  0ED5      	MOVLW 0xD5
1A06  6E6A      	MOVWF gbl_14_LSR
1A08  0EC4      	MOVLW 0xC4
1A0A  6E6B      	MOVWF gbl_14_LSR+D'1'
1A0C  0EBB      	MOVLW 0xBB
1A0E  6E6C      	MOVWF gbl_14_LSR+D'2'
1A10  0EDC      	MOVLW 0xDC
1A12  6E6D      	MOVWF gbl_14_LSR+D'3'
1A14  6A6E      	CLRF gbl_15_gbl_aSig
1A16  6A6F      	CLRF gbl_15_gbl_aSig+D'1'
1A18  6A70      	CLRF gbl_15_gbl_aSig+D'2'
1A1A  6A71      	CLRF gbl_15_gbl_aSig+D'3'
1A1C  6A72      	CLRF gbl_15_gbl_bSig
1A1E  6A73      	CLRF gbl_15_gbl_bSig+D'1'
1A20  6A74      	CLRF gbl_15_gbl_bSig+D'2'
1A22  6A75      	CLRF gbl_15_gbl_bSig+D'3'
1A24  6A76      	CLRF gbl_15_gbl_zSig
1A26  6A77      	CLRF gbl_15_gbl_zSig+D'1'
1A28  6A78      	CLRF gbl_15_gbl_zSig+D'2'
1A2A  6A79      	CLRF gbl_15_gbl_zSig+D'3'
1A2C  0100      	MOVLB 0x00
1A2E  6B9D      	CLRF gbl_15_gbl_aExp, 1
1A30  6B9E      	CLRF gbl_15_gbl_bExp, 1
1A32  6A7E      	CLRF gbl_15_gbl_zExp
1A34  6A7F      	CLRF gbl_15_gbl_zExp+D'1'
1A36  6B9F      	CLRF gbl_15_gbl_aSign, 1
1A38  6BA0      	CLRF gbl_15_gbl_bSign, 1
1A3A  6BA1      	CLRF gbl_15_gbl_zSign, 1
1A3C  6BA2      	CLRF gbl_15_gbl_zSigZero, 1
1A3E  6A7A      	CLRF gbl_15_gbl_ret
1A40  6A7B      	CLRF gbl_15_gbl_ret+D'1'
1A42  6A7C      	CLRF gbl_15_gbl_ret+D'2'
1A44  6A7D      	CLRF gbl_15_gbl_ret+D'3'
1A46  6B9B      	CLRF gbl_float_rounding_mode, 1
1A48  6B9C      	CLRF gbl_float_exception_flags, 1
1A4A  6B9A      	CLRF gbl_float_detect_tininess, 1





















1AB4  EFF0F00C  	GOTO	main

300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  79FF      	DW 0x79FF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
