;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
0384  51B9      	MOVF FC_CAL_Por_00042_arg_Tris+D'1', W, 1
0386  6EEA      	MOVWF FSR0H
0388  51B8      	MOVF FC_CAL_Por_00042_arg_Tris, W, 1
038A  6EE9      	MOVWF FSR0L
038C  51BA      	MOVF FC_CAL_Por_00042_arg_InMask, W, 1
038E  10EF      	IORWF INDF0, W
0390  6FBC      	MOVWF CompTempVar1825, 1
0392  51BC      	MOVF CompTempVar1825, W, 1
0394  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
0396  51B7      	MOVF FC_CAL_Por_00042_arg_Port+D'1', W, 1
0398  6EEA      	MOVWF FSR0H
039A  51B6      	MOVF FC_CAL_Por_00042_arg_Port, W, 1
039C  6EE9      	MOVWF FSR0L
039E  51BA      	MOVF FC_CAL_Por_00042_arg_InMask, W, 1
03A0  14EF      	ANDWF INDF0, W
03A2  6FBC      	MOVWF CompTempVarRet1822, 1
03A4  51BB      	MOVF FC_CAL_Por_00042_arg_Shift, W, 1
03A6  6FBD      	MOVWF CompTempVar1827, 1
03A8            label29
03A8  B4D8      	BTFSC STATUS,Z
03AC  90D8      	BCF STATUS,C
03AE  33BC      	RRCF CompTempVarRet1822, F, 1
03B0  07BD      	DECF CompTempVar1827, F, 1
03B2  D7FA      	BRA	label29

		}
03AA  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
03F0  6BF7      	CLRF FCI_GETLEN_0004B_1_tmp, 1
03F2            label30
03F2  51F6      	MOVF FCI_GETLEN_0004B_arg_iStr1_len, W, 1
03F4  61F7      	CPFSLT FCI_GETLEN_0004B_1_tmp, 1
03F6  D009      	BRA	label31
03F8  51F5      	MOVF FCI_GETLEN_0004B_arg_sStr1+D'1', W, 1
03FA  6EEA      	MOVWF FSR0H
03FC  51F4      	MOVF FCI_GETLEN_0004B_arg_sStr1, W, 1
03FE  25F7      	ADDWF FCI_GETLEN_0004B_1_tmp, W, 1
0400  6EE9      	MOVWF FSR0L
0402  52EF      	MOVF INDF0, F
0404  E002      	BZ	label31
0406  2BF7      	INCF FCI_GETLEN_0004B_1_tmp, F, 1
0408  D7F4      	BRA	label30
040A            label31

	return (tmp);
040A  51F7      	MOVF FCI_GETLEN_0004B_1_tmp, W, 1
040C  6FF8      	MOVWF CompTempVarRet1850, 1

}
040E  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	if (iDst_len == 0) return sDst;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (sDst);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BatailleNavale\Stockage_bateau_tableau_v2.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Tuesday, March 07, 2017 17:25:15
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x79
#endif
#ifdef HI_TECH_C
__CONFIG(0x79);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_TABLEAU 101
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT16 FCV_Y_LIGNE = (0x18);
120E  0E18      	MOVLW 0x18
1210  6F84      	MOVWF gbl_FCV_Y_LIGNE, 1
1212  6B85      	CLRF gbl_FCV_Y_LIGNE+D'1', 1

MX_GLOBAL MX_UINT8 FCV_NUM_CASE = (0x0);
1214  6BA3      	CLRF gbl_FCV_NUM_CASE, 1

MX_GLOBAL MX_UINT16 FCV_X_SORTIE = (0x0);
1216  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1218  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

MX_GLOBAL MX_UINT16 FCV_Y_TOUCH = (0x0);
121A  6B88      	CLRF gbl_FCV_Y_TOUCH, 1
121C  6B89      	CLRF gbl_FCV_Y_TOUCH+D'1', 1

MX_GLOBAL MX_UINT8 FCV_HITBOX = (0x1);
121E  0E01      	MOVLW 0x01
1220  6FA4      	MOVWF gbl_FCV_HITBOX, 1

MX_GLOBAL MX_UINT16 FCV_X_LIGNE = (0x18);
1222  0E18      	MOVLW 0x18
1224  6F8A      	MOVWF gbl_FCV_X_LIGNE, 1
1226  6B8B      	CLRF gbl_FCV_X_LIGNE+D'1', 1

MX_GLOBAL MX_UINT16 FCV_Y = (0x18);
1228  0E18      	MOVLW 0x18
122A  6F8C      	MOVWF gbl_FCV_Y, 1
122C  6B8D      	CLRF gbl_FCV_Y+D'1', 1

MX_GLOBAL MX_UINT16 FCV_X = (0x18);
122E  0E18      	MOVLW 0x18
1230  6F8E      	MOVWF gbl_FCV_X, 1
1232  6B8F      	CLRF gbl_FCV_X+D'1', 1

MX_GLOBAL MX_UINT16 FCV_X_TOUCH = (0x0);
1234  6B90      	CLRF gbl_FCV_X_TOUCH, 1
1236  6B91      	CLRF gbl_FCV_X_TOUCH+D'1', 1

MX_GLOBAL MX_UINT8 FCV_APPUI_ECRAN = (0x0);
1238  6BA5      	CLRF gbl_FCV_APPUI_ECRAN, 1

MX_GLOBAL MX_UINT8 FCV_HITBOX_2 = (0x0);
123A  6BA6      	CLRF gbl_FCV_HITBOX_2, 1

MX_GLOBAL MX_UINT8 FCV_BATEAU = (0x0);
123C  6BA7      	CLRF gbl_FCV_BATEAU, 1

MX_GLOBAL MX_UINT8 FCV_JOUEUR1 = (0x0);
123E  6BA8      	CLRF gbl_FCV_JOUEUR1, 1

MX_GLOBAL MX_CHAR FCV_TABLEAU[FCVsz_TABLEAU];

void FCM_X_144();
void FCM_Hitbox_v2();
void FCM_Lecture_Coordonnes();
void FCM_X_72();
void FCM_X_168();
void FCM_Initialisation();
void FCM_Message_bateau();
void FCM_Reinitialisation_tactile();
void FCM_X_96();
void FCM_Hitbox();
void FCM_X_24();
void FCM_X_240();
void FCM_affichage_bateau();
void FCM_X_48();
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2, MX_UINT8 FCL_ROUGE, MX_UINT8 FCL_VERT, MX_UINT8 FCL_BLEU);
void FCM_Reinitialisation_texte();
void FCM_Appui_tactile();
void FCM_Recuperation_coordonees();
void FCM_X_192();
void FCM_X_120();
void FCM_affichage_bateau_touche();
void FCM_X_216();
void FCM_phase_jeu();
void FCM_lignes();

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 porta
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 porta
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisa
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisa
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (2)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
1240  0E00      	MOVLW 0x00
1242  6FA9      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000, 1

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
1244  0E01      	MOVLW 0x01
1246  6FAA      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001, 1

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
1248  0E02      	MOVLW 0x02
124A  6FAB      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002, 1

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
124C  0E03      	MOVLW 0x03
124E  6FAC      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003, 1

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
1250  0E04      	MOVLW 0x04
1252  6FAD      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004, 1

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
1254  0E05      	MOVLW 0x05
1256  6FAE      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005, 1

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
1258  0E06      	MOVLW 0x06
125A  6FAF      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006, 1

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
125C  0E07      	MOVLW 0x07
125E  6FB0      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007, 1

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
1260  6B80      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009, 1
1262  6B81      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1', 1
1264  6B82      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2', 1
1266  6B83      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3', 1

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
1268  6BB1      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B, 1


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x63);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)

{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;
0912  6BB4      	CLRF FCD_0f051__00060_1_FCR_RETVAL, 1
0914  6BB5      	CLRF FCD_0f051__00060_1_FCR_RETVAL+D'1', 1


	if (FCL_AXIS == 0)
0916  53B3      	MOVF FCD_0f051__00060_arg_FCL_AXIS, F, 1
0918  E007      	BZ	label46

	{

	} else {

		if (FCL_AXIS == 'x')
091A  0E78      	MOVLW 0x78
091C  63B3      	CPFSEQ FCD_0f051__00060_arg_FCL_AXIS, 1
091E  D001      	BRA	label45
0922            label45

		{

		} else {
0920  D003      	BRA	label46


			if (FCL_AXIS == 'X')
0922  0E58      	MOVLW 0x58
0924  63B3      	CPFSEQ FCD_0f051__00060_arg_FCL_AXIS, 1
0926  D004      	BRA	label47
0928            label46

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;
0928  5198      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W, 1
092A  6FB4      	MOVWF FCD_0f051__00060_1_FCR_RETVAL, 1
092C  5199      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', W, 1
092E  6FB5      	MOVWF FCD_0f051__00060_1_FCR_RETVAL+D'1', 1


FCC_G4D_ReadTouchCoordinatesPicaso_A:
0930            label47

;

	if (FCL_AXIS == 1)
0930  05B3      	DECF FCD_0f051__00060_arg_FCL_AXIS, W, 1
0932  E007      	BZ	label49

	{

	} else {

		if (FCL_AXIS == 'y')
0934  0E79      	MOVLW 0x79
0936  63B3      	CPFSEQ FCD_0f051__00060_arg_FCL_AXIS, 1
0938  D001      	BRA	label48
093C            label48

		{

		} else {
093A  D003      	BRA	label49


			if (FCL_AXIS == 'Y')
093C  0E59      	MOVLW 0x59
093E  63B3      	CPFSEQ FCD_0f051__00060_arg_FCL_AXIS, 1
0940  D004      	BRA	label50
0942            label49

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;
0942  5196      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W, 1
0944  6FB4      	MOVWF FCD_0f051__00060_1_FCR_RETVAL, 1
0946  5197      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', W, 1
0948  6FB5      	MOVWF FCD_0f051__00060_1_FCR_RETVAL+D'1', 1


FCC_G4D_ReadTouchCoordinatesPicaso_B:
094A            label50

;

	return (FCR_RETVAL);
094A  51B4      	MOVF FCD_0f051__00060_1_FCR_RETVAL, W, 1
094C  6FB6      	MOVWF CompTempVarRet2656, 1
094E  51B5      	MOVF FCD_0f051__00060_1_FCR_RETVAL+D'1', W, 1
0950  6FB7      	MOVWF CompTempVarRet2656+D'1', 1


}
0952  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x6F);
05E0  0E6F      	MOVLW 0x6F
05E2  0100      	MOVLB 0x00
05E4  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
05E6  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
05E8  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(4);
05EC  0E04      	MOVLW 0x04
05EE  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
05F0  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
05F2  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
05F6  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
05F8  EC4EF000  	CALL FC_CAL_UAR_00079


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
05FC  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
05FE  EC4EF000  	CALL FC_CAL_UAR_00079
0602  51FD      	MOVF CompTempVarRet2795, W, 1
0604  6FB4      	MOVWF FCD_0f051__00072_1_FCR_RETVAL, 1


	FC_CAL_UART_Receive_1(255);
0606  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
0608  EC4EF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Receive_1(255);
060C  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
060E  EC4EF000  	CALL FC_CAL_UAR_00079


	if (FCR_RETVAL)
0612  53B4      	MOVF FCD_0f051__00072_1_FCR_RETVAL, F, 1
0614  E032      	BZ	label36
067A            label36

	{

		FC_CAL_UART_Send_1(0x6F);
0616  0E6F      	MOVLW 0x6F
0618  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
061A  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
061C  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(5);
0620  0E05      	MOVLW 0x05
0622  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0624  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0626  EC46F000  	CALL FC_CAL_UAR_0007A


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_1(255);
062A  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
062C  EC4EF000  	CALL FC_CAL_UAR_00079
0630  51FD      	MOVF CompTempVarRet2795, W, 1
0632  6F98      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F, 1
0634  51FE      	MOVF CompTempVarRet2795+D'1', W, 1
0636  6F99      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', 1


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
0638  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
063A  EC4EF000  	CALL FC_CAL_UAR_00079
063E  51FD      	MOVF CompTempVarRet2795, W, 1
0640  6FB3      	MOVWF FCD_0f051__00072_1_FCL_TEMP, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
0642  6BB5      	CLRF CompTempVar2753, 1
0644  5198      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W, 1
0646  6F99      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', 1
0648  51B5      	MOVF CompTempVar2753, W, 1
064A  6F98      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F, 1

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;
064C  51B3      	MOVF FCD_0f051__00072_1_FCL_TEMP, W, 1
064E  1398      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000F, F, 1
0650  5399      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', F, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_1(255);
0652  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
0654  EC4EF000  	CALL FC_CAL_UAR_00079
0658  51FD      	MOVF CompTempVarRet2795, W, 1
065A  6F96      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E, 1
065C  51FE      	MOVF CompTempVarRet2795+D'1', W, 1
065E  6F97      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', 1


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
0660  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
0662  EC4EF000  	CALL FC_CAL_UAR_00079
0666  51FD      	MOVF CompTempVarRet2795, W, 1
0668  6FB3      	MOVWF FCD_0f051__00072_1_FCL_TEMP, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
066A  6BB5      	CLRF CompTempVar2757, 1
066C  5196      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W, 1
066E  6F97      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', 1
0670  51B5      	MOVF CompTempVar2757, W, 1
0672  6F96      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E, 1

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;
0674  51B3      	MOVF FCD_0f051__00072_1_FCL_TEMP, W, 1
0676  1396      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000E, F, 1
0678  5397      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', F, 1


	// } else {

	}

	return (FCR_RETVAL);
067A  51B4      	MOVF FCD_0f051__00072_1_FCR_RETVAL, W, 1
067C  6FB5      	MOVWF CompTempVarRet2752, 1


}
067E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_1(FCL_RADIUS);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
0410  6BBB      	CLRF FCD_0f051__00075_1_FCL_D1, 1
0412  6BBC      	CLRF FCD_0f051__00075_1_FCL_D1+D'1', 1

	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
0414  0E01      	MOVLW 0x01
0416  6FBD      	MOVWF FCD_0f051__00075_1_FCL_YINC, 1
0418  6BBE      	CLRF FCD_0f051__00075_1_FCL_YINC+D'1', 1

	MX_SINT16 FCL_XINC = (1);
041A  0E01      	MOVLW 0x01
041C  6FBF      	MOVWF FCD_0f051__00075_1_FCL_XINC, 1
041E  6BC0      	CLRF FCD_0f051__00075_1_FCL_XINC+D'1', 1



	FC_CAL_UART_Send_1(0x4C);
0420  0E4C      	MOVLW 0x4C
0422  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0424  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0426  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
042A  51B4      	MOVF FCD_0f051__00075_arg_FCL_X1+D'1', W, 1
042C  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
042E  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0430  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X1);
0434  51B3      	MOVF FCD_0f051__00075_arg_FCL_X1, W, 1
0436  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0438  51B4      	MOVF FCD_0f051__00075_arg_FCL_X1+D'1', W, 1
043A  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
043C  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0440  51B6      	MOVF FCD_0f051__00075_arg_FCL_Y1+D'1', W, 1
0442  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0444  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0446  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y1);
044A  51B5      	MOVF FCD_0f051__00075_arg_FCL_Y1, W, 1
044C  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
044E  51B6      	MOVF FCD_0f051__00075_arg_FCL_Y1+D'1', W, 1
0450  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0452  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
0456  51B8      	MOVF FCD_0f051__00075_arg_FCL_X2+D'1', W, 1
0458  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
045A  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
045C  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X2);
0460  51B7      	MOVF FCD_0f051__00075_arg_FCL_X2, W, 1
0462  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0464  51B8      	MOVF FCD_0f051__00075_arg_FCL_X2+D'1', W, 1
0466  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0468  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
046C  51BA      	MOVF FCD_0f051__00075_arg_FCL_Y2+D'1', W, 1
046E  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0470  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0472  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y2);
0476  51B9      	MOVF FCD_0f051__00075_arg_FCL_Y2, W, 1
0478  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
047A  51BA      	MOVF FCD_0f051__00075_arg_FCL_Y2+D'1', W, 1
047C  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
047E  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
0482  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0484  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0486  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0488  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
048C  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
048E  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0490  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0492  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0494  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
0498  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
049A  EC4EF000  	CALL FC_CAL_UAR_00079


}
049E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_POSH >> 8);

	FC_CAL_UART_Send_1(FCL_POSH);

	FC_CAL_UART_Send_1(FCL_POSL >> 8);

	FC_CAL_UART_Send_1(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
06E2  0E59      	MOVLW 0x59
06E4  0100      	MOVLB 0x00
06E6  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
06E8  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
06EA  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(0x05);
06EE  0E05      	MOVLW 0x05
06F0  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
06F2  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
06F4  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(0x01);
06F8  0E01      	MOVLW 0x01
06FA  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
06FC  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
06FE  EC46F000  	CALL FC_CAL_UAR_0007A


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0702  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
0704  EC4EF000  	CALL FC_CAL_UAR_00079
0708  51FD      	MOVF CompTempVarRet2795, W, 1
070A  6FB3      	MOVWF FCD_0f051__00068_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
070C  0E06      	MOVLW 0x06
070E  63B3      	CPFSEQ FCD_0f051__00068_1_FCR_RETVAL, 1
0710  D002      	BRA	label39
0716            label39

	{

		FCR_RETVAL = 0;
0712  6BB3      	CLRF FCD_0f051__00068_1_FCR_RETVAL, 1


	} else {
0714  D001      	BRA	label40
0718            label40


		FCR_RETVAL = 255;
0716  69B3      	SETF FCD_0f051__00068_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
0718  51B3      	MOVF FCD_0f051__00068_1_FCR_RETVAL, W, 1
071A  6FB4      	MOVWF CompTempVarRet2716, 1


}
071C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x00);

	FC_CAL_UART_Send_1(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x01);

	FC_CAL_UART_Send_1(FCL_DISPLAY);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x02);

	FC_CAL_UART_Send_1(FCL_CONTRAST);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
0680  0E59      	MOVLW 0x59
0682  0100      	MOVLB 0x00
0684  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0686  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0688  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(0x05);
068C  0E05      	MOVLW 0x05
068E  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0690  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0692  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(0x00);
0696  6BF4      	CLRF FC_CAL_UAR_0007A_arg_nChar, 1
0698  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
069A  EC46F000  	CALL FC_CAL_UAR_0007A


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
069E  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
06A0  EC4EF000  	CALL FC_CAL_UAR_00079
06A4  51FD      	MOVF CompTempVarRet2795, W, 1
06A6  6FB3      	MOVWF FCD_0f051__00069_1_FCR_RETVAL, 1


	FC_CAL_UART_Send_1(0x59);
06A8  0E59      	MOVLW 0x59
06AA  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
06AC  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
06AE  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(0x05);
06B2  0E05      	MOVLW 0x05
06B4  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
06B6  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
06B8  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(0x02);
06BC  0E02      	MOVLW 0x02
06BE  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
06C0  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
06C2  EC46F000  	CALL FC_CAL_UAR_0007A


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
06C6  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
06C8  EC4EF000  	CALL FC_CAL_UAR_00079
06CC  51FD      	MOVF CompTempVarRet2795, W, 1
06CE  6FB3      	MOVWF FCD_0f051__00069_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
06D0  0E06      	MOVLW 0x06
06D2  63B3      	CPFSEQ FCD_0f051__00069_1_FCR_RETVAL, 1
06D4  D002      	BRA	label37
06DA            label37

	{

		FCR_RETVAL = 0;
06D6  6BB3      	CLRF FCD_0f051__00069_1_FCR_RETVAL, 1


	} else {
06D8  D001      	BRA	label38
06DC            label38


		FCR_RETVAL = 255;
06DA  69B3      	SETF FCD_0f051__00069_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
06DC  51B3      	MOVF FCD_0f051__00069_1_FCR_RETVAL, W, 1
06DE  6FB4      	MOVWF CompTempVarRet2717, 1


}
06E0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x56);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_1(0x10);

	} else {

		FC_CAL_UART_Send_1(0x08);

	}

	FC_CAL_UART_Send_1(FCL_DELAY);

	FC_CAL_UART_Send_1(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_1(FCL_FRAMES);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x76);

	FC_CAL_UART_Send_1(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_1(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_1(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_1(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_1(0x03);

		}
	}

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x65);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RX >> 8);

	FC_CAL_UART_Send_1(FCL_RX);

	FC_CAL_UART_Send_1(FCL_RY >> 8);

	FC_CAL_UART_Send_1(FCL_RY);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);
0954  6BF3      	CLRF FCD_0f051__0005D_1_FCL_IDX, 1



	FC_CAL_UART_Send_1(0x4F);
0956  0E4F      	MOVLW 0x4F
0958  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
095A  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
095C  EC46F000  	CALL FC_CAL_UAR_0007A


	if (FCL_TRANSPARENT)
0960  53F1      	MOVF FCD_0f051__0005D_arg_FCL_T_0005E, F, 1
0962  E005      	BZ	label51
096E            label51

	{

		FC_CAL_UART_Send_1(0x00);
0964  6BF4      	CLRF FC_CAL_UAR_0007A_arg_nChar, 1
0966  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0968  EC46F000  	CALL FC_CAL_UAR_0007A


	} else {
096C  D005      	BRA	label52
0978            label52


		FC_CAL_UART_Send_1(0x01);
096E  0E01      	MOVLW 0x01
0970  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0972  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0974  EC46F000  	CALL FC_CAL_UAR_0007A


	}

	FC_CAL_UART_Receive_1(255);
0978  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
097A  EC4EF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Send_1(0x53);
097E  0E53      	MOVLW 0x53
0980  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0982  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0984  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0988  51ED      	MOVF FCD_0f051__0005D_arg_FCL_X1+D'1', W, 1
098A  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
098C  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
098E  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X1);
0992  51EC      	MOVF FCD_0f051__0005D_arg_FCL_X1, W, 1
0994  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0996  51ED      	MOVF FCD_0f051__0005D_arg_FCL_X1+D'1', W, 1
0998  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
099A  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
099E  51EF      	MOVF FCD_0f051__0005D_arg_FCL_Y1+D'1', W, 1
09A0  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
09A2  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
09A4  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y1);
09A8  51EE      	MOVF FCD_0f051__0005D_arg_FCL_Y1, W, 1
09AA  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
09AC  51EF      	MOVF FCD_0f051__0005D_arg_FCL_Y1+D'1', W, 1
09AE  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
09B0  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_FONT);
09B4  51F0      	MOVF FCD_0f051__0005D_arg_FCL_FONT, W, 1
09B6  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
09B8  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
09BA  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
09BE  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
09C0  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
09C2  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
09C4  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
09C8  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
09CA  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
09CC  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
09CE  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
09D0  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(1);
09D4  0E01      	MOVLW 0x01
09D6  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
09D8  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
09DA  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(1);
09DE  0E01      	MOVLW 0x01
09E0  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
09E2  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
09E4  EC46F000  	CALL FC_CAL_UAR_0007A


	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);
09E8  51B3      	MOVF FCD_0f051__0005D_arg_FCL_STR, W, 1
09EA  6FF4      	MOVWF FCI_GETLEN_0004B_arg_sStr1, 1
09EC  51B4      	MOVF FCD_0f051__0005D_arg_FCL_STR+D'1', W, 1
09EE  6FF5      	MOVWF FCI_GETLEN_0004B_arg_sStr1+D'1', 1
09F0  51EA      	MOVF FCD_0f051__0005D_arg_FCLsz_STR, W, 1
09F2  6FF6      	MOVWF FCI_GETLEN_0004B_arg_iStr1_len, 1
09F4  ECF8F001  	CALL FCI_GETLEN_0004B
09F8  51F8      	MOVF CompTempVarRet1850, W, 1
09FA  6FF2      	MOVWF FCD_0f051__0005D_1_FCL_LEN_STR, 1


	while (FCL_IDX < FCL_LEN_STR)
09FC            label53
09FC  51F2      	MOVF FCD_0f051__0005D_1_FCL_LEN_STR, W, 1
09FE  61F3      	CPFSLT FCD_0f051__0005D_1_FCL_IDX, 1
0A00  D014      	BRA	label54
0A28  D7E9      	BRA	label53
0A2A            label54

	{

		if (FCL_STR[FCL_IDX] == 0)
0A02  51B4      	MOVF FCD_0f051__0005D_arg_FCL_STR+D'1', W, 1
0A04  6EEA      	MOVWF FSR0H
0A06  51B3      	MOVF FCD_0f051__0005D_arg_FCL_STR, W, 1
0A08  25F3      	ADDWF FCD_0f051__0005D_1_FCL_IDX, W, 1
0A0A  6EE9      	MOVWF FSR0L
0A0C  52EF      	MOVF INDF0, F
0A0E  E00D      	BZ	label54

		{

			goto FCC_Print_A;


		// } else {

		}

		FC_CAL_UART_Send_1(FCL_STR[FCL_IDX]);
0A10  51B4      	MOVF FCD_0f051__0005D_arg_FCL_STR+D'1', W, 1
0A12  6EEA      	MOVWF FSR0H
0A14  51B3      	MOVF FCD_0f051__0005D_arg_FCL_STR, W, 1
0A16  25F3      	ADDWF FCD_0f051__0005D_1_FCL_IDX, W, 1
0A18  6EE9      	MOVWF FSR0L
0A1A  50EF      	MOVF INDF0, W
0A1C  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0A1E  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0A20  EC46F000  	CALL FC_CAL_UAR_0007A


		FCL_IDX = FCL_IDX + 1;
0A24  29F3      	INCF FCD_0f051__0005D_1_FCL_IDX, W, 1
0A26  6FF3      	MOVWF FCD_0f051__0005D_1_FCL_IDX, 1



	}

FCC_Print_A:
;

	FC_CAL_UART_Send_1(0);
0A2A  6BF4      	CLRF FC_CAL_UAR_0007A_arg_nChar, 1
0A2C  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0A2E  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
0A32  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
0A34  EC4EF000  	CALL FC_CAL_UAR_00079


}
0A38  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x0c);

	FC_CAL_UART_Send_1(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
04A0  0100      	MOVLB 0x00
04A2  6BB6      	CLRF FCD_0f051__00063_1_FCL_Y, 1
04A4  6BB7      	CLRF FCD_0f051__00063_1_FCL_Y+D'1', 1

	MX_UINT16 FCL_X = (0x0);
04A6  6BB8      	CLRF FCD_0f051__00063_1_FCL_X, 1
04A8  6BB9      	CLRF FCD_0f051__00063_1_FCL_X+D'1', 1



	FC_CAL_UART_Send_1(0x42);
04AA  0E42      	MOVLW 0x42
04AC  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
04AE  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
04B0  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
04B4  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
04B6  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
04B8  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
04BA  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
04BE  5192      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W, 1
04C0  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
04C2  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
04C4  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
04C6  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
04CA  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
04CC  EC4EF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Send_1(0x45);
04D0  0E45      	MOVLW 0x45
04D2  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
04D4  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
04D6  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
04DA  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
04DC  EC4EF000  	CALL FC_CAL_UAR_00079


}
04E0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x49);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)

{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
0286  33BE      	RRCF FCD_0f051__0006B_arg_FCL_RED, F, 1
0288  33BE      	RRCF FCD_0f051__0006B_arg_FCL_RED, F, 1
028A  33BE      	RRCF FCD_0f051__0006B_arg_FCL_RED, F, 1
028C  0E1F      	MOVLW 0x1F
028E  17BE      	ANDWF FCD_0f051__0006B_arg_FCL_RED, F, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
0290  33BF      	RRCF FCD_0f051__0006B_arg_FCL_GREEN, F, 1
0292  33BF      	RRCF FCD_0f051__0006B_arg_FCL_GREEN, F, 1
0294  0E3F      	MOVLW 0x3F
0296  17BF      	ANDWF FCD_0f051__0006B_arg_FCL_GREEN, F, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0298  33C0      	RRCF FCD_0f051__0006B_arg_FCL_BLUE, F, 1
029A  33C0      	RRCF FCD_0f051__0006B_arg_FCL_BLUE, F, 1
029C  33C0      	RRCF FCD_0f051__0006B_arg_FCL_BLUE, F, 1
029E  0E1F      	MOVLW 0x1F
02A0  17C0      	ANDWF FCD_0f051__0006B_arg_FCL_BLUE, F, 1


	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
02A2  51BF      	MOVF FCD_0f051__0006B_arg_FCL_GREEN, W, 1
02A4  6FC1      	MOVWF CompTempVar2721, 1
02A6  6B95      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', 1
02A8  37C1      	RLCF CompTempVar2721, F, 1
02AA  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
02AC  37C1      	RLCF CompTempVar2721, F, 1
02AE  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
02B0  37C1      	RLCF CompTempVar2721, F, 1
02B2  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
02B4  37C1      	RLCF CompTempVar2721, F, 1
02B6  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
02B8  37C1      	RLCF CompTempVar2721, F, 1
02BA  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
02BC  0EE0      	MOVLW 0xE0
02BE  17C1      	ANDWF CompTempVar2721, F, 1
02C0  51C1      	MOVF CompTempVar2721, W, 1
02C2  11C0      	IORWF FCD_0f051__0006B_arg_FCL_BLUE, W, 1
02C4  6F94      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
02C6  6BC1      	CLRF CompTempVar2725, 1
02C8  51BE      	MOVF FCD_0f051__0006B_arg_FCL_RED, W, 1
02CA  6FC2      	MOVWF CompTempVar2726, 1
02CC  90D8      	BCF STATUS,C
02CE  37C2      	RLCF CompTempVar2726, F, 1
02D0  90D8      	BCF STATUS,C
02D2  37C2      	RLCF CompTempVar2726, F, 1
02D4  90D8      	BCF STATUS,C
02D6  37C2      	RLCF CompTempVar2726, F, 1
02D8  51C1      	MOVF CompTempVar2725, W, 1
02DA  1394      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F, 1
02DC  51C2      	MOVF CompTempVar2726, W, 1
02DE  1395      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1


}
02E0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x75);
071E  0E75      	MOVLW 0x75
0720  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0722  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0724  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0728  51B4      	MOVF FCD_0f051__00064_arg_FCL_X1+D'1', W, 1
072A  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
072C  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
072E  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X1);
0732  51B3      	MOVF FCD_0f051__00064_arg_FCL_X1, W, 1
0734  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0736  51B4      	MOVF FCD_0f051__00064_arg_FCL_X1+D'1', W, 1
0738  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
073A  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
073E  51B6      	MOVF FCD_0f051__00064_arg_FCL_Y1+D'1', W, 1
0740  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0742  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0744  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y1);
0748  51B5      	MOVF FCD_0f051__00064_arg_FCL_Y1, W, 1
074A  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
074C  51B6      	MOVF FCD_0f051__00064_arg_FCL_Y1+D'1', W, 1
074E  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0750  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
0754  51B8      	MOVF FCD_0f051__00064_arg_FCL_X2+D'1', W, 1
0756  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0758  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
075A  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X2);
075E  51B7      	MOVF FCD_0f051__00064_arg_FCL_X2, W, 1
0760  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0762  51B8      	MOVF FCD_0f051__00064_arg_FCL_X2+D'1', W, 1
0764  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0766  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
076A  51BA      	MOVF FCD_0f051__00064_arg_FCL_Y2+D'1', W, 1
076C  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
076E  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0770  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y2);
0774  51B9      	MOVF FCD_0f051__00064_arg_FCL_Y2, W, 1
0776  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0778  51BA      	MOVF FCD_0f051__00064_arg_FCL_Y2+D'1', W, 1
077A  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
077C  EC46F000  	CALL FC_CAL_UAR_0007A


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0780  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
0782  EC4EF000  	CALL FC_CAL_UAR_00079
0786  51FD      	MOVF CompTempVarRet2795, W, 1
0788  6FBB      	MOVWF FCD_0f051__00064_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
078A  0E06      	MOVLW 0x06
078C  63BB      	CPFSEQ FCD_0f051__00064_1_FCR_RETVAL, 1
078E  D002      	BRA	label41
0794            label41

	{

		FCR_RETVAL = 0;
0790  6BBB      	CLRF FCD_0f051__00064_1_FCR_RETVAL, 1


	} else {
0792  D001      	BRA	label42
0796            label42


		FCR_RETVAL = 255;
0794  69BB      	SETF FCD_0f051__00064_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
0796  51BB      	MOVF FCD_0f051__00064_1_FCR_RETVAL, W, 1
0798  6FBC      	MOVWF CompTempVarRet2697, 1


}
079A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6C);

	FC_CAL_UART_Send_1(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)

{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
0140  53C6      	MOVF FCD_0f051__0006C_arg_FCL_T_0006D, F, 1
0142  E14D      	BNZ	label15
0144  53C7      	MOVF FCD_0f051__0006C_arg_FCL_SOLID, F, 1
0146  E14B      	BNZ	label15
01DE            label15

	{

		FC_CAL_UART_Send_1(0x70);
0148  0E70      	MOVLW 0x70
014A  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
014C  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
014E  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(0x00);
0152  6BF4      	CLRF FC_CAL_UAR_0007A_arg_nChar, 1
0154  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0156  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Receive_1(255);
015A  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
015C  EC4EF000  	CALL FC_CAL_UAR_00079


		FC_CAL_UART_Send_1(0x72);
0160  0E72      	MOVLW 0x72
0162  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0164  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0166  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(FCL_X1 >> 8);
016A  51BF      	MOVF FCD_0f051__0006C_arg_FCL_X1+D'1', W, 1
016C  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
016E  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0170  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(FCL_X1);
0174  51BE      	MOVF FCD_0f051__0006C_arg_FCL_X1, W, 1
0176  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0178  51BF      	MOVF FCD_0f051__0006C_arg_FCL_X1+D'1', W, 1
017A  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
017C  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0180  51C1      	MOVF FCD_0f051__0006C_arg_FCL_Y1+D'1', W, 1
0182  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0184  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0186  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(FCL_Y1);
018A  51C0      	MOVF FCD_0f051__0006C_arg_FCL_Y1, W, 1
018C  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
018E  51C1      	MOVF FCD_0f051__0006C_arg_FCL_Y1+D'1', W, 1
0190  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0192  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(FCL_X2 >> 8);
0196  51C3      	MOVF FCD_0f051__0006C_arg_FCL_X2+D'1', W, 1
0198  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
019A  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
019C  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(FCL_X2);
01A0  51C2      	MOVF FCD_0f051__0006C_arg_FCL_X2, W, 1
01A2  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
01A4  51C3      	MOVF FCD_0f051__0006C_arg_FCL_X2+D'1', W, 1
01A6  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
01A8  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(FCL_Y2 >> 8);
01AC  51C5      	MOVF FCD_0f051__0006C_arg_FCL_Y2+D'1', W, 1
01AE  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
01B0  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
01B2  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(FCL_Y2);
01B6  51C4      	MOVF FCD_0f051__0006C_arg_FCL_Y2, W, 1
01B8  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
01BA  51C5      	MOVF FCD_0f051__0006C_arg_FCL_Y2+D'1', W, 1
01BC  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
01BE  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
01C2  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
01C4  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
01C6  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
01C8  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
01CC  5192      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W, 1
01CE  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
01D0  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
01D2  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
01D4  EC46F000  	CALL FC_CAL_UAR_0007A


		FC_CAL_UART_Receive_1(255);
01D8  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
01DA  EC4EF000  	CALL FC_CAL_UAR_00079


	// } else {

	}

	FC_CAL_UART_Send_1(0x70);
01DE  0E70      	MOVLW 0x70
01E0  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
01E2  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
01E4  EC46F000  	CALL FC_CAL_UAR_0007A


	if (FCL_SOLID)
01E8  53C7      	MOVF FCD_0f051__0006C_arg_FCL_SOLID, F, 1
01EA  E005      	BZ	label16
01F6            label16

	{

		FC_CAL_UART_Send_1(0x00);
01EC  6BF4      	CLRF FC_CAL_UAR_0007A_arg_nChar, 1
01EE  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
01F0  EC46F000  	CALL FC_CAL_UAR_0007A


	} else {
01F4  D005      	BRA	label17
0200            label17


		FC_CAL_UART_Send_1(0x01);
01F6  0E01      	MOVLW 0x01
01F8  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
01FA  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
01FC  EC46F000  	CALL FC_CAL_UAR_0007A


	}

	FC_CAL_UART_Receive_1(255);
0200  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
0202  EC4EF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Send_1(0x72);
0206  0E72      	MOVLW 0x72
0208  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
020A  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
020C  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0210  51BF      	MOVF FCD_0f051__0006C_arg_FCL_X1+D'1', W, 1
0212  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0214  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0216  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X1);
021A  51BE      	MOVF FCD_0f051__0006C_arg_FCL_X1, W, 1
021C  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
021E  51BF      	MOVF FCD_0f051__0006C_arg_FCL_X1+D'1', W, 1
0220  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0222  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0226  51C1      	MOVF FCD_0f051__0006C_arg_FCL_Y1+D'1', W, 1
0228  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
022A  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
022C  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y1);
0230  51C0      	MOVF FCD_0f051__0006C_arg_FCL_Y1, W, 1
0232  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0234  51C1      	MOVF FCD_0f051__0006C_arg_FCL_Y1+D'1', W, 1
0236  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0238  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
023C  51C3      	MOVF FCD_0f051__0006C_arg_FCL_X2+D'1', W, 1
023E  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0240  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0242  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_X2);
0246  51C2      	MOVF FCD_0f051__0006C_arg_FCL_X2, W, 1
0248  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
024A  51C3      	MOVF FCD_0f051__0006C_arg_FCL_X2+D'1', W, 1
024C  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
024E  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
0252  51C5      	MOVF FCD_0f051__0006C_arg_FCL_Y2+D'1', W, 1
0254  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0256  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0258  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCL_Y2);
025C  51C4      	MOVF FCD_0f051__0006C_arg_FCL_Y2, W, 1
025E  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0260  51C5      	MOVF FCD_0f051__0006C_arg_FCL_Y2+D'1', W, 1
0262  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0264  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
0268  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
026A  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
026C  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
026E  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0272  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
0274  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0276  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0278  6FF5      	MOVWF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
027A  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
027E  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
0280  EC4EF000  	CALL FC_CAL_UAR_00079


}
0284  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, C, 0x20, 0x5, 0);
079C  0100      	MOVLB 0x00
079E  6BB6      	CLRF FCD_0f051__00062_2_ptmp, 1
07A0  9A94      	BCF gbl_trisc,5
07A2  53B6      	MOVF FCD_0f051__00062_2_ptmp, F, 1
07A4  E004      	BZ	label43
07A6  0E20      	MOVLW 0x20
07A8  108B      	IORWF gbl_latc, W
07AA  6E82      	MOVWF gbl_portc
07AC  D003      	BRA	label44
07AE            label43
07AE  0EDF      	MOVLW 0xDF
07B0  148B      	ANDWF gbl_latc, W
07B2  6E82      	MOVWF gbl_portc
07B4            label44


	FC_CAL_UART_Init_1();
07B4  EC71F001  	CALL FC_CAL_UAR_0007B


	FCI_DELAYBYTE_US(100);
07B8  0E64      	MOVLW 0x64
07BA  6FB6      	MOVWF delay_us_00000_arg_del, 1
07BC  EC2EF000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, C, 0x20, 0x5);
07C0  0E0F      	MOVLW HIGH(gbl_portc+D'0')
07C2  6FB7      	MOVWF FC_CAL_Por_00042_arg_Port+D'1', 1
07C4  0E82      	MOVLW LOW(gbl_portc+D'0')
07C6  6FB6      	MOVWF FC_CAL_Por_00042_arg_Port, 1
07C8  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
07CA  6FB9      	MOVWF FC_CAL_Por_00042_arg_Tris+D'1', 1
07CC  0E94      	MOVLW LOW(gbl_trisc+D'0')
07CE  6FB8      	MOVWF FC_CAL_Por_00042_arg_Tris, 1
07D0  0E20      	MOVLW 0x20
07D2  6FBA      	MOVWF FC_CAL_Por_00042_arg_InMask, 1
07D4  0E05      	MOVLW 0x05
07D6  6FBB      	MOVWF FC_CAL_Por_00042_arg_Shift, 1
07D8  ECC2F001  	CALL FC_CAL_Por_00042
07DC  51BC      	MOVF CompTempVarRet1822, W, 1
07DE  6FB5      	MOVWF FCD_0f051__00062_1_FCL_DUMMY, 1


	FCI_DELAYBYTE_S(3);
07E0  0E03      	MOVLW 0x03
07E2  6FB6      	MOVWF delay_s_00000_arg_del, 1
07E4  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_1(0);
07E8  6BF4      	CLRF FC_CAL_UAR_00079_arg_nTimeout, 1
07EA  EC4EF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Receive_1(0);
07EE  6BF4      	CLRF FC_CAL_UAR_00079_arg_nTimeout, 1
07F0  EC4EF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Receive_1(0);
07F4  6BF4      	CLRF FC_CAL_UAR_00079_arg_nTimeout, 1
07F6  EC4EF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Send_1(0x55);
07FA  0E55      	MOVLW 0x55
07FC  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
07FE  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0800  EC46F000  	CALL FC_CAL_UAR_0007A


	FC_CAL_UART_Receive_1(255);
0804  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
0806  EC4EF000  	CALL FC_CAL_UAR_00079


	#if (1) // 1 == 1

		#if (1) // 1 != 0

			FC_CAL_UART_Send_1(0x51);
080A  0E51      	MOVLW 0x51
080C  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
080E  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
0810  EC46F000  	CALL FC_CAL_UAR_0007A


			FC_CAL_UART_Send_1(0x0C);
0814  0E0C      	MOVLW 0x0C
0816  6FF4      	MOVWF FC_CAL_UAR_0007A_arg_nChar, 1
0818  6BF5      	CLRF FC_CAL_UAR_0007A_arg_nChar+D'1', 1
081A  EC46F000  	CALL FC_CAL_UAR_0007A


			FC_CAL_UART_Receive_1(255);
081E  69F4      	SETF FC_CAL_UAR_00079_arg_nTimeout, 1
0820  EC4EF000  	CALL FC_CAL_UAR_00079


			FC_CAL_UART_UpdateBaud_1(6);
0824  0E06      	MOVLW 0x06
0826  6FB6      	MOVWF FC_CAL_UAR_00077_arg_new_baud, 1
0828  EC7AF001  	CALL FC_CAL_UAR_00077



		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_1(10);
082C  0E0A      	MOVLW 0x0A
082E  6FF4      	MOVWF FC_CAL_UAR_00079_arg_nTimeout, 1
0830  EC4EF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Receive_1(10);
0834  0E0A      	MOVLW 0x0A
0836  6FF4      	MOVWF FC_CAL_UAR_00079_arg_nTimeout, 1
0838  EC4EF000  	CALL FC_CAL_UAR_00079


	FCL_RED = 0 & 0xFF;
083C  6BB2      	CLRF FCD_0f051__00062_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
083E  33B2      	RRCF FCD_0f051__00062_1_FCL_RED, F, 1
0840  33B2      	RRCF FCD_0f051__00062_1_FCL_RED, F, 1
0842  33B2      	RRCF FCD_0f051__00062_1_FCL_RED, F, 1
0844  0E1F      	MOVLW 0x1F
0846  17B2      	ANDWF FCD_0f051__00062_1_FCL_RED, F, 1

	FCL_GREEN = (0 >> 8) & 0xFF;
0848  6BB3      	CLRF FCD_0f051__00062_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
084A  33B3      	RRCF FCD_0f051__00062_1_FCL_GREEN, F, 1
084C  33B3      	RRCF FCD_0f051__00062_1_FCL_GREEN, F, 1
084E  0E3F      	MOVLW 0x3F
0850  17B3      	ANDWF FCD_0f051__00062_1_FCL_GREEN, F, 1

	FCL_BLUE = (0 >> 16) & 0xFF;
0852  6BB4      	CLRF FCD_0f051__00062_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0854  33B4      	RRCF FCD_0f051__00062_1_FCL_BLUE, F, 1
0856  33B4      	RRCF FCD_0f051__00062_1_FCL_BLUE, F, 1
0858  33B4      	RRCF FCD_0f051__00062_1_FCL_BLUE, F, 1
085A  0E1F      	MOVLW 0x1F
085C  17B4      	ANDWF FCD_0f051__00062_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
085E  51B3      	MOVF FCD_0f051__00062_1_FCL_GREEN, W, 1
0860  6FB6      	MOVWF CompTempVar2670, 1
0862  6B95      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', 1
0864  37B6      	RLCF CompTempVar2670, F, 1
0866  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0868  37B6      	RLCF CompTempVar2670, F, 1
086A  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
086C  37B6      	RLCF CompTempVar2670, F, 1
086E  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0870  37B6      	RLCF CompTempVar2670, F, 1
0872  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0874  37B6      	RLCF CompTempVar2670, F, 1
0876  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0878  0EE0      	MOVLW 0xE0
087A  17B6      	ANDWF CompTempVar2670, F, 1
087C  51B6      	MOVF CompTempVar2670, W, 1
087E  11B4      	IORWF FCD_0f051__00062_1_FCL_BLUE, W, 1
0880  6F94      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
0882  6BB6      	CLRF CompTempVar2674, 1
0884  51B2      	MOVF FCD_0f051__00062_1_FCL_RED, W, 1
0886  6FB7      	MOVWF CompTempVar2675, 1
0888  90D8      	BCF STATUS,C
088A  37B7      	RLCF CompTempVar2675, F, 1
088C  90D8      	BCF STATUS,C
088E  37B7      	RLCF CompTempVar2675, F, 1
0890  90D8      	BCF STATUS,C
0892  37B7      	RLCF CompTempVar2675, F, 1
0894  51B6      	MOVF CompTempVar2674, W, 1
0896  1394      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F, 1
0898  51B7      	MOVF CompTempVar2675, W, 1
089A  1395      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1

	FCL_RED = 16777215 & 0xFF;
089C  69B2      	SETF FCD_0f051__00062_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
089E  33B2      	RRCF FCD_0f051__00062_1_FCL_RED, F, 1
08A0  33B2      	RRCF FCD_0f051__00062_1_FCL_RED, F, 1
08A2  33B2      	RRCF FCD_0f051__00062_1_FCL_RED, F, 1
08A4  0E1F      	MOVLW 0x1F
08A6  17B2      	ANDWF FCD_0f051__00062_1_FCL_RED, F, 1

	FCL_GREEN = (16777215 >> 8) & 0xFF;
08A8  69B3      	SETF FCD_0f051__00062_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
08AA  33B3      	RRCF FCD_0f051__00062_1_FCL_GREEN, F, 1
08AC  33B3      	RRCF FCD_0f051__00062_1_FCL_GREEN, F, 1
08AE  0E3F      	MOVLW 0x3F
08B0  17B3      	ANDWF FCD_0f051__00062_1_FCL_GREEN, F, 1

	FCL_BLUE = (16777215 >> 16) & 0xFF;
08B2  69B4      	SETF FCD_0f051__00062_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
08B4  33B4      	RRCF FCD_0f051__00062_1_FCL_BLUE, F, 1
08B6  33B4      	RRCF FCD_0f051__00062_1_FCL_BLUE, F, 1
08B8  33B4      	RRCF FCD_0f051__00062_1_FCL_BLUE, F, 1
08BA  0E1F      	MOVLW 0x1F
08BC  17B4      	ANDWF FCD_0f051__00062_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
08BE  51B3      	MOVF FCD_0f051__00062_1_FCL_GREEN, W, 1
08C0  6FB6      	MOVWF CompTempVar2681, 1
08C2  6B93      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', 1
08C4  37B6      	RLCF CompTempVar2681, F, 1
08C6  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
08C8  37B6      	RLCF CompTempVar2681, F, 1
08CA  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
08CC  37B6      	RLCF CompTempVar2681, F, 1
08CE  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
08D0  37B6      	RLCF CompTempVar2681, F, 1
08D2  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
08D4  37B6      	RLCF CompTempVar2681, F, 1
08D6  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
08D8  0EE0      	MOVLW 0xE0
08DA  17B6      	ANDWF CompTempVar2681, F, 1
08DC  51B6      	MOVF CompTempVar2681, W, 1
08DE  11B4      	IORWF FCD_0f051__00062_1_FCL_BLUE, W, 1
08E0  6F92      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
08E2  6BB6      	CLRF CompTempVar2685, 1
08E4  51B2      	MOVF FCD_0f051__00062_1_FCL_RED, W, 1
08E6  6FB7      	MOVWF CompTempVar2686, 1
08E8  90D8      	BCF STATUS,C
08EA  37B7      	RLCF CompTempVar2686, F, 1
08EC  90D8      	BCF STATUS,C
08EE  37B7      	RLCF CompTempVar2686, F, 1
08F0  90D8      	BCF STATUS,C
08F2  37B7      	RLCF CompTempVar2686, F, 1
08F4  51B6      	MOVF CompTempVar2685, W, 1
08F6  1392      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F, 1
08F8  51B7      	MOVF CompTempVar2686, W, 1
08FA  1393      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
08FC  EC50F002  	CALL FCD_0f051__00063


	FC_CAL_UART_Receive_1(10);
0900  0E0A      	MOVLW 0x0A
0902  6FF4      	MOVWF FC_CAL_UAR_00079_arg_nTimeout, 1
0904  EC4EF000  	CALL FC_CAL_UAR_00079


	FC_CAL_UART_Receive_1(10);
0908  0E0A      	MOVLW 0x0A
090A  6FF4      	MOVWF FC_CAL_UAR_00079_arg_nTimeout, 1
090C  EC4EF000  	CALL FC_CAL_UAR_00079


}
0910  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_144()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 6
		FCV_HITBOX = 6;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 16
			FCV_HITBOX = 16;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 26
				FCV_HITBOX = 26;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 36
					FCV_HITBOX = 36;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 46
						FCV_HITBOX = 46;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 56
							FCV_HITBOX = 56;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 66
								FCV_HITBOX = 66;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 76
									FCV_HITBOX = 76;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 86
										FCV_HITBOX = 86;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 96
											FCV_HITBOX = 96;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Hitbox_v2()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
101A  0E01      	MOVLW 0x01
101C  0100      	MOVLB 0x00
101E  6FA4      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
1020  0E18      	MOVLW 0x18
1022  6F8C      	MOVWF gbl_FCV_Y, 1
1024  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
1026  0E18      	MOVLW 0x18
1028  6F8E      	MOVWF gbl_FCV_X, 1
102A  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
102C            label76
102C  0E01      	MOVLW 0x01
102E  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
1030  E23A      	BC	label84
1032  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
1034  D038      	BRA	label84
10A4  D7C3      	BRA	label76
10A6            label84

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
1036  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1038  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
103A  E102      	BNZ	label77
103C  518C      	MOVF gbl_FCV_Y, W, 1
103E  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
1040            label77
1040  E227      	BC	label83
1042            label78
1090            label83

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
1042  518F      	MOVF gbl_FCV_X+D'1', W, 1
1044  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1046  E102      	BNZ	label79
1048  518E      	MOVF gbl_FCV_X, W, 1
104A  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
104C            label79
104C  E309      	BNC	label80

				{

				} else {
1060            label80


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
104E  29A4      	INCF gbl_FCV_HITBOX, W, 1
1050  6FA4      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
1052  6BB4      	CLRF CompTempVar2635, 1
1054  0E18      	MOVLW 0x18
1056  278E      	ADDWF gbl_FCV_X, F, 1
1058  518F      	MOVF gbl_FCV_X+D'1', W, 1
105A  23B4      	ADDWFC CompTempVar2635, F, 1
105C  51B4      	MOVF CompTempVar2635, W, 1
105E  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
1060  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
1062  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
1064  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
1066  B4D8      	BTFSC STATUS,Z
1068  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
106A  6BB3      	CLRF CompTempVar2633, 1
106C  518F      	MOVF gbl_FCV_X+D'1', W, 1
106E  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1070  E104      	BNZ	label81
1072  518E      	MOVF gbl_FCV_X, W, 1
1074  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
1076  D001      	BRA	label81
1078  D001      	BRA	label82
107A            label81
107A  A0D8      	BTFSS STATUS,C
107C  71B3      	BTG CompTempVar2633,0, 1
107E  53B3      	MOVF CompTempVar2633, F, 1
1080  E0E0      	BZ	label78

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
1082  ECB6F002  	CALL FCM_affich_0005C


			// Calcul
			// Calcul:
			//  X = 0
			//  Y = 0
			FCV_X = 0;
1086  6B8E      	CLRF gbl_FCV_X, 1
1088  6B8F      	CLRF gbl_FCV_X+D'1', 1

			FCV_Y = 0;
108A  6B8C      	CLRF gbl_FCV_Y, 1
108C  6B8D      	CLRF gbl_FCV_Y+D'1', 1


		} else {
108E  D7CE      	BRA	label76


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
1090  0E0A      	MOVLW 0x0A
1092  25A4      	ADDWF gbl_FCV_HITBOX, W, 1
1094  6FA4      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
1096  6BB3      	CLRF CompTempVar2639, 1
1098  0E18      	MOVLW 0x18
109A  278C      	ADDWF gbl_FCV_Y, F, 1
109C  518D      	MOVF gbl_FCV_Y+D'1', W, 1
109E  23B3      	ADDWFC CompTempVar2639, F, 1
10A0  51B3      	MOVF CompTempVar2639, W, 1
10A2  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000001
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	FCV_TABLEAU[FCV_HITBOX] = 1;
10A6  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
10AA  50E9      	MOVF FSR0L, W
10AC  51A4      	MOVF gbl_FCV_HITBOX, W, 1
10AE  26E9      	ADDWF FSR0L, F
10B0  0E01      	MOVLW 0x01
10B2  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
10B4  29A7      	INCF gbl_FCV_BATEAU, W, 1
10B6  6FA7      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
10B8  6B86      	CLRF gbl_FCV_X_SORTIE, 1
10BA  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print(tableau, 50, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print(FCV_TABLEAU, FCVsz_TABLEAU, 50, 241, 2, 1);
10BC  0E00      	MOVLW HIGH(gbl_FCV_TABLEAU+D'0')
10BE  6FB4      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
10C0  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
10C2  6FB3      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
10C4  0E65      	MOVLW 0x65
10C6  6FEA      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
10C8  6BEB      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
10CA  0E32      	MOVLW 0x32
10CC  6FEC      	MOVWF FCD_0f051__0005D_arg_FCL_X1, 1
10CE  6BED      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
10D0  0EF1      	MOVLW 0xF1
10D2  6FEE      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
10D4  6BEF      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
10D6  0E02      	MOVLW 0x02
10D8  6FF0      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
10DA  0E01      	MOVLW 0x01
10DC  6FF1      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
10DE  ECAAF004  	CALL FCD_0f051__0005D


}
10E2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Lecture_Coordonnes()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: X_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);
0F92  0100      	MOVLB 0x00
0F94  6BB3      	CLRF FCD_0f051__00060_arg_FCL_AXIS, 1
0F96  EC89F004  	CALL FCD_0f051__00060
0F9A  51B6      	MOVF CompTempVarRet2656, W, 1
0F9C  6F90      	MOVWF gbl_FCV_X_TOUCH, 1
0F9E  51B7      	MOVF CompTempVarRet2656+D'1', W, 1
0FA0  6F91      	MOVWF gbl_FCV_X_TOUCH+D'1', 1


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);
0FA2  0E01      	MOVLW 0x01
0FA4  6FB3      	MOVWF FCD_0f051__00060_arg_FCL_AXIS, 1
0FA6  EC89F004  	CALL FCD_0f051__00060
0FAA  51B6      	MOVF CompTempVarRet2656, W, 1
0FAC  6F88      	MOVWF gbl_FCV_Y_TOUCH, 1
0FAE  51B7      	MOVF CompTempVarRet2656+D'1', W, 1
0FB0  6F89      	MOVWF gbl_FCV_Y_TOUCH+D'1', 1


}
0FB2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_72()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 3
		FCV_HITBOX = 3;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 13
			FCV_HITBOX = 13;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 23
				FCV_HITBOX = 23;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 33
					FCV_HITBOX = 33;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// Calcul
						// Calcul:
						//  hitbox = 43
						FCV_HITBOX = 43;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 53
							FCV_HITBOX = 53;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 63
								FCV_HITBOX = 63;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 73
									FCV_HITBOX = 73;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 83
										FCV_HITBOX = 83;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 93
											FCV_HITBOX = 93;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_168()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 7
		FCV_HITBOX = 7;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 17
			FCV_HITBOX = 17;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 27
				FCV_HITBOX = 27;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 37
					FCV_HITBOX = 37;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 47
						FCV_HITBOX = 47;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 57
							FCV_HITBOX = 57;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 67
								FCV_HITBOX = 67;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 77
									FCV_HITBOX = 77;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 87
										FCV_HITBOX = 87;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 97
											FCV_HITBOX = 97;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Initialisation()

{

	// Calcul
	// Calcul:

	// Boucle
	// Boucle: While hitbox = 101
	while (1)
0FB4            label74

	{

		// Calcul
		// Calcul:
		//  tableau[hitbox] = 0b00000000
		//  hitbox = hitbox + 1
		FCV_TABLEAU[FCV_HITBOX] = 0;
0FB4  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0FB8  50E9      	MOVF FSR0L, W
0FBA  0100      	MOVLB 0x00
0FBC  51A4      	MOVF gbl_FCV_HITBOX, W, 1
0FBE  26E9      	ADDWF FSR0L, F
0FC0  0E00      	MOVLW 0x00
0FC2  6EEF      	MOVWF INDF0

		FCV_HITBOX = FCV_HITBOX + 1;
0FC4  29A4      	INCF gbl_FCV_HITBOX, W, 1
0FC6  6FA4      	MOVWF gbl_FCV_HITBOX, 1



		if ((FCV_HITBOX == 101) != 0) break;
0FC8  6BB2      	CLRF CompTempVar2657, 1
0FCA  0E65      	MOVLW 0x65
0FCC  63A4      	CPFSEQ gbl_FCV_HITBOX, 1
0FCE  D001      	BRA	label75
0FD0  2BB2      	INCF CompTempVar2657, F, 1
0FD2            label75
0FD2  53B2      	MOVF CompTempVar2657, F, 1
0FD4  E0EF      	BZ	label74

	}

	// Calcul
	// Calcul:
	//  tableau[Joueur1] = tableau[hitbox]
	FCV_TABLEAU[FCV_JOUEUR1] = FCV_TABLEAU[FCV_HITBOX];
0FD6  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0FDA  50E9      	MOVF FSR0L, W
0FDC  51A4      	MOVF gbl_FCV_HITBOX, W, 1
0FDE  6FB2      	MOVWF CompTempVar2661, 1
0FE0  51B2      	MOVF CompTempVar2661, W, 1
0FE2  26E9      	ADDWF FSR0L, F
0FE4  50EF      	MOVF INDF0, W
0FE6  6FB3      	MOVWF CompTempVar2662, 1
0FE8  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0FEA  6EE9      	MOVWF FSR0L
0FEC  51A8      	MOVF gbl_FCV_JOUEUR1, W, 1
0FEE  26E9      	ADDWF FSR0L, F
0FF0  51B3      	MOVF CompTempVar2662, W, 1
0FF2  6EEF      	MOVWF INDF0


	#if 0 // Disabled code
	// Calcul
	// Calcul:
	//  tableau[23] = 0b00000001
	//  tableau[24] = 0b00000001
	//  tableau[25] = 0b00000001
	FCV_TABLEAU[23] = 1;
	FCV_TABLEAU[24] = 1;
	FCV_TABLEAU[25] = 1;

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
0FF4  ECCEF003  	CALL FCD_0f051__00062


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
0FF8  EC50F002  	CALL FCD_0f051__00063


	// Appel d'une Macro
	// Appel d'une Macro: lignes()
	FCM_lignes();
0FFC  EC71F002  	CALL FCM_lignes_00000


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_SetTouchRegionPicaso(0, 0, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(0, 0, 240, 240);
1000  6BB3      	CLRF FCD_0f051__00064_arg_FCL_X1, 1
1002  6BB4      	CLRF FCD_0f051__00064_arg_FCL_X1+D'1', 1
1004  6BB5      	CLRF FCD_0f051__00064_arg_FCL_Y1, 1
1006  6BB6      	CLRF FCD_0f051__00064_arg_FCL_Y1+D'1', 1
1008  0EF0      	MOVLW 0xF0
100A  6FB7      	MOVWF FCD_0f051__00064_arg_FCL_X2, 1
100C  6BB8      	CLRF FCD_0f051__00064_arg_FCL_X2+D'1', 1
100E  0EF0      	MOVLW 0xF0
1010  6FB9      	MOVWF FCD_0f051__00064_arg_FCL_Y2, 1
1012  6BBA      	CLRF FCD_0f051__00064_arg_FCL_Y2+D'1', 1
1014  EC8FF003  	CALL FCD_0f051__00064


}
1018  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Message_bateau()

{

	// Décision
	// Décision: bateau >= 5?
	if (FCV_BATEAU >= 5)
0C46  0E05      	MOVLW 0x05
0C48  0100      	MOVLB 0x00
0C4A  61A7      	CPFSLT gbl_FCV_BATEAU, 1
0C4C  D001      	BRA	label66
0C4E  D153      	BRA	label73
0C50            label66
0EF6            label73

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_texte()
		FCM_Reinitialisation_texte();
0C50  ECD4F002  	CALL FCM_Reinit_00066


		// Décision
		// Décision: bateau >= 9?
		if (FCV_BATEAU >= 9)
0C54  0E09      	MOVLW 0x09
0C56  61A7      	CPFSLT gbl_FCV_BATEAU, 1
0C58  D001      	BRA	label67
0C5A  D105      	BRA	label72
0C5C            label67
0E66            label72

		{

			// Appel d'une Macro
			// Appel d'une Macro: Reinitialisation_texte()
			FCM_Reinitialisation_texte();
0C5C  ECD4F002  	CALL FCM_Reinit_00066


			// Décision
			// Décision: bateau >= 12?
			if (FCV_BATEAU >= 12)
0C60  0E0C      	MOVLW 0x0C
0C62  61A7      	CPFSLT gbl_FCV_BATEAU, 1
0C64  D001      	BRA	label68
0C66  D0A5      	BRA	label71
0C68            label68
0DB2            label71

			{

				// Appel d'une Macro
				// Appel d'une Macro: Reinitialisation_texte()
				FCM_Reinitialisation_texte();
0C68  ECD4F002  	CALL FCM_Reinit_00066


				// Décision
				// Décision: bateau >= 15?
				if (FCV_BATEAU >= 15)
0C6C  0E0F      	MOVLW 0x0F
0C6E  61A7      	CPFSLT gbl_FCV_BATEAU, 1
0C70  D001      	BRA	label69
0C72  D051      	BRA	label70
0C74            label69
0D16            label70

				{

					// Appel d'une Macro
					// Appel d'une Macro: Reinitialisation_texte()
					FCM_Reinitialisation_texte();
0C74  ECD4F002  	CALL FCM_Reinit_00066


					// Décision
					// Décision: bateau >= 17?
					if (FCV_BATEAU >= 17)
0C78  0E11      	MOVLW 0x11
0C7A  61A7      	CPFSLT gbl_FCV_BATEAU, 1

					{

					} else {

						// Appel de la Routine Composant
						// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le torpilleur (2 cases)", 0, 241, 2, 1)
						FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le torpilleur (2 cases)", 40, 0, 241, 2, 1);
0C7E  0E20      	MOVLW 0x20
0C80  6FBD      	MOVWF CompTempVar2706+D'8', 1
0C82  6FC4      	MOVWF CompTempVar2706+D'15', 1
0C84  6FC7      	MOVWF CompTempVar2706+D'18', 1
0C86  6FD2      	MOVWF CompTempVar2706+D'29', 1
0C88  6FD5      	MOVWF CompTempVar2706+D'32', 1
0C8A  0E28      	MOVLW 0x28
0C8C  6FD3      	MOVWF CompTempVar2706+D'30', 1
0C8E  0E29      	MOVLW 0x29
0C90  6FDB      	MOVWF CompTempVar2706+D'38', 1
0C92  0E32      	MOVLW 0x32
0C94  6FD4      	MOVWF CompTempVar2706+D'31', 1
0C96  0E56      	MOVLW 0x56
0C98  6FB5      	MOVWF CompTempVar2706, 1
0C9A  0E61      	MOVLW 0x61
0C9C  6FC0      	MOVWF CompTempVar2706+D'11', 1
0C9E  6FD7      	MOVWF CompTempVar2706+D'34', 1
0CA0  0E63      	MOVLW 0x63
0CA2  6FC1      	MOVWF CompTempVar2706+D'12', 1
0CA4  6FD6      	MOVWF CompTempVar2706+D'33', 1
0CA6  0E65      	MOVLW 0x65
0CA8  6FB6      	MOVWF CompTempVar2706+D'1', 1
0CAA  6FBB      	MOVWF CompTempVar2706+D'6', 1
0CAC  6FC2      	MOVWF CompTempVar2706+D'13', 1
0CAE  6FC6      	MOVWF CompTempVar2706+D'17', 1
0CB0  6FCF      	MOVWF CompTempVar2706+D'26', 1
0CB2  6FD9      	MOVWF CompTempVar2706+D'36', 1
0CB4  0E69      	MOVLW 0x69
0CB6  6FB8      	MOVWF CompTempVar2706+D'3', 1
0CB8  6FCC      	MOVWF CompTempVar2706+D'23', 1
0CBA  0E6C      	MOVLW 0x6C
0CBC  6FB9      	MOVWF CompTempVar2706+D'4', 1
0CBE  6FBA      	MOVWF CompTempVar2706+D'5', 1
0CC0  6FBF      	MOVWF CompTempVar2706+D'10', 1
0CC2  6FC5      	MOVWF CompTempVar2706+D'16', 1
0CC4  6FCD      	MOVWF CompTempVar2706+D'24', 1
0CC6  6FCE      	MOVWF CompTempVar2706+D'25', 1
0CC8  0E6F      	MOVLW 0x6F
0CCA  6FC9      	MOVWF CompTempVar2706+D'20', 1
0CCC  0E70      	MOVLW 0x70
0CCE  6FBE      	MOVWF CompTempVar2706+D'9', 1
0CD0  6FCB      	MOVWF CompTempVar2706+D'22', 1
0CD2  0E72      	MOVLW 0x72
0CD4  6FC3      	MOVWF CompTempVar2706+D'14', 1
0CD6  6FCA      	MOVWF CompTempVar2706+D'21', 1
0CD8  6FD1      	MOVWF CompTempVar2706+D'28', 1
0CDA  0E73      	MOVLW 0x73
0CDC  6FD8      	MOVWF CompTempVar2706+D'35', 1
0CDE  6FDA      	MOVWF CompTempVar2706+D'37', 1
0CE0  0E74      	MOVLW 0x74
0CE2  6FC8      	MOVWF CompTempVar2706+D'19', 1
0CE4  0E75      	MOVLW 0x75
0CE6  6FB7      	MOVWF CompTempVar2706+D'2', 1
0CE8  6FD0      	MOVWF CompTempVar2706+D'27', 1
0CEA  0E7A      	MOVLW 0x7A
0CEC  6FBC      	MOVWF CompTempVar2706+D'7', 1
0CEE  6BDC      	CLRF CompTempVar2706+D'39', 1
0CF0  0E00      	MOVLW HIGH(CompTempVar2706+D'0')
0CF2  6FB4      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0CF4  0EB5      	MOVLW LOW(CompTempVar2706+D'0')
0CF6  6FB3      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0CF8  0E28      	MOVLW 0x28
0CFA  6FEA      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0CFC  6BEB      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0CFE  6BEC      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0D00  6BED      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0D02  0EF1      	MOVLW 0xF1
0D04  6FEE      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0D06  6BEF      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0D08  0E02      	MOVLW 0x02
0D0A  6FF0      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0D0C  0E01      	MOVLW 0x01
0D0E  6FF1      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0D10  ECAAF004  	CALL FCD_0f051__0005D


					}

				} else {

					// Appel de la Routine Composant
					// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le sous-marin (3 cases)", 0, 241, 2, 1)
					FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le sous-marin (3 cases)", 40, 0, 241, 2, 1);
0D16  0E20      	MOVLW 0x20
0D18  6FBD      	MOVWF CompTempVar2708+D'8', 1
0D1A  6FC4      	MOVWF CompTempVar2708+D'15', 1
0D1C  6FC7      	MOVWF CompTempVar2708+D'18', 1
0D1E  6FD2      	MOVWF CompTempVar2708+D'29', 1
0D20  6FD5      	MOVWF CompTempVar2708+D'32', 1
0D22  0E28      	MOVLW 0x28
0D24  6FD3      	MOVWF CompTempVar2708+D'30', 1
0D26  0E29      	MOVLW 0x29
0D28  6FDB      	MOVWF CompTempVar2708+D'38', 1
0D2A  0E2D      	MOVLW 0x2D
0D2C  6FCC      	MOVWF CompTempVar2708+D'23', 1
0D2E  0E33      	MOVLW 0x33
0D30  6FD4      	MOVWF CompTempVar2708+D'31', 1
0D32  0E56      	MOVLW 0x56
0D34  6FB5      	MOVWF CompTempVar2708, 1
0D36  0E61      	MOVLW 0x61
0D38  6FC0      	MOVWF CompTempVar2708+D'11', 1
0D3A  6FCE      	MOVWF CompTempVar2708+D'25', 1
0D3C  6FD7      	MOVWF CompTempVar2708+D'34', 1
0D3E  0E63      	MOVLW 0x63
0D40  6FC1      	MOVWF CompTempVar2708+D'12', 1
0D42  6FD6      	MOVWF CompTempVar2708+D'33', 1
0D44  0E65      	MOVLW 0x65
0D46  6FB6      	MOVWF CompTempVar2708+D'1', 1
0D48  6FBB      	MOVWF CompTempVar2708+D'6', 1
0D4A  6FC2      	MOVWF CompTempVar2708+D'13', 1
0D4C  6FC6      	MOVWF CompTempVar2708+D'17', 1
0D4E  6FD9      	MOVWF CompTempVar2708+D'36', 1
0D50  0E69      	MOVLW 0x69
0D52  6FB8      	MOVWF CompTempVar2708+D'3', 1
0D54  6FD0      	MOVWF CompTempVar2708+D'27', 1
0D56  0E6C      	MOVLW 0x6C
0D58  6FB9      	MOVWF CompTempVar2708+D'4', 1
0D5A  6FBA      	MOVWF CompTempVar2708+D'5', 1
0D5C  6FBF      	MOVWF CompTempVar2708+D'10', 1
0D5E  6FC5      	MOVWF CompTempVar2708+D'16', 1
0D60  0E6D      	MOVLW 0x6D
0D62  6FCD      	MOVWF CompTempVar2708+D'24', 1
0D64  0E6E      	MOVLW 0x6E
0D66  6FD1      	MOVWF CompTempVar2708+D'28', 1
0D68  0E6F      	MOVLW 0x6F
0D6A  6FC9      	MOVWF CompTempVar2708+D'20', 1
0D6C  0E70      	MOVLW 0x70
0D6E  6FBE      	MOVWF CompTempVar2708+D'9', 1
0D70  0E72      	MOVLW 0x72
0D72  6FC3      	MOVWF CompTempVar2708+D'14', 1
0D74  6FCF      	MOVWF CompTempVar2708+D'26', 1
0D76  0E73      	MOVLW 0x73
0D78  6FC8      	MOVWF CompTempVar2708+D'19', 1
0D7A  6FCB      	MOVWF CompTempVar2708+D'22', 1
0D7C  6FD8      	MOVWF CompTempVar2708+D'35', 1
0D7E  6FDA      	MOVWF CompTempVar2708+D'37', 1
0D80  0E75      	MOVLW 0x75
0D82  6FB7      	MOVWF CompTempVar2708+D'2', 1
0D84  6FCA      	MOVWF CompTempVar2708+D'21', 1
0D86  0E7A      	MOVLW 0x7A
0D88  6FBC      	MOVWF CompTempVar2708+D'7', 1
0D8A  6BDC      	CLRF CompTempVar2708+D'39', 1
0D8C  0E00      	MOVLW HIGH(CompTempVar2708+D'0')
0D8E  6FB4      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0D90  0EB5      	MOVLW LOW(CompTempVar2708+D'0')
0D92  6FB3      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0D94  0E28      	MOVLW 0x28
0D96  6FEA      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0D98  6BEB      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0D9A  6BEC      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0D9C  6BED      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0D9E  0EF1      	MOVLW 0xF1
0DA0  6FEE      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0DA2  6BEF      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0DA4  0E02      	MOVLW 0x02
0DA6  6FF0      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0DA8  0E01      	MOVLW 0x01
0DAA  6FF1      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0DAC  ECAAF004  	CALL FCD_0f051__0005D


				}

			} else {

				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le contre        torpilleur(3 cases)", 0, 241, 2, 1)
				FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le contre        torpilleur(3 cases)", 53, 0, 241, 2, 1);
0DB2  0E20      	MOVLW 0x20
0DB4  6FBD      	MOVWF CompTempVar2710+D'8', 1
0DB6  6FC4      	MOVWF CompTempVar2710+D'15', 1
0DB8  6FC7      	MOVWF CompTempVar2710+D'18', 1
0DBA  6FCE      	MOVWF CompTempVar2710+D'25', 1
0DBC  6FCF      	MOVWF CompTempVar2710+D'26', 1
0DBE  6FD0      	MOVWF CompTempVar2710+D'27', 1
0DC0  6FD1      	MOVWF CompTempVar2710+D'28', 1
0DC2  6FD2      	MOVWF CompTempVar2710+D'29', 1
0DC4  6FD3      	MOVWF CompTempVar2710+D'30', 1
0DC6  6FD4      	MOVWF CompTempVar2710+D'31', 1
0DC8  6FD5      	MOVWF CompTempVar2710+D'32', 1
0DCA  6FE2      	MOVWF CompTempVar2710+D'45', 1
0DCC  0E28      	MOVLW 0x28
0DCE  6FE0      	MOVWF CompTempVar2710+D'43', 1
0DD0  0E29      	MOVLW 0x29
0DD2  6FE8      	MOVWF CompTempVar2710+D'51', 1
0DD4  0E33      	MOVLW 0x33
0DD6  6FE1      	MOVWF CompTempVar2710+D'44', 1
0DD8  0E56      	MOVLW 0x56
0DDA  6FB5      	MOVWF CompTempVar2710, 1
0DDC  0E61      	MOVLW 0x61
0DDE  6FC0      	MOVWF CompTempVar2710+D'11', 1
0DE0  6FE4      	MOVWF CompTempVar2710+D'47', 1
0DE2  0E63      	MOVLW 0x63
0DE4  6FC1      	MOVWF CompTempVar2710+D'12', 1
0DE6  6FC8      	MOVWF CompTempVar2710+D'19', 1
0DE8  6FE3      	MOVWF CompTempVar2710+D'46', 1
0DEA  0E65      	MOVLW 0x65
0DEC  6FB6      	MOVWF CompTempVar2710+D'1', 1
0DEE  6FBB      	MOVWF CompTempVar2710+D'6', 1
0DF0  6FC2      	MOVWF CompTempVar2710+D'13', 1
0DF2  6FC6      	MOVWF CompTempVar2710+D'17', 1
0DF4  6FCD      	MOVWF CompTempVar2710+D'24', 1
0DF6  6FDD      	MOVWF CompTempVar2710+D'40', 1
0DF8  6FE6      	MOVWF CompTempVar2710+D'49', 1
0DFA  0E69      	MOVLW 0x69
0DFC  6FB8      	MOVWF CompTempVar2710+D'3', 1
0DFE  6FDA      	MOVWF CompTempVar2710+D'37', 1
0E00  0E6C      	MOVLW 0x6C
0E02  6FB9      	MOVWF CompTempVar2710+D'4', 1
0E04  6FBA      	MOVWF CompTempVar2710+D'5', 1
0E06  6FBF      	MOVWF CompTempVar2710+D'10', 1
0E08  6FC5      	MOVWF CompTempVar2710+D'16', 1
0E0A  6FDB      	MOVWF CompTempVar2710+D'38', 1
0E0C  6FDC      	MOVWF CompTempVar2710+D'39', 1
0E0E  0E6E      	MOVLW 0x6E
0E10  6FCA      	MOVWF CompTempVar2710+D'21', 1
0E12  0E6F      	MOVLW 0x6F
0E14  6FC9      	MOVWF CompTempVar2710+D'20', 1
0E16  6FD7      	MOVWF CompTempVar2710+D'34', 1
0E18  0E70      	MOVLW 0x70
0E1A  6FBE      	MOVWF CompTempVar2710+D'9', 1
0E1C  6FD9      	MOVWF CompTempVar2710+D'36', 1
0E1E  0E72      	MOVLW 0x72
0E20  6FC3      	MOVWF CompTempVar2710+D'14', 1
0E22  6FCC      	MOVWF CompTempVar2710+D'23', 1
0E24  6FD8      	MOVWF CompTempVar2710+D'35', 1
0E26  6FDF      	MOVWF CompTempVar2710+D'42', 1
0E28  0E73      	MOVLW 0x73
0E2A  6FE5      	MOVWF CompTempVar2710+D'48', 1
0E2C  6FE7      	MOVWF CompTempVar2710+D'50', 1
0E2E  0E74      	MOVLW 0x74
0E30  6FCB      	MOVWF CompTempVar2710+D'22', 1
0E32  6FD6      	MOVWF CompTempVar2710+D'33', 1
0E34  0E75      	MOVLW 0x75
0E36  6FB7      	MOVWF CompTempVar2710+D'2', 1
0E38  6FDE      	MOVWF CompTempVar2710+D'41', 1
0E3A  0E7A      	MOVLW 0x7A
0E3C  6FBC      	MOVWF CompTempVar2710+D'7', 1
0E3E  6BE9      	CLRF CompTempVar2710+D'52', 1
0E40  0E00      	MOVLW HIGH(CompTempVar2710+D'0')
0E42  6FB4      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0E44  0EB5      	MOVLW LOW(CompTempVar2710+D'0')
0E46  6FB3      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0E48  0E35      	MOVLW 0x35
0E4A  6FEA      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0E4C  6BEB      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0E4E  6BEC      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0E50  6BED      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0E52  0EF1      	MOVLW 0xF1
0E54  6FEE      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0E56  6BEF      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0E58  0E02      	MOVLW 0x02
0E5A  6FF0      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0E5C  0E01      	MOVLW 0x01
0E5E  6FF1      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0E60  ECAAF004  	CALL FCD_0f051__0005D


			}

		} else {

			// Appel de la Routine Composant
			// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le croiseur(4 cases)", 0, 241, 2, 1)
			FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le croiseur(4 cases)", 37, 0, 241, 2, 1);
0E66  0E20      	MOVLW 0x20
0E68  6FBD      	MOVWF CompTempVar2712+D'8', 1
0E6A  6FC4      	MOVWF CompTempVar2712+D'15', 1
0E6C  6FC7      	MOVWF CompTempVar2712+D'18', 1
0E6E  6FD2      	MOVWF CompTempVar2712+D'29', 1
0E70  0E28      	MOVLW 0x28
0E72  6FD0      	MOVWF CompTempVar2712+D'27', 1
0E74  0E29      	MOVLW 0x29
0E76  6FD8      	MOVWF CompTempVar2712+D'35', 1
0E78  0E34      	MOVLW 0x34
0E7A  6FD1      	MOVWF CompTempVar2712+D'28', 1
0E7C  0E56      	MOVLW 0x56
0E7E  6FB5      	MOVWF CompTempVar2712, 1
0E80  0E61      	MOVLW 0x61
0E82  6FC0      	MOVWF CompTempVar2712+D'11', 1
0E84  6FD4      	MOVWF CompTempVar2712+D'31', 1
0E86  0E63      	MOVLW 0x63
0E88  6FC1      	MOVWF CompTempVar2712+D'12', 1
0E8A  6FC8      	MOVWF CompTempVar2712+D'19', 1
0E8C  6FD3      	MOVWF CompTempVar2712+D'30', 1
0E8E  0E65      	MOVLW 0x65
0E90  6FB6      	MOVWF CompTempVar2712+D'1', 1
0E92  6FBB      	MOVWF CompTempVar2712+D'6', 1
0E94  6FC2      	MOVWF CompTempVar2712+D'13', 1
0E96  6FC6      	MOVWF CompTempVar2712+D'17', 1
0E98  6FCD      	MOVWF CompTempVar2712+D'24', 1
0E9A  6FD6      	MOVWF CompTempVar2712+D'33', 1
0E9C  0E69      	MOVLW 0x69
0E9E  6FB8      	MOVWF CompTempVar2712+D'3', 1
0EA0  6FCB      	MOVWF CompTempVar2712+D'22', 1
0EA2  0E6C      	MOVLW 0x6C
0EA4  6FB9      	MOVWF CompTempVar2712+D'4', 1
0EA6  6FBA      	MOVWF CompTempVar2712+D'5', 1
0EA8  6FBF      	MOVWF CompTempVar2712+D'10', 1
0EAA  6FC5      	MOVWF CompTempVar2712+D'16', 1
0EAC  0E6F      	MOVLW 0x6F
0EAE  6FCA      	MOVWF CompTempVar2712+D'21', 1
0EB0  0E70      	MOVLW 0x70
0EB2  6FBE      	MOVWF CompTempVar2712+D'9', 1
0EB4  0E72      	MOVLW 0x72
0EB6  6FC3      	MOVWF CompTempVar2712+D'14', 1
0EB8  6FC9      	MOVWF CompTempVar2712+D'20', 1
0EBA  6FCF      	MOVWF CompTempVar2712+D'26', 1
0EBC  0E73      	MOVLW 0x73
0EBE  6FCC      	MOVWF CompTempVar2712+D'23', 1
0EC0  6FD5      	MOVWF CompTempVar2712+D'32', 1
0EC2  6FD7      	MOVWF CompTempVar2712+D'34', 1
0EC4  0E75      	MOVLW 0x75
0EC6  6FB7      	MOVWF CompTempVar2712+D'2', 1
0EC8  6FCE      	MOVWF CompTempVar2712+D'25', 1
0ECA  0E7A      	MOVLW 0x7A
0ECC  6FBC      	MOVWF CompTempVar2712+D'7', 1
0ECE  6BD9      	CLRF CompTempVar2712+D'36', 1
0ED0  0E00      	MOVLW HIGH(CompTempVar2712+D'0')
0ED2  6FB4      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0ED4  0EB5      	MOVLW LOW(CompTempVar2712+D'0')
0ED6  6FB3      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0ED8  0E25      	MOVLW 0x25
0EDA  6FEA      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0EDC  6BEB      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0EDE  6BEC      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0EE0  6BED      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0EE2  0EF1      	MOVLW 0xF1
0EE4  6FEE      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0EE6  6BEF      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0EE8  0E02      	MOVLW 0x02
0EEA  6FF0      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0EEC  0E01      	MOVLW 0x01
0EEE  6FF1      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0EF0  ECAAF004  	CALL FCD_0f051__0005D


		}

	} else {

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le porte avion(5 cases)", 0, 241, 2, 1)
		FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le porte avion(5 cases)", 40, 0, 241, 2, 1);
0EF6  0E20      	MOVLW 0x20
0EF8  6FBD      	MOVWF CompTempVar2714+D'8', 1
0EFA  6FC4      	MOVWF CompTempVar2714+D'15', 1
0EFC  6FC7      	MOVWF CompTempVar2714+D'18', 1
0EFE  6FCD      	MOVWF CompTempVar2714+D'24', 1
0F00  6FD5      	MOVWF CompTempVar2714+D'32', 1
0F02  0E28      	MOVLW 0x28
0F04  6FD3      	MOVWF CompTempVar2714+D'30', 1
0F06  0E29      	MOVLW 0x29
0F08  6FDB      	MOVWF CompTempVar2714+D'38', 1
0F0A  0E35      	MOVLW 0x35
0F0C  6FD4      	MOVWF CompTempVar2714+D'31', 1
0F0E  0E56      	MOVLW 0x56
0F10  6FB5      	MOVWF CompTempVar2714, 1
0F12  0E61      	MOVLW 0x61
0F14  6FC0      	MOVWF CompTempVar2714+D'11', 1
0F16  6FCE      	MOVWF CompTempVar2714+D'25', 1
0F18  6FD7      	MOVWF CompTempVar2714+D'34', 1
0F1A  0E63      	MOVLW 0x63
0F1C  6FC1      	MOVWF CompTempVar2714+D'12', 1
0F1E  6FD6      	MOVWF CompTempVar2714+D'33', 1
0F20  0E65      	MOVLW 0x65
0F22  6FB6      	MOVWF CompTempVar2714+D'1', 1
0F24  6FBB      	MOVWF CompTempVar2714+D'6', 1
0F26  6FC2      	MOVWF CompTempVar2714+D'13', 1
0F28  6FC6      	MOVWF CompTempVar2714+D'17', 1
0F2A  6FCC      	MOVWF CompTempVar2714+D'23', 1
0F2C  6FD9      	MOVWF CompTempVar2714+D'36', 1
0F2E  0E69      	MOVLW 0x69
0F30  6FB8      	MOVWF CompTempVar2714+D'3', 1
0F32  6FD0      	MOVWF CompTempVar2714+D'27', 1
0F34  0E6C      	MOVLW 0x6C
0F36  6FB9      	MOVWF CompTempVar2714+D'4', 1
0F38  6FBA      	MOVWF CompTempVar2714+D'5', 1
0F3A  6FBF      	MOVWF CompTempVar2714+D'10', 1
0F3C  6FC5      	MOVWF CompTempVar2714+D'16', 1
0F3E  0E6E      	MOVLW 0x6E
0F40  6FD2      	MOVWF CompTempVar2714+D'29', 1
0F42  0E6F      	MOVLW 0x6F
0F44  6FC9      	MOVWF CompTempVar2714+D'20', 1
0F46  6FD1      	MOVWF CompTempVar2714+D'28', 1
0F48  0E70      	MOVLW 0x70
0F4A  6FBE      	MOVWF CompTempVar2714+D'9', 1
0F4C  6FC8      	MOVWF CompTempVar2714+D'19', 1
0F4E  0E72      	MOVLW 0x72
0F50  6FC3      	MOVWF CompTempVar2714+D'14', 1
0F52  6FCA      	MOVWF CompTempVar2714+D'21', 1
0F54  0E73      	MOVLW 0x73
0F56  6FD8      	MOVWF CompTempVar2714+D'35', 1
0F58  6FDA      	MOVWF CompTempVar2714+D'37', 1
0F5A  0E74      	MOVLW 0x74
0F5C  6FCB      	MOVWF CompTempVar2714+D'22', 1
0F5E  0E75      	MOVLW 0x75
0F60  6FB7      	MOVWF CompTempVar2714+D'2', 1
0F62  0E76      	MOVLW 0x76
0F64  6FCF      	MOVWF CompTempVar2714+D'26', 1
0F66  0E7A      	MOVLW 0x7A
0F68  6FBC      	MOVWF CompTempVar2714+D'7', 1
0F6A  6BDC      	CLRF CompTempVar2714+D'39', 1
0F6C  0E00      	MOVLW HIGH(CompTempVar2714+D'0')
0F6E  6FB4      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0F70  0EB5      	MOVLW LOW(CompTempVar2714+D'0')
0F72  6FB3      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0F74  0E28      	MOVLW 0x28
0F76  6FEA      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0F78  6BEB      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0F7A  6BEC      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0F7C  6BED      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0F7E  0EF1      	MOVLW 0xF1
0F80  6FEE      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0F82  6BEF      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0F84  0E02      	MOVLW 0x02
0F86  6FF0      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0F88  0E01      	MOVLW 0x01
0F8A  6FF1      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0F8C  ECAAF004  	CALL FCD_0f051__0005D


	}

}
0C7C  0012      	RETURN
0D14  0012      	RETURN
0DB0  0012      	RETURN
0E64  0012      	RETURN
0EF4  0012      	RETURN
0F90  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_tactile()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_DisableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
0C1A  EC71F003  	CALL FCD_0f051__00068


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_EnableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
0C1E  EC40F003  	CALL FCD_0f051__00069


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_SetTouchRegionPicaso(0, 0, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(0, 0, 240, 240);
0C22  6BB3      	CLRF FCD_0f051__00064_arg_FCL_X1, 1
0C24  6BB4      	CLRF FCD_0f051__00064_arg_FCL_X1+D'1', 1
0C26  6BB5      	CLRF FCD_0f051__00064_arg_FCL_Y1, 1
0C28  6BB6      	CLRF FCD_0f051__00064_arg_FCL_Y1+D'1', 1
0C2A  0EF0      	MOVLW 0xF0
0C2C  6FB7      	MOVWF FCD_0f051__00064_arg_FCL_X2, 1
0C2E  6BB8      	CLRF FCD_0f051__00064_arg_FCL_X2+D'1', 1
0C30  0EF0      	MOVLW 0xF0
0C32  6FB9      	MOVWF FCD_0f051__00064_arg_FCL_Y2, 1
0C34  6BBA      	CLRF FCD_0f051__00064_arg_FCL_Y2+D'1', 1
0C36  EC8FF003  	CALL FCD_0f051__00064


}
0C3A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_96()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 4
		FCV_HITBOX = 4;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 14
			FCV_HITBOX = 14;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 24
				FCV_HITBOX = 24;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 34
					FCV_HITBOX = 34;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 44
						FCV_HITBOX = 44;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 54
							FCV_HITBOX = 54;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 64
								FCV_HITBOX = 64;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 74
									FCV_HITBOX = 74;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 84
										FCV_HITBOX = 84;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 94
											FCV_HITBOX = 94;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Hitbox()
{

	// Décision
	// Décision: X < 24?
	if (FCV_X < 24)
	{

		// Appel d'une Macro
		// Appel d'une Macro: X_24()
		FCM_X_24();

	} else {

		// Décision
		// Décision: X < 48?
		if (FCV_X < 48)
		{

			// Appel d'une Macro
			// Appel d'une Macro: X_48()
			FCM_X_48();

		} else {

			// Décision
			// Décision: X < 72?
			if (FCV_X < 72)
			{

				// Appel d'une Macro
				// Appel d'une Macro: X_72()
				FCM_X_72();

			} else {

				// Décision
				// Décision: X < 96?
				if (FCV_X < 96)
				{

					// Appel d'une Macro
					// Appel d'une Macro: X_96()
					FCM_X_96();

				} else {

					// Décision
					// Décision: X < 120?
					if (FCV_X < 120)
					{

						// Appel d'une Macro
						// Appel d'une Macro: X_120()
						FCM_X_120();

					} else {

						// Décision
						// Décision: X < 144?
						if (FCV_X < 144)
						{

							// Appel d'une Macro
							// Appel d'une Macro: X_144()
							FCM_X_144();

						} else {

							// Décision
							// Décision: X < 168?
							if (FCV_X < 168)
							{

								// Appel d'une Macro
								// Appel d'une Macro: X_168()
								FCM_X_168();

							} else {

								// Décision
								// Décision: X < 192?
								if (FCV_X < 192)
								{

									// Appel d'une Macro
									// Appel d'une Macro: X_192()
									FCM_X_192();

								} else {

									// Décision
									// Décision: X < 216?
									if (FCV_X < 216)
									{

										// Appel d'une Macro
										// Appel d'une Macro: X_216()
										FCM_X_216();

									} else {

										// Décision
										// Décision: X < 240?
										if (FCV_X < 240)
										{

											// Appel d'une Macro
											// Appel d'une Macro: X_240()
											FCM_X_240();

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_24()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 1
		FCV_HITBOX = 1;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 11
			FCV_HITBOX = 11;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 21
				FCV_HITBOX = 21;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 31
					FCV_HITBOX = 31;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 41
						FCV_HITBOX = 41;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 51
							FCV_HITBOX = 51;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 61
								FCV_HITBOX = 61;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 71
									FCV_HITBOX = 71;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 81
										FCV_HITBOX = 81;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 91
											FCV_HITBOX = 91;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_240()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 10
		FCV_HITBOX = 10;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 20
			FCV_HITBOX = 20;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 30
				FCV_HITBOX = 30;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 40
					FCV_HITBOX = 40;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 50
						FCV_HITBOX = 50;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 60
							FCV_HITBOX = 60;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 70
								FCV_HITBOX = 70;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 80
									FCV_HITBOX = 80;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 90
										FCV_HITBOX = 90;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 100
											FCV_HITBOX = 100;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_affichage_bateau()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 70, 70, 70)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 70, 70, 70);
056C  0100      	MOVLB 0x00
056E  518E      	MOVF gbl_FCV_X, W, 1
0570  6FB3      	MOVWF FCM_parame_0006A_arg_FCL_POS_X1, 1
0572  518F      	MOVF gbl_FCV_X+D'1', W, 1
0574  6FB4      	MOVWF FCM_parame_0006A_arg_FCL_POS_X1+D'1', 1
0576  0E18      	MOVLW 0x18
0578  5D8E      	SUBWF gbl_FCV_X, W, 1
057A  6FB5      	MOVWF FCM_parame_0006A_arg_FCL_POS_X2, 1
057C  598E      	SUBWFB gbl_FCV_X, W, 1
057E  0818      	SUBLW 0x18
0580  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0582  6FB6      	MOVWF FCM_parame_0006A_arg_FCL_POS_X2+D'1', 1
0584  518C      	MOVF gbl_FCV_Y, W, 1
0586  6FB7      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y1, 1
0588  518D      	MOVF gbl_FCV_Y+D'1', W, 1
058A  6FB8      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y1+D'1', 1
058C  0E18      	MOVLW 0x18
058E  5D8C      	SUBWF gbl_FCV_Y, W, 1
0590  6FB9      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y2, 1
0592  598C      	SUBWFB gbl_FCV_Y, W, 1
0594  0818      	SUBLW 0x18
0596  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0598  6FBA      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y2+D'1', 1
059A  0E46      	MOVLW 0x46
059C  6FBB      	MOVWF FCM_parame_0006A_arg_FCL_ROUGE, 1
059E  6FBC      	MOVWF FCM_parame_0006A_arg_FCL_VERT, 1
05A0  6FBD      	MOVWF FCM_parame_0006A_arg_FCL_BLEU, 1
05A2  ECDAF001  	CALL FCM_parame_0006A


}
05A6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_48()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 2
		FCV_HITBOX = 2;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 12
			FCV_HITBOX = 12;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 22
				FCV_HITBOX = 22;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 32
					FCV_HITBOX = 32;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// Calcul
						// Calcul:
						//  hitbox = 42
						FCV_HITBOX = 42;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 52
							FCV_HITBOX = 52;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 62
								FCV_HITBOX = 62;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 72
									FCV_HITBOX = 72;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 82
										FCV_HITBOX = 82;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 92
											FCV_HITBOX = 92;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro parametres_bateau :
       :  pos_x1 : MX_UINT16
       :  pos_x2 : MX_UINT16
       :  pos_y1 : MX_UINT16
       :  pos_y2 : MX_UINT16
       :  Rouge : MX_UINT8
       :  Vert : MX_UINT8
       :  Bleu : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2, MX_UINT8 FCL_ROUGE, MX_UINT8 FCL_VERT, MX_UINT8 FCL_BLEU)

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(.Rouge, .Vert, .Bleu)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(FCL_ROUGE, FCL_VERT, FCL_BLEU);
03B4  51BB      	MOVF FCM_parame_0006A_arg_FCL_ROUGE, W, 1
03B6  6FBE      	MOVWF FCD_0f051__0006B_arg_FCL_RED, 1
03B8  51BC      	MOVF FCM_parame_0006A_arg_FCL_VERT, W, 1
03BA  6FBF      	MOVWF FCD_0f051__0006B_arg_FCL_GREEN, 1
03BC  51BD      	MOVF FCM_parame_0006A_arg_FCL_BLEU, W, 1
03BE  6FC0      	MOVWF FCD_0f051__0006B_arg_FCL_BLUE, 1
03C0  EC43F001  	CALL FCD_0f051__0006B


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(.pos_x1, .pos_y1, .pos_x2, .pos_y2, 0, 1)
	FCD_0f051_gLCD_EB076_4D1__DrawRectangle(FCL_POS_X1, FCL_POS_Y1, FCL_POS_X2, FCL_POS_Y2, 0, 1);
03C4  51B3      	MOVF FCM_parame_0006A_arg_FCL_POS_X1, W, 1
03C6  6FBE      	MOVWF FCD_0f051__0006C_arg_FCL_X1, 1
03C8  51B4      	MOVF FCM_parame_0006A_arg_FCL_POS_X1+D'1', W, 1
03CA  6FBF      	MOVWF FCD_0f051__0006C_arg_FCL_X1+D'1', 1
03CC  51B7      	MOVF FCM_parame_0006A_arg_FCL_POS_Y1, W, 1
03CE  6FC0      	MOVWF FCD_0f051__0006C_arg_FCL_Y1, 1
03D0  51B8      	MOVF FCM_parame_0006A_arg_FCL_POS_Y1+D'1', W, 1
03D2  6FC1      	MOVWF FCD_0f051__0006C_arg_FCL_Y1+D'1', 1
03D4  51B5      	MOVF FCM_parame_0006A_arg_FCL_POS_X2, W, 1
03D6  6FC2      	MOVWF FCD_0f051__0006C_arg_FCL_X2, 1
03D8  51B6      	MOVF FCM_parame_0006A_arg_FCL_POS_X2+D'1', W, 1
03DA  6FC3      	MOVWF FCD_0f051__0006C_arg_FCL_X2+D'1', 1
03DC  51B9      	MOVF FCM_parame_0006A_arg_FCL_POS_Y2, W, 1
03DE  6FC4      	MOVWF FCD_0f051__0006C_arg_FCL_Y2, 1
03E0  51BA      	MOVF FCM_parame_0006A_arg_FCL_POS_Y2+D'1', W, 1
03E2  6FC5      	MOVWF FCD_0f051__0006C_arg_FCL_Y2+D'1', 1
03E4  6BC6      	CLRF FCD_0f051__0006C_arg_FCL_T_0006D, 1
03E6  0E01      	MOVLW 0x01
03E8  6FC7      	MOVWF FCD_0f051__0006C_arg_FCL_SOLID, 1
03EA  ECA0F000  	CALL FCD_0f051__0006C


}
03EE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_texte()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(255, 255, 255)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(255, 255, 255);
05A8  0100      	MOVLB 0x00
05AA  69BE      	SETF FCD_0f051__0006B_arg_FCL_RED, 1
05AC  69BF      	SETF FCD_0f051__0006B_arg_FCL_GREEN, 1
05AE  69C0      	SETF FCD_0f051__0006B_arg_FCL_BLUE, 1
05B0  EC43F001  	CALL FCD_0f051__0006B


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 241, 240, 320, 1, 1)
	FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 241, 240, 320, 1, 1);
05B4  6BBE      	CLRF FCD_0f051__0006C_arg_FCL_X1, 1
05B6  6BBF      	CLRF FCD_0f051__0006C_arg_FCL_X1+D'1', 1
05B8  0EF1      	MOVLW 0xF1
05BA  6FC0      	MOVWF FCD_0f051__0006C_arg_FCL_Y1, 1
05BC  6BC1      	CLRF FCD_0f051__0006C_arg_FCL_Y1+D'1', 1
05BE  0EF0      	MOVLW 0xF0
05C0  6FC2      	MOVWF FCD_0f051__0006C_arg_FCL_X2, 1
05C2  6BC3      	CLRF FCD_0f051__0006C_arg_FCL_X2+D'1', 1
05C4  0E40      	MOVLW 0x40
05C6  6FC4      	MOVWF FCD_0f051__0006C_arg_FCL_Y2, 1
05C8  0E01      	MOVLW 0x01
05CA  6FC5      	MOVWF FCD_0f051__0006C_arg_FCL_Y2+D'1', 1
05CC  6FC6      	MOVWF FCD_0f051__0006C_arg_FCL_T_0006D, 1
05CE  6FC7      	MOVWF FCD_0f051__0006C_arg_FCL_SOLID, 1
05D0  ECA0F000  	CALL FCD_0f051__0006C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(0, 0, 0)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(0, 0, 0);
05D4  6BBE      	CLRF FCD_0f051__0006B_arg_FCL_RED, 1
05D6  6BBF      	CLRF FCD_0f051__0006B_arg_FCL_GREEN, 1
05D8  6BC0      	CLRF FCD_0f051__0006B_arg_FCL_BLUE, 1
05DA  EC43F001  	CALL FCD_0f051__0006B


}
05DE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Appui_tactile()
{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	#if 0 // Disabled code
	//Commentaire:
	//Coordonnée pour X

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: X=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);

	#if 0 // Disabled code
	//Commentaire:
	//Coordonée pour Y

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(X, 80, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_X, 80, 150, 2, 1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(Y, 120, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_Y, 120, 150, 2, 1);

	// Pause
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	// Calcul
	// Calcul:
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	FCV_APPUI_ECRAN = 0;
	FCV_X = 0;
	FCV_Y = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Recuperation_coordonees()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Appui_Ecran=gLCD_EB076_4D1::G4D_GetTouchCoordinatesPicaso()
	FCV_APPUI_ECRAN = FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
0C3C  ECF0F002  	CALL FCD_0f051__00072
0C40  51B5      	MOVF CompTempVarRet2752, W, 1
0C42  6FA5      	MOVWF gbl_FCV_APPUI_ECRAN, 1


}
0C44  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_192()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 8
		FCV_HITBOX = 8;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 18
			FCV_HITBOX = 18;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 28
				FCV_HITBOX = 28;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 38
					FCV_HITBOX = 38;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 48
						FCV_HITBOX = 48;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 58
							FCV_HITBOX = 58;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 68
								FCV_HITBOX = 68;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 78
									FCV_HITBOX = 78;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 88
										FCV_HITBOX = 88;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 98
											FCV_HITBOX = 98;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_120()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 5
		FCV_HITBOX = 5;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 15
			FCV_HITBOX = 15;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 25
				FCV_HITBOX = 25;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 35
					FCV_HITBOX = 35;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 45
						FCV_HITBOX = 45;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 55
							FCV_HITBOX = 55;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 65
								FCV_HITBOX = 65;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 75
									FCV_HITBOX = 75;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 85
										FCV_HITBOX = 85;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 95
											FCV_HITBOX = 95;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_affichage_bateau_touche()
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_216()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 9
		FCV_HITBOX = 9;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 19
			FCV_HITBOX = 19;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 29
				FCV_HITBOX = 29;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 39
					FCV_HITBOX = 39;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 49
						FCV_HITBOX = 49;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 59
							FCV_HITBOX = 59;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 69
								FCV_HITBOX = 69;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 79
									FCV_HITBOX = 79;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 89
										FCV_HITBOX = 89;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 99
											FCV_HITBOX = 99;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_phase_jeu()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
0A3A  0E01      	MOVLW 0x01
0A3C  0100      	MOVLB 0x00
0A3E  6FA4      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
0A40  0E18      	MOVLW 0x18
0A42  6F8C      	MOVWF gbl_FCV_Y, 1
0A44  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
0A46  0E18      	MOVLW 0x18
0A48  6F8E      	MOVWF gbl_FCV_X, 1
0A4A  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
0A4C            label55
0A4C  0E01      	MOVLW 0x01
0A4E  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
0A50  E234      	BC	label63
0A52  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
0A54  D032      	BRA	label63
0AB8  D7C9      	BRA	label55
0ABA            label63

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
0A56  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0A58  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
0A5A  E102      	BNZ	label56
0A5C  518C      	MOVF gbl_FCV_Y, W, 1
0A5E  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
0A60            label56
0A60  E221      	BC	label62
0A62            label57
0AA4            label62

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
0A62  518F      	MOVF gbl_FCV_X+D'1', W, 1
0A64  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
0A66  E102      	BNZ	label58
0A68  518E      	MOVF gbl_FCV_X, W, 1
0A6A  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
0A6C            label58
0A6C  E309      	BNC	label59

				{

				} else {
0A80            label59


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
0A6E  29A4      	INCF gbl_FCV_HITBOX, W, 1
0A70  6FA4      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
0A72  6BB3      	CLRF CompTempVar2764, 1
0A74  0E18      	MOVLW 0x18
0A76  278E      	ADDWF gbl_FCV_X, F, 1
0A78  518F      	MOVF gbl_FCV_X+D'1', W, 1
0A7A  23B3      	ADDWFC CompTempVar2764, F, 1
0A7C  51B3      	MOVF CompTempVar2764, W, 1
0A7E  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
0A80  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
0A82  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
0A84  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
0A86  B4D8      	BTFSC STATUS,Z
0A88  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
0A8A  6BB2      	CLRF CompTempVar2762, 1
0A8C  518F      	MOVF gbl_FCV_X+D'1', W, 1
0A8E  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
0A90  E104      	BNZ	label60
0A92  518E      	MOVF gbl_FCV_X, W, 1
0A94  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
0A96  D001      	BRA	label60
0A98  D001      	BRA	label61
0A9A            label60
0A9A  A0D8      	BTFSS STATUS,C
0A9C  71B2      	BTG CompTempVar2762,0, 1
0A9E  53B2      	MOVF CompTempVar2762, F, 1
0AA0  E0E0      	BZ	label57

			}

			// Aller au Point de Jonction
			// Aller au Point de Jonction: [A]: A
			goto FCC_phase_jeu_A;
0AA2  D00B      	BRA	label63


		} else {

			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
0AA4  0E0A      	MOVLW 0x0A
0AA6  25A4      	ADDWF gbl_FCV_HITBOX, W, 1
0AA8  6FA4      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
0AAA  6BB2      	CLRF CompTempVar2768, 1
0AAC  0E18      	MOVLW 0x18
0AAE  278C      	ADDWF gbl_FCV_Y, F, 1
0AB0  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0AB2  23B2      	ADDWFC CompTempVar2768, F, 1
0AB4  51B2      	MOVF CompTempVar2768, W, 1
0AB6  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Sortie_BOUCLE
	// Point de Jonction: [A]: A
FCC_phase_jeu_A:
;

	// Décision
	// Décision: tableau[hitbox] = 0b00000001?
	if (FCV_TABLEAU[FCV_HITBOX] == 1)
0ABA  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0ABE  50E9      	MOVF FSR0L, W
0AC0  51A4      	MOVF gbl_FCV_HITBOX, W, 1
0AC2  26E9      	ADDWF FSR0L, F
0AC4  04EF      	DECF INDF0, W
0AC6  E158      	BNZ	label64
0B78            label64

	{

		// Appel de la Routine Composant
		// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
		FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0AC8  518E      	MOVF gbl_FCV_X, W, 1
0ACA  6FB3      	MOVWF FCM_parame_0006A_arg_FCL_POS_X1, 1
0ACC  518F      	MOVF gbl_FCV_X+D'1', W, 1
0ACE  6FB4      	MOVWF FCM_parame_0006A_arg_FCL_POS_X1+D'1', 1
0AD0  0E18      	MOVLW 0x18
0AD2  5D8E      	SUBWF gbl_FCV_X, W, 1
0AD4  6FB5      	MOVWF FCM_parame_0006A_arg_FCL_POS_X2, 1
0AD6  598E      	SUBWFB gbl_FCV_X, W, 1
0AD8  0818      	SUBLW 0x18
0ADA  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0ADC  6FB6      	MOVWF FCM_parame_0006A_arg_FCL_POS_X2+D'1', 1
0ADE  518C      	MOVF gbl_FCV_Y, W, 1
0AE0  6FB7      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y1, 1
0AE2  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0AE4  6FB8      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y1+D'1', 1
0AE6  0E18      	MOVLW 0x18
0AE8  5D8C      	SUBWF gbl_FCV_Y, W, 1
0AEA  6FB9      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y2, 1
0AEC  598C      	SUBWFB gbl_FCV_Y, W, 1
0AEE  0818      	SUBLW 0x18
0AF0  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0AF2  6FBA      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y2+D'1', 1
0AF4  69BB      	SETF FCM_parame_0006A_arg_FCL_ROUGE, 1
0AF6  6BBC      	CLRF FCM_parame_0006A_arg_FCL_VERT, 1
0AF8  6BBD      	CLRF FCM_parame_0006A_arg_FCL_BLEU, 1
0AFA  ECDAF001  	CALL FCM_parame_0006A


		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
		FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0AFE  0E20      	MOVLW 0x20
0B00  6FB5      	MOVWF CompTempVar2773, 1
0B02  6FB6      	MOVWF CompTempVar2773+D'1', 1
0B04  6FB7      	MOVWF CompTempVar2773+D'2', 1
0B06  6FB8      	MOVWF CompTempVar2773+D'3', 1
0B08  6FB9      	MOVWF CompTempVar2773+D'4', 1
0B0A  6FBA      	MOVWF CompTempVar2773+D'5', 1
0B0C  6FBB      	MOVWF CompTempVar2773+D'6', 1
0B0E  6FBC      	MOVWF CompTempVar2773+D'7', 1
0B10  6FBD      	MOVWF CompTempVar2773+D'8', 1
0B12  6FBE      	MOVWF CompTempVar2773+D'9', 1
0B14  6FBF      	MOVWF CompTempVar2773+D'10', 1
0B16  6FC0      	MOVWF CompTempVar2773+D'11', 1
0B18  6FC7      	MOVWF CompTempVar2773+D'18', 1
0B1A  6FC8      	MOVWF CompTempVar2773+D'19', 1
0B1C  6FC9      	MOVWF CompTempVar2773+D'20', 1
0B1E  0E54      	MOVLW 0x54
0B20  6FC1      	MOVWF CompTempVar2773+D'12', 1
0B22  0E63      	MOVLW 0x63
0B24  6FC4      	MOVWF CompTempVar2773+D'15', 1
0B26  0E65      	MOVLW 0x65
0B28  6FC6      	MOVWF CompTempVar2773+D'17', 1
0B2A  0E68      	MOVLW 0x68
0B2C  6FC5      	MOVWF CompTempVar2773+D'16', 1
0B2E  0E6F      	MOVLW 0x6F
0B30  6FC2      	MOVWF CompTempVar2773+D'13', 1
0B32  0E75      	MOVLW 0x75
0B34  6FC3      	MOVWF CompTempVar2773+D'14', 1
0B36  6BCA      	CLRF CompTempVar2773+D'21', 1
0B38  0E00      	MOVLW HIGH(CompTempVar2773+D'0')
0B3A  6FB4      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0B3C  0EB5      	MOVLW LOW(CompTempVar2773+D'0')
0B3E  6FB3      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0B40  0E16      	MOVLW 0x16
0B42  6FEA      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0B44  6BEB      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0B46  6BEC      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0B48  6BED      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0B4A  0EF1      	MOVLW 0xF1
0B4C  6FEE      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0B4E  6BEF      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0B50  0E02      	MOVLW 0x02
0B52  6FF0      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0B54  0E01      	MOVLW 0x01
0B56  6FF1      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0B58  ECAAF004  	CALL FCD_0f051__0005D


		// Calcul
		// Calcul:
		//  Tableau[hitbox] = tableau[hitbox] || 0b00000011
		FCV_TABLEAU[FCV_HITBOX] = FCV_TABLEAU[FCV_HITBOX] || 3;
0B5C  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0B60  50E9      	MOVF FSR0L, W
0B62  51A4      	MOVF gbl_FCV_HITBOX, W, 1
0B64  26E9      	ADDWF FSR0L, F
0B66  6BB2      	CLRF CompTempVar2777, 1
0B68  2BB2      	INCF CompTempVar2777, F, 1
0B6A  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0B6C  6EE9      	MOVWF FSR0L
0B6E  51A4      	MOVF gbl_FCV_HITBOX, W, 1
0B70  26E9      	ADDWF FSR0L, F
0B72  51B2      	MOVF CompTempVar2777, W, 1
0B74  6EEF      	MOVWF INDF0


	} else {
0B76  D04A      	BRA	label65
0C0C            label65


		// Appel de la Routine Composant
		// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 0, 0, 0)
		FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 0, 0, 0);
0B78  518E      	MOVF gbl_FCV_X, W, 1
0B7A  6FB3      	MOVWF FCM_parame_0006A_arg_FCL_POS_X1, 1
0B7C  518F      	MOVF gbl_FCV_X+D'1', W, 1
0B7E  6FB4      	MOVWF FCM_parame_0006A_arg_FCL_POS_X1+D'1', 1
0B80  0E18      	MOVLW 0x18
0B82  5D8E      	SUBWF gbl_FCV_X, W, 1
0B84  6FB5      	MOVWF FCM_parame_0006A_arg_FCL_POS_X2, 1
0B86  598E      	SUBWFB gbl_FCV_X, W, 1
0B88  0818      	SUBLW 0x18
0B8A  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0B8C  6FB6      	MOVWF FCM_parame_0006A_arg_FCL_POS_X2+D'1', 1
0B8E  518C      	MOVF gbl_FCV_Y, W, 1
0B90  6FB7      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y1, 1
0B92  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0B94  6FB8      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y1+D'1', 1
0B96  0E18      	MOVLW 0x18
0B98  5D8C      	SUBWF gbl_FCV_Y, W, 1
0B9A  6FB9      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y2, 1
0B9C  598C      	SUBWFB gbl_FCV_Y, W, 1
0B9E  0818      	SUBLW 0x18
0BA0  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0BA2  6FBA      	MOVWF FCM_parame_0006A_arg_FCL_POS_Y2+D'1', 1
0BA4  6BBB      	CLRF FCM_parame_0006A_arg_FCL_ROUGE, 1
0BA6  6BBC      	CLRF FCM_parame_0006A_arg_FCL_VERT, 1
0BA8  6BBD      	CLRF FCM_parame_0006A_arg_FCL_BLEU, 1
0BAA  ECDAF001  	CALL FCM_parame_0006A


		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Manque   ", 0, 241, 2, 1)
		FCD_0f051_gLCD_EB076_4D1__Print("            Manque   ", 22, 0, 241, 2, 1);
0BAE  0E20      	MOVLW 0x20
0BB0  6FB5      	MOVWF CompTempVar2783, 1
0BB2  6FB6      	MOVWF CompTempVar2783+D'1', 1
0BB4  6FB7      	MOVWF CompTempVar2783+D'2', 1
0BB6  6FB8      	MOVWF CompTempVar2783+D'3', 1
0BB8  6FB9      	MOVWF CompTempVar2783+D'4', 1
0BBA  6FBA      	MOVWF CompTempVar2783+D'5', 1
0BBC  6FBB      	MOVWF CompTempVar2783+D'6', 1
0BBE  6FBC      	MOVWF CompTempVar2783+D'7', 1
0BC0  6FBD      	MOVWF CompTempVar2783+D'8', 1
0BC2  6FBE      	MOVWF CompTempVar2783+D'9', 1
0BC4  6FBF      	MOVWF CompTempVar2783+D'10', 1
0BC6  6FC0      	MOVWF CompTempVar2783+D'11', 1
0BC8  6FC7      	MOVWF CompTempVar2783+D'18', 1
0BCA  6FC8      	MOVWF CompTempVar2783+D'19', 1
0BCC  6FC9      	MOVWF CompTempVar2783+D'20', 1
0BCE  0E4D      	MOVLW 0x4D
0BD0  6FC1      	MOVWF CompTempVar2783+D'12', 1
0BD2  0E61      	MOVLW 0x61
0BD4  6FC2      	MOVWF CompTempVar2783+D'13', 1
0BD6  0E65      	MOVLW 0x65
0BD8  6FC6      	MOVWF CompTempVar2783+D'17', 1
0BDA  0E6E      	MOVLW 0x6E
0BDC  6FC3      	MOVWF CompTempVar2783+D'14', 1
0BDE  0E71      	MOVLW 0x71
0BE0  6FC4      	MOVWF CompTempVar2783+D'15', 1
0BE2  0E75      	MOVLW 0x75
0BE4  6FC5      	MOVWF CompTempVar2783+D'16', 1
0BE6  6BCA      	CLRF CompTempVar2783+D'21', 1
0BE8  0E00      	MOVLW HIGH(CompTempVar2783+D'0')
0BEA  6FB4      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0BEC  0EB5      	MOVLW LOW(CompTempVar2783+D'0')
0BEE  6FB3      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0BF0  0E16      	MOVLW 0x16
0BF2  6FEA      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0BF4  6BEB      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0BF6  6BEC      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0BF8  6BED      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0BFA  0EF1      	MOVLW 0xF1
0BFC  6FEE      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0BFE  6BEF      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0C00  0E02      	MOVLW 0x02
0C02  6FF0      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0C04  0E01      	MOVLW 0x01
0C06  6FF1      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0C08  ECAAF004  	CALL FCD_0f051__0005D


	}

	// Calcul
	// Calcul:
	//  X = 0
	//  Y = 0
	FCV_X = 0;
0C0C  6B8E      	CLRF gbl_FCV_X, 1
0C0E  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
0C10  6B8C      	CLRF gbl_FCV_Y, 1
0C12  6B8D      	CLRF gbl_FCV_Y+D'1', 1


	// Calcul
	// Calcul:
	//  X_SORTIE = 0
	FCV_X_SORTIE = 0;
0C14  6B86      	CLRF gbl_FCV_X_SORTIE, 1
0C16  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1


}
0C18  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_lignes()

{

	// Calcul
	// Calcul:
	//  X_ligne = 24
	//  Y_ligne = 24
	FCV_X_LIGNE = 24;
04E2  0E18      	MOVLW 0x18
04E4  0100      	MOVLB 0x00
04E6  6F8A      	MOVWF gbl_FCV_X_LIGNE, 1
04E8  6B8B      	CLRF gbl_FCV_X_LIGNE+D'1', 1

	FCV_Y_LIGNE = 24;
04EA  0E18      	MOVLW 0x18
04EC  6F84      	MOVWF gbl_FCV_Y_LIGNE, 1
04EE  6B85      	CLRF gbl_FCV_Y_LIGNE+D'1', 1


	// tracé des verticales
	// Boucle: While X_ligne = 240
	while (1)
04F0            label32

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(X_ligne, 0, X_ligne, 240)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(FCV_X_LIGNE, 0, FCV_X_LIGNE, 240);
04F0  518A      	MOVF gbl_FCV_X_LIGNE, W, 1
04F2  6FB3      	MOVWF FCD_0f051__00075_arg_FCL_X1, 1
04F4  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
04F6  6FB4      	MOVWF FCD_0f051__00075_arg_FCL_X1+D'1', 1
04F8  6BB5      	CLRF FCD_0f051__00075_arg_FCL_Y1, 1
04FA  6BB6      	CLRF FCD_0f051__00075_arg_FCL_Y1+D'1', 1
04FC  518A      	MOVF gbl_FCV_X_LIGNE, W, 1
04FE  6FB7      	MOVWF FCD_0f051__00075_arg_FCL_X2, 1
0500  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
0502  6FB8      	MOVWF FCD_0f051__00075_arg_FCL_X2+D'1', 1
0504  0EF0      	MOVLW 0xF0
0506  6FB9      	MOVWF FCD_0f051__00075_arg_FCL_Y2, 1
0508  6BBA      	CLRF FCD_0f051__00075_arg_FCL_Y2+D'1', 1
050A  EC08F002  	CALL FCD_0f051__00075


		// Calcul
		// Calcul:
		//  X_ligne = X_ligne + 24
		FCV_X_LIGNE = FCV_X_LIGNE + 24;
050E  6BB3      	CLRF CompTempVar2693, 1
0510  0E18      	MOVLW 0x18
0512  278A      	ADDWF gbl_FCV_X_LIGNE, F, 1
0514  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
0516  23B3      	ADDWFC CompTempVar2693, F, 1
0518  51B3      	MOVF CompTempVar2693, W, 1
051A  6F8B      	MOVWF gbl_FCV_X_LIGNE+D'1', 1



		if ((FCV_X_LIGNE == 240) != 0) break;
051C  6BB2      	CLRF CompTempVar2691, 1
051E  0EF0      	MOVLW 0xF0
0520  638A      	CPFSEQ gbl_FCV_X_LIGNE, 1
0522  D003      	BRA	label33
0524  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
0526  B4D8      	BTFSC STATUS,Z
0528  2BB2      	INCF CompTempVar2691, F, 1
052A            label33
052A  53B2      	MOVF CompTempVar2691, F, 1
052C  E0E1      	BZ	label32

	}

	// tracé des horizontales
	// Boucle: While Y_ligne <= 240
	while (1)
	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, Y_ligne, 240, Y_ligne)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(0, FCV_Y_LIGNE, 240, FCV_Y_LIGNE);
052E  6BB3      	CLRF FCD_0f051__00075_arg_FCL_X1, 1
0530  6BB4      	CLRF FCD_0f051__00075_arg_FCL_X1+D'1', 1
0532  5184      	MOVF gbl_FCV_Y_LIGNE, W, 1
0534  6FB5      	MOVWF FCD_0f051__00075_arg_FCL_Y1, 1
0536  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
0538  6FB6      	MOVWF FCD_0f051__00075_arg_FCL_Y1+D'1', 1
053A  0EF0      	MOVLW 0xF0
053C  6FB7      	MOVWF FCD_0f051__00075_arg_FCL_X2, 1
053E  6BB8      	CLRF FCD_0f051__00075_arg_FCL_X2+D'1', 1
0540  5184      	MOVF gbl_FCV_Y_LIGNE, W, 1
0542  6FB9      	MOVWF FCD_0f051__00075_arg_FCL_Y2, 1
0544  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
0546  6FBA      	MOVWF FCD_0f051__00075_arg_FCL_Y2+D'1', 1
0548  EC08F002  	CALL FCD_0f051__00075


		// Calcul
		// Calcul:
		//  Y_ligne = Y_ligne + 24
		FCV_Y_LIGNE = FCV_Y_LIGNE + 24;
054C  6BB3      	CLRF CompTempVar2696, 1
054E  0E18      	MOVLW 0x18
0550  2784      	ADDWF gbl_FCV_Y_LIGNE, F, 1
0552  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
0554  23B3      	ADDWFC CompTempVar2696, F, 1
0556  51B3      	MOVF CompTempVar2696, W, 1
0558  6F85      	MOVWF gbl_FCV_Y_LIGNE+D'1', 1



		if ((FCV_Y_LIGNE <= 240) == 0) break;
055A  6BB2      	CLRF CompTempVar2694, 1
055C  0EF0      	MOVLW 0xF0
055E  6584      	CPFSGT gbl_FCV_Y_LIGNE, 1
0560  6785      	TSTFSZ gbl_FCV_Y_LIGNE+D'1', 1
0562  D001      	BRA	label35
0564  2BB2      	INCF CompTempVar2694, F, 1
0566            label35
0566  53B2      	MOVF CompTempVar2694, F, 1
0568  E1E2      	BNZ	label34

	}

}
056A  0012      	RETURN




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
10E4  0E0F      	MOVLW 0x0F
10E6  6EC1      	MOVWF gbl_adcon1





	// Appel d'une Macro
	// Appel d'une Macro: Initialisation()
	FCM_Initialisation();
10E8  ECDAF007  	CALL FCM_Initia_00061


	// Boucle
	// Boucle: While bateau >= 17
	while (1)
10EC            label85

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_texte()
		FCM_Reinitialisation_texte();
10EC  ECD4F002  	CALL FCM_Reinit_00066


		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_tactile()
		FCM_Reinitialisation_tactile();
10F0  EC0DF006  	CALL FCM_Reinit_00067


		// Appel d'une Macro
		// Appel d'une Macro: Message_bateau()
		FCM_Message_bateau();
10F4  EC23F006  	CALL FCM_Messag_00065


		// Boucle
		// Boucle: While Appui_Ecran = 0
		while (FCV_APPUI_ECRAN == 0)
10F8            label86
10F8  53A5      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
10FA  E103      	BNZ	label87
1100  D7FB      	BRA	label86
1102            label87

		{

			// Appel d'une Macro
			// Appel d'une Macro: Recuperation_coordonees()
			FCM_Recuperation_coordonees();
10FC  EC1EF006  	CALL FCM_Recupe_00071



		}

		// Appel d'une Macro
		// Appel d'une Macro: Lecture_Coordonnes()
		FCM_Lecture_Coordonnes();
1102  ECC9F007  	CALL FCM_Lectur_0005F


		// Appel d'une Macro
		// Appel d'une Macro: Hitbox_v2()
		FCM_Hitbox_v2();
1106  EC0DF008  	CALL FCM_Hitbox_0005B


		// Calcul
		// Calcul:
		//  Appui_Ecran = 0
		FCV_APPUI_ECRAN = 0;
110A  6BA5      	CLRF gbl_FCV_APPUI_ECRAN, 1


		// Pause
		// Pause: 100 ms
		FCI_DELAYBYTE_MS(100);
110C  0E64      	MOVLW 0x64
110E  6FB7      	MOVWF delay_ms_00000_arg_del, 1
1110  EC06F000  	CALL delay_ms_00000



		if ((FCV_BATEAU >= 17) != 0) break;
1114  6BB2      	CLRF CompTempVar3040, 1
1116  0E11      	MOVLW 0x11
1118  61A7      	CPFSLT gbl_FCV_BATEAU, 1
111A  2BB2      	INCF CompTempVar3040, F, 1
111C  53B2      	MOVF CompTempVar3040, F, 1
111E  E0E6      	BZ	label85

	}

	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_texte()
	FCM_Reinitialisation_texte();
1120  ECD4F002  	CALL FCM_Reinit_00066


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("    En attente du joueur 2 ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("    En attente du joueur 2 ", 28, 0, 241, 2, 1);
1124  0E20      	MOVLW 0x20
1126  6FB5      	MOVWF CompTempVar3041, 1
1128  6FB6      	MOVWF CompTempVar3041+D'1', 1
112A  6FB7      	MOVWF CompTempVar3041+D'2', 1
112C  6FB8      	MOVWF CompTempVar3041+D'3', 1
112E  6FBB      	MOVWF CompTempVar3041+D'6', 1
1130  6FC3      	MOVWF CompTempVar3041+D'14', 1
1132  6FC6      	MOVWF CompTempVar3041+D'17', 1
1134  6FCD      	MOVWF CompTempVar3041+D'24', 1
1136  6FCF      	MOVWF CompTempVar3041+D'26', 1
1138  0E32      	MOVLW 0x32
113A  6FCE      	MOVWF CompTempVar3041+D'25', 1
113C  0E45      	MOVLW 0x45
113E  6FB9      	MOVWF CompTempVar3041+D'4', 1
1140  0E61      	MOVLW 0x61
1142  6FBC      	MOVWF CompTempVar3041+D'7', 1
1144  0E64      	MOVLW 0x64
1146  6FC4      	MOVWF CompTempVar3041+D'15', 1
1148  0E65      	MOVLW 0x65
114A  6FBF      	MOVWF CompTempVar3041+D'10', 1
114C  6FC2      	MOVWF CompTempVar3041+D'13', 1
114E  6FCA      	MOVWF CompTempVar3041+D'21', 1
1150  0E6A      	MOVLW 0x6A
1152  6FC7      	MOVWF CompTempVar3041+D'18', 1
1154  0E6E      	MOVLW 0x6E
1156  6FBA      	MOVWF CompTempVar3041+D'5', 1
1158  6FC0      	MOVWF CompTempVar3041+D'11', 1
115A  0E6F      	MOVLW 0x6F
115C  6FC8      	MOVWF CompTempVar3041+D'19', 1
115E  0E72      	MOVLW 0x72
1160  6FCC      	MOVWF CompTempVar3041+D'23', 1
1162  0E74      	MOVLW 0x74
1164  6FBD      	MOVWF CompTempVar3041+D'8', 1
1166  6FBE      	MOVWF CompTempVar3041+D'9', 1
1168  6FC1      	MOVWF CompTempVar3041+D'12', 1
116A  0E75      	MOVLW 0x75
116C  6FC5      	MOVWF CompTempVar3041+D'16', 1
116E  6FC9      	MOVWF CompTempVar3041+D'20', 1
1170  6FCB      	MOVWF CompTempVar3041+D'22', 1
1172  6BD0      	CLRF CompTempVar3041+D'27', 1
1174  0E00      	MOVLW HIGH(CompTempVar3041+D'0')
1176  6FB4      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1178  0EB5      	MOVLW LOW(CompTempVar3041+D'0')
117A  6FB3      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
117C  0E1C      	MOVLW 0x1C
117E  6FEA      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1180  6BEB      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
1182  6BEC      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1184  6BED      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1186  0EF1      	MOVLW 0xF1
1188  6FEE      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
118A  6BEF      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
118C  0E02      	MOVLW 0x02
118E  6FF0      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
1190  0E01      	MOVLW 0x01
1192  6FF1      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1194  ECAAF004  	CALL FCD_0f051__0005D


	// mettre attente donnes joueur 2
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);
1198  0E02      	MOVLW 0x02
119A  6FB6      	MOVWF delay_s_00000_arg_del, 1
119C  EC33F000  	CALL delay_s_00000


	// Boucle
	// Boucle: While 1
	while (1)
11A0            label88
11C4  D7ED      	BRA	label88

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_texte()
		FCM_Reinitialisation_texte();
11A0  ECD4F002  	CALL FCM_Reinit_00066


		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_tactile()
		FCM_Reinitialisation_tactile();
11A4  EC0DF006  	CALL FCM_Reinit_00067


		// Boucle
		// Boucle: While Appui_Ecran = 0
		while (FCV_APPUI_ECRAN == 0)
11A8            label89
11A8  53A5      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
11AA  E103      	BNZ	label90
11B0  D7FB      	BRA	label89
11B2            label90

		{

			// Appel d'une Macro
			// Appel d'une Macro: Recuperation_coordonees()
			FCM_Recuperation_coordonees();
11AC  EC1EF006  	CALL FCM_Recupe_00071



		}

		// Appel d'une Macro
		// Appel d'une Macro: Lecture_Coordonnes()
		FCM_Lecture_Coordonnes();
11B2  ECC9F007  	CALL FCM_Lectur_0005F


		// Appel d'une Macro
		// Appel d'une Macro: phase_jeu()
		FCM_phase_jeu();
11B6  EC1DF005  	CALL FCM_phase__00074


		// Calcul
		// Calcul:
		//  Appui_Ecran = 0
		FCV_APPUI_ECRAN = 0;
11BA  6BA5      	CLRF gbl_FCV_APPUI_ECRAN, 1


		// Pause
		// Pause: 100 ms
		FCI_DELAYBYTE_MS(100);
11BC  0E64      	MOVLW 0x64
11BE  6FB7      	MOVWF delay_ms_00000_arg_del, 1
11C0  EC06F000  	CALL delay_ms_00000



	}

	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

}
126E  CFEAF001  	MOVFF FSR0H,  Int1Context
1272  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1276  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
127A  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
127E  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
1282  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
1286  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
128A  C001FFEA  	MOVFF Int1Context,  FSR0H
128E  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
02E2  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
02E4  0E7F      	MOVLW 0x7F
02E6  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
02E8  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
02EA  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
02EC  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
02EE  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
02F0  9A9D      	BCF gbl_pie1,5

			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
02F2  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
013A  6AAB      	CLRF gbl_rcsta

			txsta = 0;
013C  6AAC      	CLRF gbl_txsta

		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}
013E  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
008C            label5
008C  0E10      	MOVLW 0x10
008E  149E      	ANDWF gbl_pir1, W
0090  6FF6      	MOVWF CompTempVar2799, 1
0092  53F6      	MOVF CompTempVar2799, F, 1
0094  E0FB      	BZ	label5


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0096  51F4      	MOVF FC_CAL_UAR_0007A_arg_nChar, W, 1
0098  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
009A  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
009C  69F5      	SETF FC_CAL_UAR_00079_1_retVal, 1

  #endif

	MX_UINT8 delay1 = 0;
009E  6BF6      	CLRF FC_CAL_UAR_00079_1_delay1, 1

	MX_UINT8 regcheck = 0;
00A0  6BF7      	CLRF FC_CAL_UAR_00079_1_regcheck, 1

	MX_UINT8 bWaitForever = 0;
00A2  6BF8      	CLRF FC_CAL_UAR_00079_1_bWaitForever, 1

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
00A4  6BF9      	CLRF FC_CAL_UAR_00079_1_rxStatus, 1

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
00A6  6BFC      	CLRF FC_CAL_UAR_00079_1_dummy, 1

  #endif

	if (nTimeout == 255)
00A8  29F4      	INCF FC_CAL_UAR_00079_arg_nTimeout, W, 1
00AA  E102      	BNZ	label6
00B0            label6

		bWaitForever = 1;
00AC  0E01      	MOVLW 0x01
00AE  6FF8      	MOVWF FC_CAL_UAR_00079_1_bWaitForever, 1


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00B0  53F9      	MOVF FC_CAL_UAR_00079_1_rxStatus, F, 1
00B2  E124      	BNZ	label11
00FA  D7DA      	BRA	label6
00FC            label11

	{
		if (bWaitForever == 0)
00B4  53F8      	MOVF FC_CAL_UAR_00079_1_bWaitForever, F, 1
00B6  E118      	BNZ	label10

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00B8  53F4      	MOVF FC_CAL_UAR_00079_arg_nTimeout, F, 1
00BA  E103      	BNZ	label7
00C2            label7

			{
				rxStatus = UART_STATUS_TIMEOUT;
00BC  0E01      	MOVLW 0x01
00BE  6FF9      	MOVWF FC_CAL_UAR_00079_1_rxStatus, 1

			}
			else
00C0  D013      	BRA	label10

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00C2  6BFA      	CLRF FC_CAL_UAR_00079_1_delaycnt, 1
00C4  6BFB      	CLRF FC_CAL_UAR_00079_1_delaycnt+D'1', 1
00C6            label8
00C6  0E31      	MOVLW 0x31
00C8  5DFA      	SUBWF FC_CAL_UAR_00079_1_delaycnt, W, 1
00CA  E205      	BC	label9
00CC  67FB      	TSTFSZ FC_CAL_UAR_00079_1_delaycnt+D'1', 1
00CE  D003      	BRA	label9
00D0  4BFA      	INFSNZ FC_CAL_UAR_00079_1_delaycnt, F, 1
00D2  2BFB      	INCF FC_CAL_UAR_00079_1_delaycnt+D'1', F, 1
00D4  D7F8      	BRA	label8
00D6            label9

				delay1 = delay1 + 1;
00D6  29F6      	INCF FC_CAL_UAR_00079_1_delay1, W, 1
00D8  6FF6      	MOVWF FC_CAL_UAR_00079_1_delay1, 1

				if(delay1 == 100)
00DA  0E64      	MOVLW 0x64
00DC  63F6      	CPFSEQ FC_CAL_UAR_00079_1_delay1, 1
00DE  D004      	BRA	label10
00E8            label10

				{
					nTimeout = nTimeout - 1;
00E0  05F4      	DECF FC_CAL_UAR_00079_arg_nTimeout, W, 1
00E2  6FF4      	MOVWF FC_CAL_UAR_00079_arg_nTimeout, 1

					MX_CLEAR_WATCHDOG;
00E4  0004      	CLRWDT

					delay1 = 0;
00E6  6BF6      	CLRF FC_CAL_UAR_00079_1_delay1, 1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00E8  0E20      	MOVLW 0x20
00EA  149E      	ANDWF gbl_pir1, W
00EC  6FFD      	MOVWF CompTempVar2796, 1
00EE  51FD      	MOVF CompTempVar2796, W, 1
00F0  6FF7      	MOVWF FC_CAL_UAR_00079_1_regcheck, 1

			if (regcheck != 0)
00F2  53F7      	MOVF FC_CAL_UAR_00079_1_regcheck, F, 1
00F4  E0DD      	BZ	label6

				rxStatus = UART_STATUS_RXBYTE;
00F6  0E02      	MOVLW 0x02
00F8  6FF9      	MOVWF FC_CAL_UAR_00079_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00FC  0E02      	MOVLW 0x02
00FE  63F9      	CPFSEQ FC_CAL_UAR_00079_1_rxStatus, 1
0100  D018      	BRA	label14

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0102  0E04      	MOVLW 0x04
0104  14AB      	ANDWF gbl_rcsta, W
0106  6FFD      	MOVWF CompTempVar2797, 1
0108  51FD      	MOVF CompTempVar2797, W, 1
010A  6FF7      	MOVWF FC_CAL_UAR_00079_1_regcheck, 1

			if (regcheck != 0)
010C  53F7      	MOVF FC_CAL_UAR_00079_1_regcheck, F, 1
010E  E003      	BZ	label12
0116            label12

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0110  50AE      	MOVF gbl_rcreg, W
0112  6FFC      	MOVWF FC_CAL_UAR_00079_1_dummy, 1

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0114  D00E      	BRA	label14

			{
				regcheck = ts_bit(rcsta, OERR);
0116  0E02      	MOVLW 0x02
0118  14AB      	ANDWF gbl_rcsta, W
011A  6FFD      	MOVWF CompTempVar2798, 1
011C  51FD      	MOVF CompTempVar2798, W, 1
011E  6FF7      	MOVWF FC_CAL_UAR_00079_1_regcheck, 1

				if (regcheck != 0)
0120  53F7      	MOVF FC_CAL_UAR_00079_1_regcheck, F, 1
0122  E003      	BZ	label13
012A            label13

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0124  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0126  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0128  D004      	BRA	label14
0132            label14

				{
					retVal = 0;
012A  6BF5      	CLRF FC_CAL_UAR_00079_1_retVal, 1


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
012C  50AE      	MOVF gbl_rcreg, W
012E  11F5      	IORWF FC_CAL_UAR_00079_1_retVal, W, 1
0130  6FF5      	MOVWF FC_CAL_UAR_00079_1_retVal, 1

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0132  51F5      	MOVF FC_CAL_UAR_00079_1_retVal, W, 1
0134  6FFD      	MOVWF CompTempVarRet2795, 1
0136  6BFE      	CLRF CompTempVarRet2795+D'1', 1

}
0138  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))

{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
02F4  0E07      	MOVLW 0x07
02F6  65B6      	CPFSGT FC_CAL_UAR_00077_arg_new_baud, 1
02F8  D001      	BRA	label18
02FC            label18

		return;

	if (new_baud == 0)
02FC  53B6      	MOVF FC_CAL_UAR_00077_arg_new_baud, F, 1
02FE  E104      	BNZ	label19
0308            label19

	{
		baudrate = MX_HARD_BAUD_1200;
0300  69B7      	SETF FC_CAL_UAR_00077_1_baudrate, 1

		baudmode = MX_HARD_SLOW_1200;
0302  0E01      	MOVLW 0x01
0304  6FB8      	MOVWF FC_CAL_UAR_00077_1_baudmode, 1

	}
	else if (new_baud == 1)
0306  D02F      	BRA	label26
0308  05B6      	DECF FC_CAL_UAR_00077_arg_new_baud, W, 1
030A  E105      	BNZ	label20
0316            label20

	{
		baudrate = MX_HARD_BAUD_2400;
030C  0E7F      	MOVLW 0x7F
030E  6FB7      	MOVWF FC_CAL_UAR_00077_1_baudrate, 1

		baudmode = MX_HARD_SLOW_2400;
0310  0E01      	MOVLW 0x01
0312  6FB8      	MOVWF FC_CAL_UAR_00077_1_baudmode, 1

	}
	else if (new_baud == 2)
0314  D028      	BRA	label26
0316  0E02      	MOVLW 0x02
0318  63B6      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud, 1
031A  D003      	BRA	label21
0322            label21

	{
		baudrate = MX_HARD_BAUD_4800;
031C  69B7      	SETF FC_CAL_UAR_00077_1_baudrate, 1

		baudmode = MX_HARD_SLOW_4800;
031E  6BB8      	CLRF FC_CAL_UAR_00077_1_baudmode, 1

	}
	else if (new_baud == 3)
0320  D022      	BRA	label26
0322  0E03      	MOVLW 0x03
0324  63B6      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud, 1
0326  D004      	BRA	label22
0330            label22

	{
		baudrate = MX_HARD_BAUD_9600;
0328  0E7F      	MOVLW 0x7F
032A  6FB7      	MOVWF FC_CAL_UAR_00077_1_baudrate, 1

		baudmode = MX_HARD_SLOW_9600;
032C  6BB8      	CLRF FC_CAL_UAR_00077_1_baudmode, 1

	}
	else if (new_baud == 4)
032E  D01B      	BRA	label26
0330  0E04      	MOVLW 0x04
0332  63B6      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud, 1
0334  D004      	BRA	label23
033E            label23

	{
		baudrate = MX_HARD_BAUD_19200;
0336  0E3F      	MOVLW 0x3F
0338  6FB7      	MOVWF FC_CAL_UAR_00077_1_baudrate, 1

		baudmode = MX_HARD_SLOW_19200;
033A  6BB8      	CLRF FC_CAL_UAR_00077_1_baudmode, 1

	}
	else if (new_baud == 5)
033C  D014      	BRA	label26
033E  0E05      	MOVLW 0x05
0340  63B6      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud, 1
0342  D004      	BRA	label24
034C            label24

	{
		baudrate = MX_HARD_BAUD_38400;
0344  0E1F      	MOVLW 0x1F
0346  6FB7      	MOVWF FC_CAL_UAR_00077_1_baudrate, 1

		baudmode = MX_HARD_SLOW_38400;
0348  6BB8      	CLRF FC_CAL_UAR_00077_1_baudmode, 1

	}
	else if (new_baud == 6)
034A  D00D      	BRA	label26
034C  0E06      	MOVLW 0x06
034E  63B6      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud, 1
0350  D004      	BRA	label25
035A            label25

	{
		baudrate = MX_HARD_BAUD_57600;
0352  0E14      	MOVLW 0x14
0354  6FB7      	MOVWF FC_CAL_UAR_00077_1_baudrate, 1

		baudmode = MX_HARD_SLOW_57600;
0356  6BB8      	CLRF FC_CAL_UAR_00077_1_baudmode, 1

	}
	else if (new_baud == 7)
0358  D006      	BRA	label26
035A  0E07      	MOVLW 0x07
035C  63B6      	CPFSEQ FC_CAL_UAR_00077_arg_new_baud, 1
035E  D003      	BRA	label26
0366            label26

	{
		baudrate = MX_HARD_BAUD_115200;
0360  0E0A      	MOVLW 0x0A
0362  6FB7      	MOVWF FC_CAL_UAR_00077_1_baudrate, 1

		baudmode = MX_HARD_SLOW_115200;
0364  6BB8      	CLRF FC_CAL_UAR_00077_1_baudmode, 1

	}

	UART_Uninit();
0366  EC9DF000  	CALL FC_CAL_UAR_00078


	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
036A  05B8      	DECF FC_CAL_UAR_00077_1_baudmode, W, 1
036C  E102      	BNZ	label27
0372            label27

			cr_bit(txsta, BRGH);					//Low Speed
036E  94AC      	BCF gbl_txsta,2

	    else
0370  D001      	BRA	label28
0374            label28

			st_bit(txsta, BRGH);					//High Speed
0372  84AC      	BSF gbl_txsta,2


		spbrg = baudrate;   						// set the baud rate
0374  51B7      	MOVF FC_CAL_UAR_00077_1_baudrate, W, 1
0376  6EAF      	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
0378  6AAB      	CLRF gbl_rcsta


		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
037A  8EAB      	BSF gbl_rcsta,7

		st_bit(txsta, TXEN);
037C  8AAC      	BSF gbl_txsta,5

		st_bit(rcsta, CREN);
037E  88AB      	BSF gbl_rcsta,4


		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
0380  9A9D      	BCF gbl_pie1,5

		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
02FA  0012      	RETURN
0382  0012      	RETURN


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EFE3F008  	GOTO	_startup

0008  EF37F009  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  53B7      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF5      	MOVLW 0xF5
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0FFF      	ADDLW 0xFF
0038  A4D8      	BTFSS STATUS,Z
003A  D7ED      	BRA	label2
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  2FB7      	DECFSZ delay_ms_00000_arg_del, F, 1
0058  D7DD      	BRA	label1
005A  0012      	RETURN
005C            ; } delay_ms function end

005C            delay_us_00000
005C            ; { delay_us ; function begin
005C            label3
005C  0000      	NOP
005E  0000      	NOP
0060  2FB6      	DECFSZ delay_us_00000_arg_del, F, 1
0062  D7FC      	BRA	label3
0064  0012      	RETURN
0066            ; } delay_us function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6FB7      	MOVWF delay_ms_00000_arg_del, 1
006A  EC06F000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6FB7      	MOVWF delay_ms_00000_arg_del, 1
0072  EC06F000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6FB7      	MOVWF delay_ms_00000_arg_del, 1
007A  EC06F000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6FB7      	MOVWF delay_ms_00000_arg_del, 1
0082  EC06F000  	CALL delay_ms_00000
0086  2FB6      	DECFSZ delay_s_00000_arg_del, F, 1
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end





























































11C6            _startup
11C6  0ED5      	MOVLW 0xD5
11C8  6E6A      	MOVWF gbl_14_LSR
11CA  0EC4      	MOVLW 0xC4
11CC  6E6B      	MOVWF gbl_14_LSR+D'1'
11CE  0EBB      	MOVLW 0xBB
11D0  6E6C      	MOVWF gbl_14_LSR+D'2'
11D2  0EDC      	MOVLW 0xDC
11D4  6E6D      	MOVWF gbl_14_LSR+D'3'
11D6  6A6E      	CLRF gbl_15_gbl_aSig
11D8  6A6F      	CLRF gbl_15_gbl_aSig+D'1'
11DA  6A70      	CLRF gbl_15_gbl_aSig+D'2'
11DC  6A71      	CLRF gbl_15_gbl_aSig+D'3'
11DE  6A72      	CLRF gbl_15_gbl_bSig
11E0  6A73      	CLRF gbl_15_gbl_bSig+D'1'
11E2  6A74      	CLRF gbl_15_gbl_bSig+D'2'
11E4  6A75      	CLRF gbl_15_gbl_bSig+D'3'
11E6  6A76      	CLRF gbl_15_gbl_zSig
11E8  6A77      	CLRF gbl_15_gbl_zSig+D'1'
11EA  6A78      	CLRF gbl_15_gbl_zSig+D'2'
11EC  6A79      	CLRF gbl_15_gbl_zSig+D'3'
11EE  0100      	MOVLB 0x00
11F0  6B9D      	CLRF gbl_15_gbl_aExp, 1
11F2  6B9E      	CLRF gbl_15_gbl_bExp, 1
11F4  6A7E      	CLRF gbl_15_gbl_zExp
11F6  6A7F      	CLRF gbl_15_gbl_zExp+D'1'
11F8  6B9F      	CLRF gbl_15_gbl_aSign, 1
11FA  6BA0      	CLRF gbl_15_gbl_bSign, 1
11FC  6BA1      	CLRF gbl_15_gbl_zSign, 1
11FE  6BA2      	CLRF gbl_15_gbl_zSigZero, 1
1200  6A7A      	CLRF gbl_15_gbl_ret
1202  6A7B      	CLRF gbl_15_gbl_ret+D'1'
1204  6A7C      	CLRF gbl_15_gbl_ret+D'2'
1206  6A7D      	CLRF gbl_15_gbl_ret+D'3'
1208  6B9B      	CLRF gbl_float_rounding_mode, 1
120A  6B9C      	CLRF gbl_float_exception_flags, 1
120C  6B9A      	CLRF gbl_float_detect_tininess, 1















126A  EF72F008  	GOTO	main

300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  79FF      	DW 0x79FF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
