;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
01E2  503C      	MOVF FC_CAL_Por_00042_arg_Tris+D'1', W
01E4  6EEA      	MOVWF FSR0H
01E6  503B      	MOVF FC_CAL_Por_00042_arg_Tris, W
01E8  6EE9      	MOVWF FSR0L
01EA  503D      	MOVF FC_CAL_Por_00042_arg_InMask, W
01EC  10EF      	IORWF INDF0, W
01EE  6E3F      	MOVWF CompTempVar1825
01F0  503F      	MOVF CompTempVar1825, W
01F2  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
01F4  503A      	MOVF FC_CAL_Por_00042_arg_Port+D'1', W
01F6  6EEA      	MOVWF FSR0H
01F8  5039      	MOVF FC_CAL_Por_00042_arg_Port, W
01FA  6EE9      	MOVWF FSR0L
01FC  503D      	MOVF FC_CAL_Por_00042_arg_InMask, W
01FE  14EF      	ANDWF INDF0, W
0200  6E3F      	MOVWF CompTempVarRet1822
0202  503E      	MOVF FC_CAL_Por_00042_arg_Shift, W
0204  6E40      	MOVWF CompTempVar1827
0206            label26
0206  B4D8      	BTFSC STATUS,Z
020A  90D8      	BCF STATUS,C
020C  323F      	RRCF CompTempVarRet1822, F
020E  0640      	DECF CompTempVar1827, F
0210  D7FA      	BRA	label26

		}
0208  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BatailleNavale\lignes_ok.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Monday, January 16, 2017 16:55:08
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0xFB
#endif
#ifdef HI_TECH_C
__CONFIG(0xFB);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)

void FCM_lignesV();
void FCM_lignesH();

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 porta
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 porta
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisa
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisa
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (2)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
06BE  0E00      	MOVLW 0x00
06C0  6E2C      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
06C2  0E01      	MOVLW 0x01
06C4  6E2D      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
06C6  0E02      	MOVLW 0x02
06C8  6E2E      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
06CA  0E03      	MOVLW 0x03
06CC  6E2F      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
06CE  0E04      	MOVLW 0x04
06D0  6E30      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
06D2  0E05      	MOVLW 0x05
06D4  6E31      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
06D6  0E06      	MOVLW 0x06
06D8  6E32      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
06DA  0E07      	MOVLW 0x07
06DC  6E33      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
06DE  6A19      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009
06E0  6A1A      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1'
06E2  6A1B      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2'
06E4  6A1C      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3'

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
06E6  6A34      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x63);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)
{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;

	if (FCL_AXIS == 0)
	{

	} else {

		if (FCL_AXIS == 'x')
		{

		} else {

			if (FCL_AXIS == 'X')
			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;

			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;

FCC_G4D_ReadTouchCoordinatesPicaso_A:
;

	if (FCL_AXIS == 1)
	{

	} else {

		if (FCL_AXIS == 'y')
		{

		} else {

			if (FCL_AXIS == 'Y')
			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;

			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;

FCC_G4D_ReadTouchCoordinatesPicaso_B:
;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()
{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x6F);

	FC_CAL_UART_Send_1(4);

	FC_CAL_UART_Receive_1(255);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL)
	{

		FC_CAL_UART_Send_1(0x6F);

		FC_CAL_UART_Send_1(5);

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_1(255);

		FCL_TEMP = FC_CAL_UART_Receive_1(255);

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_1(255);

		FCL_TEMP = FC_CAL_UART_Receive_1(255);

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;

	// } else {

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_1(FCL_RADIUS);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
0252  6A3D      	CLRF FCD_0f051__0005C_1_FCL_D1
0254  6A3E      	CLRF FCD_0f051__0005C_1_FCL_D1+D'1'

	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
0256  0E01      	MOVLW 0x01
0258  6E3F      	MOVWF FCD_0f051__0005C_1_FCL_YINC
025A  6A40      	CLRF FCD_0f051__0005C_1_FCL_YINC+D'1'

	MX_SINT16 FCL_XINC = (1);
025C  0E01      	MOVLW 0x01
025E  6E41      	MOVWF FCD_0f051__0005C_1_FCL_XINC
0260  6A42      	CLRF FCD_0f051__0005C_1_FCL_XINC+D'1'



	FC_CAL_UART_Send_1(0x4C);
0262  0E4C      	MOVLW 0x4C
0264  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
0266  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
0268  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
026C  5036      	MOVF FCD_0f051__0005C_arg_FCL_X1+D'1', W
026E  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
0270  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
0272  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCL_X1);
0276  5035      	MOVF FCD_0f051__0005C_arg_FCL_X1, W
0278  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
027A  5036      	MOVF FCD_0f051__0005C_arg_FCL_X1+D'1', W
027C  6E44      	MOVWF FC_CAL_UAR_00062_arg_nChar+D'1'
027E  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0282  5038      	MOVF FCD_0f051__0005C_arg_FCL_Y1+D'1', W
0284  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
0286  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
0288  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCL_Y1);
028C  5037      	MOVF FCD_0f051__0005C_arg_FCL_Y1, W
028E  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
0290  5038      	MOVF FCD_0f051__0005C_arg_FCL_Y1+D'1', W
0292  6E44      	MOVWF FC_CAL_UAR_00062_arg_nChar+D'1'
0294  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
0298  503A      	MOVF FCD_0f051__0005C_arg_FCL_X2+D'1', W
029A  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
029C  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
029E  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCL_X2);
02A2  5039      	MOVF FCD_0f051__0005C_arg_FCL_X2, W
02A4  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
02A6  503A      	MOVF FCD_0f051__0005C_arg_FCL_X2+D'1', W
02A8  6E44      	MOVWF FC_CAL_UAR_00062_arg_nChar+D'1'
02AA  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
02AE  503C      	MOVF FCD_0f051__0005C_arg_FCL_Y2+D'1', W
02B0  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
02B2  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
02B4  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCL_Y2);
02B8  503B      	MOVF FCD_0f051__0005C_arg_FCL_Y2, W
02BA  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
02BC  503C      	MOVF FCD_0f051__0005C_arg_FCL_Y2+D'1', W
02BE  6E44      	MOVWF FC_CAL_UAR_00062_arg_nChar+D'1'
02C0  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
02C4  5022      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
02C6  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
02C8  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
02CA  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
02CE  5021      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W
02D0  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
02D2  5022      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
02D4  6E44      	MOVWF FC_CAL_UAR_00062_arg_nChar+D'1'
02D6  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Receive_1(255);
02DA  6843      	SETF FC_CAL_UAR_00061_arg_nTimeout
02DC  EC4EF000  	CALL FC_CAL_UAR_00061


}
02E0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_POSH >> 8);

	FC_CAL_UART_Send_1(FCL_POSH);

	FC_CAL_UART_Send_1(FCL_POSL >> 8);

	FC_CAL_UART_Send_1(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x05);

	FC_CAL_UART_Send_1(0x01);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x00);

	FC_CAL_UART_Send_1(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x01);

	FC_CAL_UART_Send_1(FCL_DISPLAY);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x02);

	FC_CAL_UART_Send_1(FCL_CONTRAST);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x05);

	FC_CAL_UART_Send_1(0x00);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x05);

	FC_CAL_UART_Send_1(0x02);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x56);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_1(0x10);

	} else {

		FC_CAL_UART_Send_1(0x08);

	}

	FC_CAL_UART_Send_1(FCL_DELAY);

	FC_CAL_UART_Send_1(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_1(FCL_FRAMES);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x76);

	FC_CAL_UART_Send_1(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_1(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_1(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_1(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_1(0x03);

		}
	}

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x65);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RX >> 8);

	FC_CAL_UART_Send_1(FCL_RX);

	FC_CAL_UART_Send_1(FCL_RY >> 8);

	FC_CAL_UART_Send_1(FCL_RY);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);


	FC_CAL_UART_Send_1(0x4F);

	if (FCL_TRANSPARENT)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x53);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_FONT);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Send_1(1);

	FC_CAL_UART_Send_1(1);

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		if (FCL_STR[FCL_IDX] == 0)
		{

			goto FCC_Print_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_STR[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_Print_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x0c);

	FC_CAL_UART_Send_1(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
0212  6A39      	CLRF FCD_0f051__00093_1_FCL_Y
0214  6A3A      	CLRF FCD_0f051__00093_1_FCL_Y+D'1'

	MX_UINT16 FCL_X = (0x0);
0216  6A3B      	CLRF FCD_0f051__00093_1_FCL_X
0218  6A3C      	CLRF FCD_0f051__00093_1_FCL_X+D'1'



	FC_CAL_UART_Send_1(0x42);
021A  0E42      	MOVLW 0x42
021C  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
021E  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
0220  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
0224  5020      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
0226  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
0228  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
022A  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
022E  501F      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W
0230  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
0232  5020      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
0234  6E44      	MOVWF FC_CAL_UAR_00062_arg_nChar+D'1'
0236  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Receive_1(255);
023A  6843      	SETF FC_CAL_UAR_00061_arg_nTimeout
023C  EC4EF000  	CALL FC_CAL_UAR_00061


	FC_CAL_UART_Send_1(0x45);
0240  0E45      	MOVLW 0x45
0242  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
0244  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
0246  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Receive_1(255);
024A  6843      	SETF FC_CAL_UAR_00061_arg_nTimeout
024C  EC4EF000  	CALL FC_CAL_UAR_00061


}
0250  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x49);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x75);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6C);

	FC_CAL_UART_Send_1(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
	{

		FC_CAL_UART_Send_1(0x70);

		FC_CAL_UART_Send_1(0x00);

		FC_CAL_UART_Receive_1(255);

		FC_CAL_UART_Send_1(0x72);

		FC_CAL_UART_Send_1(FCL_X1 >> 8);

		FC_CAL_UART_Send_1(FCL_X1);

		FC_CAL_UART_Send_1(FCL_Y1 >> 8);

		FC_CAL_UART_Send_1(FCL_Y1);

		FC_CAL_UART_Send_1(FCL_X2 >> 8);

		FC_CAL_UART_Send_1(FCL_X2);

		FC_CAL_UART_Send_1(FCL_Y2 >> 8);

		FC_CAL_UART_Send_1(FCL_Y2);

		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

		FC_CAL_UART_Receive_1(255);

	// } else {

	}

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x72);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, C, 0x20, 0x5, 0);
04EE  6A39      	CLRF FCD_0f051__0009E_2_ptmp
04F0  9A94      	BCF gbl_trisc,5
04F2  5239      	MOVF FCD_0f051__0009E_2_ptmp, F
04F4  E004      	BZ	label27
04F6  0E20      	MOVLW 0x20
04F8  108B      	IORWF gbl_latc, W
04FA  6E82      	MOVWF gbl_portc
04FC  D003      	BRA	label28
04FE            label27
04FE  0EDF      	MOVLW 0xDF
0500  148B      	ANDWF gbl_latc, W
0502  6E82      	MOVWF gbl_portc
0504            label28


	FC_CAL_UART_Init_1();
0504  ECA0F000  	CALL FC_CAL_UAR_00063


	FCI_DELAYBYTE_US(100);
0508  0E64      	MOVLW 0x64
050A  6E39      	MOVWF delay_us_00000_arg_del
050C  EC2EF000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, C, 0x20, 0x5);
0510  0E0F      	MOVLW HIGH(gbl_portc+D'0')
0512  6E3A      	MOVWF FC_CAL_Por_00042_arg_Port+D'1'
0514  0E82      	MOVLW LOW(gbl_portc+D'0')
0516  6E39      	MOVWF FC_CAL_Por_00042_arg_Port
0518  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
051A  6E3C      	MOVWF FC_CAL_Por_00042_arg_Tris+D'1'
051C  0E94      	MOVLW LOW(gbl_trisc+D'0')
051E  6E3B      	MOVWF FC_CAL_Por_00042_arg_Tris
0520  0E20      	MOVLW 0x20
0522  6E3D      	MOVWF FC_CAL_Por_00042_arg_InMask
0524  0E05      	MOVLW 0x05
0526  6E3E      	MOVWF FC_CAL_Por_00042_arg_Shift
0528  ECF1F000  	CALL FC_CAL_Por_00042
052C  503F      	MOVF CompTempVarRet1822, W
052E  6E38      	MOVWF FCD_0f051__0009E_1_FCL_DUMMY


	FCI_DELAYBYTE_S(3);
0530  0E03      	MOVLW 0x03
0532  6E39      	MOVWF delay_s_00000_arg_del
0534  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_1(0);
0538  6A43      	CLRF FC_CAL_UAR_00061_arg_nTimeout
053A  EC4EF000  	CALL FC_CAL_UAR_00061


	FC_CAL_UART_Receive_1(0);
053E  6A43      	CLRF FC_CAL_UAR_00061_arg_nTimeout
0540  EC4EF000  	CALL FC_CAL_UAR_00061


	FC_CAL_UART_Receive_1(0);
0544  6A43      	CLRF FC_CAL_UAR_00061_arg_nTimeout
0546  EC4EF000  	CALL FC_CAL_UAR_00061


	FC_CAL_UART_Send_1(0x55);
054A  0E55      	MOVLW 0x55
054C  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
054E  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
0550  EC46F000  	CALL FC_CAL_UAR_00062


	FC_CAL_UART_Receive_1(255);
0554  6843      	SETF FC_CAL_UAR_00061_arg_nTimeout
0556  EC4EF000  	CALL FC_CAL_UAR_00061


	#if (1) // 1 == 1

		#if (1) // 1 != 0

			FC_CAL_UART_Send_1(0x51);
055A  0E51      	MOVLW 0x51
055C  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
055E  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
0560  EC46F000  	CALL FC_CAL_UAR_00062


			FC_CAL_UART_Send_1(0x0C);
0564  0E0C      	MOVLW 0x0C
0566  6E43      	MOVWF FC_CAL_UAR_00062_arg_nChar
0568  6A44      	CLRF FC_CAL_UAR_00062_arg_nChar+D'1'
056A  EC46F000  	CALL FC_CAL_UAR_00062


			FC_CAL_UART_Receive_1(255);
056E  6843      	SETF FC_CAL_UAR_00061_arg_nTimeout
0570  EC4EF000  	CALL FC_CAL_UAR_00061


			FC_CAL_UART_UpdateBaud_1(6);
0574  0E06      	MOVLW 0x06
0576  6E39      	MOVWF FC_CAL_UAR_0005F_arg_new_baud
0578  ECA9F000  	CALL FC_CAL_UAR_0005F



		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_1(10);
057C  0E0A      	MOVLW 0x0A
057E  6E43      	MOVWF FC_CAL_UAR_00061_arg_nTimeout
0580  EC4EF000  	CALL FC_CAL_UAR_00061


	FC_CAL_UART_Receive_1(10);
0584  0E0A      	MOVLW 0x0A
0586  6E43      	MOVWF FC_CAL_UAR_00061_arg_nTimeout
0588  EC4EF000  	CALL FC_CAL_UAR_00061


	FCL_RED = 0 & 0xFF;
058C  6A35      	CLRF FCD_0f051__0009E_1_FCL_RED

	FCL_RED = FCL_RED >> (8 - 5);
058E  3235      	RRCF FCD_0f051__0009E_1_FCL_RED, F
0590  3235      	RRCF FCD_0f051__0009E_1_FCL_RED, F
0592  3235      	RRCF FCD_0f051__0009E_1_FCL_RED, F
0594  0E1F      	MOVLW 0x1F
0596  1635      	ANDWF FCD_0f051__0009E_1_FCL_RED, F

	FCL_GREEN = (0 >> 8) & 0xFF;
0598  6A36      	CLRF FCD_0f051__0009E_1_FCL_GREEN

	FCL_GREEN = FCL_GREEN >> (8 - 6);
059A  3236      	RRCF FCD_0f051__0009E_1_FCL_GREEN, F
059C  3236      	RRCF FCD_0f051__0009E_1_FCL_GREEN, F
059E  0E3F      	MOVLW 0x3F
05A0  1636      	ANDWF FCD_0f051__0009E_1_FCL_GREEN, F

	FCL_BLUE = (0 >> 16) & 0xFF;
05A2  6A37      	CLRF FCD_0f051__0009E_1_FCL_BLUE

	FCL_BLUE = FCL_BLUE >> (8 - 5);
05A4  3237      	RRCF FCD_0f051__0009E_1_FCL_BLUE, F
05A6  3237      	RRCF FCD_0f051__0009E_1_FCL_BLUE, F
05A8  3237      	RRCF FCD_0f051__0009E_1_FCL_BLUE, F
05AA  0E1F      	MOVLW 0x1F
05AC  1637      	ANDWF FCD_0f051__0009E_1_FCL_BLUE, F

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
05AE  5036      	MOVF FCD_0f051__0009E_1_FCL_GREEN, W
05B0  6E39      	MOVWF CompTempVar2962
05B2  6A22      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1'
05B4  3639      	RLCF CompTempVar2962, F
05B6  3622      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
05B8  3639      	RLCF CompTempVar2962, F
05BA  3622      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
05BC  3639      	RLCF CompTempVar2962, F
05BE  3622      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
05C0  3639      	RLCF CompTempVar2962, F
05C2  3622      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
05C4  3639      	RLCF CompTempVar2962, F
05C6  3622      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
05C8  0EE0      	MOVLW 0xE0
05CA  1639      	ANDWF CompTempVar2962, F
05CC  5039      	MOVF CompTempVar2962, W
05CE  1037      	IORWF FCD_0f051__0009E_1_FCL_BLUE, W
05D0  6E21      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
05D2  6A39      	CLRF CompTempVar2966
05D4  5035      	MOVF FCD_0f051__0009E_1_FCL_RED, W
05D6  6E3A      	MOVWF CompTempVar2967
05D8  90D8      	BCF STATUS,C
05DA  363A      	RLCF CompTempVar2967, F
05DC  90D8      	BCF STATUS,C
05DE  363A      	RLCF CompTempVar2967, F
05E0  90D8      	BCF STATUS,C
05E2  363A      	RLCF CompTempVar2967, F
05E4  5039      	MOVF CompTempVar2966, W
05E6  1221      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F
05E8  503A      	MOVF CompTempVar2967, W
05EA  1222      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F

	FCL_RED = 16777215 & 0xFF;
05EC  6835      	SETF FCD_0f051__0009E_1_FCL_RED

	FCL_RED = FCL_RED >> (8 - 5);
05EE  3235      	RRCF FCD_0f051__0009E_1_FCL_RED, F
05F0  3235      	RRCF FCD_0f051__0009E_1_FCL_RED, F
05F2  3235      	RRCF FCD_0f051__0009E_1_FCL_RED, F
05F4  0E1F      	MOVLW 0x1F
05F6  1635      	ANDWF FCD_0f051__0009E_1_FCL_RED, F

	FCL_GREEN = (16777215 >> 8) & 0xFF;
05F8  6836      	SETF FCD_0f051__0009E_1_FCL_GREEN

	FCL_GREEN = FCL_GREEN >> (8 - 6);
05FA  3236      	RRCF FCD_0f051__0009E_1_FCL_GREEN, F
05FC  3236      	RRCF FCD_0f051__0009E_1_FCL_GREEN, F
05FE  0E3F      	MOVLW 0x3F
0600  1636      	ANDWF FCD_0f051__0009E_1_FCL_GREEN, F

	FCL_BLUE = (16777215 >> 16) & 0xFF;
0602  6837      	SETF FCD_0f051__0009E_1_FCL_BLUE

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0604  3237      	RRCF FCD_0f051__0009E_1_FCL_BLUE, F
0606  3237      	RRCF FCD_0f051__0009E_1_FCL_BLUE, F
0608  3237      	RRCF FCD_0f051__0009E_1_FCL_BLUE, F
060A  0E1F      	MOVLW 0x1F
060C  1637      	ANDWF FCD_0f051__0009E_1_FCL_BLUE, F

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
060E  5036      	MOVF FCD_0f051__0009E_1_FCL_GREEN, W
0610  6E39      	MOVWF CompTempVar2973
0612  6A20      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1'
0614  3639      	RLCF CompTempVar2973, F
0616  3620      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
0618  3639      	RLCF CompTempVar2973, F
061A  3620      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
061C  3639      	RLCF CompTempVar2973, F
061E  3620      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
0620  3639      	RLCF CompTempVar2973, F
0622  3620      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
0624  3639      	RLCF CompTempVar2973, F
0626  3620      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
0628  0EE0      	MOVLW 0xE0
062A  1639      	ANDWF CompTempVar2973, F
062C  5039      	MOVF CompTempVar2973, W
062E  1037      	IORWF FCD_0f051__0009E_1_FCL_BLUE, W
0630  6E1F      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
0632  6A39      	CLRF CompTempVar2977
0634  5035      	MOVF FCD_0f051__0009E_1_FCL_RED, W
0636  6E3A      	MOVWF CompTempVar2978
0638  90D8      	BCF STATUS,C
063A  363A      	RLCF CompTempVar2978, F
063C  90D8      	BCF STATUS,C
063E  363A      	RLCF CompTempVar2978, F
0640  90D8      	BCF STATUS,C
0642  363A      	RLCF CompTempVar2978, F
0644  5039      	MOVF CompTempVar2977, W
0646  121F      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F
0648  503A      	MOVF CompTempVar2978, W
064A  1220      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
064C  EC09F001  	CALL FCD_0f051__00093


	FC_CAL_UART_Receive_1(10);
0650  0E0A      	MOVLW 0x0A
0652  6E43      	MOVWF FC_CAL_UAR_00061_arg_nTimeout
0654  EC4EF000  	CALL FC_CAL_UAR_00061


	FC_CAL_UART_Receive_1(10);
0658  0E0A      	MOVLW 0x0A
065A  6E43      	MOVWF FC_CAL_UAR_00061_arg_nTimeout
065C  EC4EF000  	CALL FC_CAL_UAR_00061


}
0660  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_lignesV()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(24, 0, 24, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(24, 0, 24, 240);
03E8  0E18      	MOVLW 0x18
03EA  6E35      	MOVWF FCD_0f051__0005C_arg_FCL_X1
03EC  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
03EE  6A37      	CLRF FCD_0f051__0005C_arg_FCL_Y1
03F0  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
03F2  0E18      	MOVLW 0x18
03F4  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
03F6  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
03F8  0EF0      	MOVLW 0xF0
03FA  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
03FC  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
03FE  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(48, 0, 48, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(48, 0, 48, 240);
0402  0E30      	MOVLW 0x30
0404  6E35      	MOVWF FCD_0f051__0005C_arg_FCL_X1
0406  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
0408  6A37      	CLRF FCD_0f051__0005C_arg_FCL_Y1
040A  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
040C  0E30      	MOVLW 0x30
040E  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
0410  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
0412  0EF0      	MOVLW 0xF0
0414  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
0416  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
0418  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(72, 0, 72, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(72, 0, 72, 240);
041C  0E48      	MOVLW 0x48
041E  6E35      	MOVWF FCD_0f051__0005C_arg_FCL_X1
0420  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
0422  6A37      	CLRF FCD_0f051__0005C_arg_FCL_Y1
0424  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
0426  0E48      	MOVLW 0x48
0428  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
042A  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
042C  0EF0      	MOVLW 0xF0
042E  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
0430  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
0432  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(96, 0, 96, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(96, 0, 96, 240);
0436  0E60      	MOVLW 0x60
0438  6E35      	MOVWF FCD_0f051__0005C_arg_FCL_X1
043A  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
043C  6A37      	CLRF FCD_0f051__0005C_arg_FCL_Y1
043E  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
0440  0E60      	MOVLW 0x60
0442  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
0444  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
0446  0EF0      	MOVLW 0xF0
0448  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
044A  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
044C  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(120, 0, 120, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(120, 0, 120, 240);
0450  0E78      	MOVLW 0x78
0452  6E35      	MOVWF FCD_0f051__0005C_arg_FCL_X1
0454  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
0456  6A37      	CLRF FCD_0f051__0005C_arg_FCL_Y1
0458  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
045A  0E78      	MOVLW 0x78
045C  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
045E  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
0460  0EF0      	MOVLW 0xF0
0462  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
0464  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
0466  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(144, 0, 144, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(144, 0, 144, 240);
046A  0E90      	MOVLW 0x90
046C  6E35      	MOVWF FCD_0f051__0005C_arg_FCL_X1
046E  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
0470  6A37      	CLRF FCD_0f051__0005C_arg_FCL_Y1
0472  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
0474  0E90      	MOVLW 0x90
0476  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
0478  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
047A  0EF0      	MOVLW 0xF0
047C  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
047E  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
0480  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(168, 0, 168, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(168, 0, 168, 240);
0484  0EA8      	MOVLW 0xA8
0486  6E35      	MOVWF FCD_0f051__0005C_arg_FCL_X1
0488  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
048A  6A37      	CLRF FCD_0f051__0005C_arg_FCL_Y1
048C  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
048E  0EA8      	MOVLW 0xA8
0490  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
0492  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
0494  0EF0      	MOVLW 0xF0
0496  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
0498  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
049A  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(192, 0, 192, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(192, 0, 192, 240);
049E  0EC0      	MOVLW 0xC0
04A0  6E35      	MOVWF FCD_0f051__0005C_arg_FCL_X1
04A2  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
04A4  6A37      	CLRF FCD_0f051__0005C_arg_FCL_Y1
04A6  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
04A8  0EC0      	MOVLW 0xC0
04AA  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
04AC  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
04AE  0EF0      	MOVLW 0xF0
04B0  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
04B2  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
04B4  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(216, 0, 216, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(216, 0, 216, 240);
04B8  0ED8      	MOVLW 0xD8
04BA  6E35      	MOVWF FCD_0f051__0005C_arg_FCL_X1
04BC  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
04BE  6A37      	CLRF FCD_0f051__0005C_arg_FCL_Y1
04C0  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
04C2  0ED8      	MOVLW 0xD8
04C4  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
04C6  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
04C8  0EF0      	MOVLW 0xF0
04CA  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
04CC  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
04CE  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(240, 0, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(240, 0, 240, 240);
04D2  0EF0      	MOVLW 0xF0
04D4  6E35      	MOVWF FCD_0f051__0005C_arg_FCL_X1
04D6  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
04D8  6A37      	CLRF FCD_0f051__0005C_arg_FCL_Y1
04DA  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
04DC  0EF0      	MOVLW 0xF0
04DE  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
04E0  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
04E2  0EF0      	MOVLW 0xF0
04E4  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
04E6  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
04E8  EC29F001  	CALL FCD_0f051__0005C


}
04EC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_lignesH()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 24, 240, 24)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 24, 240, 24);
02E2  6A35      	CLRF FCD_0f051__0005C_arg_FCL_X1
02E4  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
02E6  0E18      	MOVLW 0x18
02E8  6E37      	MOVWF FCD_0f051__0005C_arg_FCL_Y1
02EA  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
02EC  0EF0      	MOVLW 0xF0
02EE  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
02F0  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
02F2  0E18      	MOVLW 0x18
02F4  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
02F6  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
02F8  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 48, 240, 48)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 48, 240, 48);
02FC  6A35      	CLRF FCD_0f051__0005C_arg_FCL_X1
02FE  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
0300  0E30      	MOVLW 0x30
0302  6E37      	MOVWF FCD_0f051__0005C_arg_FCL_Y1
0304  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
0306  0EF0      	MOVLW 0xF0
0308  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
030A  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
030C  0E30      	MOVLW 0x30
030E  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
0310  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
0312  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 72, 240, 72)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 72, 240, 72);
0316  6A35      	CLRF FCD_0f051__0005C_arg_FCL_X1
0318  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
031A  0E48      	MOVLW 0x48
031C  6E37      	MOVWF FCD_0f051__0005C_arg_FCL_Y1
031E  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
0320  0EF0      	MOVLW 0xF0
0322  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
0324  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
0326  0E48      	MOVLW 0x48
0328  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
032A  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
032C  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 96, 240, 96)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 96, 240, 96);
0330  6A35      	CLRF FCD_0f051__0005C_arg_FCL_X1
0332  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
0334  0E60      	MOVLW 0x60
0336  6E37      	MOVWF FCD_0f051__0005C_arg_FCL_Y1
0338  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
033A  0EF0      	MOVLW 0xF0
033C  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
033E  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
0340  0E60      	MOVLW 0x60
0342  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
0344  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
0346  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 120, 240, 120)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 120, 240, 120);
034A  6A35      	CLRF FCD_0f051__0005C_arg_FCL_X1
034C  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
034E  0E78      	MOVLW 0x78
0350  6E37      	MOVWF FCD_0f051__0005C_arg_FCL_Y1
0352  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
0354  0EF0      	MOVLW 0xF0
0356  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
0358  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
035A  0E78      	MOVLW 0x78
035C  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
035E  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
0360  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 144, 240, 144)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 144, 240, 144);
0364  6A35      	CLRF FCD_0f051__0005C_arg_FCL_X1
0366  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
0368  0E90      	MOVLW 0x90
036A  6E37      	MOVWF FCD_0f051__0005C_arg_FCL_Y1
036C  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
036E  0EF0      	MOVLW 0xF0
0370  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
0372  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
0374  0E90      	MOVLW 0x90
0376  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
0378  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
037A  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 168, 240, 168)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 168, 240, 168);
037E  6A35      	CLRF FCD_0f051__0005C_arg_FCL_X1
0380  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
0382  0EA8      	MOVLW 0xA8
0384  6E37      	MOVWF FCD_0f051__0005C_arg_FCL_Y1
0386  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
0388  0EF0      	MOVLW 0xF0
038A  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
038C  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
038E  0EA8      	MOVLW 0xA8
0390  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
0392  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
0394  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 192, 240, 192)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 192, 240, 192);
0398  6A35      	CLRF FCD_0f051__0005C_arg_FCL_X1
039A  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
039C  0EC0      	MOVLW 0xC0
039E  6E37      	MOVWF FCD_0f051__0005C_arg_FCL_Y1
03A0  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
03A2  0EF0      	MOVLW 0xF0
03A4  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
03A6  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
03A8  0EC0      	MOVLW 0xC0
03AA  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
03AC  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
03AE  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 216, 240, 216)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 216, 240, 216);
03B2  6A35      	CLRF FCD_0f051__0005C_arg_FCL_X1
03B4  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
03B6  0ED8      	MOVLW 0xD8
03B8  6E37      	MOVWF FCD_0f051__0005C_arg_FCL_Y1
03BA  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
03BC  0EF0      	MOVLW 0xF0
03BE  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
03C0  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
03C2  0ED8      	MOVLW 0xD8
03C4  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
03C6  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
03C8  EC29F001  	CALL FCD_0f051__0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, 240, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__DrawLine(0, 240, 240, 240);
03CC  6A35      	CLRF FCD_0f051__0005C_arg_FCL_X1
03CE  6A36      	CLRF FCD_0f051__0005C_arg_FCL_X1+D'1'
03D0  0EF0      	MOVLW 0xF0
03D2  6E37      	MOVWF FCD_0f051__0005C_arg_FCL_Y1
03D4  6A38      	CLRF FCD_0f051__0005C_arg_FCL_Y1+D'1'
03D6  0EF0      	MOVLW 0xF0
03D8  6E39      	MOVWF FCD_0f051__0005C_arg_FCL_X2
03DA  6A3A      	CLRF FCD_0f051__0005C_arg_FCL_X2+D'1'
03DC  0EF0      	MOVLW 0xF0
03DE  6E3B      	MOVWF FCD_0f051__0005C_arg_FCL_Y2
03E0  6A3C      	CLRF FCD_0f051__0005C_arg_FCL_Y2+D'1'
03E2  EC29F001  	CALL FCD_0f051__0005C


}
03E6  0012      	RETURN




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
0662  0E0F      	MOVLW 0x0F
0664  6EC1      	MOVWF gbl_adcon1





	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
0666  EC77F002  	CALL FCD_0f051__0009E


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
066A  EC09F001  	CALL FCD_0f051__00093


	// Boucle
	// Boucle: While 1
	while (1)
066E            label29
0676  D7FB      	BRA	label29

	{

		// lignes horizontales
		// Appel d'une Macro: lignesH()
		FCM_lignesH();
066E  EC71F001  	CALL FCM_lignes_0005D


		// Appel d'une Macro
		// Appel d'une Macro: lignesV()
		FCM_lignesV();
0672  ECF4F001  	CALL FCM_lignes_0005B



	}

	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

}
06EC  CFEAF001  	MOVFF FSR0H,  Int1Context
06F0  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
06F4  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
06F8  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
06FC  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
0700  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
0704  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
0708  C001FFEA  	MOVFF Int1Context,  FSR0H
070C  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0140  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0142  0E7F      	MOVLW 0x7F
0144  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0146  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0148  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
014A  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
014C  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
014E  9A9D      	BCF gbl_pie1,5

			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0150  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
013A  6AAB      	CLRF gbl_rcsta

			txsta = 0;
013C  6AAC      	CLRF gbl_txsta

		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}
013E  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
008C            label5
008C  0E10      	MOVLW 0x10
008E  149E      	ANDWF gbl_pir1, W
0090  6E45      	MOVWF CompTempVar2647
0092  5245      	MOVF CompTempVar2647, F
0094  E0FB      	BZ	label5


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0096  5043      	MOVF FC_CAL_UAR_00062_arg_nChar, W
0098  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
009A  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
009C  6844      	SETF FC_CAL_UAR_00061_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
009E  6A45      	CLRF FC_CAL_UAR_00061_1_delay1

	MX_UINT8 regcheck = 0;
00A0  6A46      	CLRF FC_CAL_UAR_00061_1_regcheck

	MX_UINT8 bWaitForever = 0;
00A2  6A47      	CLRF FC_CAL_UAR_00061_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
00A4  6A48      	CLRF FC_CAL_UAR_00061_1_rxStatus

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
00A6  6A4B      	CLRF FC_CAL_UAR_00061_1_dummy

  #endif

	if (nTimeout == 255)
00A8  2843      	INCF FC_CAL_UAR_00061_arg_nTimeout, W
00AA  E102      	BNZ	label6
00B0            label6

		bWaitForever = 1;
00AC  0E01      	MOVLW 0x01
00AE  6E47      	MOVWF FC_CAL_UAR_00061_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00B0  5248      	MOVF FC_CAL_UAR_00061_1_rxStatus, F
00B2  E124      	BNZ	label11
00FA  D7DA      	BRA	label6
00FC            label11

	{
		if (bWaitForever == 0)
00B4  5247      	MOVF FC_CAL_UAR_00061_1_bWaitForever, F
00B6  E118      	BNZ	label10

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00B8  5243      	MOVF FC_CAL_UAR_00061_arg_nTimeout, F
00BA  E103      	BNZ	label7
00C2            label7

			{
				rxStatus = UART_STATUS_TIMEOUT;
00BC  0E01      	MOVLW 0x01
00BE  6E48      	MOVWF FC_CAL_UAR_00061_1_rxStatus

			}
			else
00C0  D013      	BRA	label10

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00C2  6A49      	CLRF FC_CAL_UAR_00061_1_delaycnt
00C4  6A4A      	CLRF FC_CAL_UAR_00061_1_delaycnt+D'1'
00C6            label8
00C6  0E31      	MOVLW 0x31
00C8  5C49      	SUBWF FC_CAL_UAR_00061_1_delaycnt, W
00CA  E205      	BC	label9
00CC  664A      	TSTFSZ FC_CAL_UAR_00061_1_delaycnt+D'1'
00CE  D003      	BRA	label9
00D0  4A49      	INFSNZ FC_CAL_UAR_00061_1_delaycnt, F
00D2  2A4A      	INCF FC_CAL_UAR_00061_1_delaycnt+D'1', F
00D4  D7F8      	BRA	label8
00D6            label9

				delay1 = delay1 + 1;
00D6  2845      	INCF FC_CAL_UAR_00061_1_delay1, W
00D8  6E45      	MOVWF FC_CAL_UAR_00061_1_delay1

				if(delay1 == 100)
00DA  0E64      	MOVLW 0x64
00DC  6245      	CPFSEQ FC_CAL_UAR_00061_1_delay1
00DE  D004      	BRA	label10
00E8            label10

				{
					nTimeout = nTimeout - 1;
00E0  0443      	DECF FC_CAL_UAR_00061_arg_nTimeout, W
00E2  6E43      	MOVWF FC_CAL_UAR_00061_arg_nTimeout

					MX_CLEAR_WATCHDOG;
00E4  0004      	CLRWDT

					delay1 = 0;
00E6  6A45      	CLRF FC_CAL_UAR_00061_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00E8  0E20      	MOVLW 0x20
00EA  149E      	ANDWF gbl_pir1, W
00EC  6E4C      	MOVWF CompTempVar2644
00EE  504C      	MOVF CompTempVar2644, W
00F0  6E46      	MOVWF FC_CAL_UAR_00061_1_regcheck

			if (regcheck != 0)
00F2  5246      	MOVF FC_CAL_UAR_00061_1_regcheck, F
00F4  E0DD      	BZ	label6

				rxStatus = UART_STATUS_RXBYTE;
00F6  0E02      	MOVLW 0x02
00F8  6E48      	MOVWF FC_CAL_UAR_00061_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00FC  0E02      	MOVLW 0x02
00FE  6248      	CPFSEQ FC_CAL_UAR_00061_1_rxStatus
0100  D018      	BRA	label14

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0102  0E04      	MOVLW 0x04
0104  14AB      	ANDWF gbl_rcsta, W
0106  6E4C      	MOVWF CompTempVar2645
0108  504C      	MOVF CompTempVar2645, W
010A  6E46      	MOVWF FC_CAL_UAR_00061_1_regcheck

			if (regcheck != 0)
010C  5246      	MOVF FC_CAL_UAR_00061_1_regcheck, F
010E  E003      	BZ	label12
0116            label12

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0110  50AE      	MOVF gbl_rcreg, W
0112  6E4B      	MOVWF FC_CAL_UAR_00061_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0114  D00E      	BRA	label14

			{
				regcheck = ts_bit(rcsta, OERR);
0116  0E02      	MOVLW 0x02
0118  14AB      	ANDWF gbl_rcsta, W
011A  6E4C      	MOVWF CompTempVar2646
011C  504C      	MOVF CompTempVar2646, W
011E  6E46      	MOVWF FC_CAL_UAR_00061_1_regcheck

				if (regcheck != 0)
0120  5246      	MOVF FC_CAL_UAR_00061_1_regcheck, F
0122  E003      	BZ	label13
012A            label13

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0124  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0126  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0128  D004      	BRA	label14
0132            label14

				{
					retVal = 0;
012A  6A44      	CLRF FC_CAL_UAR_00061_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
012C  50AE      	MOVF gbl_rcreg, W
012E  1044      	IORWF FC_CAL_UAR_00061_1_retVal, W
0130  6E44      	MOVWF FC_CAL_UAR_00061_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0132  5044      	MOVF FC_CAL_UAR_00061_1_retVal, W
0134  6E4C      	MOVWF CompTempVarRet2643
0136  6A4D      	CLRF CompTempVarRet2643+D'1'

}
0138  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))

{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
0152  0E07      	MOVLW 0x07
0154  6439      	CPFSGT FC_CAL_UAR_0005F_arg_new_baud
0156  D001      	BRA	label15
015A            label15

		return;

	if (new_baud == 0)
015A  5239      	MOVF FC_CAL_UAR_0005F_arg_new_baud, F
015C  E104      	BNZ	label16
0166            label16

	{
		baudrate = MX_HARD_BAUD_1200;
015E  683A      	SETF FC_CAL_UAR_0005F_1_baudrate

		baudmode = MX_HARD_SLOW_1200;
0160  0E01      	MOVLW 0x01
0162  6E3B      	MOVWF FC_CAL_UAR_0005F_1_baudmode

	}
	else if (new_baud == 1)
0164  D02F      	BRA	label23
0166  0439      	DECF FC_CAL_UAR_0005F_arg_new_baud, W
0168  E105      	BNZ	label17
0174            label17

	{
		baudrate = MX_HARD_BAUD_2400;
016A  0E7F      	MOVLW 0x7F
016C  6E3A      	MOVWF FC_CAL_UAR_0005F_1_baudrate

		baudmode = MX_HARD_SLOW_2400;
016E  0E01      	MOVLW 0x01
0170  6E3B      	MOVWF FC_CAL_UAR_0005F_1_baudmode

	}
	else if (new_baud == 2)
0172  D028      	BRA	label23
0174  0E02      	MOVLW 0x02
0176  6239      	CPFSEQ FC_CAL_UAR_0005F_arg_new_baud
0178  D003      	BRA	label18
0180            label18

	{
		baudrate = MX_HARD_BAUD_4800;
017A  683A      	SETF FC_CAL_UAR_0005F_1_baudrate

		baudmode = MX_HARD_SLOW_4800;
017C  6A3B      	CLRF FC_CAL_UAR_0005F_1_baudmode

	}
	else if (new_baud == 3)
017E  D022      	BRA	label23
0180  0E03      	MOVLW 0x03
0182  6239      	CPFSEQ FC_CAL_UAR_0005F_arg_new_baud
0184  D004      	BRA	label19
018E            label19

	{
		baudrate = MX_HARD_BAUD_9600;
0186  0E7F      	MOVLW 0x7F
0188  6E3A      	MOVWF FC_CAL_UAR_0005F_1_baudrate

		baudmode = MX_HARD_SLOW_9600;
018A  6A3B      	CLRF FC_CAL_UAR_0005F_1_baudmode

	}
	else if (new_baud == 4)
018C  D01B      	BRA	label23
018E  0E04      	MOVLW 0x04
0190  6239      	CPFSEQ FC_CAL_UAR_0005F_arg_new_baud
0192  D004      	BRA	label20
019C            label20

	{
		baudrate = MX_HARD_BAUD_19200;
0194  0E3F      	MOVLW 0x3F
0196  6E3A      	MOVWF FC_CAL_UAR_0005F_1_baudrate

		baudmode = MX_HARD_SLOW_19200;
0198  6A3B      	CLRF FC_CAL_UAR_0005F_1_baudmode

	}
	else if (new_baud == 5)
019A  D014      	BRA	label23
019C  0E05      	MOVLW 0x05
019E  6239      	CPFSEQ FC_CAL_UAR_0005F_arg_new_baud
01A0  D004      	BRA	label21
01AA            label21

	{
		baudrate = MX_HARD_BAUD_38400;
01A2  0E1F      	MOVLW 0x1F
01A4  6E3A      	MOVWF FC_CAL_UAR_0005F_1_baudrate

		baudmode = MX_HARD_SLOW_38400;
01A6  6A3B      	CLRF FC_CAL_UAR_0005F_1_baudmode

	}
	else if (new_baud == 6)
01A8  D00D      	BRA	label23
01AA  0E06      	MOVLW 0x06
01AC  6239      	CPFSEQ FC_CAL_UAR_0005F_arg_new_baud
01AE  D004      	BRA	label22
01B8            label22

	{
		baudrate = MX_HARD_BAUD_57600;
01B0  0E14      	MOVLW 0x14
01B2  6E3A      	MOVWF FC_CAL_UAR_0005F_1_baudrate

		baudmode = MX_HARD_SLOW_57600;
01B4  6A3B      	CLRF FC_CAL_UAR_0005F_1_baudmode

	}
	else if (new_baud == 7)
01B6  D006      	BRA	label23
01B8  0E07      	MOVLW 0x07
01BA  6239      	CPFSEQ FC_CAL_UAR_0005F_arg_new_baud
01BC  D003      	BRA	label23
01C4            label23

	{
		baudrate = MX_HARD_BAUD_115200;
01BE  0E0A      	MOVLW 0x0A
01C0  6E3A      	MOVWF FC_CAL_UAR_0005F_1_baudrate

		baudmode = MX_HARD_SLOW_115200;
01C2  6A3B      	CLRF FC_CAL_UAR_0005F_1_baudmode

	}

	UART_Uninit();
01C4  EC9DF000  	CALL FC_CAL_UAR_00060


	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
01C8  043B      	DECF FC_CAL_UAR_0005F_1_baudmode, W
01CA  E102      	BNZ	label24
01D0            label24

			cr_bit(txsta, BRGH);					//Low Speed
01CC  94AC      	BCF gbl_txsta,2

	    else
01CE  D001      	BRA	label25
01D2            label25

			st_bit(txsta, BRGH);					//High Speed
01D0  84AC      	BSF gbl_txsta,2


		spbrg = baudrate;   						// set the baud rate
01D2  503A      	MOVF FC_CAL_UAR_0005F_1_baudrate, W
01D4  6EAF      	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
01D6  6AAB      	CLRF gbl_rcsta


		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
01D8  8EAB      	BSF gbl_rcsta,7

		st_bit(txsta, TXEN);
01DA  8AAC      	BSF gbl_txsta,5

		st_bit(rcsta, CREN);
01DC  88AB      	BSF gbl_rcsta,4


		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
01DE  9A9D      	BCF gbl_pie1,5

		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0158  0012      	RETURN
01E0  0012      	RETURN


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF3CF003  	GOTO	_startup

0008  EF76F003  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  523A      	MOVF delay_ms_00000_arg_del, F
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF5      	MOVLW 0xF5
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0FFF      	ADDLW 0xFF
0038  A4D8      	BTFSS STATUS,Z
003A  D7ED      	BRA	label2
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  2E3A      	DECFSZ delay_ms_00000_arg_del, F
0058  D7DD      	BRA	label1
005A  0012      	RETURN
005C            ; } delay_ms function end

005C            delay_us_00000
005C            ; { delay_us ; function begin
005C            label3
005C  0000      	NOP
005E  0000      	NOP
0060  2E39      	DECFSZ delay_us_00000_arg_del, F
0062  D7FC      	BRA	label3
0064  0012      	RETURN
0066            ; } delay_us function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6E3A      	MOVWF delay_ms_00000_arg_del
006A  EC06F000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6E3A      	MOVWF delay_ms_00000_arg_del
0072  EC06F000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6E3A      	MOVWF delay_ms_00000_arg_del
007A  EC06F000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6E3A      	MOVWF delay_ms_00000_arg_del
0082  EC06F000  	CALL delay_ms_00000
0086  2E39      	DECFSZ delay_s_00000_arg_del, F
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end















































0678            _startup
0678  0ED5      	MOVLW 0xD5
067A  6E05      	MOVWF gbl_14_LSR
067C  0EC4      	MOVLW 0xC4
067E  6E06      	MOVWF gbl_14_LSR+D'1'
0680  0EBB      	MOVLW 0xBB
0682  6E07      	MOVWF gbl_14_LSR+D'2'
0684  0EDC      	MOVLW 0xDC
0686  6E08      	MOVWF gbl_14_LSR+D'3'
0688  6A09      	CLRF gbl_15_gbl_aSig
068A  6A0A      	CLRF gbl_15_gbl_aSig+D'1'
068C  6A0B      	CLRF gbl_15_gbl_aSig+D'2'
068E  6A0C      	CLRF gbl_15_gbl_aSig+D'3'
0690  6A0D      	CLRF gbl_15_gbl_bSig
0692  6A0E      	CLRF gbl_15_gbl_bSig+D'1'
0694  6A0F      	CLRF gbl_15_gbl_bSig+D'2'
0696  6A10      	CLRF gbl_15_gbl_bSig+D'3'
0698  6A11      	CLRF gbl_15_gbl_zSig
069A  6A12      	CLRF gbl_15_gbl_zSig+D'1'
069C  6A13      	CLRF gbl_15_gbl_zSig+D'2'
069E  6A14      	CLRF gbl_15_gbl_zSig+D'3'
06A0  6A26      	CLRF gbl_15_gbl_aExp
06A2  6A27      	CLRF gbl_15_gbl_bExp
06A4  6A1D      	CLRF gbl_15_gbl_zExp
06A6  6A1E      	CLRF gbl_15_gbl_zExp+D'1'
06A8  6A28      	CLRF gbl_15_gbl_aSign
06AA  6A29      	CLRF gbl_15_gbl_bSign
06AC  6A2A      	CLRF gbl_15_gbl_zSign
06AE  6A2B      	CLRF gbl_15_gbl_zSigZero
06B0  6A15      	CLRF gbl_15_gbl_ret
06B2  6A16      	CLRF gbl_15_gbl_ret+D'1'
06B4  6A17      	CLRF gbl_15_gbl_ret+D'2'
06B6  6A18      	CLRF gbl_15_gbl_ret+D'3'
06B8  6A24      	CLRF gbl_float_rounding_mode
06BA  6A25      	CLRF gbl_float_exception_flags
06BC  6A23      	CLRF gbl_float_detect_tininess



06E8  EF31F003  	GOTO	main

300000  32FF      	DW 0x32FF
300002  FEFF      	DW 0xFEFF
300004  FBFF      	DW 0xFBFF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
