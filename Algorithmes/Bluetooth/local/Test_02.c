//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BOYER\PROJET\Tests\Bluetooth\local\Test_02.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Monday, January 23, 2017 17:31:36
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0xFB
#endif
#ifdef HI_TECH_C
__CONFIG(0xFB);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"

MX_UINT8 FCLV_LOOP1;


/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_WAITING (0)
#define FCV_CONNECTED (1)
#define FCV_TRUE (1)
MX_GLOBAL MX_BOOL FCV_BLUETOOTH_CONNECTED = (0); // Bluetooth connecté ou pas

void FCM_INITIALISATION();
void FCM_BLUETTOOH_CONNECT();

/*========================================================================*\
   Use :ctrl_lcd
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_eb005
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_0ad31_lcd_eb005__Clear FCD_04071_LCD__Clear
#define FCD_0ad31_lcd_eb005__PrintString FCD_04071_LCD__PrintString
#define FCD_0ad31_lcd_eb005__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0ad31_lcd_eb005__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0ad31_lcd_eb005__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0ad31_lcd_eb005__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0ad31_lcd_eb005__Cursor FCD_04071_LCD__Cursor
#define FCD_0ad31_lcd_eb005__Command FCD_04071_LCD__Command
#define FCD_0ad31_lcd_eb005__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0ad31_lcd_eb005__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0ad31_lcd_eb005__RawSend FCD_04071_LCD__RawSend
#define FCD_0ad31_lcd_eb005__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :InjectorBase1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :COMPort1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (5)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (1)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 portc
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 portc
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisc
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisc
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (4)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :Bluetooth1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_05181_Bluetooth1__COMMANDARRAY 32
#define FCVsz_05181_Bluetooth1__RESPONSE_ARRAY 14
#define FCV_05181_Bluetooth1__RS_FERR (3)
#define FCV_05181_Bluetooth1__RESPONSE_PAIR (6)
#define FCV_05181_Bluetooth1__RESPONSE_ERROR (2)
#define FCV_05181_Bluetooth1__SENDCMD_TIMEOUT (200)
#define FCV_05181_Bluetooth1__RESPONSE_OK (1)
#define FCV_05181_Bluetooth1__RESPONSE_RING (7)
#define FCV_05181_Bluetooth1__RS_OERR (4)
#define FCV_05181_Bluetooth1__RS_TIMEOUT (1)
#define FCV_05181_Bluetooth1__RESPONSE_NOCARRIER (4)
#define FCV_05181_Bluetooth1__RESPONSE_AUDIO (5)
#define FCV_05181_Bluetooth1__SENDSCRIPT_TIMEOUT (200)
#define FCV_05181_Bluetooth1__RESPONSE_CONNECT (3)
#define FCV_05181_Bluetooth1__RS_OK (0)
#define FCV_05181_Bluetooth1__RESPONSE_TIMEOUT (75)
#define FCV_05181_Bluetooth1__STRINGRX_TIMEOUT (200)
#define FCV_05181_Bluetooth1__COMMANDARRAYSIZE (32)
MX_GLOBAL MX_UINT8 FCV_05181_Bluetooth1__COMMANDARRAYRXPTR;
MX_GLOBAL MX_UINT8 FCV_05181_Bluetooth1__COMMANDARRAY[FCVsz_05181_Bluetooth1__COMMANDARRAY];
MX_GLOBAL MX_UINT8 FCV_05181_Bluetooth1__COMMANDARRAYTXPTR;
MX_GLOBAL MX_UINT8 FCV_05181_Bluetooth1__RX_STATUS;
MX_GLOBAL MX_UINT8 FCV_05181_Bluetooth1__RESPONSE_ARRAY[FCVsz_05181_Bluetooth1__RESPONSE_ARRAY];

MX_UINT8 FCD_05181_Bluetooth1__StringRead(MX_UINT8 FCL_IDX);
MX_UINT8 FCD_05181_Bluetooth1__SendScript(MX_UINT8 FCL_IDX);
MX_UINT8 FCD_05181_Bluetooth1__SendCommand(MX_UINT8 FCL_EXPECTECHO, MX_UINT8 FCL_SENDCR);
void FCD_05181_Bluetooth1__SendScriptString(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
MX_UINT8 FCD_05181_Bluetooth1__Read_byte(MX_UINT8 FCL_TIMEOUT);
MX_UINT8 FCD_05181_Bluetooth1__CreateCommandString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA);
MX_UINT8 FCD_05181_Bluetooth1__StringReceive();
MX_UINT8 FCD_05181_Bluetooth1__CreateCommand(MX_UINT8 FCL_CHARACTER);
void FCD_05181_Bluetooth1__Send_byte(MX_UINT8 FCL_BYTEVAL);
MX_UINT8 FCD_05181_Bluetooth1__WaitForResponse(MX_UINT8 FCL_RESPONSE_CODE, MX_UINT8 FCL_TIMEOUT);
void FCD_05181_Bluetooth1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :ctrl_lcd
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()
{




	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Param??tres pour la macro PrintString :
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_COUNT;



	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

	while (FCL_IDX < FCL_COUNT)
	{

		FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);

		FCL_IDX = FCL_IDX + 1;


	}


}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Param??tres pour la macro PrintAscii :
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)
{
	//Définitions des variables locales
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Param??tres pour la macro RAMWrite :
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Param??tres pour la macro ClearLine :
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Param??tres pour la macro Cursor :
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{



	#if (0) // 2 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
		{

			FCL_Y = 0x80;

		} else {

			FCL_Y = 0xC0;

		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 2 == 4

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Param??tres pour la macro Command :
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Param??tres pour la macro PrintFormattedNumber :
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Définitions des variables locales
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Param??tres pour la macro ScrollDisplay :
       :  Position : Holds the number of positions to shift the display
       :  direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Définitions des variables locales
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	switch (FCL_DIRECTION)
	{
		case 0:
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'l':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'L':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 1:
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'r':
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'R':
		{
			FCL_CMD = 0x1C;


			break;
		}
		// default:

	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Param??tres pour la macro RawSend :
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_NIBBLE;


	//Commentaire:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
		FCP_SET(B, A, 0x2, 0x1, 0);
		FCP_SET(B, A, 0x4, 0x2, 0);
		FCP_SET(B, A, 0x8, 0x3, 0);
		FCP_SET(B, A, 0x10, 0x4, 0);
		FCP_SET(B, A, 0x20, 0x5, 0);

		#if (0)

		//Le code a été optimisé par le préprocesseur
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	//Commentaire:
	//Output byte to pins

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	//Commentaire:
	//Output byte to port

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	if (FCL_TYPE)
	{

		FCP_SET(B, A, 0x10, 0x4, 1);

	// } else {

	}

	FCI_DELAYBYTE_US(100);

	//Commentaire:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, A, 0x20, 0x5, 1);

	FCI_DELAYBYTE_US(100);

	FCP_SET(B, A, 0x20, 0x5, 0);

	FCI_DELAYBYTE_US(100);

	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
		FCP_SET(B, A, 0x2, 0x1, 0);
		FCP_SET(B, A, 0x4, 0x2, 0);
		FCP_SET(B, A, 0x8, 0x3, 0);
		FCP_SET(B, A, 0x10, 0x4, 0);

		FCL_NIBBLE = (FCL_DATA & 0xf);
		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));

		if (FCL_TYPE)
		{

			FCP_SET(B, A, 0x10, 0x4, 1);

		// } else {

		}

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, A, 0x20, 0x5, 1);

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, A, 0x20, 0x5, 0);

		FCI_DELAYBYTE_US(100);

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()
{



	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
		FCP_SET(B, A, 0x2, 0x1, 0);
		FCP_SET(B, A, 0x4, 0x2, 0);
		FCP_SET(B, A, 0x8, 0x3, 0);
		FCP_SET(B, A, 0x10, 0x4, 0);
		FCP_SET(B, A, 0x20, 0x5, 0);

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0)

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	#if (0) // 0 > 0

	//Le code a été optimisé par le préprocesseur
	#else

		FCD_04071_LCD__RawSend(0x32, 0);

		FCI_DELAYBYTE_MS(2);

		FCD_04071_LCD__RawSend(0x2c, 0);

	#endif

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x06, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x0c, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__Clear();

}


/*========================================================================*\
   Use :lcd_eb005
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :InjectorBase1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :COMPort1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :Bluetooth1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Returns the ASCII value of character idx of the Response string.
       :
       :Param??tres pour la macro StringRead :
       :  idx : Needs to be a equal to or less than the string length of the response in order to retrieve a valid character.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05181_Bluetooth1__StringRead(MX_UINT8 FCL_IDX)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	if (FCL_IDX < FCV_05181_Bluetooth1__COMMANDARRAYRXPTR)
	{

		FCR_RETVAL = FCV_05181_Bluetooth1__COMMANDARRAY[FCL_IDX];

	} else {

		FCR_RETVAL = 0;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sends Script idx 
       :Note that the general property Number of Scripts needs to be set so that it allows the scripts to be accessed and sent. 
       :Returns 0 for success and 1 for error
       :
       :Param??tres pour la macro SendScript :
       :  idx : Refers to the Script page to send (1-4).
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05181_Bluetooth1__SendScript(MX_UINT8 FCL_IDX)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	if ((FCL_IDX < 1) || (FCL_IDX > 1))
	{

		FCR_RETVAL = 1;

	} else {

		switch (FCL_IDX)
		{
			case 2:
			{
				FCD_05181_Bluetooth1__SendScriptString("", 1);

				break;
			}
			case 3:
			{
				FCD_05181_Bluetooth1__SendScriptString("", 1);

				break;
			}
			case 4:
			{
				FCD_05181_Bluetooth1__SendScriptString("", 1);

				break;
			}
			default:
			{
				FCD_05181_Bluetooth1__SendScriptString("AT\r\nAT+IPR\r\nAT+CSS\r\n", 21);

			}
		}

		FCR_RETVAL = 0;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sends the command buffer.
       :Returns 1 for success in sending the command.
       :Returns 0 for errors.
       :
       :Param??tres pour la macro SendCommand :
       :  ExpectEcho : Remote module automatically echos back data: 1 = On (Expect echo), 0 = off
       :  SendCR : Automatically adds \n to the end of the command data: 1 = append CR, 0 = no CR.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05181_Bluetooth1__SendCommand(MX_UINT8 FCL_EXPECTECHO, MX_UINT8 FCL_SENDCR)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_DUMMY;
	MX_UINT8 FCR_RETVAL;


	if (FCV_05181_Bluetooth1__COMMANDARRAYTXPTR)
	{

		while (FCL_IDX < FCV_05181_Bluetooth1__COMMANDARRAYTXPTR)
		{

			FCD_05181_Bluetooth1__Send_byte(FCV_05181_Bluetooth1__COMMANDARRAY[FCL_IDX]);

			if (FCL_EXPECTECHO)
			{

				FCL_DUMMY = FCD_05181_Bluetooth1__Read_byte(FCV_05181_Bluetooth1__SENDCMD_TIMEOUT);

			// } else {

			}

			FCL_IDX = FCL_IDX + 1;


		}

		if (FCL_SENDCR)
		{

			FCD_05181_Bluetooth1__Send_byte(0x0d);

			if (FCL_EXPECTECHO)
			{

				FCL_DUMMY = FCD_05181_Bluetooth1__Read_byte(FCV_05181_Bluetooth1__SENDCMD_TIMEOUT);

			// } else {

			}

		// } else {

		}

		FCV_05181_Bluetooth1__COMMANDARRAYTXPTR = 0;

		FCR_RETVAL = 1;

	} else {

		FCR_RETVAL = 0;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro SendScriptString :
       :  str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05181_Bluetooth1__SendScriptString(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{
	//Définitions des variables locales
	MX_UINT8 FCL_I = (0x0);


	FCL_I = 0;

	while (FCL_STR[FCL_I] > 0)
	{

		FCD_05181_Bluetooth1__Send_byte(FCL_STR[FCL_I]);

		FCD_05181_Bluetooth1__Read_byte(FCV_05181_Bluetooth1__SENDSCRIPT_TIMEOUT);

		if (FCL_STR[FCL_I] == 0x0d)
		{

			FCV_05181_Bluetooth1__RX_STATUS = FCV_05181_Bluetooth1__RS_OK;

			FCD_05181_Bluetooth1__Read_byte(FCV_05181_Bluetooth1__RESPONSE_TIMEOUT);

			while (FCV_05181_Bluetooth1__RX_STATUS == FCV_05181_Bluetooth1__RS_OK)
			{

				FCD_05181_Bluetooth1__Read_byte(FCV_05181_Bluetooth1__SENDSCRIPT_TIMEOUT);


			}

		// } else {

		}

		FCL_I = FCL_I + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Read_byte :
       :  Timeout : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05181_Bluetooth1__Read_byte(MX_UINT8 FCL_TIMEOUT)
{
	//Définitions des variables locales
	MX_SINT16 FCL_RXINT;
	MX_UINT8 FCR_RETVAL;


	FCL_RXINT = FC_CAL_UART_Receive_1(FCL_TIMEOUT);

	if (FCL_RXINT >= 0x0100)
	{

		FCR_RETVAL = 0xff;

		if (FCL_RXINT & 0x0100)
		{

			FCV_05181_Bluetooth1__RX_STATUS = FCV_05181_Bluetooth1__RS_TIMEOUT;

		} else {

			if (FCL_RXINT & 0x0200)
			{

				FCV_05181_Bluetooth1__RX_STATUS = FCV_05181_Bluetooth1__RS_OERR;

			} else {

				FCV_05181_Bluetooth1__RX_STATUS = FCV_05181_Bluetooth1__RS_FERR;

			}

		}

	} else {

		FCV_05181_Bluetooth1__RX_STATUS = FCV_05181_Bluetooth1__RS_OK;

		FCR_RETVAL = FCL_RXINT;


	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Assigns a string of characters to the Command buffer.
       :Returns 1 for success in adding the characters to the buffer.
       :Returns 0 for errors, including Buffer overflow.
       :
       :Param??tres pour la macro CreateCommandString :
       :  Data[20] : MX_CHAR (by-ref)
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05181_Bluetooth1__CreateCommandString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN;
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FCL_LEN = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);

	if (FCL_LEN < FCV_05181_Bluetooth1__COMMANDARRAYSIZE)
	{

		while (FCL_IDX < FCL_LEN)
		{

			FCV_05181_Bluetooth1__COMMANDARRAY[FCL_IDX] = FCL_DATA[FCL_IDX];

			FCL_IDX = FCL_IDX + 1;


		}

		FCV_05181_Bluetooth1__COMMANDARRAYTXPTR = FCL_LEN;
		FCR_RETVAL = 1;

	} else {

		FCR_RETVAL = 0;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Checks for a response string.
       :Returns the length of the response string if one is present otherwise returns 0.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05181_Bluetooth1__StringReceive()
{
	//Définitions des variables locales
	MX_UINT8 FCL_CH;
	MX_UINT8 FCL_CRLF_FLAGS = (0x0);
	MX_UINT8 FCL_TIMEOUT = (0x0);
	MX_UINT8 FCR_RETVAL;


	FCV_05181_Bluetooth1__COMMANDARRAYRXPTR = 0;
	FCV_05181_Bluetooth1__RX_STATUS = FCV_05181_Bluetooth1__RS_OK;

	while (FCL_CRLF_FLAGS <= 2)
	{

		FCL_CH = FCD_05181_Bluetooth1__Read_byte(FCV_05181_Bluetooth1__STRINGRX_TIMEOUT);

		if (FCV_05181_Bluetooth1__RX_STATUS == FCV_05181_Bluetooth1__RS_OK)
		{

			switch (FCL_CH)
			{
				case 0x0d:
				{
					FCL_CRLF_FLAGS = FCL_CRLF_FLAGS | 0x01;

					break;
				}
				case 0x0a:
				{
					FCL_CRLF_FLAGS = FCL_CRLF_FLAGS | 0x02;

					break;
				}
				default:
				{
					FCV_05181_Bluetooth1__COMMANDARRAY[FCV_05181_Bluetooth1__COMMANDARRAYRXPTR] = FCL_CH;
					FCV_05181_Bluetooth1__COMMANDARRAYRXPTR = FCV_05181_Bluetooth1__COMMANDARRAYRXPTR + 1;

					FCL_TIMEOUT = 0;

					if (FCV_05181_Bluetooth1__COMMANDARRAYRXPTR >= FCV_05181_Bluetooth1__COMMANDARRAYSIZE)
					{

						FCL_CRLF_FLAGS = 0xff;

					// } else {

					}

				}
			}

		} else {

			FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT > 1)
			{

				FCL_CRLF_FLAGS = 0xff;

			// } else {

			}

		}

		FCR_RETVAL = FCV_05181_Bluetooth1__COMMANDARRAYRXPTR;


	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Adds a single characters to the end of the Command buffer.
       :Returns 1 for success in adding the characters to the buffer.
       :Returns 0 for errors, including Buffer overflow.
       :
       :Param??tres pour la macro CreateCommand :
       :  Character : ASCII value or single character,
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05181_Bluetooth1__CreateCommand(MX_UINT8 FCL_CHARACTER)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	if (FCV_05181_Bluetooth1__COMMANDARRAYTXPTR < FCV_05181_Bluetooth1__COMMANDARRAYSIZE)
	{

		FCV_05181_Bluetooth1__COMMANDARRAY[FCV_05181_Bluetooth1__COMMANDARRAYTXPTR] = FCL_CHARACTER;
		FCV_05181_Bluetooth1__COMMANDARRAYTXPTR = FCV_05181_Bluetooth1__COMMANDARRAYTXPTR + 1;

		FCR_RETVAL = 1;

	} else {

		FCR_RETVAL = 0;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Send_byte :
       :  ByteVal : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_05181_Bluetooth1__Send_byte(MX_UINT8 FCL_BYTEVAL)
{

	FC_CAL_UART_Send_1(FCL_BYTEVAL);


}

/*=----------------------------------------------------------------------=*\
   Use :Waits for a response message of type response_code for timeout ms.
       :Returns: 0 for a Response of type response_code
       :255 (0xFF) for a timeout or invalid response
       :Response string length for any Response not of type response_code
       :
       :Param??tres pour la macro WaitForResponse :
       :  response_code : 1:OK / 2:ERROR / 3:CONNECT / 4:NO CARRIER / 5:AUDIO / 6:PAIR / 7:RING
       :  timeout : The timeout value will need to set to allow sufficient time for the response to arrive.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05181_Bluetooth1__WaitForResponse(MX_UINT8 FCL_RESPONSE_CODE, MX_UINT8 FCL_TIMEOUT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_RESP_SIZE = (0x0);
	MX_UINT8 FCL_CH;
	MX_UINT8 FCL_RX_PTR;
	MX_UINT8 FCL_CRLF_FLAGS = (0x0);
	MX_UINT8 FCL_UNEXPECTED = (0x0);
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = 0;

	switch (FCL_RESPONSE_CODE)
	{
		case FCV_05181_Bluetooth1__RESPONSE_OK:
		{
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[0] = 'O';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[1] = 'K';

			FCL_RESP_SIZE = 2;

			break;
		}
		case FCV_05181_Bluetooth1__RESPONSE_ERROR:
		{
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[0] = 'E';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[1] = 'R';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[2] = 'R';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[3] = 'O';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[4] = 'R';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[5] = ' ';

			FCL_RESP_SIZE = 6;

			break;
		}
		case FCV_05181_Bluetooth1__RESPONSE_CONNECT:
		{
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[0] = 'C';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[1] = 'O';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[2] = 'N';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[3] = 'N';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[4] = 'E';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[5] = 'C';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[6] = 'T';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[7] = ' ';

			FCL_RESP_SIZE = 8;

			break;
		}
		case FCV_05181_Bluetooth1__RESPONSE_NOCARRIER:
		{
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[0] = 'N';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[1] = 'O';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[2] = ' ';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[3] = 'C';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[4] = 'A';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[5] = 'R';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[6] = 'R';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[7] = 'I';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[8] = 'E';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[9] = 'R';

			FCL_RESP_SIZE = 10;

			break;
		}
		case FCV_05181_Bluetooth1__RESPONSE_AUDIO:
		{
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[0] = 'A';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[1] = 'U';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[2] = 'D';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[3] = 'I';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[4] = 'O';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[5] = ' ';

			FCL_RESP_SIZE = 6;

			break;
		}
		case FCV_05181_Bluetooth1__RESPONSE_PAIR:
		{
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[0] = 'P';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[1] = 'A';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[2] = 'I';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[3] = 'R';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[4] = ' ';

			FCL_RESP_SIZE = 5;

			break;
		}
		case FCV_05181_Bluetooth1__RESPONSE_RING:
		{
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[0] = 'R';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[1] = 'I';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[2] = 'N';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[3] = 'G';
			FCV_05181_Bluetooth1__RESPONSE_ARRAY[4] = ' ';

			FCL_RESP_SIZE = 5;

			break;
		}
		default:
		{
			FCR_RETVAL = 0xff;

		}
	}

	if (FCR_RETVAL == 0)
	{

		FCV_05181_Bluetooth1__COMMANDARRAYRXPTR = 0;
		FCL_RX_PTR = 0;

		while (FCL_CRLF_FLAGS < 0x03)
		{

			FCL_CH = FCD_05181_Bluetooth1__Read_byte(FCV_05181_Bluetooth1__RESPONSE_TIMEOUT);

			while (FCV_05181_Bluetooth1__RX_STATUS != FCV_05181_Bluetooth1__RS_OK)
			{

				if (FCL_TIMEOUT)
				{

					FCL_TIMEOUT = FCL_TIMEOUT - 1;

					FCL_CH = FCD_05181_Bluetooth1__Read_byte(FCV_05181_Bluetooth1__STRINGRX_TIMEOUT);

				} else {

					FCR_RETVAL = 0xff;

					FCV_05181_Bluetooth1__RX_STATUS = FCV_05181_Bluetooth1__RS_OK;
					FCL_CRLF_FLAGS = 0x03;

				}


			}

			if (FCR_RETVAL == 0)
			{

				switch (FCL_CH)
				{
					case 0x0d:
					{
						FCL_CRLF_FLAGS = FCL_CRLF_FLAGS | 0x01;

						break;
					}
					case 0x0a:
					{
						FCL_CRLF_FLAGS = FCL_CRLF_FLAGS | 0x02;

						break;
					}
					default:
					{
						FCV_05181_Bluetooth1__COMMANDARRAY[FCV_05181_Bluetooth1__COMMANDARRAYRXPTR] = FCL_CH;
						FCV_05181_Bluetooth1__COMMANDARRAYRXPTR = FCV_05181_Bluetooth1__COMMANDARRAYRXPTR + 1;

						if (FCV_05181_Bluetooth1__COMMANDARRAYRXPTR >= FCV_05181_Bluetooth1__COMMANDARRAYSIZE)
						{

							FCR_RETVAL = FCV_05181_Bluetooth1__COMMANDARRAYRXPTR;

							FCL_CRLF_FLAGS = 0x03;

						} else {

							if (FCL_UNEXPECTED == 0)
							{

								FCL_CRLF_FLAGS = 0;

								if (FCL_CH != FCV_05181_Bluetooth1__RESPONSE_ARRAY[FCL_RX_PTR])
								{

									FCL_UNEXPECTED = 1;

								// } else {

								}

								FCL_RX_PTR = FCL_RX_PTR + 1;

							// } else {

							}

						}

					}
				}

				if ((FCL_UNEXPECTED == 0) & (FCL_RX_PTR == FCL_RESP_SIZE))
				{

					FCL_CRLF_FLAGS = 0x03;

				// } else {

				}

			// } else {

			}


		}

		if (FCL_UNEXPECTED)
		{

			FCR_RETVAL = FCV_05181_Bluetooth1__COMMANDARRAYRXPTR;

		// } else {

		}

	// } else {

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Required to be used whenever the Bluetooth component is used in a program.
       :Initialises the Bluetooth component ready for use.
\*=----------------------------------------------------------------------=*/
void FCD_05181_Bluetooth1__Initialise()
{

	FCV_05181_Bluetooth1__COMMANDARRAYTXPTR = 0;
	FCV_05181_Bluetooth1__COMMANDARRAYRXPTR = 0;

	FC_CAL_UART_Init_1();

}


/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :D??arrage des modules
\*=----------------------------------------------------------------------=*/
void FCM_INITIALISATION()
{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth1::Initialise()
	FCD_05181_Bluetooth1__Initialise();

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Start()
	FCD_0ad31_lcd_eb005__Start();

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Clear()
	FCD_0ad31_lcd_eb005__Clear();

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Initiate conn.")
	FCD_0ad31_lcd_eb005__PrintString("Initiate conn.", 15);

}

/*=----------------------------------------------------------------------=*\
   Use :Connexion du bluethooth ?? l'autre carte
\*=----------------------------------------------------------------------=*/
void FCM_BLUETTOOH_CONNECT()
{

	// Calcul
	// Calcul:
	//  bluetooth_connected = WAITING
	FCV_BLUETOOTH_CONNECTED = FCV_WAITING;

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Clear()
	FCD_0ad31_lcd_eb005__Clear();

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Waiting pairing")
	FCD_0ad31_lcd_eb005__PrintString("Waiting pairing", 16);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Cursor(0, 1)
	FCD_0ad31_lcd_eb005__Cursor(0, 1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Please wait...")
	FCD_0ad31_lcd_eb005__PrintString("Please wait...", 15);

	// Boucle
	// Boucle: While bluetooth_connected == WAITING
	while (FCV_BLUETOOTH_CONNECTED == FCV_WAITING)
	{

		#if 0 // Disabled code
		// Calcul
		// Calcul:
		//  bluetooth_connected = CONNECTED
		FCV_BLUETOOTH_CONNECTED = FCV_CONNECTED;

		#endif // #if 0: Disabled code

	}

}



/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()
{
adcon1 = 0x0F;




	// Appel d'une Macro
	// Appel d'une Macro: INITIALISATION()
	FCM_INITIALISATION();

	// Appel d'une Macro
	// Appel d'une Macro: BLUETTOOH_CONNECT()
	FCM_BLUETTOOH_CONNECT();

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

}




