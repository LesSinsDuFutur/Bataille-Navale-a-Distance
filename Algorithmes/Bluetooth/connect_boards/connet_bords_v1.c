//************************************************************************************
//**  
//**  Source name:   F:\Projet\Bluetooth\connect_boards\connet_bords_v1.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Tuesday, March 14, 2017 15:45:01
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x78
#endif
#ifdef HI_TECH_C
__CONFIG(0x78);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_RETURN 20
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_OCTET;
MX_GLOBAL MX_CHAR FCV_RETURN[FCVsz_RETURN];
MX_GLOBAL MX_SINT16 FCV_LOOP;

void FCM_INITIALISATION();
void FCM_CHECK_BT_GETTING();

/*========================================================================*\
   Use :ctrl_lcd
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_eb005
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_0ad31_lcd_eb005__Clear FCD_04071_LCD__Clear
#define FCD_0ad31_lcd_eb005__PrintString FCD_04071_LCD__PrintString
#define FCD_0ad31_lcd_eb005__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0ad31_lcd_eb005__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0ad31_lcd_eb005__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0ad31_lcd_eb005__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0ad31_lcd_eb005__Cursor FCD_04071_LCD__Cursor
#define FCD_0ad31_lcd_eb005__Command FCD_04071_LCD__Command
#define FCD_0ad31_lcd_eb005__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0ad31_lcd_eb005__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0ad31_lcd_eb005__RawSend FCD_04071_LCD__RawSend
#define FCD_0ad31_lcd_eb005__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :InjectorBase1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 portb
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 portb
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisb
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisb
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (4)
#define MX_UART_INT_1 (1)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :Bluetooth2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_0c851_Bluetooth2__STRING_ARRAY 50
#define FCV_0c851_Bluetooth2__BT_CHAR_CR (13)
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__STRING_ARRAY[FCVsz_0c851_Bluetooth2__STRING_ARRAY];
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_IDX = (0x0);
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_DONE = (0x0);
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_LENGTH = (0x0);

MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY);
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT);
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX);
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR);
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES);
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings();
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA);
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE);
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive();
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings();
MX_UINT8 FCD_0c851_Bluetooth2__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :ctrl_lcd
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()
{




	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Param??tres pour la macro PrintString :
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_COUNT;



	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

	while (FCL_IDX < FCL_COUNT)
	{

		FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);

		FCL_IDX = FCL_IDX + 1;


	}


}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Param??tres pour la macro PrintAscii :
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)
{
	//Définitions des variables locales
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Param??tres pour la macro RAMWrite :
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Param??tres pour la macro ClearLine :
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Param??tres pour la macro Cursor :
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{



	#if (0) // 2 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
		{

			FCL_Y = 0x80;

		} else {

			FCL_Y = 0xC0;

		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 2 == 4

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Param??tres pour la macro Command :
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Param??tres pour la macro PrintFormattedNumber :
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Définitions des variables locales
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Param??tres pour la macro ScrollDisplay :
       :  Position : Holds the number of positions to shift the display
       :  direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Définitions des variables locales
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	switch (FCL_DIRECTION)
	{
		case 0:
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'l':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'L':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 1:
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'r':
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'R':
		{
			FCL_CMD = 0x1C;


			break;
		}
		// default:

	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Param??tres pour la macro RawSend :
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_NIBBLE;


	//Commentaire:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
		FCP_SET(B, A, 0x2, 0x1, 0);
		FCP_SET(B, A, 0x4, 0x2, 0);
		FCP_SET(B, A, 0x8, 0x3, 0);
		FCP_SET(B, A, 0x10, 0x4, 0);
		FCP_SET(B, A, 0x20, 0x5, 0);

		#if (0)

		//Le code a été optimisé par le préprocesseur
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	//Commentaire:
	//Output byte to pins

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	//Commentaire:
	//Output byte to port

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	if (FCL_TYPE)
	{

		FCP_SET(B, A, 0x10, 0x4, 1);

	// } else {

	}

	FCI_DELAYBYTE_US(100);

	//Commentaire:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, A, 0x20, 0x5, 1);

	FCI_DELAYBYTE_US(100);

	FCP_SET(B, A, 0x20, 0x5, 0);

	FCI_DELAYBYTE_US(100);

	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
		FCP_SET(B, A, 0x2, 0x1, 0);
		FCP_SET(B, A, 0x4, 0x2, 0);
		FCP_SET(B, A, 0x8, 0x3, 0);
		FCP_SET(B, A, 0x10, 0x4, 0);

		FCL_NIBBLE = (FCL_DATA & 0xf);
		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));

		if (FCL_TYPE)
		{

			FCP_SET(B, A, 0x10, 0x4, 1);

		// } else {

		}

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, A, 0x20, 0x5, 1);

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, A, 0x20, 0x5, 0);

		FCI_DELAYBYTE_US(100);

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()
{



	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
		FCP_SET(B, A, 0x2, 0x1, 0);
		FCP_SET(B, A, 0x4, 0x2, 0);
		FCP_SET(B, A, 0x8, 0x3, 0);
		FCP_SET(B, A, 0x10, 0x4, 0);
		FCP_SET(B, A, 0x20, 0x5, 0);

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0)

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	#if (0) // 0 > 0

	//Le code a été optimisé par le préprocesseur
	#else

		FCD_04071_LCD__RawSend(0x32, 0);

		FCI_DELAYBYTE_MS(2);

		FCD_04071_LCD__RawSend(0x2c, 0);

	#endif

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x06, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x0c, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__Clear();

}


/*========================================================================*\
   Use :lcd_eb005
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :InjectorBase1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :Bluetooth2
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the 4 digit Bluetooth pair key based on a string of numbers.
       :e.g. "1234"
       :Returns 0 to indicate success
       :
       :Param??tres pour la macro SetPairKey :
       :  PairKey[5] : Key to use as the Pair key, e.g. "1234" or "0000"
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY)
{
	//Définitions des variables locales
	#define FCLsz_COMMANDSTR 20
	MX_CHAR FCL_COMMANDSTR[FCLsz_COMMANDSTR];
	MX_UINT8 FCR_RETVAL;


	FCI_SHEAD("AT+BTK=\"",9, FCL_PAIRKEY,FCLsz_PAIRKEY, FCL_COMMANDSTR,20);
	FCI_SHEAD(FCL_COMMANDSTR,FCLsz_COMMANDSTR, "\"",2, FCL_COMMANDSTR,20);

	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand(FCL_COMMANDSTR, FCLsz_COMMANDSTR, 1);

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_COMMANDSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Receives a single data byte from the Bluetooth module.
       :0xFF signifies no data available.
       :
       :Param??tres pour la macro ReceiveByte :
       :  Timeout : Amount of time to wait in milliseconds 0=Wait forever
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	FCV_0c851_Bluetooth2__RX_DONE = 0;

FCC_ReceiveByte_A:
;

	if (FCV_0c851_Bluetooth2__RX_IDX < FCV_0c851_Bluetooth2__RX_LENGTH)
	{

		FCR_RETVAL = FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_IDX];

		FCV_0c851_Bluetooth2__RX_IDX = FCV_0c851_Bluetooth2__RX_IDX + 1;

	} else {

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 50)
		{

			if ((FCL_TIMEOUT == 0) || (FCL_COUNT < FCL_TIMEOUT))
			{

				FCI_DELAYBYTE_MS(1);

				FCL_COUNT = FCL_COUNT + 1;

				goto FCC_ReceiveByte_A;

			// } else {

			}

		// } else {

		}

		FCV_0c851_Bluetooth2__RX_IDX = 0;
		FCV_0c851_Bluetooth2__RX_LENGTH = 0;

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Send an AT command script.
       :Returns 0 for fail, 1 for success and 255 for unrecognised script idx.
       :
       :Param??tres pour la macro SendScript :
       :  idx : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX)
{
	//Définitions des variables locales
	MX_UINT8 FCL_I = (0x0);
	MX_UINT8 FCL_CH = (0xff);
	#define FCLsz_SCRIPT_STR 40
	MX_CHAR FCL_SCRIPT_STR[FCLsz_SCRIPT_STR];
	MX_UINT8 FCL_LEN = (0x0);
	MX_UINT8 FCR_RETVAL;


	if ((FCL_IDX < 1) || (FCL_IDX > 2))
	{

		FCR_RETVAL = 255;

		goto FCC_SendScript_A;

	// } else {

	}

	switch (FCL_IDX)
	{
		case 1:
		{
			FCI_SCOPY("ATS0=1\r\nATR\r\nATS512=7\r\nATS536=1\r\nATS502=",41, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		case 2:
		{
			FCI_SCOPY("ATS531=2\r\nATA\r\nAT&W\r\nATZ0",26, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		case 3:
		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		case 4:
		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		default:
		{
			FCR_RETVAL = 255;

			goto FCC_SendScript_A;

		}
	}

	while (FCL_CH > 0)
	{

		FCL_CH = FCL_SCRIPT_STR[FCL_I];

		if ((FCL_CH > 0) && (FCL_CH != 0x0A))
		{

			FC_CAL_UART_Send_1(FCL_CH);

			FCL_LEN = FCL_LEN + 1;

			if (FCL_CH == FCV_0c851_Bluetooth2__BT_CHAR_CR)
			{

				#if (1) // 1 == 1

					FCD_0c851_Bluetooth2__StringReceive();

				// #else

				//Le code a été optimisé par le préprocesseur
				#endif

				FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();

				FCL_LEN = 0;

			// } else {

			}

		// } else {

		}

		FCL_I = FCL_I + 1;


	}

	if (FCL_LEN > 0)
	{

		FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);

		#if (1) // 1 == 1

			FCD_0c851_Bluetooth2__StringReceive();

		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();

	// } else {

	}

FCC_SendScript_A:
;

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_SCRIPT_STR
}

/*=----------------------------------------------------------------------=*\
   Use :Sends a command string to the GSM module.
       :0 = Command sent ok, 255 = No Reply
       :
       :Param??tres pour la macro SendCommand :
       :  Command[20] : MX_CHAR (by-ref)
       :  SendCR : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_LEN;
	MX_UINT8 FCR_RETVAL;


	while (1)
	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();


		if ((FCR_RETVAL) == 0) break;
	}

	FCL_LEN = FCI_GETLENGTH(FCL_COMMAND, FCLsz_COMMAND);

	if (FCL_LEN)
	{

		while (FCL_IDX < FCL_LEN)
		{

			FC_CAL_UART_Send_1(FCL_COMMAND[FCL_IDX]);

			FCL_IDX = FCL_IDX + 1;


		}

		if (FCL_SENDCR)
		{

			FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);

		// } else {

		}

	// } else {

	}

	#if (1) // 1 == 1

		FCD_0c851_Bluetooth2__StringReceive();

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();

	if (FCR_RETVAL == 0)
	{

		FCR_RETVAL = 255;

	} else {

		FCR_RETVAL = 0;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies the incoming data from the data string array to a local string variable.
       :
       :Param??tres pour la macro ReadString :
       :  NumBytes : MX_UINT8
       :
       :Renvoie : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);


	while ((FCL_IDX < FCL_NUMBYTES) && (FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX] > 0))
	{

		FCR_RETVAL[FCL_IDX] = FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX];
		FCL_IDX = FCL_IDX + 1;


	}

	if (FCL_IDX < FCL_NUMBYTES)
	{

		FCR_RETVAL[FCL_IDX] = 0;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Saves the current settings to firmware using the AT&W command followed by the ATZ command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&W", 5, 1);

	if (FCR_RETVAL == 0)
	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATZ", 4, 1);

	// } else {

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sends a single data byte out to the Bluetooth module.
       :
       :Param??tres pour la macro SendByte :
       :  Data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA)
{

	FC_CAL_UART_Send_1(FCL_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the bluetooth mode to be discoverable and or connectable.
       :Returns 0 for success.
       :
       :Param??tres pour la macro SetMode :
       :  Discoverable : 0 = Not Discoverable, 1 = Discoverable
       :  Connectable : 0 = Not Connectable, 1 = Connectable
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	if (FCL_DISCOVERABLE)
	{

		if (FCL_CONNECTABLE)
		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=4", 9, 1);

		} else {

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 1);

		}

	} else {

		if (FCL_CONNECTABLE)
		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 3);

		} else {

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=0", 9, 1);

		}

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to receive a string from the GSM modem terminated with a 0x10 CR character. Used to collect the replies from commands.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive()
{
	//Définitions des variables locales
	MX_UINT8 FCL_TOUT = (0x0);
	MX_UINT8 FCL_LEN = (0x0);
	MX_UINT8 FCR_RETVAL;


	FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
	FCV_0c851_Bluetooth2__RX_DONE = 0;
	FCV_0c851_Bluetooth2__RX_LENGTH = 0;
	FCV_0c851_Bluetooth2__RX_IDX = 0;

	while ((FCV_0c851_Bluetooth2__RX_DONE == 0) && (FCL_TOUT < 255))
	{

		FCL_TOUT = FCL_TOUT + 1;

		if (FCL_LEN != FCV_0c851_Bluetooth2__RX_LENGTH)
		{

			FCL_TOUT = 0;
			FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;

		// } else {

		}

		FCI_DELAYINT_US(500);


	}

	if (FCL_TOUT == 255)
	{

		FCV_0c851_Bluetooth2__RX_DONE = 0;
		FCV_0c851_Bluetooth2__RX_LENGTH = 0;
		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 1;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Restores the factory settings to firmware using the AT&F* command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&F*", 6, 1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets up the GSM module.
       :Returns 0 for OK, 255 for no reply and 254 for command fail.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__Initialise()
{
	//Définitions des variables locales
	#define FCLsz_CMDSTR 20
	MX_CHAR FCL_CMDSTR[FCLsz_CMDSTR];
	MX_UINT8 FCR_RETVAL;


	FCP_SET(B, B, 0x2, 0x1, 0);

	FCI_DELAYBYTE_MS(100);

	FCP_SET(B, B, 0x2, 0x1, 1);

	FCR_RETVAL = 0;

	FC_CAL_UART_Init_1();

	FCI_DELAYBYTE_MS(10);

	FCD_0c851_Bluetooth2__StringReceive();

	#if (1)

		FCD_0c851_Bluetooth2__RestoreFactorySettings();

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCI_SHEAD("AT+BTN=\"",9, "MARCHE_PTN",11, FCL_CMDSTR,20);
	FCI_SHEAD(FCL_CMDSTR,FCLsz_CMDSTR, "\"",2, FCL_CMDSTR,20);

	FCD_0c851_Bluetooth2__SendCommand(FCL_CMDSTR, FCLsz_CMDSTR, 1);

	FCD_0c851_Bluetooth2__SetPairKey("1379", 5);

	FCD_0c851_Bluetooth2__SetMode(1, 1);

	FCR_RETVAL = FCD_0c851_Bluetooth2__SaveSettings();

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_CMDSTR
}


/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_INITIALISATION()
{

	//Commentaire:
	//BT4

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::Initialise()
	FCD_0c851_Bluetooth2__Initialise();

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Start()
	FCD_0ad31_lcd_eb005__Start();

	// Pause
	// Pause: 1 s
	FCI_DELAYBYTE_S(1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendScript(1)
	FCD_0c851_Bluetooth2__SendScript(1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendScript(2)
	FCD_0c851_Bluetooth2__SendScript(2);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Initialisation...")
	FCD_0ad31_lcd_eb005__PrintString("Initialisation...", 18);

	// Pause
	// Pause: 1 s
	FCI_DELAYBYTE_S(1);

	// Boucle
	// Boucle: While 1
	while (1)
	{

		// Calcul
		// Calcul:
		//  octet = 0
		FCV_OCTET = 0;

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();

		// Appel de la Routine Composant
		// Appel de la Routine Composant: octet=Bluetooth2::ReceiveByte(20)
		FCV_OCTET = FCD_0c851_Bluetooth2__ReceiveByte(20);

		// Appel de la Routine Composant
		// Appel de la Routine Composant: return=Bluetooth2::ReadString(octet)
		FCD_0c851_Bluetooth2__ReadString(FCV_RETURN,20, FCV_OCTET);

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString(return)
		FCD_0ad31_lcd_eb005__PrintString(FCV_RETURN, FCVsz_RETURN);

		#if 0 // Disabled code
		// Pause
		// Pause: 1 s
		FCI_DELAYBYTE_S(1);

		#endif // #if 0: Disabled code
		// Calcul
		// Calcul:
		//  loop = loop + 1
		FCV_LOOP = FCV_LOOP + 1;

		// Décision
		// Décision: loop >= 15?
		if (FCV_LOOP >= 15)
		{

			// Calcul
			// Calcul:
			//  loop = 0
			FCV_LOOP = 0;

			// Appel de la Routine Composant
			// Appel de la Routine Composant: Bluetooth2::SendCommand("salut", 0)
			FCD_0c851_Bluetooth2__SendCommand("salut", 6, 0);

		// } else {

		}


	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_CHECK_BT_GETTING()
{

}



/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()
{
adcon1 = 0x0F;




	// Appel d'une Macro
	// Appel d'une Macro: INITIALISATION()
	FCM_INITIALISATION();

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

	MX_UART_INT_CH1_FUNC

	MX_UINT8 FCL_BT_IN;

	FCL_BT_IN = MX_UART_INT_CH1_DET;

	if (FCL_BT_IN)
	{

	FCL_BT_IN = FC_CAL_UART_Receive_1(1);

	if (FCV_0c851_Bluetooth2__RX_DONE == 0)
	{

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 50)
		{

			if (FCL_BT_IN == 0x0A)
			{

				FCV_0c851_Bluetooth2__RX_DONE = 1;
				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = 0;

			} else {

				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = FCL_BT_IN;
				FCV_0c851_Bluetooth2__RX_LENGTH = FCV_0c851_Bluetooth2__RX_LENGTH + 1;

			}

		// } else {

		}

	// } else {

	}

	MX_UART_INT_CH1_CLR;

	}

	MX_UART_INT_FUNC_END
}




