;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

// Delay by bytes
#define FCI_DELAYBYTE_S(count)     delay_s((count))
#define FCI_DELAYBYTE_MS(count)    delay_ms((count))
#define FCI_DELAYBYTE_US(count)    delay_us((count))
// With watchdog timer
#define FCI_DELAYBYTEWDT_S(count)  Wdt_Delay_S((count))
#define FCI_DELAYBYTEWDT_MS(count) Wdt_Delay_Ms((count))
#define FCI_DELAYBYTEWDT_US(count) delay_us((count))

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)
{
    char i;
    for (i=0; i<delay; i++)
    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
        delay_ms(1);
    }
}


void FCI_DELAYINT_US(MX_UINT16 Delay)

{
  	while (Delay > 255)
012A            label14
012A  0EFF      	MOVLW 0xFF
012C  65AB      	CPFSGT FCI_DELAYI_00038_arg_Delay, 1
012E  67AC      	TSTFSZ FCI_DELAYI_00038_arg_Delay+D'1', 1
0130  D001      	BRA	label15
0132  D00C      	BRA	label16
0134            label15
014A  D7EF      	BRA	label14
014C            label16

  	{
	  	delay_us(255);
0134  69AD      	SETF delay_us_00000_arg_del, 1
0136  EC06F000  	CALL delay_us_00000

	  	Delay = Delay - 255;
013A  0EFF      	MOVLW 0xFF
013C  5DAB      	SUBWF FCI_DELAYI_00038_arg_Delay, W, 1
013E  6FAD      	MOVWF CompTempVar1836, 1
0140  59AB      	SUBWFB FCI_DELAYI_00038_arg_Delay, W, 1
0142  08FF      	SUBLW 0xFF
0144  5FAC      	SUBWF FCI_DELAYI_00038_arg_Delay+D'1', F, 1
0146  51AD      	MOVF CompTempVar1836, W, 1
0148  6FAB      	MOVWF FCI_DELAYI_00038_arg_Delay, 1

  	}
  	if (Delay > 0)
014C  0E00      	MOVLW 0x00
014E  65AB      	CPFSGT FCI_DELAYI_00038_arg_Delay, 1
0150  67AC      	TSTFSZ FCI_DELAYI_00038_arg_Delay+D'1', 1
0152  D001      	BRA	label17
0156            label17

  		delay_us(Delay & 0xFF);
0156  51AB      	MOVF FCI_DELAYI_00038_arg_Delay, W, 1
0158  6FAD      	MOVWF delay_us_00000_arg_del, 1
015A  EC06F000  	CALL delay_us_00000

}
0154  0012      	RETURN
015E  0012      	RETURN


void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
0170  6B99      	CLRF FCI_GETLEN_0003E_1_tmp, 1
0172            label19
0172  5198      	MOVF FCI_GETLEN_0003E_arg_iStr1_len, W, 1
0174  6199      	CPFSLT FCI_GETLEN_0003E_1_tmp, 1
0176  D009      	BRA	label20
0178  5197      	MOVF FCI_GETLEN_0003E_arg_sStr1+D'1', W, 1
017A  6EEA      	MOVWF FSR0H
017C  5196      	MOVF FCI_GETLEN_0003E_arg_sStr1, W, 1
017E  2599      	ADDWF FCI_GETLEN_0003E_1_tmp, W, 1
0180  6EE9      	MOVWF FSR0L
0182  52EF      	MOVF INDF0, F
0184  E002      	BZ	label20
0186  2B99      	INCF FCI_GETLEN_0003E_1_tmp, F, 1
0188  D7F4      	BRA	label19
018A            label20

	return (tmp);
018A  5199      	MOVF FCI_GETLEN_0003E_1_tmp, W, 1
018C  6F9A      	MOVWF CompTempVarRet1850, 1

}
018E  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)

{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;
07E2  5067      	MOVF FCI_TOSTRI_00042_arg_iSrc1, W
07E4  6E6F      	MOVWF FCI_TOSTRI_00042_1_iSrc
07E6  5068      	MOVF FCI_TOSTRI_00042_arg_iSrc1+D'1', W
07E8  6E70      	MOVWF FCI_TOSTRI_00042_1_iSrc+D'1'
07EA  5069      	MOVF FCI_TOSTRI_00042_arg_iSrc1+D'2', W
07EC  6E71      	MOVWF FCI_TOSTRI_00042_1_iSrc+D'2'
07EE  506A      	MOVF FCI_TOSTRI_00042_arg_iSrc1+D'3', W
07F0  6E72      	MOVWF FCI_TOSTRI_00042_1_iSrc+D'3'


	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
07F2  6A73      	CLRF FCI_TOSTRI_00042_1_top
07F4  0ECA      	MOVLW 0xCA
07F6  6E74      	MOVWF FCI_TOSTRI_00042_1_top+D'1'
07F8  0E9A      	MOVLW 0x9A
07FA  6E75      	MOVWF FCI_TOSTRI_00042_1_top+D'2'
07FC  0E3B      	MOVLW 0x3B
07FE  6E76      	MOVWF FCI_TOSTRI_00042_1_top+D'3'

	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;
0800  6A77      	CLRF FCI_TOSTRI_00042_1_idx


	if (iDst_len == 0) return sDst;
0802  526D      	MOVF FCI_TOSTRI_00042_arg_iDst_len, F
0804  E105      	BNZ	label102
0806  506B      	MOVF FCI_TOSTRI_00042_arg_sDst, W
0808  6E78      	MOVWF CompTempVarRet1863
080A  506C      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W
080C  6E79      	MOVWF CompTempVarRet1863+D'1'
0810            label102


	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
0810  AE72      	BTFSS FCI_TOSTRI_00042_1_iSrc+D'3',7
0812  D014      	BRA	label103

	{
		sDst[0] = '-';
0814  506C      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W
0816  6EEA      	MOVWF FSR0H
0818  506B      	MOVF FCI_TOSTRI_00042_arg_sDst, W
081A  6EE9      	MOVWF FSR0L
081C  6A7A      	CLRF CompTempVar1865
081E  507A      	MOVF CompTempVar1865, W
0820  26E9      	ADDWF FSR0L, F
0822  0E2D      	MOVLW 0x2D
0824  6EEF      	MOVWF INDF0

		idx++;
0826  2A77      	INCF FCI_TOSTRI_00042_1_idx, F

		iSrc = -iSrc;
0828  1E6F      	COMF FCI_TOSTRI_00042_1_iSrc, F
082A  1E70      	COMF FCI_TOSTRI_00042_1_iSrc+D'1', F
082C  1E71      	COMF FCI_TOSTRI_00042_1_iSrc+D'2', F
082E  1E72      	COMF FCI_TOSTRI_00042_1_iSrc+D'3', F
0830  3E6F      	INCFSZ FCI_TOSTRI_00042_1_iSrc, F
0832  D004      	BRA	label103
0834  3E70      	INCFSZ FCI_TOSTRI_00042_1_iSrc+D'1', F
0836  D002      	BRA	label103
0838  4A71      	INFSNZ FCI_TOSTRI_00042_1_iSrc+D'2', F
083A  2A72      	INCF FCI_TOSTRI_00042_1_iSrc+D'3', F
083C            label103

	}

	tmp1 = 0;    // Nothing added yet
083C  6A6E      	CLRF FCI_TOSTRI_00042_1_tmp1

	if (iSrc == 0) // Force showing zero
083E  506F      	MOVF FCI_TOSTRI_00042_1_iSrc, W
0840  1070      	IORWF FCI_TOSTRI_00042_1_iSrc+D'1', W
0842  1071      	IORWF FCI_TOSTRI_00042_1_iSrc+D'2', W
0844  1072      	IORWF FCI_TOSTRI_00042_1_iSrc+D'3', W
0846  0BFF      	ANDLW 0xFF
0848  E106      	BNZ	label104
0856            label104

	{
		tmp1 = 1;
084A  0E01      	MOVLW 0x01
084C  6E6E      	MOVWF FCI_TOSTRI_00042_1_tmp1

		top = 1;
084E  6E73      	MOVWF FCI_TOSTRI_00042_1_top
0850  6A74      	CLRF FCI_TOSTRI_00042_1_top+D'1'
0852  6A75      	CLRF FCI_TOSTRI_00042_1_top+D'2'
0854  6A76      	CLRF FCI_TOSTRI_00042_1_top+D'3'

	}
	while (( idx < iDst_len) && (top > 0))
0856  506D      	MOVF FCI_TOSTRI_00042_arg_iDst_len, W
0858  6077      	CPFSLT FCI_TOSTRI_00042_1_idx
085A  D074      	BRA	label109
085C  5076      	MOVF FCI_TOSTRI_00042_1_top+D'3', W
085E  0800      	SUBLW 0x00
0860  E108      	BNZ	label105
0862  5075      	MOVF FCI_TOSTRI_00042_1_top+D'2', W
0864  0800      	SUBLW 0x00
0866  E105      	BNZ	label105
0868  5074      	MOVF FCI_TOSTRI_00042_1_top+D'1', W
086A  0800      	SUBLW 0x00
086C  E102      	BNZ	label105
086E  5073      	MOVF FCI_TOSTRI_00042_1_top, W
0870  0800      	SUBLW 0x00
0872            label105
0872  E268      	BC	label109
0942  D789      	BRA	label104
0944            label109

	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
0874  5076      	MOVF FCI_TOSTRI_00042_1_top+D'3', W
0876  5C72      	SUBWF FCI_TOSTRI_00042_1_iSrc+D'3', W
0878  E108      	BNZ	label106
087A  5075      	MOVF FCI_TOSTRI_00042_1_top+D'2', W
087C  5C71      	SUBWF FCI_TOSTRI_00042_1_iSrc+D'2', W
087E  E105      	BNZ	label106
0880  5074      	MOVF FCI_TOSTRI_00042_1_top+D'1', W
0882  5C70      	SUBWF FCI_TOSTRI_00042_1_iSrc+D'1', W
0884  E102      	BNZ	label106
0886  5073      	MOVF FCI_TOSTRI_00042_1_top, W
0888  5C6F      	SUBWF FCI_TOSTRI_00042_1_iSrc, W
088A            label106
088A  E202      	BC	label107
088C  526E      	MOVF FCI_TOSTRI_00042_1_tmp1, F
088E  E041      	BZ	label108
0890            label107
0912            label108

		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
0890  506F      	MOVF FCI_TOSTRI_00042_1_iSrc, W
0892  6E7A      	MOVWF __div_32_3_00004_arg_a
0894  5070      	MOVF FCI_TOSTRI_00042_1_iSrc+D'1', W
0896  6E7B      	MOVWF __div_32_3_00004_arg_a+D'1'
0898  5071      	MOVF FCI_TOSTRI_00042_1_iSrc+D'2', W
089A  6E7C      	MOVWF __div_32_3_00004_arg_a+D'2'
089C  5072      	MOVF FCI_TOSTRI_00042_1_iSrc+D'3', W
089E  6E7D      	MOVWF __div_32_3_00004_arg_a+D'3'
08A0  5073      	MOVF FCI_TOSTRI_00042_1_top, W
08A2  0100      	MOVLB 0x00
08A4  6F80      	MOVWF __div_32_3_00004_arg_b, 1
08A6  5074      	MOVF FCI_TOSTRI_00042_1_top+D'1', W
08A8  6F81      	MOVWF __div_32_3_00004_arg_b+D'1', 1
08AA  5075      	MOVF FCI_TOSTRI_00042_1_top+D'2', W
08AC  6F82      	MOVWF __div_32_3_00004_arg_b+D'2', 1
08AE  5076      	MOVF FCI_TOSTRI_00042_1_top+D'3', W
08B0  6F83      	MOVWF __div_32_3_00004_arg_b+D'3', 1
08B2  EC2FF001  	CALL __div_32_3_00004
08B6  5188      	MOVF CompTempVarRet172, W, 1
08B8  6E6E      	MOVWF FCI_TOSTRI_00042_1_tmp1

			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
08BA  506E      	MOVF FCI_TOSTRI_00042_1_tmp1, W
08BC  0F30      	ADDLW 0x30
08BE  6E7A      	MOVWF CompTempVar1871
08C0  506C      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W
08C2  6EEA      	MOVWF FSR0H
08C4  506B      	MOVF FCI_TOSTRI_00042_arg_sDst, W
08C6  2477      	ADDWF FCI_TOSTRI_00042_1_idx, W
08C8  6EE9      	MOVWF FSR0L
08CA  507A      	MOVF CompTempVar1871, W
08CC  6EEF      	MOVWF INDF0

			idx++;
08CE  2A77      	INCF FCI_TOSTRI_00042_1_idx, F

			iSrc -= tmp1 * top;				// Remove digit
08D0  506E      	MOVF FCI_TOSTRI_00042_1_tmp1, W
08D2  6E7A      	MOVWF __mul_32_3_00009_arg_a
08D4  6A7B      	CLRF __mul_32_3_00009_arg_a+D'1'
08D6  6A7C      	CLRF __mul_32_3_00009_arg_a+D'2'
08D8  6A7D      	CLRF __mul_32_3_00009_arg_a+D'3'
08DA  5073      	MOVF FCI_TOSTRI_00042_1_top, W
08DC  6F80      	MOVWF __mul_32_3_00009_arg_b, 1
08DE  5074      	MOVF FCI_TOSTRI_00042_1_top+D'1', W
08E0  6F81      	MOVWF __mul_32_3_00009_arg_b+D'1', 1
08E2  5075      	MOVF FCI_TOSTRI_00042_1_top+D'2', W
08E4  6F82      	MOVWF __mul_32_3_00009_arg_b+D'2', 1
08E6  5076      	MOVF FCI_TOSTRI_00042_1_top+D'3', W
08E8  6F83      	MOVWF __mul_32_3_00009_arg_b+D'3', 1
08EA  ECF0F000  	CALL __mul_32_3_00009
08EE  5186      	MOVF CompTempVarRet414, W, 1
08F0  6E7E      	MOVWF CompTempVar1872
08F2  5187      	MOVF CompTempVarRet414+D'1', W, 1
08F4  6E7F      	MOVWF CompTempVar1873
08F6  5188      	MOVF CompTempVarRet414+D'2', W, 1
08F8  6F84      	MOVWF CompTempVar1874, 1
08FA  5189      	MOVF CompTempVarRet414+D'3', W, 1
08FC  6F85      	MOVWF CompTempVar1875, 1
08FE  507E      	MOVF CompTempVar1872, W
0900  5E6F      	SUBWF FCI_TOSTRI_00042_1_iSrc, F
0902  507F      	MOVF CompTempVar1873, W
0904  5A70      	SUBWFB FCI_TOSTRI_00042_1_iSrc+D'1', F
0906  5184      	MOVF CompTempVar1874, W, 1
0908  5A71      	SUBWFB FCI_TOSTRI_00042_1_iSrc+D'2', F
090A  5185      	MOVF CompTempVar1875, W, 1
090C  5A72      	SUBWFB FCI_TOSTRI_00042_1_iSrc+D'3', F

			tmp1 = 1;						// Add zeros now
090E  0E01      	MOVLW 0x01
0910  6E6E      	MOVWF FCI_TOSTRI_00042_1_tmp1

		}
		top /= 10;							// Go to next digit
0912  5073      	MOVF FCI_TOSTRI_00042_1_top, W
0914  6E7A      	MOVWF __div_32_3_00004_arg_a
0916  5074      	MOVF FCI_TOSTRI_00042_1_top+D'1', W
0918  6E7B      	MOVWF __div_32_3_00004_arg_a+D'1'
091A  5075      	MOVF FCI_TOSTRI_00042_1_top+D'2', W
091C  6E7C      	MOVWF __div_32_3_00004_arg_a+D'2'
091E  5076      	MOVF FCI_TOSTRI_00042_1_top+D'3', W
0920  6E7D      	MOVWF __div_32_3_00004_arg_a+D'3'
0922  0E0A      	MOVLW 0x0A
0924  0100      	MOVLB 0x00
0926  6F80      	MOVWF __div_32_3_00004_arg_b, 1
0928  6B81      	CLRF __div_32_3_00004_arg_b+D'1', 1
092A  6B82      	CLRF __div_32_3_00004_arg_b+D'2', 1
092C  6B83      	CLRF __div_32_3_00004_arg_b+D'3', 1
092E  EC2FF001  	CALL __div_32_3_00004
0932  5188      	MOVF CompTempVarRet172, W, 1
0934  6E73      	MOVWF FCI_TOSTRI_00042_1_top
0936  5189      	MOVF CompTempVarRet172+D'1', W, 1
0938  6E74      	MOVWF FCI_TOSTRI_00042_1_top+D'1'
093A  518A      	MOVF CompTempVarRet172+D'2', W, 1
093C  6E75      	MOVWF FCI_TOSTRI_00042_1_top+D'2'
093E  518B      	MOVF CompTempVarRet172+D'3', W, 1
0940  6E76      	MOVWF FCI_TOSTRI_00042_1_top+D'3'

	}

	if (idx < iDst_len)						//add terminating null (if we can)
0944  506D      	MOVF FCI_TOSTRI_00042_arg_iDst_len, W
0946  6077      	CPFSLT FCI_TOSTRI_00042_1_idx
0948  D007      	BRA	label110
0958            label110

		sDst[idx] = '\0';
094A  506C      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W
094C  6EEA      	MOVWF FSR0H
094E  506B      	MOVF FCI_TOSTRI_00042_arg_sDst, W
0950  2477      	ADDWF FCI_TOSTRI_00042_1_idx, W
0952  6EE9      	MOVWF FSR0L
0954  0E00      	MOVLW 0x00
0956  6EEF      	MOVWF INDF0

	return (sDst);
0958  506B      	MOVF FCI_TOSTRI_00042_arg_sDst, W
095A  6E78      	MOVWF CompTempVarRet1863
095C  506C      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W
095E  6E79      	MOVWF CompTempVarRet1863+D'1'

}
080E  0012      	RETURN
0960  0012      	RETURN




void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len, strt;

  len = 0;
02C2  6BA0      	CLRF FCI_SHEAD_00000_1_len, 1

  if (sSrc2 == sDst)
02C4  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
02C6  627D      	CPFSEQ FCI_SHEAD_00000_arg_sSrc2
02C8  D08C      	BRA	label40
02CA  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
02CC  627E      	CPFSEQ FCI_SHEAD_00000_arg_sSrc2+D'1'
02CE  D089      	BRA	label40
03E2            label40

  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
02D0  6BA1      	CLRF FCI_SHEAD_00000_1_strt, 1
02D2            label29
02D2  507C      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
02D4  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
02D6  D009      	BRA	label30
02D8  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
02DA  6EEA      	MOVWF FSR0H
02DC  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
02DE  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
02E0  6EE9      	MOVWF FSR0L
02E2  52EF      	MOVF INDF0, F
02E4  E002      	BZ	label30
02E6  2BA1      	INCF FCI_SHEAD_00000_1_strt, F, 1
02E8  D7F4      	BRA	label29
02EA            label30
03E0  D7E0      	BRA	label39

    if (strt < iDst_len)
02EA  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
02EC  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
02EE  D058      	BRA	label38
03A0            label38

    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
02F0  6BA0      	CLRF FCI_SHEAD_00000_1_len, 1
02F2            label31
02F2  507F      	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W
02F4  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
02F6  D009      	BRA	label32
02F8  507E      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
02FA  6EEA      	MOVWF FSR0H
02FC  507D      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
02FE  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
0300  6EE9      	MOVWF FSR0L
0302  52EF      	MOVF INDF0, F
0304  E002      	BZ	label32
0306  2BA0      	INCF FCI_SHEAD_00000_1_len, F, 1
0308  D7F4      	BRA	label31
030A            label32

      if (len > (iDst_len - strt))
030A  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
030C  5D9F      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
030E  6FA2      	MOVWF CompTempVar2023, 1
0310  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
0312  61A2      	CPFSLT CompTempVar2023, 1
0314  D005      	BRA	label33
0320            label33

      {
        len = (iDst_len - strt); // Length of string to copy to
0316  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
0318  5D9F      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
031A  6FA3      	MOVWF CompTempVar2029, 1
031C  51A3      	MOVF CompTempVar2029, W, 1
031E  6FA0      	MOVWF FCI_SHEAD_00000_1_len, 1

      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
0320  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
0322  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0324  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len

      strt = len;
0326  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
0328  6FA1      	MOVWF FCI_SHEAD_00000_1_strt, 1

      while (strt > 0)
032A            label34
032A  0E00      	MOVLW 0x00
032C  65A1      	CPFSGT FCI_SHEAD_00000_1_strt, 1
032E  D014      	BRA	label35
0356  D7E9      	BRA	label34
0358            label35

      {
        strt--;
0330  07A1      	DECF FCI_SHEAD_00000_1_strt, F, 1

        iSrc2_len--;
0332  067F      	DECF FCI_SHEAD_00000_arg_iSrc2_len, F

        sDst[iSrc2_len] = sSrc2[strt];
0334  507E      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
0336  6EEA      	MOVWF FSR0H
0338  507D      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
033A  6EE9      	MOVWF FSR0L
033C  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
033E  6FA3      	MOVWF CompTempVar2032, 1
0340  51A3      	MOVF CompTempVar2032, W, 1
0342  26E9      	ADDWF FSR0L, F
0344  50EF      	MOVF INDF0, W
0346  6FA4      	MOVWF CompTempVar2033, 1
0348  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
034A  6EEA      	MOVWF FSR0H
034C  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
034E  247F      	ADDWF FCI_SHEAD_00000_arg_iSrc2_len, W
0350  6EE9      	MOVWF FSR0L
0352  51A4      	MOVF CompTempVar2033, W, 1
0354  6EEF      	MOVWF INDF0

      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
0358  6BA1      	CLRF FCI_SHEAD_00000_1_strt, 1
035A            label36
035A  507C      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
035C  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
035E  D01D      	BRA	label37
0360  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
0362  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
0364  D01A      	BRA	label37
0366  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0368  6EEA      	MOVWF FSR0H
036A  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
036C  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
036E  6EE9      	MOVWF FSR0L
0370  52EF      	MOVF INDF0, F
0372  E013      	BZ	label37
0374  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0376  6EEA      	MOVWF FSR0H
0378  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
037A  6EE9      	MOVWF FSR0L
037C  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
037E  6FA3      	MOVWF CompTempVar2036, 1
0380  51A3      	MOVF CompTempVar2036, W, 1
0382  26E9      	ADDWF FSR0L, F
0384  50EF      	MOVF INDF0, W
0386  6FA4      	MOVWF CompTempVar2037, 1
0388  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
038A  6EEA      	MOVWF FSR0H
038C  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
038E  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0390  6EE9      	MOVWF FSR0L
0392  51A4      	MOVF CompTempVar2037, W, 1
0394  6EEF      	MOVWF INDF0
0396  2BA1      	INCF FCI_SHEAD_00000_1_strt, F, 1
0398  D7E0      	BRA	label36
039A            label37

      len += strt;
039A  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
039C  27A0      	ADDWF FCI_SHEAD_00000_1_len, F, 1

    }
    else
039E  D075      	BRA	label45

    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
03A0  6BA0      	CLRF FCI_SHEAD_00000_1_len, 1
03A2            label39
03A2  507C      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
03A4  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
03A6  D071      	BRA	label45
03A8  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
03AA  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
03AC  D06E      	BRA	label45
03AE  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
03B0  6EEA      	MOVWF FSR0H
03B2  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
03B4  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
03B6  6EE9      	MOVWF FSR0L
03B8  52EF      	MOVF INDF0, F
03BA  E067      	BZ	label45
03BC  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
03BE  6EEA      	MOVWF FSR0H
03C0  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
03C2  6EE9      	MOVWF FSR0L
03C4  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
03C6  6FA2      	MOVWF CompTempVar2044, 1
03C8  51A2      	MOVF CompTempVar2044, W, 1
03CA  26E9      	ADDWF FSR0L, F
03CC  50EF      	MOVF INDF0, W
03CE  6FA3      	MOVWF CompTempVar2045, 1
03D0  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
03D2  6EEA      	MOVWF FSR0H
03D4  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
03D6  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
03D8  6EE9      	MOVWF FSR0L
03DA  51A3      	MOVF CompTempVar2045, W, 1
03DC  6EEF      	MOVWF INDF0
03DE  2BA0      	INCF FCI_SHEAD_00000_1_len, F, 1

    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
03E2  6BA0      	CLRF FCI_SHEAD_00000_1_len, 1
03E4            label41
03E4  507C      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
03E6  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
03E8  D01D      	BRA	label42
03EA  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
03EC  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
03EE  D01A      	BRA	label42
03F0  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
03F2  6EEA      	MOVWF FSR0H
03F4  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
03F6  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
03F8  6EE9      	MOVWF FSR0L
03FA  52EF      	MOVF INDF0, F
03FC  E013      	BZ	label42
03FE  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0400  6EEA      	MOVWF FSR0H
0402  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0404  6EE9      	MOVWF FSR0L
0406  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
0408  6FA2      	MOVWF CompTempVar2052, 1
040A  51A2      	MOVF CompTempVar2052, W, 1
040C  26E9      	ADDWF FSR0L, F
040E  50EF      	MOVF INDF0, W
0410  6FA3      	MOVWF CompTempVar2053, 1
0412  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0414  6EEA      	MOVWF FSR0H
0416  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
0418  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
041A  6EE9      	MOVWF FSR0L
041C  51A3      	MOVF CompTempVar2053, W, 1
041E  6EEF      	MOVWF INDF0
0420  2BA0      	INCF FCI_SHEAD_00000_1_len, F, 1
0422  D7E0      	BRA	label41
0424            label42

    // Copy second
    if (len < iDst_len)
0424  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
0426  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
0428  D030      	BRA	label45
048A            label45

    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
042A  6BA3      	CLRF CompTempVar2059, 1
042C  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
042E  259D      	ADDWF FCI_SHEAD_00000_arg_sDst, W, 1
0430  6FA2      	MOVWF CompTempVar2058, 1
0432  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0434  23A3      	ADDWFC CompTempVar2059, F, 1
0436  51A2      	MOVF CompTempVar2058, W, 1
0438  6E7A      	MOVWF FCI_SHEAD_00000_arg_sSrc1
043A  51A3      	MOVF CompTempVar2059, W, 1
043C  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'

      iSrc1_len = iDst_len - len;
043E  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
0440  5D9F      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
0442  6E7C      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len

      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
0444  6BA1      	CLRF FCI_SHEAD_00000_1_strt, 1
0446            label43
0446  507F      	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W
0448  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
044A  D01D      	BRA	label44
044C  507C      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
044E  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
0450  D01A      	BRA	label44
0452  507E      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
0454  6EEA      	MOVWF FSR0H
0456  507D      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
0458  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
045A  6EE9      	MOVWF FSR0L
045C  52EF      	MOVF INDF0, F
045E  E013      	BZ	label44
0460  507E      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
0462  6EEA      	MOVWF FSR0H
0464  507D      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
0466  6EE9      	MOVWF FSR0L
0468  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
046A  6FA2      	MOVWF CompTempVar2062, 1
046C  51A2      	MOVF CompTempVar2062, W, 1
046E  26E9      	ADDWF FSR0L, F
0470  50EF      	MOVF INDF0, W
0472  6FA3      	MOVWF CompTempVar2063, 1
0474  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0476  6EEA      	MOVWF FSR0H
0478  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
047A  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
047C  6EE9      	MOVWF FSR0L
047E  51A3      	MOVF CompTempVar2063, W, 1
0480  6EEF      	MOVWF INDF0
0482  2BA1      	INCF FCI_SHEAD_00000_1_strt, F, 1
0484  D7E0      	BRA	label43
0486            label44

      len += strt;
0486  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
0488  27A0      	ADDWF FCI_SHEAD_00000_1_len, F, 1

    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
048A  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
048C  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1

  {
    sDst[len] = '\0';
0490  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0492  6EEA      	MOVWF FSR0H
0494  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
0496  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
0498  6EE9      	MOVWF FSR0L
049A  0E00      	MOVLW 0x00
049C  6EEF      	MOVWF INDF0

  }
}
048E  0012      	RETURN
049E  0012      	RETURN



/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
0962  0100      	MOVLB 0x00
0964  6BD1      	CLRF FCI_SCOPY_00000_1_len, 1
0966            label111
0966  507C      	MOVF FCI_SCOPY_00000_arg_iSrc_len, W
0968  61D1      	CPFSLT FCI_SCOPY_00000_1_len, 1
096A  D01D      	BRA	label112
096C  507F      	MOVF FCI_SCOPY_00000_arg_iDst_len, W
096E  61D1      	CPFSLT FCI_SCOPY_00000_1_len, 1
0970  D01A      	BRA	label112
0972  5061      	MOVF FCI_SCOPY_00000_arg_sSrc+D'1', W
0974  6EEA      	MOVWF FSR0H
0976  5060      	MOVF FCI_SCOPY_00000_arg_sSrc, W
0978  25D1      	ADDWF FCI_SCOPY_00000_1_len, W, 1
097A  6EE9      	MOVWF FSR0L
097C  52EF      	MOVF INDF0, F
097E  E013      	BZ	label112
0980  5061      	MOVF FCI_SCOPY_00000_arg_sSrc+D'1', W
0982  6EEA      	MOVWF FSR0H
0984  5060      	MOVF FCI_SCOPY_00000_arg_sSrc, W
0986  6EE9      	MOVWF FSR0L
0988  51D1      	MOVF FCI_SCOPY_00000_1_len, W, 1
098A  6FD2      	MOVWF CompTempVar2071, 1
098C  51D2      	MOVF CompTempVar2071, W, 1
098E  26E9      	ADDWF FSR0L, F
0990  50EF      	MOVF INDF0, W
0992  6FD3      	MOVWF CompTempVar2072, 1
0994  507E      	MOVF FCI_SCOPY_00000_arg_sDst+D'1', W
0996  6EEA      	MOVWF FSR0H
0998  507D      	MOVF FCI_SCOPY_00000_arg_sDst, W
099A  25D1      	ADDWF FCI_SCOPY_00000_1_len, W, 1
099C  6EE9      	MOVWF FSR0L
099E  51D3      	MOVF CompTempVar2072, W, 1
09A0  6EEF      	MOVWF INDF0
09A2  2BD1      	INCF FCI_SCOPY_00000_1_len, F, 1
09A4  D7E0      	BRA	label111
09A6            label112

  // Terminate (only if can)
  if (len < iDst_len)
09A6  507F      	MOVF FCI_SCOPY_00000_arg_iDst_len, W
09A8  61D1      	CPFSLT FCI_SCOPY_00000_1_len, 1

  {
    sDst[len] = '\0';
09AC  507E      	MOVF FCI_SCOPY_00000_arg_sDst+D'1', W
09AE  6EEA      	MOVWF FSR0H
09B0  507D      	MOVF FCI_SCOPY_00000_arg_sDst, W
09B2  25D1      	ADDWF FCI_SCOPY_00000_1_len, W, 1
09B4  6EE9      	MOVWF FSR0L
09B6  0E00      	MOVLW 0x00
09B8  6EEF      	MOVWF INDF0

  }
}
09AA  0012      	RETURN
09BA  0012      	RETURN





//************************************************************************************
//**  
//**  Source name:   G:\Projet\Bluetooth\connect_boards\first_player\joueur_1.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Tuesday, March 21, 2017 16:36:42
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x78
#endif
#ifdef HI_TECH_C
__CONFIG(0x78);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_RETURN 20
#define FCV_FALSE (0)
#define FCV_BT_CONNECTED (255) // Indique si les deux modules bluetooth sont connectés
#define FCV_BT_COMMAND_EMPTY (255) // Résultat de la commande vide
#define FCV_BT_COMMAND_OK (0) // Succès de la commande
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_OCTET;
MX_GLOBAL MX_CHAR FCV_RETURN[FCVsz_RETURN];
MX_GLOBAL MX_UINT8 FCV_COMMAND_RETURN; // Retour des commandes envoyés/reçues
MX_GLOBAL MX_UINT8 FCV_BT_STATE = (0xa5); // État du bluetooth
1372  0EA5      	MOVLW 0xA5
1374  6E57      	MOVWF gbl_FCV_BT_STATE

MX_GLOBAL MX_SINT16 FCV_LOOP;

void FCM_INITIALISATION();
void FCM_BT_CHECK_CONNECTON();
void FCM_CHECK_BT_GETTING();
void FCM_BT_CONNECTION();

/*========================================================================*\
   Use :ctrl_lcd
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_eb005
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_0ad31_lcd_eb005__Clear FCD_04071_LCD__Clear
#define FCD_0ad31_lcd_eb005__PrintString FCD_04071_LCD__PrintString
#define FCD_0ad31_lcd_eb005__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0ad31_lcd_eb005__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0ad31_lcd_eb005__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0ad31_lcd_eb005__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0ad31_lcd_eb005__Cursor FCD_04071_LCD__Cursor
#define FCD_0ad31_lcd_eb005__Command FCD_04071_LCD__Command
#define FCD_0ad31_lcd_eb005__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0ad31_lcd_eb005__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0ad31_lcd_eb005__RawSend FCD_04071_LCD__RawSend
#define FCD_0ad31_lcd_eb005__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :InjectorBase1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 portb
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 portb
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisb
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisb
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (4)
#define MX_UART_INT_1 (1)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :Bluetooth2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_0c851_Bluetooth2__STRING_ARRAY 50
#define FCV_0c851_Bluetooth2__BT_CHAR_CR (13)
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__STRING_ARRAY[FCVsz_0c851_Bluetooth2__STRING_ARRAY];
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_IDX = (0x0);
1376  6A58      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX

MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_DONE = (0x0);
1378  6A59      	CLRF gbl_FCV_0c851_Bluetooth2___00001

MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_LENGTH = (0x0);
137A  6A5A      	CLRF gbl_FCV_0c851_Bluetooth2___00002


MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY);
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT);
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX);
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR);
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES);
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings();
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA);
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE);
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive();
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings();
MX_UINT8 FCD_0c851_Bluetooth2__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :ctrl_lcd
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()

{




	FCD_04071_LCD__RawSend(0x01, 0);
0BF4  0E01      	MOVLW 0x01
0BF6  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
0BF8  0100      	MOVLB 0x00
0BFA  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
0BFC  EC88F002  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
0C00  0E02      	MOVLW 0x02
0C02  6E70      	MOVWF delay_ms_00000_arg_del
0C04  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x02, 0);
0C08  0E02      	MOVLW 0x02
0C0A  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
0C0C  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
0C0E  EC88F002  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
0C12  0E02      	MOVLW 0x02
0C14  6E70      	MOVWF delay_ms_00000_arg_del
0C16  EC0BF000  	CALL delay_ms_00000


}
0C1A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Param??tres pour la macro PrintString :
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
0C1C  6A7D      	CLRF FCD_04071__00053_1_FCL_IDX

	MX_UINT8 FCL_COUNT;



	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);
0C1E  5067      	MOVF FCD_04071__00053_arg_FCL_TEXT, W
0C20  0100      	MOVLB 0x00
0C22  6F96      	MOVWF FCI_GETLEN_0003E_arg_sStr1, 1
0C24  5068      	MOVF FCD_04071__00053_arg_FCL_TEXT+D'1', W
0C26  6F97      	MOVWF FCI_GETLEN_0003E_arg_sStr1+D'1', 1
0C28  507B      	MOVF FCD_04071__00053_arg_FCLsz_TEXT, W
0C2A  6F98      	MOVWF FCI_GETLEN_0003E_arg_iStr1_len, 1
0C2C  ECB8F000  	CALL FCI_GETLEN_0003E
0C30  519A      	MOVF CompTempVarRet1850, W, 1
0C32  6E7E      	MOVWF FCD_04071__00053_1_FCL_COUNT


	while (FCL_IDX < FCL_COUNT)
0C34            label118
0C34  507E      	MOVF FCD_04071__00053_1_FCL_COUNT, W
0C36  607D      	CPFSLT FCD_04071__00053_1_FCL_IDX
0C52  D7F0      	BRA	label118

	{

		FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);
0C3A  5068      	MOVF FCD_04071__00053_arg_FCL_TEXT+D'1', W
0C3C  6EEA      	MOVWF FSR0H
0C3E  5067      	MOVF FCD_04071__00053_arg_FCL_TEXT, W
0C40  247D      	ADDWF FCD_04071__00053_1_FCL_IDX, W
0C42  6EE9      	MOVWF FSR0L
0C44  50EF      	MOVF INDF0, W
0C46  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
0C48  8180      	BSF FCD_04071__0005C_arg_FCL_TYPE,0, 1
0C4A  EC88F002  	CALL FCD_04071__0005C


		FCL_IDX = FCL_IDX + 1;
0C4E  287D      	INCF FCD_04071__00053_1_FCL_IDX, W
0C50  6E7D      	MOVWF FCD_04071__00053_1_FCL_IDX



	}


}
0C38  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Param??tres pour la macro PrintAscii :
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)

{
	//Définitions des variables locales
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);
0F56  505B      	MOVF FCD_04071__0005B_arg_FCL_NUMBER, W
0F58  6E67      	MOVWF FCI_TOSTRI_00042_arg_iSrc1
0F5A  505C      	MOVF FCD_04071__0005B_arg_FCL_NUMBER+D'1', W
0F5C  6E68      	MOVWF FCI_TOSTRI_00042_arg_iSrc1+D'1'
0F5E  6A69      	CLRF FCI_TOSTRI_00042_arg_iSrc1+D'2'
0F60  6A6A      	CLRF FCI_TOSTRI_00042_arg_iSrc1+D'3'
0F62  AE5C      	BTFSS FCD_04071__0005B_arg_FCL_NUMBER+D'1',7
0F64  D002      	BRA	label138
0F66  0669      	DECF FCI_TOSTRI_00042_arg_iSrc1+D'2', F
0F68  066A      	DECF FCI_TOSTRI_00042_arg_iSrc1+D'3', F
0F6A            label138
0F6A  0E00      	MOVLW HIGH(FCD_04071__0005B_1_FCL_S+D'0')
0F6C  6E6C      	MOVWF FCI_TOSTRI_00042_arg_sDst+D'1'
0F6E  0E5D      	MOVLW LOW(FCD_04071__0005B_1_FCL_S+D'0')
0F70  6E6B      	MOVWF FCI_TOSTRI_00042_arg_sDst
0F72  0E0A      	MOVLW 0x0A
0F74  6E6D      	MOVWF FCI_TOSTRI_00042_arg_iDst_len
0F76  ECF1F003  	CALL FCI_TOSTRI_00042


	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);
0F7A  0E00      	MOVLW HIGH(FCD_04071__0005B_1_FCL_S+D'0')
0F7C  6E68      	MOVWF FCD_04071__00053_arg_FCL_TEXT+D'1'
0F7E  0E5D      	MOVLW LOW(FCD_04071__0005B_1_FCL_S+D'0')
0F80  6E67      	MOVWF FCD_04071__00053_arg_FCL_TEXT
0F82  0E0A      	MOVLW 0x0A
0F84  6E7B      	MOVWF FCD_04071__00053_arg_FCLsz_TEXT
0F86  6A7C      	CLRF FCD_04071__00053_arg_FCLsz_TEXT+D'1'
0F88  EC0EF006  	CALL FCD_04071__00053


	//Définitions des variables locales
	#undef FCLsz_S
}
0F8C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Param??tres pour la macro RAMWrite :
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Param??tres pour la macro ClearLine :
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Param??tres pour la macro Cursor :
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)

{



	#if (0) // 2 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
0F8E  525C      	MOVF FCD_04071__00054_arg_FCL_Y, F
0F90  E103      	BNZ	label139
0F98            label139

		{

			FCL_Y = 0x80;
0F92  0E80      	MOVLW 0x80
0F94  6E5C      	MOVWF FCD_04071__00054_arg_FCL_Y


		} else {
0F96  D002      	BRA	label140
0F9C            label140


			FCL_Y = 0xC0;
0F98  0EC0      	MOVLW 0xC0
0F9A  6E5C      	MOVWF FCD_04071__00054_arg_FCL_Y


		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 2 == 4

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);
0F9C  505B      	MOVF FCD_04071__00054_arg_FCL_X, W
0F9E  245C      	ADDWF FCD_04071__00054_arg_FCL_Y, W
0FA0  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
0FA2  0100      	MOVLB 0x00
0FA4  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
0FA6  EC88F002  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
0FAA  0E02      	MOVLW 0x02
0FAC  6E70      	MOVWF delay_ms_00000_arg_del
0FAE  EC0BF000  	CALL delay_ms_00000


}
0FB2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Param??tres pour la macro Command :
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Param??tres pour la macro PrintFormattedNumber :
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Définitions des variables locales
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Param??tres pour la macro ScrollDisplay :
       :  Position : Holds the number of positions to shift the display
       :  direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Définitions des variables locales
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	switch (FCL_DIRECTION)
	{
		case 0:
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'l':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'L':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 1:
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'r':
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'R':
		{
			FCL_CMD = 0x1C;


			break;
		}
		// default:

	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Param??tres pour la macro RawSend :
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)

{
	//Définitions des variables locales
	MX_UINT8 FCL_NIBBLE;


	//Commentaire:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
0510  6B82      	CLRF FCD_04071__0005C_2_ptmp, 1
0512  9092      	BCF gbl_trisa,0
0514  5382      	MOVF FCD_04071__0005C_2_ptmp, F, 1
0516  E004      	BZ	label52
0518  0E01      	MOVLW 0x01
051A  1089      	IORWF gbl_lata, W
051C  6E80      	MOVWF gbl_porta
051E  D003      	BRA	label53
0520            label52
0520  0EFE      	MOVLW 0xFE
0522  1489      	ANDWF gbl_lata, W
0524  6E80      	MOVWF gbl_porta
0526            label53

		FCP_SET(B, A, 0x2, 0x1, 0);
0526  6B82      	CLRF FCD_04071__0005C_9_ptmp, 1
0528  9292      	BCF gbl_trisa,1
052A  5382      	MOVF FCD_04071__0005C_9_ptmp, F, 1
052C  E004      	BZ	label54
052E  0E02      	MOVLW 0x02
0530  1089      	IORWF gbl_lata, W
0532  6E80      	MOVWF gbl_porta
0534  D003      	BRA	label55
0536            label54
0536  0EFD      	MOVLW 0xFD
0538  1489      	ANDWF gbl_lata, W
053A  6E80      	MOVWF gbl_porta
053C            label55

		FCP_SET(B, A, 0x4, 0x2, 0);
053C  6B82      	CLRF FCD_04071__0005C_16_ptmp, 1
053E  9492      	BCF gbl_trisa,2
0540  5382      	MOVF FCD_04071__0005C_16_ptmp, F, 1
0542  E004      	BZ	label56
0544  0E04      	MOVLW 0x04
0546  1089      	IORWF gbl_lata, W
0548  6E80      	MOVWF gbl_porta
054A  D003      	BRA	label57
054C            label56
054C  0EFB      	MOVLW 0xFB
054E  1489      	ANDWF gbl_lata, W
0550  6E80      	MOVWF gbl_porta
0552            label57

		FCP_SET(B, A, 0x8, 0x3, 0);
0552  6B82      	CLRF FCD_04071__0005C_23_ptmp, 1
0554  9692      	BCF gbl_trisa,3
0556  5382      	MOVF FCD_04071__0005C_23_ptmp, F, 1
0558  E004      	BZ	label58
055A  0E08      	MOVLW 0x08
055C  1089      	IORWF gbl_lata, W
055E  6E80      	MOVWF gbl_porta
0560  D003      	BRA	label59
0562            label58
0562  0EF7      	MOVLW 0xF7
0564  1489      	ANDWF gbl_lata, W
0566  6E80      	MOVWF gbl_porta
0568            label59

		FCP_SET(B, A, 0x10, 0x4, 0);
0568  6B82      	CLRF FCD_04071__0005C_30_ptmp, 1
056A  9892      	BCF gbl_trisa,4
056C  5382      	MOVF FCD_04071__0005C_30_ptmp, F, 1
056E  E004      	BZ	label60
0570  0E10      	MOVLW 0x10
0572  1089      	IORWF gbl_lata, W
0574  6E80      	MOVWF gbl_porta
0576  D003      	BRA	label61
0578            label60
0578  0EEF      	MOVLW 0xEF
057A  1489      	ANDWF gbl_lata, W
057C  6E80      	MOVWF gbl_porta
057E            label61

		FCP_SET(B, A, 0x20, 0x5, 0);
057E  6B82      	CLRF FCD_04071__0005C_37_ptmp, 1
0580  9A92      	BCF gbl_trisa,5
0582  5382      	MOVF FCD_04071__0005C_37_ptmp, F, 1
0584  E004      	BZ	label62
0586  0E20      	MOVLW 0x20
0588  1089      	IORWF gbl_lata, W
058A  6E80      	MOVWF gbl_porta
058C  D003      	BRA	label63
058E            label62
058E  0EDF      	MOVLW 0xDF
0590  1489      	ANDWF gbl_lata, W
0592  6E80      	MOVWF gbl_porta
0594            label63


		#if (0)

		//Le code a été optimisé par le préprocesseur
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
0594  387F      	SWAPF FCD_04071__0005C_arg_FCL_DATA, W
0596  0B0F      	ANDLW 0x0F
0598  6F81      	MOVWF FCD_04071__0005C_1_FCL_NIBBLE, 1

		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
059A  0E01      	MOVLW 0x01
059C  1581      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W, 1
059E  6F82      	MOVWF FCD_04071__0005C_46_ptmp, 1
05A0  9092      	BCF gbl_trisa,0
05A2  5382      	MOVF FCD_04071__0005C_46_ptmp, F, 1
05A4  E004      	BZ	label64
05A6  0E01      	MOVLW 0x01
05A8  1089      	IORWF gbl_lata, W
05AA  6E80      	MOVWF gbl_porta
05AC  D003      	BRA	label65
05AE            label64
05AE  0EFE      	MOVLW 0xFE
05B0  1489      	ANDWF gbl_lata, W
05B2  6E80      	MOVWF gbl_porta
05B4            label65

		FCL_NIBBLE = FCL_NIBBLE >> 1;
05B4  5381      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F, 1
05B6  90D8      	BCF STATUS,C
05B8  3381      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
05BA  0E01      	MOVLW 0x01
05BC  1581      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W, 1
05BE  6F82      	MOVWF FCD_04071__0005C_55_ptmp, 1
05C0  9292      	BCF gbl_trisa,1
05C2  5382      	MOVF FCD_04071__0005C_55_ptmp, F, 1
05C4  E004      	BZ	label66
05C6  0E02      	MOVLW 0x02
05C8  1089      	IORWF gbl_lata, W
05CA  6E80      	MOVWF gbl_porta
05CC  D003      	BRA	label67
05CE            label66
05CE  0EFD      	MOVLW 0xFD
05D0  1489      	ANDWF gbl_lata, W
05D2  6E80      	MOVWF gbl_porta
05D4            label67

		FCL_NIBBLE = FCL_NIBBLE >> 1;
05D4  5381      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F, 1
05D6  90D8      	BCF STATUS,C
05D8  3381      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
05DA  0E01      	MOVLW 0x01
05DC  1581      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W, 1
05DE  6F82      	MOVWF FCD_04071__0005C_64_ptmp, 1
05E0  9492      	BCF gbl_trisa,2
05E2  5382      	MOVF FCD_04071__0005C_64_ptmp, F, 1
05E4  E004      	BZ	label68
05E6  0E04      	MOVLW 0x04
05E8  1089      	IORWF gbl_lata, W
05EA  6E80      	MOVWF gbl_porta
05EC  D003      	BRA	label69
05EE            label68
05EE  0EFB      	MOVLW 0xFB
05F0  1489      	ANDWF gbl_lata, W
05F2  6E80      	MOVWF gbl_porta
05F4            label69

		FCL_NIBBLE = FCL_NIBBLE >> 1;
05F4  5381      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F, 1
05F6  90D8      	BCF STATUS,C
05F8  3381      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));
05FA  0E01      	MOVLW 0x01
05FC  1581      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W, 1
05FE  6F82      	MOVWF FCD_04071__0005C_73_ptmp, 1
0600  9692      	BCF gbl_trisa,3
0602  5382      	MOVF FCD_04071__0005C_73_ptmp, F, 1
0604  E004      	BZ	label70
0606  0E08      	MOVLW 0x08
0608  1089      	IORWF gbl_lata, W
060A  6E80      	MOVWF gbl_porta
060C  D003      	BRA	label71
060E            label70
060E  0EF7      	MOVLW 0xF7
0610  1489      	ANDWF gbl_lata, W
0612  6E80      	MOVWF gbl_porta
0614            label71


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	//Commentaire:
	//Output byte to pins

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	//Commentaire:
	//Output byte to port

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	if (FCL_TYPE)
0614  A180      	BTFSS FCD_04071__0005C_arg_FCL_TYPE,0, 1
0616  D00C      	BRA	label73

	{

		FCP_SET(B, A, 0x10, 0x4, 1);
0618  0E01      	MOVLW 0x01
061A  6F82      	MOVWF FCD_04071__0005C_82_ptmp, 1
061C  9892      	BCF gbl_trisa,4
061E  5382      	MOVF FCD_04071__0005C_82_ptmp, F, 1
0620  E004      	BZ	label72
0622  0E10      	MOVLW 0x10
0624  1089      	IORWF gbl_lata, W
0626  6E80      	MOVWF gbl_porta
0628  D003      	BRA	label73
062A            label72
062A  0EEF      	MOVLW 0xEF
062C  1489      	ANDWF gbl_lata, W
062E  6E80      	MOVWF gbl_porta
0630            label73


	// } else {

	}

	FCI_DELAYBYTE_US(100);
0630  0E64      	MOVLW 0x64
0632  6FAD      	MOVWF delay_us_00000_arg_del, 1
0634  EC06F000  	CALL delay_us_00000


	//Commentaire:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, A, 0x20, 0x5, 1);
0638  0E01      	MOVLW 0x01
063A  6F82      	MOVWF FCD_04071__0005C_93_ptmp, 1
063C  9A92      	BCF gbl_trisa,5
063E  5382      	MOVF FCD_04071__0005C_93_ptmp, F, 1
0640  E004      	BZ	label74
0642  0E20      	MOVLW 0x20
0644  1089      	IORWF gbl_lata, W
0646  6E80      	MOVWF gbl_porta
0648  D003      	BRA	label75
064A            label74
064A  0EDF      	MOVLW 0xDF
064C  1489      	ANDWF gbl_lata, W
064E  6E80      	MOVWF gbl_porta
0650            label75


	FCI_DELAYBYTE_US(100);
0650  0E64      	MOVLW 0x64
0652  6FAD      	MOVWF delay_us_00000_arg_del, 1
0654  EC06F000  	CALL delay_us_00000


	FCP_SET(B, A, 0x20, 0x5, 0);
0658  6B82      	CLRF FCD_04071__0005C_104_ptmp, 1
065A  9A92      	BCF gbl_trisa,5
065C  5382      	MOVF FCD_04071__0005C_104_ptmp, F, 1
065E  E004      	BZ	label76
0660  0E20      	MOVLW 0x20
0662  1089      	IORWF gbl_lata, W
0664  6E80      	MOVWF gbl_porta
0666  D003      	BRA	label77
0668            label76
0668  0EDF      	MOVLW 0xDF
066A  1489      	ANDWF gbl_lata, W
066C  6E80      	MOVWF gbl_porta
066E            label77


	FCI_DELAYBYTE_US(100);
066E  0E64      	MOVLW 0x64
0670  6FAD      	MOVWF delay_us_00000_arg_del, 1
0672  EC06F000  	CALL delay_us_00000


	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
0676  6B82      	CLRF FCD_04071__0005C_115_ptmp, 1
0678  9092      	BCF gbl_trisa,0
067A  5382      	MOVF FCD_04071__0005C_115_ptmp, F, 1
067C  E004      	BZ	label78
067E  0E01      	MOVLW 0x01
0680  1089      	IORWF gbl_lata, W
0682  6E80      	MOVWF gbl_porta
0684  D003      	BRA	label79
0686            label78
0686  0EFE      	MOVLW 0xFE
0688  1489      	ANDWF gbl_lata, W
068A  6E80      	MOVWF gbl_porta
068C            label79

		FCP_SET(B, A, 0x2, 0x1, 0);
068C  6B82      	CLRF FCD_04071__0005C_122_ptmp, 1
068E  9292      	BCF gbl_trisa,1
0690  5382      	MOVF FCD_04071__0005C_122_ptmp, F, 1
0692  E004      	BZ	label80
0694  0E02      	MOVLW 0x02
0696  1089      	IORWF gbl_lata, W
0698  6E80      	MOVWF gbl_porta
069A  D003      	BRA	label81
069C            label80
069C  0EFD      	MOVLW 0xFD
069E  1489      	ANDWF gbl_lata, W
06A0  6E80      	MOVWF gbl_porta
06A2            label81

		FCP_SET(B, A, 0x4, 0x2, 0);
06A2  6B82      	CLRF FCD_04071__0005C_129_ptmp, 1
06A4  9492      	BCF gbl_trisa,2
06A6  5382      	MOVF FCD_04071__0005C_129_ptmp, F, 1
06A8  E004      	BZ	label82
06AA  0E04      	MOVLW 0x04
06AC  1089      	IORWF gbl_lata, W
06AE  6E80      	MOVWF gbl_porta
06B0  D003      	BRA	label83
06B2            label82
06B2  0EFB      	MOVLW 0xFB
06B4  1489      	ANDWF gbl_lata, W
06B6  6E80      	MOVWF gbl_porta
06B8            label83

		FCP_SET(B, A, 0x8, 0x3, 0);
06B8  6B82      	CLRF FCD_04071__0005C_136_ptmp, 1
06BA  9692      	BCF gbl_trisa,3
06BC  5382      	MOVF FCD_04071__0005C_136_ptmp, F, 1
06BE  E004      	BZ	label84
06C0  0E08      	MOVLW 0x08
06C2  1089      	IORWF gbl_lata, W
06C4  6E80      	MOVWF gbl_porta
06C6  D003      	BRA	label85
06C8            label84
06C8  0EF7      	MOVLW 0xF7
06CA  1489      	ANDWF gbl_lata, W
06CC  6E80      	MOVWF gbl_porta
06CE            label85

		FCP_SET(B, A, 0x10, 0x4, 0);
06CE  6B82      	CLRF FCD_04071__0005C_143_ptmp, 1
06D0  9892      	BCF gbl_trisa,4
06D2  5382      	MOVF FCD_04071__0005C_143_ptmp, F, 1
06D4  E004      	BZ	label86
06D6  0E10      	MOVLW 0x10
06D8  1089      	IORWF gbl_lata, W
06DA  6E80      	MOVWF gbl_porta
06DC  D003      	BRA	label87
06DE            label86
06DE  0EEF      	MOVLW 0xEF
06E0  1489      	ANDWF gbl_lata, W
06E2  6E80      	MOVWF gbl_porta
06E4            label87


		FCL_NIBBLE = (FCL_DATA & 0xf);
06E4  0E0F      	MOVLW 0x0F
06E6  147F      	ANDWF FCD_04071__0005C_arg_FCL_DATA, W
06E8  6F82      	MOVWF CompTempVar2692, 1
06EA  5182      	MOVF CompTempVar2692, W, 1
06EC  6F81      	MOVWF FCD_04071__0005C_1_FCL_NIBBLE, 1

		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
06EE  0E01      	MOVLW 0x01
06F0  1581      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W, 1
06F2  6F82      	MOVWF FCD_04071__0005C_152_ptmp, 1
06F4  9092      	BCF gbl_trisa,0
06F6  5382      	MOVF FCD_04071__0005C_152_ptmp, F, 1
06F8  E004      	BZ	label88
06FA  0E01      	MOVLW 0x01
06FC  1089      	IORWF gbl_lata, W
06FE  6E80      	MOVWF gbl_porta
0700  D003      	BRA	label89
0702            label88
0702  0EFE      	MOVLW 0xFE
0704  1489      	ANDWF gbl_lata, W
0706  6E80      	MOVWF gbl_porta
0708            label89

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0708  5381      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F, 1
070A  90D8      	BCF STATUS,C
070C  3381      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
070E  0E01      	MOVLW 0x01
0710  1581      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W, 1
0712  6F82      	MOVWF FCD_04071__0005C_161_ptmp, 1
0714  9292      	BCF gbl_trisa,1
0716  5382      	MOVF FCD_04071__0005C_161_ptmp, F, 1
0718  E004      	BZ	label90
071A  0E02      	MOVLW 0x02
071C  1089      	IORWF gbl_lata, W
071E  6E80      	MOVWF gbl_porta
0720  D003      	BRA	label91
0722            label90
0722  0EFD      	MOVLW 0xFD
0724  1489      	ANDWF gbl_lata, W
0726  6E80      	MOVWF gbl_porta
0728            label91

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0728  5381      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F, 1
072A  90D8      	BCF STATUS,C
072C  3381      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
072E  0E01      	MOVLW 0x01
0730  1581      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W, 1
0732  6F82      	MOVWF FCD_04071__0005C_170_ptmp, 1
0734  9492      	BCF gbl_trisa,2
0736  5382      	MOVF FCD_04071__0005C_170_ptmp, F, 1
0738  E004      	BZ	label92
073A  0E04      	MOVLW 0x04
073C  1089      	IORWF gbl_lata, W
073E  6E80      	MOVWF gbl_porta
0740  D003      	BRA	label93
0742            label92
0742  0EFB      	MOVLW 0xFB
0744  1489      	ANDWF gbl_lata, W
0746  6E80      	MOVWF gbl_porta
0748            label93

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0748  5381      	MOVF FCD_04071__0005C_1_FCL_NIBBLE, F, 1
074A  90D8      	BCF STATUS,C
074C  3381      	RRCF FCD_04071__0005C_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));
074E  0E01      	MOVLW 0x01
0750  1581      	ANDWF FCD_04071__0005C_1_FCL_NIBBLE, W, 1
0752  6F82      	MOVWF FCD_04071__0005C_179_ptmp, 1
0754  9692      	BCF gbl_trisa,3
0756  5382      	MOVF FCD_04071__0005C_179_ptmp, F, 1
0758  E004      	BZ	label94
075A  0E08      	MOVLW 0x08
075C  1089      	IORWF gbl_lata, W
075E  6E80      	MOVWF gbl_porta
0760  D003      	BRA	label95
0762            label94
0762  0EF7      	MOVLW 0xF7
0764  1489      	ANDWF gbl_lata, W
0766  6E80      	MOVWF gbl_porta
0768            label95


		if (FCL_TYPE)
0768  A180      	BTFSS FCD_04071__0005C_arg_FCL_TYPE,0, 1
076A  D00C      	BRA	label97

		{

			FCP_SET(B, A, 0x10, 0x4, 1);
076C  0E01      	MOVLW 0x01
076E  6F82      	MOVWF FCD_04071__0005C_188_ptmp, 1
0770  9892      	BCF gbl_trisa,4
0772  5382      	MOVF FCD_04071__0005C_188_ptmp, F, 1
0774  E004      	BZ	label96
0776  0E10      	MOVLW 0x10
0778  1089      	IORWF gbl_lata, W
077A  6E80      	MOVWF gbl_porta
077C  D003      	BRA	label97
077E            label96
077E  0EEF      	MOVLW 0xEF
0780  1489      	ANDWF gbl_lata, W
0782  6E80      	MOVWF gbl_porta
0784            label97


		// } else {

		}

		FCI_DELAYBYTE_US(100);
0784  0E64      	MOVLW 0x64
0786  6FAD      	MOVWF delay_us_00000_arg_del, 1
0788  EC06F000  	CALL delay_us_00000


		FCP_SET(B, A, 0x20, 0x5, 1);
078C  0E01      	MOVLW 0x01
078E  6F82      	MOVWF FCD_04071__0005C_199_ptmp, 1
0790  9A92      	BCF gbl_trisa,5
0792  5382      	MOVF FCD_04071__0005C_199_ptmp, F, 1
0794  E004      	BZ	label98
0796  0E20      	MOVLW 0x20
0798  1089      	IORWF gbl_lata, W
079A  6E80      	MOVWF gbl_porta
079C  D003      	BRA	label99
079E            label98
079E  0EDF      	MOVLW 0xDF
07A0  1489      	ANDWF gbl_lata, W
07A2  6E80      	MOVWF gbl_porta
07A4            label99


		FCI_DELAYBYTE_US(100);
07A4  0E64      	MOVLW 0x64
07A6  6FAD      	MOVWF delay_us_00000_arg_del, 1
07A8  EC06F000  	CALL delay_us_00000


		FCP_SET(B, A, 0x20, 0x5, 0);
07AC  6B82      	CLRF FCD_04071__0005C_210_ptmp, 1
07AE  9A92      	BCF gbl_trisa,5
07B0  5382      	MOVF FCD_04071__0005C_210_ptmp, F, 1
07B2  E004      	BZ	label100
07B4  0E20      	MOVLW 0x20
07B6  1089      	IORWF gbl_lata, W
07B8  6E80      	MOVWF gbl_porta
07BA  D003      	BRA	label101
07BC            label100
07BC  0EDF      	MOVLW 0xDF
07BE  1489      	ANDWF gbl_lata, W
07C0  6E80      	MOVWF gbl_porta
07C2            label101


		FCI_DELAYBYTE_US(100);
07C2  0E64      	MOVLW 0x64
07C4  6FAD      	MOVWF delay_us_00000_arg_del, 1
07C6  EC06F000  	CALL delay_us_00000


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

}
07CA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()

{



	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
0FB4  6A5B      	CLRF FCD_04071__00050_2_ptmp
0FB6  9092      	BCF gbl_trisa,0
0FB8  525B      	MOVF FCD_04071__00050_2_ptmp, F
0FBA  E004      	BZ	label141
0FBC  0E01      	MOVLW 0x01
0FBE  1089      	IORWF gbl_lata, W
0FC0  6E80      	MOVWF gbl_porta
0FC2  D003      	BRA	label142
0FC4            label141
0FC4  0EFE      	MOVLW 0xFE
0FC6  1489      	ANDWF gbl_lata, W
0FC8  6E80      	MOVWF gbl_porta
0FCA            label142

		FCP_SET(B, A, 0x2, 0x1, 0);
0FCA  6A5B      	CLRF FCD_04071__00050_9_ptmp
0FCC  9292      	BCF gbl_trisa,1
0FCE  525B      	MOVF FCD_04071__00050_9_ptmp, F
0FD0  E004      	BZ	label143
0FD2  0E02      	MOVLW 0x02
0FD4  1089      	IORWF gbl_lata, W
0FD6  6E80      	MOVWF gbl_porta
0FD8  D003      	BRA	label144
0FDA            label143
0FDA  0EFD      	MOVLW 0xFD
0FDC  1489      	ANDWF gbl_lata, W
0FDE  6E80      	MOVWF gbl_porta
0FE0            label144

		FCP_SET(B, A, 0x4, 0x2, 0);
0FE0  6A5B      	CLRF FCD_04071__00050_16_ptmp
0FE2  9492      	BCF gbl_trisa,2
0FE4  525B      	MOVF FCD_04071__00050_16_ptmp, F
0FE6  E004      	BZ	label145
0FE8  0E04      	MOVLW 0x04
0FEA  1089      	IORWF gbl_lata, W
0FEC  6E80      	MOVWF gbl_porta
0FEE  D003      	BRA	label146
0FF0            label145
0FF0  0EFB      	MOVLW 0xFB
0FF2  1489      	ANDWF gbl_lata, W
0FF4  6E80      	MOVWF gbl_porta
0FF6            label146

		FCP_SET(B, A, 0x8, 0x3, 0);
0FF6  6A5B      	CLRF FCD_04071__00050_23_ptmp
0FF8  9692      	BCF gbl_trisa,3
0FFA  525B      	MOVF FCD_04071__00050_23_ptmp, F
0FFC  E004      	BZ	label147
0FFE  0E08      	MOVLW 0x08
1000  1089      	IORWF gbl_lata, W
1002  6E80      	MOVWF gbl_porta
1004  D003      	BRA	label148
1006            label147
1006  0EF7      	MOVLW 0xF7
1008  1489      	ANDWF gbl_lata, W
100A  6E80      	MOVWF gbl_porta
100C            label148

		FCP_SET(B, A, 0x10, 0x4, 0);
100C  6A5B      	CLRF FCD_04071__00050_30_ptmp
100E  9892      	BCF gbl_trisa,4
1010  525B      	MOVF FCD_04071__00050_30_ptmp, F
1012  E004      	BZ	label149
1014  0E10      	MOVLW 0x10
1016  1089      	IORWF gbl_lata, W
1018  6E80      	MOVWF gbl_porta
101A  D003      	BRA	label150
101C            label149
101C  0EEF      	MOVLW 0xEF
101E  1489      	ANDWF gbl_lata, W
1020  6E80      	MOVWF gbl_porta
1022            label150

		FCP_SET(B, A, 0x20, 0x5, 0);
1022  6A5B      	CLRF FCD_04071__00050_37_ptmp
1024  9A92      	BCF gbl_trisa,5
1026  525B      	MOVF FCD_04071__00050_37_ptmp, F
1028  E004      	BZ	label151
102A  0E20      	MOVLW 0x20
102C  1089      	IORWF gbl_lata, W
102E  6E80      	MOVWF gbl_porta
1030  D003      	BRA	label152
1032            label151
1032  0EDF      	MOVLW 0xDF
1034  1489      	ANDWF gbl_lata, W
1036  6E80      	MOVWF gbl_porta
1038            label152


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0)

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);
1038  0E0C      	MOVLW 0x0C
103A  6E70      	MOVWF delay_ms_00000_arg_del
103C  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x33, 0);
1040  0E33      	MOVLW 0x33
1042  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
1044  0100      	MOVLB 0x00
1046  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
1048  EC88F002  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
104C  0E02      	MOVLW 0x02
104E  6E70      	MOVWF delay_ms_00000_arg_del
1050  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x33, 0);
1054  0E33      	MOVLW 0x33
1056  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
1058  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
105A  EC88F002  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
105E  0E02      	MOVLW 0x02
1060  6E70      	MOVWF delay_ms_00000_arg_del
1062  EC0BF000  	CALL delay_ms_00000


	#if (0) // 0 > 0

	//Le code a été optimisé par le préprocesseur
	#else

		FCD_04071_LCD__RawSend(0x32, 0);
1066  0E32      	MOVLW 0x32
1068  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
106A  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
106C  EC88F002  	CALL FCD_04071__0005C


		FCI_DELAYBYTE_MS(2);
1070  0E02      	MOVLW 0x02
1072  6E70      	MOVWF delay_ms_00000_arg_del
1074  EC0BF000  	CALL delay_ms_00000


		FCD_04071_LCD__RawSend(0x2c, 0);
1078  0E2C      	MOVLW 0x2C
107A  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
107C  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
107E  EC88F002  	CALL FCD_04071__0005C


	#endif

	FCI_DELAYBYTE_MS(2);
1082  0E02      	MOVLW 0x02
1084  6E70      	MOVWF delay_ms_00000_arg_del
1086  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x06, 0);
108A  0E06      	MOVLW 0x06
108C  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
108E  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
1090  EC88F002  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
1094  0E02      	MOVLW 0x02
1096  6E70      	MOVWF delay_ms_00000_arg_del
1098  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x0c, 0);
109C  0E0C      	MOVLW 0x0C
109E  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
10A0  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
10A2  EC88F002  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
10A6  0E02      	MOVLW 0x02
10A8  6E70      	MOVWF delay_ms_00000_arg_del
10AA  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x01, 0);
10AE  0E01      	MOVLW 0x01
10B0  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
10B2  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
10B4  EC88F002  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
10B8  0E02      	MOVLW 0x02
10BA  6E70      	MOVWF delay_ms_00000_arg_del
10BC  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x02, 0);
10C0  0E02      	MOVLW 0x02
10C2  6E7F      	MOVWF FCD_04071__0005C_arg_FCL_DATA
10C4  9180      	BCF FCD_04071__0005C_arg_FCL_TYPE,0, 1
10C6  EC88F002  	CALL FCD_04071__0005C


	FCI_DELAYBYTE_MS(2);
10CA  0E02      	MOVLW 0x02
10CC  6E70      	MOVWF delay_ms_00000_arg_del
10CE  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__Clear();
10D2  ECFAF005  	CALL FCD_04071__00058


}
10D6  0012      	RETURN



/*========================================================================*\
   Use :lcd_eb005
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :InjectorBase1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :Bluetooth2
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the 4 digit Bluetooth pair key based on a string of numbers.
       :e.g. "1234"
       :Returns 0 to indicate success
       :
       :Param??tres pour la macro SetPairKey :
       :  PairKey[5] : Key to use as the Pair key, e.g. "1234" or "0000"
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY)

{
	//Définitions des variables locales
	#define FCLsz_COMMANDSTR 20
	MX_CHAR FCL_COMMANDSTR[FCLsz_COMMANDSTR];
	MX_UINT8 FCR_RETVAL;


	FCI_SHEAD("AT+BTK=\"",9, FCL_PAIRKEY,FCLsz_PAIRKEY, FCL_COMMANDSTR,20);
0B5C  0E22      	MOVLW 0x22
0B5E  0100      	MOVLB 0x00
0B60  6F9B      	MOVWF CompTempVar2713+D'7', 1
0B62  0E2B      	MOVLW 0x2B
0B64  6F96      	MOVWF CompTempVar2713+D'2', 1
0B66  0E3D      	MOVLW 0x3D
0B68  6F9A      	MOVWF CompTempVar2713+D'6', 1
0B6A  0E41      	MOVLW 0x41
0B6C  6F94      	MOVWF CompTempVar2713, 1
0B6E  0E42      	MOVLW 0x42
0B70  6F97      	MOVWF CompTempVar2713+D'3', 1
0B72  0E4B      	MOVLW 0x4B
0B74  6F99      	MOVWF CompTempVar2713+D'5', 1
0B76  0E54      	MOVLW 0x54
0B78  6F95      	MOVWF CompTempVar2713+D'1', 1
0B7A  6F98      	MOVWF CompTempVar2713+D'4', 1
0B7C  6B9C      	CLRF CompTempVar2713+D'8', 1
0B7E  0E00      	MOVLW HIGH(CompTempVar2713+D'0')
0B80  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0B82  0E94      	MOVLW LOW(CompTempVar2713+D'0')
0B84  6E7A      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0B86  0E09      	MOVLW 0x09
0B88  6E7C      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0B8A  5070      	MOVF FCD_0c851__0006E_arg_FCL_PAIRKEY, W
0B8C  6E7D      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0B8E  5071      	MOVF FCD_0c851__0006E_arg_FCL_PAIRKEY+D'1', W
0B90  6E7E      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0B92  5077      	MOVF FCD_0c851__0006E_arg_FCLsz_0006F, W
0B94  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0B96  0E00      	MOVLW HIGH(FCD_0c851__0006E_1_FCL_COM_00070+D'0')
0B98  6F9E      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0B9A  0E80      	MOVLW LOW(FCD_0c851__0006E_1_FCL_COM_00070+D'0')
0B9C  6F9D      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0B9E  0E14      	MOVLW 0x14
0BA0  6F9F      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0BA2  EC61F001  	CALL FCI_SHEAD_00000

	FCI_SHEAD(FCL_COMMANDSTR,FCLsz_COMMANDSTR, "\"",2, FCL_COMMANDSTR,20);
0BA6  0E00      	MOVLW HIGH(FCD_0c851__0006E_1_FCL_COM_00070+D'0')
0BA8  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0BAA  0E80      	MOVLW LOW(FCD_0c851__0006E_1_FCL_COM_00070+D'0')
0BAC  6E7A      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0BAE  0E14      	MOVLW 0x14
0BB0  6E7C      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0BB2  0E22      	MOVLW 0x22
0BB4  6F94      	MOVWF CompTempVar2716, 1
0BB6  6B95      	CLRF CompTempVar2716+D'1', 1
0BB8  0E00      	MOVLW HIGH(CompTempVar2716+D'0')
0BBA  6E7E      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0BBC  0E94      	MOVLW LOW(CompTempVar2716+D'0')
0BBE  6E7D      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0BC0  0E02      	MOVLW 0x02
0BC2  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0BC4  0E00      	MOVLW HIGH(FCD_0c851__0006E_1_FCL_COM_00070+D'0')
0BC6  6F9E      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0BC8  0E80      	MOVLW LOW(FCD_0c851__0006E_1_FCL_COM_00070+D'0')
0BCA  6F9D      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0BCC  0E14      	MOVLW 0x14
0BCE  6F9F      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0BD0  EC61F001  	CALL FCI_SHEAD_00000


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand(FCL_COMMANDSTR, FCLsz_COMMANDSTR, 1);
0BD4  0E00      	MOVLW HIGH(FCD_0c851__0006E_1_FCL_COM_00070+D'0')
0BD6  6E7B      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND+D'1'
0BD8  0E80      	MOVLW LOW(FCD_0c851__0006E_1_FCL_COM_00070+D'0')
0BDA  6E7A      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND
0BDC  0E14      	MOVLW 0x14
0BDE  6E7C      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
0BE0  6A7D      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
0BE2  0E01      	MOVLW 0x01
0BE4  6E7E      	MOVWF FCD_0c851__00059_arg_FCL_SENDCR
0BE6  EC50F002  	CALL FCD_0c851__00059
0BEA  5196      	MOVF CompTempVarRet2677, W, 1
0BEC  6E79      	MOVWF FCD_0c851__0006E_1_FCR_RETVAL


	return (FCR_RETVAL);
0BEE  5079      	MOVF FCD_0c851__0006E_1_FCR_RETVAL, W
0BF0  6E7A      	MOVWF CompTempVarRet2712


	//Définitions des variables locales
	#undef FCLsz_COMMANDSTR
}
0BF2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Receives a single data byte from the Bluetooth module.
       :0xFF signifies no data available.
       :
       :Param??tres pour la macro ReceiveByte :
       :  Timeout : Amount of time to wait in milliseconds 0=Wait forever
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	FCV_0c851_Bluetooth2__RX_DONE = 0;

FCC_ReceiveByte_A:
;

	if (FCV_0c851_Bluetooth2__RX_IDX < FCV_0c851_Bluetooth2__RX_LENGTH)
	{

		FCR_RETVAL = FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_IDX];

		FCV_0c851_Bluetooth2__RX_IDX = FCV_0c851_Bluetooth2__RX_IDX + 1;

	} else {

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 50)
		{

			if ((FCL_TIMEOUT == 0) || (FCL_COUNT < FCL_TIMEOUT))
			{

				FCI_DELAYBYTE_MS(1);

				FCL_COUNT = FCL_COUNT + 1;

				goto FCC_ReceiveByte_A;

			// } else {

			}

		// } else {

		}

		FCV_0c851_Bluetooth2__RX_IDX = 0;
		FCV_0c851_Bluetooth2__RX_LENGTH = 0;

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Send an AT command script.
       :Returns 0 for fail, 1 for success and 255 for unrecognised script idx.
       :
       :Param??tres pour la macro SendScript :
       :  idx : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX)

{
	//Définitions des variables locales
	MX_UINT8 FCL_I = (0x0);
0C54  6A5C      	CLRF FCD_0c851__00051_1_FCL_I

	MX_UINT8 FCL_CH = (0xff);
0C56  685D      	SETF FCD_0c851__00051_1_FCL_CH

	#define FCLsz_SCRIPT_STR 40
	MX_CHAR FCL_SCRIPT_STR[FCLsz_SCRIPT_STR];
	MX_UINT8 FCL_LEN = (0x0);
0C58  6A5E      	CLRF FCD_0c851__00051_1_FCL_LEN

	MX_UINT8 FCR_RETVAL;


	if ((FCL_IDX < 1) || (FCL_IDX > 2))
0C5A  0E01      	MOVLW 0x01
0C5C  605B      	CPFSLT FCD_0c851__00051_arg_FCL_IDX
0C5E  D001      	BRA	label119
0C60  D003      	BRA	label120
0C62            label119
0C62  0E02      	MOVLW 0x02
0C64  645B      	CPFSGT FCD_0c851__00051_arg_FCL_IDX
0C66  D002      	BRA	label121
0C68            label120
0C6C            label121
0C86  D08E      	BRA	label127

	{

		FCR_RETVAL = 255;
0C68  685F      	SETF FCD_0c851__00051_1_FCR_RETVAL


		goto FCC_SendScript_A;
0C6A  D0E1      	BRA	label133


	// } else {

	}

	switch (FCL_IDX)
0DC8            label129

	{
		case 1:
0C6C  045B      	DECF FCD_0c851__00051_arg_FCL_IDX, W
0C6E  E00C      	BZ	label124
0C88            label124

		{
			FCI_SCOPY("ATS0=1\r\nATR\r\nATS512=7\r\nATS536=1\r\nATS502=",41, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0C88  0E0A      	MOVLW 0x0A
0C8A  0100      	MOVLB 0x00
0C8C  6FAF      	MOVWF CompTempVar2651+D'7', 1
0C8E  6FB4      	MOVWF CompTempVar2651+D'12', 1
0C90  6FBE      	MOVWF CompTempVar2651+D'22', 1
0C92  6FC8      	MOVWF CompTempVar2651+D'32', 1
0C94  0E0D      	MOVLW 0x0D
0C96  6FAE      	MOVWF CompTempVar2651+D'6', 1
0C98  6FB3      	MOVWF CompTempVar2651+D'11', 1
0C9A  6FBD      	MOVWF CompTempVar2651+D'21', 1
0C9C  6FC7      	MOVWF CompTempVar2651+D'31', 1
0C9E  0E30      	MOVLW 0x30
0CA0  6FAB      	MOVWF CompTempVar2651+D'3', 1
0CA2  6FCD      	MOVWF CompTempVar2651+D'37', 1
0CA4  0E31      	MOVLW 0x31
0CA6  6FAD      	MOVWF CompTempVar2651+D'5', 1
0CA8  6FB9      	MOVWF CompTempVar2651+D'17', 1
0CAA  6FC6      	MOVWF CompTempVar2651+D'30', 1
0CAC  0E32      	MOVLW 0x32
0CAE  6FBA      	MOVWF CompTempVar2651+D'18', 1
0CB0  6FCE      	MOVWF CompTempVar2651+D'38', 1
0CB2  0E33      	MOVLW 0x33
0CB4  6FC3      	MOVWF CompTempVar2651+D'27', 1
0CB6  0E35      	MOVLW 0x35
0CB8  6FB8      	MOVWF CompTempVar2651+D'16', 1
0CBA  6FC2      	MOVWF CompTempVar2651+D'26', 1
0CBC  6FCC      	MOVWF CompTempVar2651+D'36', 1
0CBE  0E36      	MOVLW 0x36
0CC0  6FC4      	MOVWF CompTempVar2651+D'28', 1
0CC2  0E37      	MOVLW 0x37
0CC4  6FBC      	MOVWF CompTempVar2651+D'20', 1
0CC6  0E3D      	MOVLW 0x3D
0CC8  6FAC      	MOVWF CompTempVar2651+D'4', 1
0CCA  6FBB      	MOVWF CompTempVar2651+D'19', 1
0CCC  6FC5      	MOVWF CompTempVar2651+D'29', 1
0CCE  6FCF      	MOVWF CompTempVar2651+D'39', 1
0CD0  0E41      	MOVLW 0x41
0CD2  6FA8      	MOVWF CompTempVar2651, 1
0CD4  6FB0      	MOVWF CompTempVar2651+D'8', 1
0CD6  6FB5      	MOVWF CompTempVar2651+D'13', 1
0CD8  6FBF      	MOVWF CompTempVar2651+D'23', 1
0CDA  6FC9      	MOVWF CompTempVar2651+D'33', 1
0CDC  0E52      	MOVLW 0x52
0CDE  6FB2      	MOVWF CompTempVar2651+D'10', 1
0CE0  0E53      	MOVLW 0x53
0CE2  6FAA      	MOVWF CompTempVar2651+D'2', 1
0CE4  6FB7      	MOVWF CompTempVar2651+D'15', 1
0CE6  6FC1      	MOVWF CompTempVar2651+D'25', 1
0CE8  6FCB      	MOVWF CompTempVar2651+D'35', 1
0CEA  0E54      	MOVLW 0x54
0CEC  6FA9      	MOVWF CompTempVar2651+D'1', 1
0CEE  6FB1      	MOVWF CompTempVar2651+D'9', 1
0CF0  6FB6      	MOVWF CompTempVar2651+D'14', 1
0CF2  6FC0      	MOVWF CompTempVar2651+D'24', 1
0CF4  6FCA      	MOVWF CompTempVar2651+D'34', 1
0CF6  6BD0      	CLRF CompTempVar2651+D'40', 1
0CF8  0E00      	MOVLW HIGH(CompTempVar2651+D'0')
0CFA  6E61      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
0CFC  0EA8      	MOVLW LOW(CompTempVar2651+D'0')
0CFE  6E60      	MOVWF FCI_SCOPY_00000_arg_sSrc
0D00  0E29      	MOVLW 0x29
0D02  6E7C      	MOVWF FCI_SCOPY_00000_arg_iSrc_len
0D04  0E00      	MOVLW HIGH(FCD_0c851__00051_1_FCL_SCR_00052+D'0')
0D06  6E7E      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
0D08  0E80      	MOVLW LOW(FCD_0c851__00051_1_FCL_SCR_00052+D'0')
0D0A  6E7D      	MOVWF FCI_SCOPY_00000_arg_sDst
0D0C  0E28      	MOVLW 0x28
0D0E  6E7F      	MOVWF FCI_SCOPY_00000_arg_iDst_len
0D10  ECB1F004  	CALL FCI_SCOPY_00000


			break;
0D14  D059      	BRA	label129

		}
		case 2:
0C70  0E02      	MOVLW 0x02
0C72  625B      	CPFSEQ FCD_0c851__00051_arg_FCL_IDX
0C74  D001      	BRA	label122
0C76  D04F      	BRA	label125
0C78            label122
0D16            label125

		{
			FCI_SCOPY("ATS531=2\r\nATA\r\nAT&W\r\nATZ0",26, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0D16  0E0A      	MOVLW 0x0A
0D18  6E6B      	MOVWF CompTempVar2654+D'9'
0D1A  6E70      	MOVWF CompTempVar2654+D'14'
0D1C  6E76      	MOVWF CompTempVar2654+D'20'
0D1E  0E0D      	MOVLW 0x0D
0D20  6E6A      	MOVWF CompTempVar2654+D'8'
0D22  6E6F      	MOVWF CompTempVar2654+D'13'
0D24  6E75      	MOVWF CompTempVar2654+D'19'
0D26  0E26      	MOVLW 0x26
0D28  6E73      	MOVWF CompTempVar2654+D'17'
0D2A  0E30      	MOVLW 0x30
0D2C  6E7A      	MOVWF CompTempVar2654+D'24'
0D2E  0E31      	MOVLW 0x31
0D30  6E67      	MOVWF CompTempVar2654+D'5'
0D32  0E32      	MOVLW 0x32
0D34  6E69      	MOVWF CompTempVar2654+D'7'
0D36  0E33      	MOVLW 0x33
0D38  6E66      	MOVWF CompTempVar2654+D'4'
0D3A  0E35      	MOVLW 0x35
0D3C  6E65      	MOVWF CompTempVar2654+D'3'
0D3E  0E3D      	MOVLW 0x3D
0D40  6E68      	MOVWF CompTempVar2654+D'6'
0D42  0E41      	MOVLW 0x41
0D44  6E62      	MOVWF CompTempVar2654
0D46  6E6C      	MOVWF CompTempVar2654+D'10'
0D48  6E6E      	MOVWF CompTempVar2654+D'12'
0D4A  6E71      	MOVWF CompTempVar2654+D'15'
0D4C  6E77      	MOVWF CompTempVar2654+D'21'
0D4E  0E53      	MOVLW 0x53
0D50  6E64      	MOVWF CompTempVar2654+D'2'
0D52  0E54      	MOVLW 0x54
0D54  6E63      	MOVWF CompTempVar2654+D'1'
0D56  6E6D      	MOVWF CompTempVar2654+D'11'
0D58  6E72      	MOVWF CompTempVar2654+D'16'
0D5A  6E78      	MOVWF CompTempVar2654+D'22'
0D5C  0E57      	MOVLW 0x57
0D5E  6E74      	MOVWF CompTempVar2654+D'18'
0D60  0E5A      	MOVLW 0x5A
0D62  6E79      	MOVWF CompTempVar2654+D'23'
0D64  6A7B      	CLRF CompTempVar2654+D'25'
0D66  0E00      	MOVLW HIGH(CompTempVar2654+D'0')
0D68  6E61      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
0D6A  0E62      	MOVLW LOW(CompTempVar2654+D'0')
0D6C  6E60      	MOVWF FCI_SCOPY_00000_arg_sSrc
0D6E  0E1A      	MOVLW 0x1A
0D70  6E7C      	MOVWF FCI_SCOPY_00000_arg_iSrc_len
0D72  0E00      	MOVLW HIGH(FCD_0c851__00051_1_FCL_SCR_00052+D'0')
0D74  6E7E      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
0D76  0E80      	MOVLW LOW(FCD_0c851__00051_1_FCL_SCR_00052+D'0')
0D78  6E7D      	MOVWF FCI_SCOPY_00000_arg_sDst
0D7A  0E28      	MOVLW 0x28
0D7C  6E7F      	MOVWF FCI_SCOPY_00000_arg_iDst_len
0D7E  ECB1F004  	CALL FCI_SCOPY_00000


			break;
0D82  D022      	BRA	label129

		}
		case 3:
0C78  0E03      	MOVLW 0x03
0C7A  625B      	CPFSEQ FCD_0c851__00051_arg_FCL_IDX
0C7C  D001      	BRA	label123
0C7E  D082      	BRA	label126
0C80            label123
0D84            label126

		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0D84  6A62      	CLRF CompTempVar2657
0D86  0E00      	MOVLW HIGH(CompTempVar2657+D'0')
0D88  6E61      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
0D8A  0E62      	MOVLW LOW(CompTempVar2657+D'0')
0D8C  6E60      	MOVWF FCI_SCOPY_00000_arg_sSrc
0D8E  0E01      	MOVLW 0x01
0D90  6E7C      	MOVWF FCI_SCOPY_00000_arg_iSrc_len
0D92  0E00      	MOVLW HIGH(FCD_0c851__00051_1_FCL_SCR_00052+D'0')
0D94  6E7E      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
0D96  0E80      	MOVLW LOW(FCD_0c851__00051_1_FCL_SCR_00052+D'0')
0D98  6E7D      	MOVWF FCI_SCOPY_00000_arg_sDst
0D9A  0E28      	MOVLW 0x28
0D9C  6E7F      	MOVWF FCI_SCOPY_00000_arg_iDst_len
0D9E  ECB1F004  	CALL FCI_SCOPY_00000


			break;
0DA2  D012      	BRA	label129

		}
		case 4:
0C80  0E04      	MOVLW 0x04
0C82  625B      	CPFSEQ FCD_0c851__00051_arg_FCL_IDX
0C84  D09F      	BRA	label128
0DA4            label127

		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0DA4  6A62      	CLRF CompTempVar2660
0DA6  0E00      	MOVLW HIGH(CompTempVar2660+D'0')
0DA8  6E61      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
0DAA  0E62      	MOVLW LOW(CompTempVar2660+D'0')
0DAC  6E60      	MOVWF FCI_SCOPY_00000_arg_sSrc
0DAE  0E01      	MOVLW 0x01
0DB0  6E7C      	MOVWF FCI_SCOPY_00000_arg_iSrc_len
0DB2  0E00      	MOVLW HIGH(FCD_0c851__00051_1_FCL_SCR_00052+D'0')
0DB4  6E7E      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
0DB6  0E80      	MOVLW LOW(FCD_0c851__00051_1_FCL_SCR_00052+D'0')
0DB8  6E7D      	MOVWF FCI_SCOPY_00000_arg_sDst
0DBA  0E28      	MOVLW 0x28
0DBC  6E7F      	MOVWF FCI_SCOPY_00000_arg_iDst_len
0DBE  ECB1F004  	CALL FCI_SCOPY_00000


			break;
0DC2  D002      	BRA	label129

		}
		default:
0DC4            label128

		{
			FCR_RETVAL = 255;
0DC4  685F      	SETF FCD_0c851__00051_1_FCR_RETVAL


			goto FCC_SendScript_A;
0DC6  D033      	BRA	label133


		}
	}

	while (FCL_CH > 0)
0DC8  0E00      	MOVLW 0x00
0DCA  645D      	CPFSGT FCD_0c851__00051_1_FCL_CH
0DCC  D022      	BRA	label132
0E10  D7DB      	BRA	label129
0E12            label132

	{

		FCL_CH = FCL_SCRIPT_STR[FCL_I];
0DCE  EE00F080  	LFSR 0x00, FCD_0c851__00051_1_FCL_SCR_00052
0DD2  50E9      	MOVF FSR0L, W
0DD4  505C      	MOVF FCD_0c851__00051_1_FCL_I, W
0DD6  26E9      	ADDWF FSR0L, F
0DD8  50EF      	MOVF INDF0, W
0DDA  6E5D      	MOVWF FCD_0c851__00051_1_FCL_CH


		if ((FCL_CH > 0) && (FCL_CH != 0x0A))
0DDC  0E00      	MOVLW 0x00
0DDE  645D      	CPFSGT FCD_0c851__00051_1_FCL_CH
0DE0  D015      	BRA	label131
0DE2  0E0A      	MOVLW 0x0A
0DE4  625D      	CPFSEQ FCD_0c851__00051_1_FCL_CH
0DE6  D001      	BRA	label130
0DE8  D011      	BRA	label131
0DEA            label130

		{

			FC_CAL_UART_Send_1(FCL_CH);
0DEA  505D      	MOVF FCD_0c851__00051_1_FCL_CH, W
0DEC  6FA8      	MOVWF FC_CAL_UAR_0006B_arg_nChar, 1
0DEE  6BA9      	CLRF FC_CAL_UAR_0006B_arg_nChar+D'1', 1
0DF0  ECB0F000  	CALL FC_CAL_UAR_0006B


			FCL_LEN = FCL_LEN + 1;
0DF4  285E      	INCF FCD_0c851__00051_1_FCL_LEN, W
0DF6  6E5E      	MOVWF FCD_0c851__00051_1_FCL_LEN


			if (FCL_CH == FCV_0c851_Bluetooth2__BT_CHAR_CR)
0DF8  0E0D      	MOVLW 0x0D
0DFA  625D      	CPFSEQ FCD_0c851__00051_1_FCL_CH
0DFC  D007      	BRA	label131
0E0C            label131

			{

				#if (1) // 1 == 1

					FCD_0c851_Bluetooth2__StringReceive();
0DFE  ECC8F000  	CALL FCD_0c851__00072


				// #else

				//Le code a été optimisé par le préprocesseur
				#endif

				FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
0E02  ECC8F000  	CALL FCD_0c851__00072
0E06  51AB      	MOVF CompTempVarRet2723, W, 1
0E08  6E5F      	MOVWF FCD_0c851__00051_1_FCR_RETVAL


				FCL_LEN = 0;
0E0A  6A5E      	CLRF FCD_0c851__00051_1_FCL_LEN


			// } else {

			}

		// } else {

		}

		FCL_I = FCL_I + 1;
0E0C  285C      	INCF FCD_0c851__00051_1_FCL_I, W
0E0E  6E5C      	MOVWF FCD_0c851__00051_1_FCL_I



	}

	if (FCL_LEN > 0)
0E12  0E00      	MOVLW 0x00
0E14  645E      	CPFSGT FCD_0c851__00051_1_FCL_LEN
0E16  D00B      	BRA	label133
0E2E            label133

	{

		FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);
0E18  0E0D      	MOVLW 0x0D
0E1A  6FA8      	MOVWF FC_CAL_UAR_0006B_arg_nChar, 1
0E1C  6BA9      	CLRF FC_CAL_UAR_0006B_arg_nChar+D'1', 1
0E1E  ECB0F000  	CALL FC_CAL_UAR_0006B


		#if (1) // 1 == 1

			FCD_0c851_Bluetooth2__StringReceive();
0E22  ECC8F000  	CALL FCD_0c851__00072


		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
0E26  ECC8F000  	CALL FCD_0c851__00072
0E2A  51AB      	MOVF CompTempVarRet2723, W, 1
0E2C  6E5F      	MOVWF FCD_0c851__00051_1_FCR_RETVAL


	// } else {

	}

FCC_SendScript_A:
;

	return (FCR_RETVAL);
0E2E  505F      	MOVF FCD_0c851__00051_1_FCR_RETVAL, W
0E30  6E60      	MOVWF CompTempVarRet2650


	//Définitions des variables locales
	#undef FCLsz_SCRIPT_STR
}
0E32  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sends a command string to the GSM module.
       :0 = Command sent ok, 255 = No Reply
       :
       :Param??tres pour la macro SendCommand :
       :  Command[20] : MX_CHAR (by-ref)
       :  SendCR : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
04A0  6A7F      	CLRF FCD_0c851__00059_1_FCL_IDX

	MX_UINT8 FCL_LEN;
	MX_UINT8 FCR_RETVAL;


	while (1)
04A2            label46

	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
04A2  ECC8F000  	CALL FCD_0c851__00072
04A6  51AB      	MOVF CompTempVarRet2723, W, 1
04A8  6F95      	MOVWF FCD_0c851__00059_1_FCR_RETVAL, 1



		if ((FCR_RETVAL) == 0) break;
04AA  5395      	MOVF FCD_0c851__00059_1_FCR_RETVAL, F, 1
04AC  E1FA      	BNZ	label46

	}

	FCL_LEN = FCI_GETLENGTH(FCL_COMMAND, FCLsz_COMMAND);
04AE  507A      	MOVF FCD_0c851__00059_arg_FCL_COMMAND, W
04B0  6F96      	MOVWF FCI_GETLEN_0003E_arg_sStr1, 1
04B2  507B      	MOVF FCD_0c851__00059_arg_FCL_COMMAND+D'1', W
04B4  6F97      	MOVWF FCI_GETLEN_0003E_arg_sStr1+D'1', 1
04B6  507C      	MOVF FCD_0c851__00059_arg_FCLsz_0005A, W
04B8  6F98      	MOVWF FCI_GETLEN_0003E_arg_iStr1_len, 1
04BA  ECB8F000  	CALL FCI_GETLEN_0003E
04BE  519A      	MOVF CompTempVarRet1850, W, 1
04C0  6F94      	MOVWF FCD_0c851__00059_1_FCL_LEN, 1


	if (FCL_LEN)
04C2  5394      	MOVF FCD_0c851__00059_1_FCL_LEN, F, 1
04C4  E017      	BZ	label49
04C6            label47

	{

		while (FCL_IDX < FCL_LEN)
04C6  5194      	MOVF FCD_0c851__00059_1_FCL_LEN, W, 1
04C8  607F      	CPFSLT FCD_0c851__00059_1_FCL_IDX
04CA  D00D      	BRA	label48
04E4  D7F0      	BRA	label47
04E6            label48

		{

			FC_CAL_UART_Send_1(FCL_COMMAND[FCL_IDX]);
04CC  507B      	MOVF FCD_0c851__00059_arg_FCL_COMMAND+D'1', W
04CE  6EEA      	MOVWF FSR0H
04D0  507A      	MOVF FCD_0c851__00059_arg_FCL_COMMAND, W
04D2  247F      	ADDWF FCD_0c851__00059_1_FCL_IDX, W
04D4  6EE9      	MOVWF FSR0L
04D6  50EF      	MOVF INDF0, W
04D8  6FA8      	MOVWF FC_CAL_UAR_0006B_arg_nChar, 1
04DA  6BA9      	CLRF FC_CAL_UAR_0006B_arg_nChar+D'1', 1
04DC  ECB0F000  	CALL FC_CAL_UAR_0006B


			FCL_IDX = FCL_IDX + 1;
04E0  287F      	INCF FCD_0c851__00059_1_FCL_IDX, W
04E2  6E7F      	MOVWF FCD_0c851__00059_1_FCL_IDX



		}

		if (FCL_SENDCR)
04E6  527E      	MOVF FCD_0c851__00059_arg_FCL_SENDCR, F
04E8  E005      	BZ	label49
04F4            label49

		{

			FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);
04EA  0E0D      	MOVLW 0x0D
04EC  6FA8      	MOVWF FC_CAL_UAR_0006B_arg_nChar, 1
04EE  6BA9      	CLRF FC_CAL_UAR_0006B_arg_nChar+D'1', 1
04F0  ECB0F000  	CALL FC_CAL_UAR_0006B


		// } else {

		}

	// } else {

	}

	#if (1) // 1 == 1

		FCD_0c851_Bluetooth2__StringReceive();
04F4  ECC8F000  	CALL FCD_0c851__00072


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
04F8  ECC8F000  	CALL FCD_0c851__00072
04FC  51AB      	MOVF CompTempVarRet2723, W, 1
04FE  6F95      	MOVWF FCD_0c851__00059_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 0)
0500  5395      	MOVF FCD_0c851__00059_1_FCR_RETVAL, F, 1
0502  E102      	BNZ	label50
0508            label50

	{

		FCR_RETVAL = 255;
0504  6995      	SETF FCD_0c851__00059_1_FCR_RETVAL, 1


	} else {
0506  D001      	BRA	label51
050A            label51


		FCR_RETVAL = 0;
0508  6B95      	CLRF FCD_0c851__00059_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
050A  5195      	MOVF FCD_0c851__00059_1_FCR_RETVAL, W, 1
050C  6F96      	MOVWF CompTempVarRet2677, 1


}
050E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies the incoming data from the data string array to a local string variable.
       :
       :Param??tres pour la macro ReadString :
       :  NumBytes : MX_UINT8
       :
       :Renvoie : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);


	while ((FCL_IDX < FCL_NUMBYTES) && (FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX] > 0))
	{

		FCR_RETVAL[FCL_IDX] = FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX];
		FCL_IDX = FCL_IDX + 1;


	}

	if (FCL_IDX < FCL_NUMBYTES)
	{

		FCR_RETVAL[FCL_IDX] = 0;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Saves the current settings to firmware using the AT&W command followed by the ATZ command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&W", 5, 1);
0AFE  0E41      	MOVLW 0x41
0B00  6E71      	MOVWF CompTempVar2731
0B02  0E54      	MOVLW 0x54
0B04  6E72      	MOVWF CompTempVar2731+D'1'
0B06  0E26      	MOVLW 0x26
0B08  6E73      	MOVWF CompTempVar2731+D'2'
0B0A  0E57      	MOVLW 0x57
0B0C  6E74      	MOVWF CompTempVar2731+D'3'
0B0E  6A75      	CLRF CompTempVar2731+D'4'
0B10  0E00      	MOVLW HIGH(CompTempVar2731+D'0')
0B12  6E7B      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND+D'1'
0B14  0E71      	MOVLW LOW(CompTempVar2731+D'0')
0B16  6E7A      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND
0B18  0E05      	MOVLW 0x05
0B1A  6E7C      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
0B1C  6A7D      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
0B1E  0E01      	MOVLW 0x01
0B20  6E7E      	MOVWF FCD_0c851__00059_arg_FCL_SENDCR
0B22  EC50F002  	CALL FCD_0c851__00059
0B26  5196      	MOVF CompTempVarRet2677, W, 1
0B28  6E70      	MOVWF FCD_0c851__00076_1_FCR_RETVAL


	if (FCR_RETVAL == 0)
0B2A  5270      	MOVF FCD_0c851__00076_1_FCR_RETVAL, F
0B2C  E114      	BNZ	label117
0B56            label117

	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATZ", 4, 1);
0B2E  0E41      	MOVLW 0x41
0B30  6E71      	MOVWF CompTempVar2733
0B32  0E54      	MOVLW 0x54
0B34  6E72      	MOVWF CompTempVar2733+D'1'
0B36  0E5A      	MOVLW 0x5A
0B38  6E73      	MOVWF CompTempVar2733+D'2'
0B3A  6A74      	CLRF CompTempVar2733+D'3'
0B3C  0E00      	MOVLW HIGH(CompTempVar2733+D'0')
0B3E  6E7B      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND+D'1'
0B40  0E71      	MOVLW LOW(CompTempVar2733+D'0')
0B42  6E7A      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND
0B44  0E04      	MOVLW 0x04
0B46  6E7C      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
0B48  6A7D      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
0B4A  0E01      	MOVLW 0x01
0B4C  6E7E      	MOVWF FCD_0c851__00059_arg_FCL_SENDCR
0B4E  EC50F002  	CALL FCD_0c851__00059
0B52  5196      	MOVF CompTempVarRet2677, W, 1
0B54  6E70      	MOVWF FCD_0c851__00076_1_FCR_RETVAL


	// } else {

	}

	return (FCR_RETVAL);
0B56  5070      	MOVF FCD_0c851__00076_1_FCR_RETVAL, W
0B58  6E71      	MOVWF CompTempVarRet2730


}
0B5A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sends a single data byte out to the Bluetooth module.
       :
       :Param??tres pour la macro SendByte :
       :  Data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA)
{

	FC_CAL_UART_Send_1(FCL_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the bluetooth mode to be discoverable and or connectable.
       :Returns 0 for success.
       :
       :Param??tres pour la macro SetMode :
       :  Discoverable : 0 = Not Discoverable, 1 = Discoverable
       :  Connectable : 0 = Not Connectable, 1 = Connectable
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE)

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	if (FCL_DISCOVERABLE)
09F2  5270      	MOVF FCD_0c851__00078_arg_FCL_D_00079, F
09F4  E041      	BZ	label114
0A78            label114

	{

		if (FCL_CONNECTABLE)
09F6  5271      	MOVF FCD_0c851__00078_arg_FCL_C_0007A, F
09F8  E020      	BZ	label113
0A3A            label113

		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=4", 9, 1);
09FA  0E41      	MOVLW 0x41
09FC  0100      	MOVLB 0x00
09FE  6F80      	MOVWF CompTempVar2736, 1
0A00  0E54      	MOVLW 0x54
0A02  6F81      	MOVWF CompTempVar2736+D'1', 1
0A04  0E53      	MOVLW 0x53
0A06  6F82      	MOVWF CompTempVar2736+D'2', 1
0A08  0E35      	MOVLW 0x35
0A0A  6F83      	MOVWF CompTempVar2736+D'3', 1
0A0C  0E31      	MOVLW 0x31
0A0E  6F84      	MOVWF CompTempVar2736+D'4', 1
0A10  0E32      	MOVLW 0x32
0A12  6F85      	MOVWF CompTempVar2736+D'5', 1
0A14  0E3D      	MOVLW 0x3D
0A16  6F86      	MOVWF CompTempVar2736+D'6', 1
0A18  0E34      	MOVLW 0x34
0A1A  6F87      	MOVWF CompTempVar2736+D'7', 1
0A1C  6B88      	CLRF CompTempVar2736+D'8', 1
0A1E  0E00      	MOVLW HIGH(CompTempVar2736+D'0')
0A20  6E7B      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND+D'1'
0A22  0E80      	MOVLW LOW(CompTempVar2736+D'0')
0A24  6E7A      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND
0A26  0E09      	MOVLW 0x09
0A28  6E7C      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
0A2A  6A7D      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
0A2C  0E01      	MOVLW 0x01
0A2E  6E7E      	MOVWF FCD_0c851__00059_arg_FCL_SENDCR
0A30  EC50F002  	CALL FCD_0c851__00059
0A34  5196      	MOVF CompTempVarRet2677, W, 1
0A36  6E72      	MOVWF FCD_0c851__00078_1_FCR_RETVAL


		} else {
0A38  D05F      	BRA	label116


			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 1);
0A3A  0E31      	MOVLW 0x31
0A3C  0100      	MOVLB 0x00
0A3E  6F84      	MOVWF CompTempVar2738+D'4', 1
0A40  0E32      	MOVLW 0x32
0A42  6F85      	MOVWF CompTempVar2738+D'5', 1
0A44  6F87      	MOVWF CompTempVar2738+D'7', 1
0A46  0E35      	MOVLW 0x35
0A48  6F83      	MOVWF CompTempVar2738+D'3', 1
0A4A  0E3D      	MOVLW 0x3D
0A4C  6F86      	MOVWF CompTempVar2738+D'6', 1
0A4E  0E41      	MOVLW 0x41
0A50  6F80      	MOVWF CompTempVar2738, 1
0A52  0E53      	MOVLW 0x53
0A54  6F82      	MOVWF CompTempVar2738+D'2', 1
0A56  0E54      	MOVLW 0x54
0A58  6F81      	MOVWF CompTempVar2738+D'1', 1
0A5A  6B88      	CLRF CompTempVar2738+D'8', 1
0A5C  0E00      	MOVLW HIGH(CompTempVar2738+D'0')
0A5E  6E7B      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND+D'1'
0A60  0E80      	MOVLW LOW(CompTempVar2738+D'0')
0A62  6E7A      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND
0A64  0E09      	MOVLW 0x09
0A66  6E7C      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
0A68  6A7D      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
0A6A  0E01      	MOVLW 0x01
0A6C  6E7E      	MOVWF FCD_0c851__00059_arg_FCL_SENDCR
0A6E  EC50F002  	CALL FCD_0c851__00059
0A72  5196      	MOVF CompTempVarRet2677, W, 1
0A74  6E72      	MOVWF FCD_0c851__00078_1_FCR_RETVAL


		}

	} else {
0A76  D040      	BRA	label116


		if (FCL_CONNECTABLE)
0A78  5271      	MOVF FCD_0c851__00078_arg_FCL_C_0007A, F
0A7A  E01F      	BZ	label115
0ABA            label115

		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 3);
0A7C  0E31      	MOVLW 0x31
0A7E  0100      	MOVLB 0x00
0A80  6F84      	MOVWF CompTempVar2740+D'4', 1
0A82  0E32      	MOVLW 0x32
0A84  6F85      	MOVWF CompTempVar2740+D'5', 1
0A86  6F87      	MOVWF CompTempVar2740+D'7', 1
0A88  0E35      	MOVLW 0x35
0A8A  6F83      	MOVWF CompTempVar2740+D'3', 1
0A8C  0E3D      	MOVLW 0x3D
0A8E  6F86      	MOVWF CompTempVar2740+D'6', 1
0A90  0E41      	MOVLW 0x41
0A92  6F80      	MOVWF CompTempVar2740, 1
0A94  0E53      	MOVLW 0x53
0A96  6F82      	MOVWF CompTempVar2740+D'2', 1
0A98  0E54      	MOVLW 0x54
0A9A  6F81      	MOVWF CompTempVar2740+D'1', 1
0A9C  6B88      	CLRF CompTempVar2740+D'8', 1
0A9E  0E00      	MOVLW HIGH(CompTempVar2740+D'0')
0AA0  6E7B      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND+D'1'
0AA2  0E80      	MOVLW LOW(CompTempVar2740+D'0')
0AA4  6E7A      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND
0AA6  0E09      	MOVLW 0x09
0AA8  6E7C      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
0AAA  6A7D      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
0AAC  0E03      	MOVLW 0x03
0AAE  6E7E      	MOVWF FCD_0c851__00059_arg_FCL_SENDCR
0AB0  EC50F002  	CALL FCD_0c851__00059
0AB4  5196      	MOVF CompTempVarRet2677, W, 1
0AB6  6E72      	MOVWF FCD_0c851__00078_1_FCR_RETVAL


		} else {
0AB8  D01F      	BRA	label116
0AF8            label116


			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=0", 9, 1);
0ABA  0E41      	MOVLW 0x41
0ABC  0100      	MOVLB 0x00
0ABE  6F80      	MOVWF CompTempVar2742, 1
0AC0  0E54      	MOVLW 0x54
0AC2  6F81      	MOVWF CompTempVar2742+D'1', 1
0AC4  0E53      	MOVLW 0x53
0AC6  6F82      	MOVWF CompTempVar2742+D'2', 1
0AC8  0E35      	MOVLW 0x35
0ACA  6F83      	MOVWF CompTempVar2742+D'3', 1
0ACC  0E31      	MOVLW 0x31
0ACE  6F84      	MOVWF CompTempVar2742+D'4', 1
0AD0  0E32      	MOVLW 0x32
0AD2  6F85      	MOVWF CompTempVar2742+D'5', 1
0AD4  0E3D      	MOVLW 0x3D
0AD6  6F86      	MOVWF CompTempVar2742+D'6', 1
0AD8  0E30      	MOVLW 0x30
0ADA  6F87      	MOVWF CompTempVar2742+D'7', 1
0ADC  6B88      	CLRF CompTempVar2742+D'8', 1
0ADE  0E00      	MOVLW HIGH(CompTempVar2742+D'0')
0AE0  6E7B      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND+D'1'
0AE2  0E80      	MOVLW LOW(CompTempVar2742+D'0')
0AE4  6E7A      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND
0AE6  0E09      	MOVLW 0x09
0AE8  6E7C      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
0AEA  6A7D      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
0AEC  0E01      	MOVLW 0x01
0AEE  6E7E      	MOVWF FCD_0c851__00059_arg_FCL_SENDCR
0AF0  EC50F002  	CALL FCD_0c851__00059
0AF4  5196      	MOVF CompTempVarRet2677, W, 1
0AF6  6E72      	MOVWF FCD_0c851__00078_1_FCR_RETVAL


		}

	}

	return (FCR_RETVAL);
0AF8  5072      	MOVF FCD_0c851__00078_1_FCR_RETVAL, W
0AFA  6E73      	MOVWF CompTempVarRet2735


}
0AFC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to receive a string from the GSM modem terminated with a 0x10 CR character. Used to collect the replies from commands.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TOUT = (0x0);
0190  0100      	MOVLB 0x00
0192  6BA8      	CLRF FCD_0c851__00072_1_FCL_TOUT, 1

	MX_UINT8 FCL_LEN = (0x0);
0194  6BA9      	CLRF FCD_0c851__00072_1_FCL_LEN, 1

	MX_UINT8 FCR_RETVAL;


	FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
0196  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
0198  6FA9      	MOVWF FCD_0c851__00072_1_FCL_LEN, 1

	FCV_0c851_Bluetooth2__RX_DONE = 0;
019A  6A59      	CLRF gbl_FCV_0c851_Bluetooth2___00001

	FCV_0c851_Bluetooth2__RX_LENGTH = 0;
019C  6A5A      	CLRF gbl_FCV_0c851_Bluetooth2___00002

	FCV_0c851_Bluetooth2__RX_IDX = 0;
019E  6A58      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX


	while ((FCV_0c851_Bluetooth2__RX_DONE == 0) && (FCL_TOUT < 255))
01A0            label21
01A0  5259      	MOVF gbl_FCV_0c851_Bluetooth2___00001, F
01A2  E113      	BNZ	label23
01A4  0EFF      	MOVLW 0xFF
01A6  61A8      	CPFSLT FCD_0c851__00072_1_FCL_TOUT, 1
01A8  D010      	BRA	label23
01C8  D7EB      	BRA	label21
01CA            label23

	{

		FCL_TOUT = FCL_TOUT + 1;
01AA  29A8      	INCF FCD_0c851__00072_1_FCL_TOUT, W, 1
01AC  6FA8      	MOVWF FCD_0c851__00072_1_FCL_TOUT, 1


		if (FCL_LEN != FCV_0c851_Bluetooth2__RX_LENGTH)
01AE  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
01B0  63A9      	CPFSEQ FCD_0c851__00072_1_FCL_LEN, 1
01B2  625A      	CPFSEQ gbl_FCV_0c851_Bluetooth2___00002
01B4  D003      	BRA	label22
01BC            label22

		{

			FCL_TOUT = 0;
01B6  6BA8      	CLRF FCD_0c851__00072_1_FCL_TOUT, 1

			FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
01B8  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
01BA  6FA9      	MOVWF FCD_0c851__00072_1_FCL_LEN, 1


		// } else {

		}

		FCI_DELAYINT_US(500);
01BC  0EF4      	MOVLW 0xF4
01BE  6FAB      	MOVWF FCI_DELAYI_00038_arg_Delay, 1
01C0  0E01      	MOVLW 0x01
01C2  6FAC      	MOVWF FCI_DELAYI_00038_arg_Delay+D'1', 1
01C4  EC95F000  	CALL FCI_DELAYI_00038



	}

	if (FCL_TOUT == 255)
01CA  29A8      	INCF FCD_0c851__00072_1_FCL_TOUT, W, 1
01CC  E104      	BNZ	label24
01D6            label24

	{

		FCV_0c851_Bluetooth2__RX_DONE = 0;
01CE  6A59      	CLRF gbl_FCV_0c851_Bluetooth2___00001

		FCV_0c851_Bluetooth2__RX_LENGTH = 0;
01D0  6A5A      	CLRF gbl_FCV_0c851_Bluetooth2___00002

		FCR_RETVAL = 0;
01D2  6BAA      	CLRF FCD_0c851__00072_1_FCR_RETVAL, 1


	} else {
01D4  D002      	BRA	label25
01DA            label25


		FCR_RETVAL = 1;
01D6  0E01      	MOVLW 0x01
01D8  6FAA      	MOVWF FCD_0c851__00072_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
01DA  51AA      	MOVF FCD_0c851__00072_1_FCR_RETVAL, W, 1
01DC  6FAB      	MOVWF CompTempVarRet2723, 1


}
01DE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Restores the factory settings to firmware using the AT&F* command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&F*", 6, 1);
09BC  0E41      	MOVLW 0x41
09BE  6E71      	MOVWF CompTempVar2745
09C0  0E54      	MOVLW 0x54
09C2  6E72      	MOVWF CompTempVar2745+D'1'
09C4  0E26      	MOVLW 0x26
09C6  6E73      	MOVWF CompTempVar2745+D'2'
09C8  0E46      	MOVLW 0x46
09CA  6E74      	MOVWF CompTempVar2745+D'3'
09CC  0E2A      	MOVLW 0x2A
09CE  6E75      	MOVWF CompTempVar2745+D'4'
09D0  6A76      	CLRF CompTempVar2745+D'5'
09D2  0E00      	MOVLW HIGH(CompTempVar2745+D'0')
09D4  6E7B      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND+D'1'
09D6  0E71      	MOVLW LOW(CompTempVar2745+D'0')
09D8  6E7A      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND
09DA  0E06      	MOVLW 0x06
09DC  6E7C      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
09DE  6A7D      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
09E0  0E01      	MOVLW 0x01
09E2  6E7E      	MOVWF FCD_0c851__00059_arg_FCL_SENDCR
09E4  EC50F002  	CALL FCD_0c851__00059
09E8  5196      	MOVF CompTempVarRet2677, W, 1
09EA  6E70      	MOVWF FCD_0c851__0007B_1_FCR_RETVAL


	return (FCR_RETVAL);
09EC  5070      	MOVF FCD_0c851__0007B_1_FCR_RETVAL, W
09EE  6E71      	MOVWF CompTempVarRet2744


}
09F0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets up the GSM module.
       :Returns 0 for OK, 255 for no reply and 254 for command fail.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__Initialise()

{
	//Définitions des variables locales
	#define FCLsz_CMDSTR 20
	MX_CHAR FCL_CMDSTR[FCLsz_CMDSTR];
	MX_UINT8 FCR_RETVAL;


	FCP_SET(B, B, 0x2, 0x1, 0);
0E34  6A70      	CLRF FCD_0c851__0004F_2_ptmp
0E36  9293      	BCF gbl_trisb,1
0E38  5270      	MOVF FCD_0c851__0004F_2_ptmp, F
0E3A  E004      	BZ	label134
0E3C  0E02      	MOVLW 0x02
0E3E  108A      	IORWF gbl_latb, W
0E40  6E81      	MOVWF gbl_portb
0E42  D003      	BRA	label135
0E44            label134
0E44  0EFD      	MOVLW 0xFD
0E46  148A      	ANDWF gbl_latb, W
0E48  6E81      	MOVWF gbl_portb
0E4A            label135


	FCI_DELAYBYTE_MS(100);
0E4A  0E64      	MOVLW 0x64
0E4C  6E70      	MOVWF delay_ms_00000_arg_del
0E4E  EC0BF000  	CALL delay_ms_00000


	FCP_SET(B, B, 0x2, 0x1, 1);
0E52  0E01      	MOVLW 0x01
0E54  6E70      	MOVWF FCD_0c851__0004F_13_ptmp
0E56  9293      	BCF gbl_trisb,1
0E58  5270      	MOVF FCD_0c851__0004F_13_ptmp, F
0E5A  E004      	BZ	label136
0E5C  0E02      	MOVLW 0x02
0E5E  108A      	IORWF gbl_latb, W
0E60  6E81      	MOVWF gbl_portb
0E62  D003      	BRA	label137
0E64            label136
0E64  0EFD      	MOVLW 0xFD
0E66  148A      	ANDWF gbl_latb, W
0E68  6E81      	MOVWF gbl_portb
0E6A            label137


	FCR_RETVAL = 0;
0E6A  6A6F      	CLRF FCD_0c851__0004F_1_FCR_RETVAL


	FC_CAL_UART_Init_1();
0E6C  ECE6F003  	CALL FC_CAL_UAR_0006C


	FCI_DELAYBYTE_MS(10);
0E70  0E0A      	MOVLW 0x0A
0E72  6E70      	MOVWF delay_ms_00000_arg_del
0E74  EC0BF000  	CALL delay_ms_00000


	FCD_0c851_Bluetooth2__StringReceive();
0E78  ECC8F000  	CALL FCD_0c851__00072


	#if (1)

		FCD_0c851_Bluetooth2__RestoreFactorySettings();
0E7C  ECDEF004  	CALL FCD_0c851__0007B


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCI_SHEAD("AT+BTN=\"",9, "lool",5, FCL_CMDSTR,20);
0E80  0E22      	MOVLW 0x22
0E82  6F87      	MOVWF CompTempVar2638+D'7', 1
0E84  0E2B      	MOVLW 0x2B
0E86  6F82      	MOVWF CompTempVar2638+D'2', 1
0E88  0E3D      	MOVLW 0x3D
0E8A  6F86      	MOVWF CompTempVar2638+D'6', 1
0E8C  0E41      	MOVLW 0x41
0E8E  6F80      	MOVWF CompTempVar2638, 1
0E90  0E42      	MOVLW 0x42
0E92  6F83      	MOVWF CompTempVar2638+D'3', 1
0E94  0E4E      	MOVLW 0x4E
0E96  6F85      	MOVWF CompTempVar2638+D'5', 1
0E98  0E54      	MOVLW 0x54
0E9A  6F81      	MOVWF CompTempVar2638+D'1', 1
0E9C  6F84      	MOVWF CompTempVar2638+D'4', 1
0E9E  6B88      	CLRF CompTempVar2638+D'8', 1
0EA0  0E00      	MOVLW HIGH(CompTempVar2638+D'0')
0EA2  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0EA4  0E80      	MOVLW LOW(CompTempVar2638+D'0')
0EA6  6E7A      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0EA8  0E09      	MOVLW 0x09
0EAA  6E7C      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0EAC  0E6C      	MOVLW 0x6C
0EAE  6F89      	MOVWF CompTempVar2639, 1
0EB0  6F8C      	MOVWF CompTempVar2639+D'3', 1
0EB2  0E6F      	MOVLW 0x6F
0EB4  6F8A      	MOVWF CompTempVar2639+D'1', 1
0EB6  6F8B      	MOVWF CompTempVar2639+D'2', 1
0EB8  6B8D      	CLRF CompTempVar2639+D'4', 1
0EBA  0E00      	MOVLW HIGH(CompTempVar2639+D'0')
0EBC  6E7E      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0EBE  0E89      	MOVLW LOW(CompTempVar2639+D'0')
0EC0  6E7D      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0EC2  0E05      	MOVLW 0x05
0EC4  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0EC6  0E00      	MOVLW HIGH(FCD_0c851__0004F_1_FCL_CMDSTR+D'0')
0EC8  6F9E      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0ECA  0E5B      	MOVLW LOW(FCD_0c851__0004F_1_FCL_CMDSTR+D'0')
0ECC  6F9D      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0ECE  0E14      	MOVLW 0x14
0ED0  6F9F      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0ED2  EC61F001  	CALL FCI_SHEAD_00000

	FCI_SHEAD(FCL_CMDSTR,FCLsz_CMDSTR, "\"",2, FCL_CMDSTR,20);
0ED6  0E00      	MOVLW HIGH(FCD_0c851__0004F_1_FCL_CMDSTR+D'0')
0ED8  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0EDA  0E5B      	MOVLW LOW(FCD_0c851__0004F_1_FCL_CMDSTR+D'0')
0EDC  6E7A      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0EDE  0E14      	MOVLW 0x14
0EE0  6E7C      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0EE2  0E22      	MOVLW 0x22
0EE4  6E71      	MOVWF CompTempVar2643
0EE6  6A72      	CLRF CompTempVar2643+D'1'
0EE8  0E00      	MOVLW HIGH(CompTempVar2643+D'0')
0EEA  6E7E      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0EEC  0E71      	MOVLW LOW(CompTempVar2643+D'0')
0EEE  6E7D      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0EF0  0E02      	MOVLW 0x02
0EF2  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0EF4  0E00      	MOVLW HIGH(FCD_0c851__0004F_1_FCL_CMDSTR+D'0')
0EF6  6F9E      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0EF8  0E5B      	MOVLW LOW(FCD_0c851__0004F_1_FCL_CMDSTR+D'0')
0EFA  6F9D      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0EFC  0E14      	MOVLW 0x14
0EFE  6F9F      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0F00  EC61F001  	CALL FCI_SHEAD_00000


	FCD_0c851_Bluetooth2__SendCommand(FCL_CMDSTR, FCLsz_CMDSTR, 1);
0F04  0E00      	MOVLW HIGH(FCD_0c851__0004F_1_FCL_CMDSTR+D'0')
0F06  6E7B      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND+D'1'
0F08  0E5B      	MOVLW LOW(FCD_0c851__0004F_1_FCL_CMDSTR+D'0')
0F0A  6E7A      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND
0F0C  0E14      	MOVLW 0x14
0F0E  6E7C      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
0F10  6A7D      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
0F12  0E01      	MOVLW 0x01
0F14  6E7E      	MOVWF FCD_0c851__00059_arg_FCL_SENDCR
0F16  EC50F002  	CALL FCD_0c851__00059


	FCD_0c851_Bluetooth2__SetPairKey("1379", 5);
0F1A  0E31      	MOVLW 0x31
0F1C  6E72      	MOVWF CompTempVar2648
0F1E  0E33      	MOVLW 0x33
0F20  6E73      	MOVWF CompTempVar2648+D'1'
0F22  0E37      	MOVLW 0x37
0F24  6E74      	MOVWF CompTempVar2648+D'2'
0F26  0E39      	MOVLW 0x39
0F28  6E75      	MOVWF CompTempVar2648+D'3'
0F2A  6A76      	CLRF CompTempVar2648+D'4'
0F2C  0E00      	MOVLW HIGH(CompTempVar2648+D'0')
0F2E  6E71      	MOVWF FCD_0c851__0006E_arg_FCL_PAIRKEY+D'1'
0F30  0E72      	MOVLW LOW(CompTempVar2648+D'0')
0F32  6E70      	MOVWF FCD_0c851__0006E_arg_FCL_PAIRKEY
0F34  0E05      	MOVLW 0x05
0F36  6E77      	MOVWF FCD_0c851__0006E_arg_FCLsz_0006F
0F38  6A78      	CLRF FCD_0c851__0006E_arg_FCLsz_0006F+D'1'
0F3A  ECAEF005  	CALL FCD_0c851__0006E


	FCD_0c851_Bluetooth2__SetMode(1, 1);
0F3E  0E01      	MOVLW 0x01
0F40  6E70      	MOVWF FCD_0c851__00078_arg_FCL_D_00079
0F42  6E71      	MOVWF FCD_0c851__00078_arg_FCL_C_0007A
0F44  ECF9F004  	CALL FCD_0c851__00078


	FCR_RETVAL = FCD_0c851_Bluetooth2__SaveSettings();
0F48  EC7FF005  	CALL FCD_0c851__00076
0F4C  5071      	MOVF CompTempVarRet2730, W
0F4E  6E6F      	MOVWF FCD_0c851__0004F_1_FCR_RETVAL


	return (FCR_RETVAL);
0F50  506F      	MOVF FCD_0c851__0004F_1_FCR_RETVAL, W
0F52  6E70      	MOVWF CompTempVarRet2637


	//Définitions des variables locales
	#undef FCLsz_CMDSTR
}
0F54  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_INITIALISATION()

{

	//Commentaire:
	//BT4

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::Initialise()
	FCD_0c851_Bluetooth2__Initialise();
10D8  EC1AF007  	CALL FCD_0c851__0004F


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Start()
	FCD_0ad31_lcd_eb005__Start();
10DC  ECDAF007  	CALL FCD_04071__00050


	// Pause
	// Pause: 1 s
	FCI_DELAYBYTE_S(1);
10E0  0E01      	MOVLW 0x01
10E2  6E5B      	MOVWF delay_s_00000_arg_del
10E4  EC33F000  	CALL delay_s_00000


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendScript(1)
	FCD_0c851_Bluetooth2__SendScript(1);
10E8  0E01      	MOVLW 0x01
10EA  6E5B      	MOVWF FCD_0c851__00051_arg_FCL_IDX
10EC  EC2AF006  	CALL FCD_0c851__00051


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendScript(2)
	FCD_0c851_Bluetooth2__SendScript(2);
10F0  0E02      	MOVLW 0x02
10F2  6E5B      	MOVWF FCD_0c851__00051_arg_FCL_IDX
10F4  EC2AF006  	CALL FCD_0c851__00051


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Initialisation...")
	FCD_0ad31_lcd_eb005__PrintString("Initialisation...", 18);
10F8  0E2E      	MOVLW 0x2E
10FA  6E77      	MOVWF CompTempVar2633+D'14'
10FC  6E78      	MOVWF CompTempVar2633+D'15'
10FE  6E79      	MOVWF CompTempVar2633+D'16'
1100  0E49      	MOVLW 0x49
1102  6E69      	MOVWF CompTempVar2633
1104  0E61      	MOVLW 0x61
1106  6E6E      	MOVWF CompTempVar2633+D'5'
1108  6E72      	MOVWF CompTempVar2633+D'9'
110A  0E69      	MOVLW 0x69
110C  6E6B      	MOVWF CompTempVar2633+D'2'
110E  6E6D      	MOVWF CompTempVar2633+D'4'
1110  6E70      	MOVWF CompTempVar2633+D'7'
1112  6E74      	MOVWF CompTempVar2633+D'11'
1114  0E6C      	MOVLW 0x6C
1116  6E6F      	MOVWF CompTempVar2633+D'6'
1118  0E6E      	MOVLW 0x6E
111A  6E6A      	MOVWF CompTempVar2633+D'1'
111C  6E76      	MOVWF CompTempVar2633+D'13'
111E  0E6F      	MOVLW 0x6F
1120  6E75      	MOVWF CompTempVar2633+D'12'
1122  0E73      	MOVLW 0x73
1124  6E71      	MOVWF CompTempVar2633+D'8'
1126  0E74      	MOVLW 0x74
1128  6E6C      	MOVWF CompTempVar2633+D'3'
112A  6E73      	MOVWF CompTempVar2633+D'10'
112C  6A7A      	CLRF CompTempVar2633+D'17'
112E  0E00      	MOVLW HIGH(CompTempVar2633+D'0')
1130  6E68      	MOVWF FCD_04071__00053_arg_FCL_TEXT+D'1'
1132  0E69      	MOVLW LOW(CompTempVar2633+D'0')
1134  6E67      	MOVWF FCD_04071__00053_arg_FCL_TEXT
1136  0E12      	MOVLW 0x12
1138  6E7B      	MOVWF FCD_04071__00053_arg_FCLsz_TEXT
113A  6A7C      	CLRF FCD_04071__00053_arg_FCLsz_TEXT+D'1'
113C  EC0EF006  	CALL FCD_04071__00053


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Cursor(0, 1)
	FCD_0ad31_lcd_eb005__Cursor(0, 1);
1140  6A5B      	CLRF FCD_04071__00054_arg_FCL_X
1142  0E01      	MOVLW 0x01
1144  6E5C      	MOVWF FCD_04071__00054_arg_FCL_Y
1146  ECC7F007  	CALL FCD_04071__00054


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Player (1)")
	FCD_0ad31_lcd_eb005__PrintString("Player (1)", 11);
114A  0E50      	MOVLW 0x50
114C  6E69      	MOVWF CompTempVar2635
114E  0E6C      	MOVLW 0x6C
1150  6E6A      	MOVWF CompTempVar2635+D'1'
1152  0E61      	MOVLW 0x61
1154  6E6B      	MOVWF CompTempVar2635+D'2'
1156  0E79      	MOVLW 0x79
1158  6E6C      	MOVWF CompTempVar2635+D'3'
115A  0E65      	MOVLW 0x65
115C  6E6D      	MOVWF CompTempVar2635+D'4'
115E  0E72      	MOVLW 0x72
1160  6E6E      	MOVWF CompTempVar2635+D'5'
1162  0E20      	MOVLW 0x20
1164  6E6F      	MOVWF CompTempVar2635+D'6'
1166  0E28      	MOVLW 0x28
1168  6E70      	MOVWF CompTempVar2635+D'7'
116A  0E31      	MOVLW 0x31
116C  6E71      	MOVWF CompTempVar2635+D'8'
116E  0E29      	MOVLW 0x29
1170  6E72      	MOVWF CompTempVar2635+D'9'
1172  6A73      	CLRF CompTempVar2635+D'10'
1174  0E00      	MOVLW HIGH(CompTempVar2635+D'0')
1176  6E68      	MOVWF FCD_04071__00053_arg_FCL_TEXT+D'1'
1178  0E69      	MOVLW LOW(CompTempVar2635+D'0')
117A  6E67      	MOVWF FCD_04071__00053_arg_FCL_TEXT
117C  0E0B      	MOVLW 0x0B
117E  6E7B      	MOVWF FCD_04071__00053_arg_FCLsz_TEXT
1180  6A7C      	CLRF FCD_04071__00053_arg_FCLsz_TEXT+D'1'
1182  EC0EF006  	CALL FCD_04071__00053


	#if 0 // Disabled code
	// Boucle
	// Boucle: While 1
	while (1)
	{

		// Calcul
		// Calcul:
		//  octet = 0
		FCV_OCTET = 0;

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();

		// Appel de la Routine Composant
		// Appel de la Routine Composant: octet=Bluetooth2::ReceiveByte(20)
		FCV_OCTET = FCD_0c851_Bluetooth2__ReceiveByte(20);

		// Appel de la Routine Composant
		// Appel de la Routine Composant: return=Bluetooth2::ReadString(octet)
		FCD_0c851_Bluetooth2__ReadString(FCV_RETURN,20, FCV_OCTET);

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString(return)
		FCD_0ad31_lcd_eb005__PrintString(FCV_RETURN, FCVsz_RETURN);

		#if 0 // Disabled code
		// Pause
		// Pause: 1 s
		FCI_DELAYBYTE_S(1);

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Calcul
		// Calcul:
		//  loop = loop + 1
		FCV_LOOP = FCV_LOOP + 1;

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Décision
		// Décision: loop >= 15?
		if (FCV_LOOP >= 15)
		{

			#if 0 // Disabled code
			// Calcul
			// Calcul:
			//  loop = 0
			FCV_LOOP = 0;

			#endif // #if 0: Disabled code
			#if 0 // Disabled code
			// Appel de la Routine Composant
			// Appel de la Routine Composant: Bluetooth2::SendCommand("salut", 0)
			FCD_0c851_Bluetooth2__SendCommand("salut", 6, 0);

			#endif // #if 0: Disabled code
		// } else {

		}

		#endif // #if 0: Disabled code

	}

	#endif // #if 0: Disabled code
}
1186  EF93F009  	GOTO	label155


/*=----------------------------------------------------------------------=*\
   Use :V??rification de la connexion des deux modules bluetooth
\*=----------------------------------------------------------------------=*/
void FCM_BT_CHECK_CONNECTON()
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_CHECK_BT_GETTING()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Connection des deux modules entre eux
\*=----------------------------------------------------------------------=*/
void FCM_BT_CONNECTION()

{

	// Boucle
	// Boucle: While bt_state != 0
	while (FCV_BT_STATE != 0)
118A            label153
118A  5257      	MOVF gbl_FCV_BT_STATE, F
118C  E07B      	BZ	label154
1282  D783      	BRA	label153
1284            label154

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();
118E  ECFAF005  	CALL FCD_04071__00058


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString("Connection...")
		FCD_0ad31_lcd_eb005__PrintString("Connection...", 14);
1192  0E2E      	MOVLW 0x2E
1194  6E73      	MOVWF CompTempVar2667+D'10'
1196  6E74      	MOVWF CompTempVar2667+D'11'
1198  6E75      	MOVWF CompTempVar2667+D'12'
119A  0E43      	MOVLW 0x43
119C  6E69      	MOVWF CompTempVar2667
119E  0E63      	MOVLW 0x63
11A0  6E6E      	MOVWF CompTempVar2667+D'5'
11A2  0E65      	MOVLW 0x65
11A4  6E6D      	MOVWF CompTempVar2667+D'4'
11A6  0E69      	MOVLW 0x69
11A8  6E70      	MOVWF CompTempVar2667+D'7'
11AA  0E6E      	MOVLW 0x6E
11AC  6E6B      	MOVWF CompTempVar2667+D'2'
11AE  6E6C      	MOVWF CompTempVar2667+D'3'
11B0  6E72      	MOVWF CompTempVar2667+D'9'
11B2  0E6F      	MOVLW 0x6F
11B4  6E6A      	MOVWF CompTempVar2667+D'1'
11B6  6E71      	MOVWF CompTempVar2667+D'8'
11B8  0E74      	MOVLW 0x74
11BA  6E6F      	MOVWF CompTempVar2667+D'6'
11BC  6A76      	CLRF CompTempVar2667+D'13'
11BE  0E00      	MOVLW HIGH(CompTempVar2667+D'0')
11C0  6E68      	MOVWF FCD_04071__00053_arg_FCL_TEXT+D'1'
11C2  0E69      	MOVLW LOW(CompTempVar2667+D'0')
11C4  6E67      	MOVWF FCD_04071__00053_arg_FCL_TEXT
11C6  0E0E      	MOVLW 0x0E
11C8  6E7B      	MOVWF FCD_04071__00053_arg_FCLsz_TEXT
11CA  6A7C      	CLRF FCD_04071__00053_arg_FCLsz_TEXT+D'1'
11CC  EC0EF006  	CALL FCD_04071__00053


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Cursor(0, 1)
		FCD_0ad31_lcd_eb005__Cursor(0, 1);
11D0  6A5B      	CLRF FCD_04071__00054_arg_FCL_X
11D2  0E01      	MOVLW 0x01
11D4  6E5C      	MOVWF FCD_04071__00054_arg_FCL_Y
11D6  ECC7F007  	CALL FCD_04071__00054


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString("Please wait...")
		FCD_0ad31_lcd_eb005__PrintString("Please wait...", 15);
11DA  0E20      	MOVLW 0x20
11DC  6E6F      	MOVWF CompTempVar2669+D'6'
11DE  0E2E      	MOVLW 0x2E
11E0  6E74      	MOVWF CompTempVar2669+D'11'
11E2  6E75      	MOVWF CompTempVar2669+D'12'
11E4  6E76      	MOVWF CompTempVar2669+D'13'
11E6  0E50      	MOVLW 0x50
11E8  6E69      	MOVWF CompTempVar2669
11EA  0E61      	MOVLW 0x61
11EC  6E6C      	MOVWF CompTempVar2669+D'3'
11EE  6E71      	MOVWF CompTempVar2669+D'8'
11F0  0E65      	MOVLW 0x65
11F2  6E6B      	MOVWF CompTempVar2669+D'2'
11F4  6E6E      	MOVWF CompTempVar2669+D'5'
11F6  0E69      	MOVLW 0x69
11F8  6E72      	MOVWF CompTempVar2669+D'9'
11FA  0E6C      	MOVLW 0x6C
11FC  6E6A      	MOVWF CompTempVar2669+D'1'
11FE  0E73      	MOVLW 0x73
1200  6E6D      	MOVWF CompTempVar2669+D'4'
1202  0E74      	MOVLW 0x74
1204  6E73      	MOVWF CompTempVar2669+D'10'
1206  0E77      	MOVLW 0x77
1208  6E70      	MOVWF CompTempVar2669+D'7'
120A  6A77      	CLRF CompTempVar2669+D'14'
120C  0E00      	MOVLW HIGH(CompTempVar2669+D'0')
120E  6E68      	MOVWF FCD_04071__00053_arg_FCL_TEXT+D'1'
1210  0E69      	MOVLW LOW(CompTempVar2669+D'0')
1212  6E67      	MOVWF FCD_04071__00053_arg_FCL_TEXT
1214  0E0F      	MOVLW 0x0F
1216  6E7B      	MOVWF FCD_04071__00053_arg_FCLsz_TEXT
1218  6A7C      	CLRF FCD_04071__00053_arg_FCLsz_TEXT+D'1'
121A  EC0EF006  	CALL FCD_04071__00053


		//Commentaire:
		//On se connete automatiquement au module bluetooth du joueur 1

		// Appel de la Routine Composant
		// Appel de la Routine Composant: command_return=Bluetooth2::SendCommand("ATD0080980B9388", 1)
		FCV_COMMAND_RETURN = FCD_0c851_Bluetooth2__SendCommand("ATD0080980B9388", 16, 1);
121E  0E30      	MOVLW 0x30
1220  6E5E      	MOVWF CompTempVar2671+D'3'
1222  6E5F      	MOVWF CompTempVar2671+D'4'
1224  6E61      	MOVWF CompTempVar2671+D'6'
1226  6E64      	MOVWF CompTempVar2671+D'9'
1228  0E33      	MOVLW 0x33
122A  6E67      	MOVWF CompTempVar2671+D'12'
122C  0E38      	MOVLW 0x38
122E  6E60      	MOVWF CompTempVar2671+D'5'
1230  6E63      	MOVWF CompTempVar2671+D'8'
1232  6E68      	MOVWF CompTempVar2671+D'13'
1234  6E69      	MOVWF CompTempVar2671+D'14'
1236  0E39      	MOVLW 0x39
1238  6E62      	MOVWF CompTempVar2671+D'7'
123A  6E66      	MOVWF CompTempVar2671+D'11'
123C  0E41      	MOVLW 0x41
123E  6E5B      	MOVWF CompTempVar2671
1240  0E42      	MOVLW 0x42
1242  6E65      	MOVWF CompTempVar2671+D'10'
1244  0E44      	MOVLW 0x44
1246  6E5D      	MOVWF CompTempVar2671+D'2'
1248  0E54      	MOVLW 0x54
124A  6E5C      	MOVWF CompTempVar2671+D'1'
124C  6A6A      	CLRF CompTempVar2671+D'15'
124E  0E00      	MOVLW HIGH(CompTempVar2671+D'0')
1250  6E7B      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND+D'1'
1252  0E5B      	MOVLW LOW(CompTempVar2671+D'0')
1254  6E7A      	MOVWF FCD_0c851__00059_arg_FCL_COMMAND
1256  0E10      	MOVLW 0x10
1258  6E7C      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
125A  6A7D      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
125C  0E01      	MOVLW 0x01
125E  6E7E      	MOVWF FCD_0c851__00059_arg_FCL_SENDCR
1260  EC50F002  	CALL FCD_0c851__00059
1264  5196      	MOVF CompTempVarRet2677, W, 1
1266  6E56      	MOVWF gbl_FCV_COMMAND_RETURN


		// Pause
		// Pause: 1 s
		FCI_DELAYBYTE_S(1);
1268  0E01      	MOVLW 0x01
126A  6E5B      	MOVWF delay_s_00000_arg_del
126C  EC33F000  	CALL delay_s_00000


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();
1270  ECFAF005  	CALL FCD_04071__00058


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintNumber(command_return)
		FCD_0ad31_lcd_eb005__PrintNumber(FCV_COMMAND_RETURN);
1274  5056      	MOVF gbl_FCV_COMMAND_RETURN, W
1276  6E5B      	MOVWF FCD_04071__0005B_arg_FCL_NUMBER
1278  6A5C      	CLRF FCD_04071__0005B_arg_FCL_NUMBER+D'1'
127A  ECABF007  	CALL FCD_04071__0005B


		// Calcul
		// Calcul:
		//  bt_state = command_return
		FCV_BT_STATE = FCV_COMMAND_RETURN;
127E  5056      	MOVF gbl_FCV_COMMAND_RETURN, W
1280  6E57      	MOVWF gbl_FCV_BT_STATE



	}

	// Pause
	// Pause: 5 s
	FCI_DELAYBYTE_S(5);
1284  0E05      	MOVLW 0x05
1286  6E5B      	MOVWF delay_s_00000_arg_del
1288  EC33F000  	CALL delay_s_00000


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Clear()
	FCD_0ad31_lcd_eb005__Clear();
128C  ECFAF005  	CALL FCD_04071__00058


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Connected to")
	FCD_0ad31_lcd_eb005__PrintString("Connected to", 13);
1290  0E20      	MOVLW 0x20
1292  6E72      	MOVWF CompTempVar2673+D'9'
1294  0E43      	MOVLW 0x43
1296  6E69      	MOVWF CompTempVar2673
1298  0E63      	MOVLW 0x63
129A  6E6E      	MOVWF CompTempVar2673+D'5'
129C  0E64      	MOVLW 0x64
129E  6E71      	MOVWF CompTempVar2673+D'8'
12A0  0E65      	MOVLW 0x65
12A2  6E6D      	MOVWF CompTempVar2673+D'4'
12A4  6E70      	MOVWF CompTempVar2673+D'7'
12A6  0E6E      	MOVLW 0x6E
12A8  6E6B      	MOVWF CompTempVar2673+D'2'
12AA  6E6C      	MOVWF CompTempVar2673+D'3'
12AC  0E6F      	MOVLW 0x6F
12AE  6E6A      	MOVWF CompTempVar2673+D'1'
12B0  6E74      	MOVWF CompTempVar2673+D'11'
12B2  0E74      	MOVLW 0x74
12B4  6E6F      	MOVWF CompTempVar2673+D'6'
12B6  6E73      	MOVWF CompTempVar2673+D'10'
12B8  6A75      	CLRF CompTempVar2673+D'12'
12BA  0E00      	MOVLW HIGH(CompTempVar2673+D'0')
12BC  6E68      	MOVWF FCD_04071__00053_arg_FCL_TEXT+D'1'
12BE  0E69      	MOVLW LOW(CompTempVar2673+D'0')
12C0  6E67      	MOVWF FCD_04071__00053_arg_FCL_TEXT
12C2  0E0D      	MOVLW 0x0D
12C4  6E7B      	MOVWF FCD_04071__00053_arg_FCLsz_TEXT
12C6  6A7C      	CLRF FCD_04071__00053_arg_FCLsz_TEXT+D'1'
12C8  EC0EF006  	CALL FCD_04071__00053


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Cursor(0, 1)
	FCD_0ad31_lcd_eb005__Cursor(0, 1);
12CC  6A5B      	CLRF FCD_04071__00054_arg_FCL_X
12CE  0E01      	MOVLW 0x01
12D0  6E5C      	MOVWF FCD_04071__00054_arg_FCL_Y
12D2  ECC7F007  	CALL FCD_04071__00054


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("player (2)")
	FCD_0ad31_lcd_eb005__PrintString("player (2)", 11);
12D6  0E70      	MOVLW 0x70
12D8  6E5B      	MOVWF CompTempVar2675
12DA  0E6C      	MOVLW 0x6C
12DC  6E5C      	MOVWF CompTempVar2675+D'1'
12DE  0E61      	MOVLW 0x61
12E0  6E5D      	MOVWF CompTempVar2675+D'2'
12E2  0E79      	MOVLW 0x79
12E4  6E5E      	MOVWF CompTempVar2675+D'3'
12E6  0E65      	MOVLW 0x65
12E8  6E5F      	MOVWF CompTempVar2675+D'4'
12EA  0E72      	MOVLW 0x72
12EC  6E60      	MOVWF CompTempVar2675+D'5'
12EE  0E20      	MOVLW 0x20
12F0  6E61      	MOVWF CompTempVar2675+D'6'
12F2  0E28      	MOVLW 0x28
12F4  6E62      	MOVWF CompTempVar2675+D'7'
12F6  0E32      	MOVLW 0x32
12F8  6E63      	MOVWF CompTempVar2675+D'8'
12FA  0E29      	MOVLW 0x29
12FC  6E64      	MOVWF CompTempVar2675+D'9'
12FE  6A65      	CLRF CompTempVar2675+D'10'
1300  0E00      	MOVLW HIGH(CompTempVar2675+D'0')
1302  6E68      	MOVWF FCD_04071__00053_arg_FCL_TEXT+D'1'
1304  0E5B      	MOVLW LOW(CompTempVar2675+D'0')
1306  6E67      	MOVWF FCD_04071__00053_arg_FCL_TEXT
1308  0E0B      	MOVLW 0x0B
130A  6E7B      	MOVWF FCD_04071__00053_arg_FCLsz_TEXT
130C  6A7C      	CLRF FCD_04071__00053_arg_FCLsz_TEXT+D'1'
130E  EC0EF006  	CALL FCD_04071__00053


	// Pause
	// Pause: 1 s
	FCI_DELAYBYTE_S(1);
1312  0E01      	MOVLW 0x01
1314  6E5B      	MOVWF delay_s_00000_arg_del
1316  EC33F000  	CALL delay_s_00000


}
131A  0012      	RETURN




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
131C  0E0F      	MOVLW 0x0F
131E  6EC1      	MOVWF gbl_adcon1





	// Appel d'une Macro
	// Appel d'une Macro: INITIALISATION()
	FCM_INITIALISATION();
1320  0E99      	MOVLW 0x99
1322  EF6CF008  	GOTO	FCM_INITIA_0004E
1326            label155


	// Appel d'une Macro
	// Appel d'une Macro: BT_CONNECTION()
	FCM_BT_CONNECTION();
1326  ECC5F008  	CALL FCM_BT_CON_00057


	mainendloop: goto mainendloop;
132A            label156
132A  D7FF      	BRA	label156

}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

	MX_UART_INT_CH1_FUNC

	MX_UINT8 FCL_BT_IN;
1380  CFEAF001  	MOVFF FSR0H,  Int1Context
1384  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1388  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
138C  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'


	FCL_BT_IN = MX_UART_INT_CH1_DET;
1390  0E20      	MOVLW 0x20
1392  149E      	ANDWF gbl_pir1, W
1394  0100      	MOVLB 0x00
1396  6FD6      	MOVWF CompTempVar2748, 1
1398  0E20      	MOVLW 0x20
139A  149D      	ANDWF gbl_pie1, W
139C  6FD5      	MOVWF CompTempVar2747, 1
139E  6BD4      	CLRF interrupt_1_FCL_BT_IN, 1
13A0  53D5      	MOVF CompTempVar2747, F, 1
13A2  A4D8      	BTFSS STATUS,Z
13A4  53D6      	MOVF CompTempVar2748, F, 1
13A6  A4D8      	BTFSS STATUS,Z
13A8  2BD4      	INCF interrupt_1_FCL_BT_IN, F, 1


	if (FCL_BT_IN)
13AA  53D4      	MOVF interrupt_1_FCL_BT_IN, F, 1
13AC  E022      	BZ	label160
13F2            label160

	{

	FCL_BT_IN = FC_CAL_UART_Receive_1(1);
13AE  0E01      	MOVLW 0x01
13B0  6FD5      	MOVWF FC_CAL_UAR_0006A_arg_nTimeout, 1
13B2  EC46F000  	CALL FC_CAL_UAR_0006A
13B6  51DE      	MOVF CompTempVarRet2707, W, 1
13B8  6FD4      	MOVWF interrupt_1_FCL_BT_IN, 1


	if (FCV_0c851_Bluetooth2__RX_DONE == 0)
13BA  5259      	MOVF gbl_FCV_0c851_Bluetooth2___00001, F
13BC  E119      	BNZ	label159

	{

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 50)
13BE  0E32      	MOVLW 0x32
13C0  605A      	CPFSLT gbl_FCV_0c851_Bluetooth2___00002
13C2  D016      	BRA	label159

		{

			if (FCL_BT_IN == 0x0A)
13C4  0E0A      	MOVLW 0x0A
13C6  63D4      	CPFSEQ interrupt_1_FCL_BT_IN, 1
13C8  D00A      	BRA	label158
13DE            label158

			{

				FCV_0c851_Bluetooth2__RX_DONE = 1;
13CA  0E01      	MOVLW 0x01
13CC  6E59      	MOVWF gbl_FCV_0c851_Bluetooth2___00001

				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = 0;
13CE  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00000
13D2  50E9      	MOVF FSR0L, W
13D4  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
13D6  26E9      	ADDWF FSR0L, F
13D8  0E00      	MOVLW 0x00
13DA  6EEF      	MOVWF INDF0


			} else {
13DC  D009      	BRA	label159
13F0            label159


				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = FCL_BT_IN;
13DE  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00000
13E2  50E9      	MOVF FSR0L, W
13E4  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
13E6  26E9      	ADDWF FSR0L, F
13E8  51D4      	MOVF interrupt_1_FCL_BT_IN, W, 1
13EA  6EEF      	MOVWF INDF0

				FCV_0c851_Bluetooth2__RX_LENGTH = FCV_0c851_Bluetooth2__RX_LENGTH + 1;
13EC  285A      	INCF gbl_FCV_0c851_Bluetooth2___00002, W
13EE  6E5A      	MOVWF gbl_FCV_0c851_Bluetooth2___00002


			}

		// } else {

		}

	// } else {

	}

	MX_UART_INT_CH1_CLR;
13F0  9A9E      	BCF gbl_pir1,5


	}

	MX_UART_INT_FUNC_END
}
13F2  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
13F6  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
13FA  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
13FE  C001FFEA  	MOVFF Int1Context,  FSR0H
1402  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
07CC  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
07CE  0E7F      	MOVLW 0x7F
07D0  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
07D2  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
07D4  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
07D6  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
07D8  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
07DA  8A9D      	BSF gbl_pie1,5

				st_bit(intcon, PEIE);
07DC  8CF2      	BSF gbl_intcon,6

				st_bit(intcon, GIE);
07DE  8EF2      	BSF gbl_intcon,7

			#else
				cr_bit (pie1, RCIE);
			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
07E0  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
0160            label18
0160  0E10      	MOVLW 0x10
0162  149E      	ANDWF gbl_pir1, W
0164  6FAA      	MOVWF CompTempVar2711, 1
0166  53AA      	MOVF CompTempVar2711, F, 1
0168  E0FB      	BZ	label18


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
016A  51A8      	MOVF FC_CAL_UAR_0006B_arg_nChar, W, 1
016C  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
016E  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
008C  69D6      	SETF FC_CAL_UAR_0006A_1_retVal, 1

  #endif

	MX_UINT8 delay1 = 0;
008E  6BD7      	CLRF FC_CAL_UAR_0006A_1_delay1, 1

	MX_UINT8 regcheck = 0;
0090  6BD8      	CLRF FC_CAL_UAR_0006A_1_regcheck, 1

	MX_UINT8 bWaitForever = 0;
0092  6BD9      	CLRF FC_CAL_UAR_0006A_1_bWaitForever, 1

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
0094  6BDA      	CLRF FC_CAL_UAR_0006A_1_rxStatus, 1

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0096  6BDD      	CLRF FC_CAL_UAR_0006A_1_dummy, 1

  #endif

	if (nTimeout == 255)
0098  29D5      	INCF FC_CAL_UAR_0006A_arg_nTimeout, W, 1
009A  E102      	BNZ	label5
00A0            label5

		bWaitForever = 1;
009C  0E01      	MOVLW 0x01
009E  6FD9      	MOVWF FC_CAL_UAR_0006A_1_bWaitForever, 1


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00A0  53DA      	MOVF FC_CAL_UAR_0006A_1_rxStatus, F, 1
00A2  E124      	BNZ	label10
00EA  D7DA      	BRA	label5
00EC            label10

	{
		if (bWaitForever == 0)
00A4  53D9      	MOVF FC_CAL_UAR_0006A_1_bWaitForever, F, 1
00A6  E118      	BNZ	label9

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00A8  53D5      	MOVF FC_CAL_UAR_0006A_arg_nTimeout, F, 1
00AA  E103      	BNZ	label6
00B2            label6

			{
				rxStatus = UART_STATUS_TIMEOUT;
00AC  0E01      	MOVLW 0x01
00AE  6FDA      	MOVWF FC_CAL_UAR_0006A_1_rxStatus, 1

			}
			else
00B0  D013      	BRA	label9

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00B2  6BDB      	CLRF FC_CAL_UAR_0006A_1_delaycnt, 1
00B4  6BDC      	CLRF FC_CAL_UAR_0006A_1_delaycnt+D'1', 1
00B6            label7
00B6  0E31      	MOVLW 0x31
00B8  5DDB      	SUBWF FC_CAL_UAR_0006A_1_delaycnt, W, 1
00BA  E205      	BC	label8
00BC  67DC      	TSTFSZ FC_CAL_UAR_0006A_1_delaycnt+D'1', 1
00BE  D003      	BRA	label8
00C0  4BDB      	INFSNZ FC_CAL_UAR_0006A_1_delaycnt, F, 1
00C2  2BDC      	INCF FC_CAL_UAR_0006A_1_delaycnt+D'1', F, 1
00C4  D7F8      	BRA	label7
00C6            label8

				delay1 = delay1 + 1;
00C6  29D7      	INCF FC_CAL_UAR_0006A_1_delay1, W, 1
00C8  6FD7      	MOVWF FC_CAL_UAR_0006A_1_delay1, 1

				if(delay1 == 100)
00CA  0E64      	MOVLW 0x64
00CC  63D7      	CPFSEQ FC_CAL_UAR_0006A_1_delay1, 1
00CE  D004      	BRA	label9
00D8            label9

				{
					nTimeout = nTimeout - 1;
00D0  05D5      	DECF FC_CAL_UAR_0006A_arg_nTimeout, W, 1
00D2  6FD5      	MOVWF FC_CAL_UAR_0006A_arg_nTimeout, 1

					MX_CLEAR_WATCHDOG;
00D4  0004      	CLRWDT

					delay1 = 0;
00D6  6BD7      	CLRF FC_CAL_UAR_0006A_1_delay1, 1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00D8  0E20      	MOVLW 0x20
00DA  149E      	ANDWF gbl_pir1, W
00DC  6FDE      	MOVWF CompTempVar2708, 1
00DE  51DE      	MOVF CompTempVar2708, W, 1
00E0  6FD8      	MOVWF FC_CAL_UAR_0006A_1_regcheck, 1

			if (regcheck != 0)
00E2  53D8      	MOVF FC_CAL_UAR_0006A_1_regcheck, F, 1
00E4  E0DD      	BZ	label5

				rxStatus = UART_STATUS_RXBYTE;
00E6  0E02      	MOVLW 0x02
00E8  6FDA      	MOVWF FC_CAL_UAR_0006A_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00EC  0E02      	MOVLW 0x02
00EE  63DA      	CPFSEQ FC_CAL_UAR_0006A_1_rxStatus, 1
00F0  D018      	BRA	label13

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
00F2  0E04      	MOVLW 0x04
00F4  14AB      	ANDWF gbl_rcsta, W
00F6  6FDE      	MOVWF CompTempVar2709, 1
00F8  51DE      	MOVF CompTempVar2709, W, 1
00FA  6FD8      	MOVWF FC_CAL_UAR_0006A_1_regcheck, 1

			if (regcheck != 0)
00FC  53D8      	MOVF FC_CAL_UAR_0006A_1_regcheck, F, 1
00FE  E003      	BZ	label11
0106            label11

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0100  50AE      	MOVF gbl_rcreg, W
0102  6FDD      	MOVWF FC_CAL_UAR_0006A_1_dummy, 1

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0104  D00E      	BRA	label13

			{
				regcheck = ts_bit(rcsta, OERR);
0106  0E02      	MOVLW 0x02
0108  14AB      	ANDWF gbl_rcsta, W
010A  6FDE      	MOVWF CompTempVar2710, 1
010C  51DE      	MOVF CompTempVar2710, W, 1
010E  6FD8      	MOVWF FC_CAL_UAR_0006A_1_regcheck, 1

				if (regcheck != 0)
0110  53D8      	MOVF FC_CAL_UAR_0006A_1_regcheck, F, 1
0112  E003      	BZ	label12
011A            label12

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0114  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0116  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0118  D004      	BRA	label13
0122            label13

				{
					retVal = 0;
011A  6BD6      	CLRF FC_CAL_UAR_0006A_1_retVal, 1


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
011C  50AE      	MOVF gbl_rcreg, W
011E  11D6      	IORWF FC_CAL_UAR_0006A_1_retVal, W, 1
0120  6FD6      	MOVWF FC_CAL_UAR_0006A_1_retVal, 1

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0122  51D6      	MOVF FC_CAL_UAR_0006A_1_retVal, W, 1
0124  6FDE      	MOVWF CompTempVarRet2707, 1
0126  6BDF      	CLRF CompTempVarRet2707+D'1', 1

}
0128  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF96F009  	GOTO	_startup

0008  EFC0F009  	GOTO	interrupt
000C            delay_us_00000
000C            ; { delay_us ; function begin
000C            label1
000C  0000      	NOP
000E  0000      	NOP
0010  2FAD      	DECFSZ delay_us_00000_arg_del, F, 1
0012  D7FC      	BRA	label1
0014  0012      	RETURN
0016            ; } delay_us function end

0016            delay_ms_00000
0016            ; { delay_ms ; function begin
0016  5270      	MOVF delay_ms_00000_arg_del, F
0018  0000      	NOP
001A  E101      	BNZ	label2
001C  0012      	RETURN
001E            label2
001E  0EF5      	MOVLW 0xF5
0020            label3
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0000      	NOP
0040  0FFF      	ADDLW 0xFF
0042  A4D8      	BTFSS STATUS,Z
0044  D7ED      	BRA	label3
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  0000      	NOP
0058  0000      	NOP
005A  0000      	NOP
005C  0000      	NOP
005E  0000      	NOP
0060  2E70      	DECFSZ delay_ms_00000_arg_del, F
0062  D7DD      	BRA	label2
0064  0012      	RETURN
0066            ; } delay_ms function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6E70      	MOVWF delay_ms_00000_arg_del
006A  EC0BF000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6E70      	MOVWF delay_ms_00000_arg_del
0072  EC0BF000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6E70      	MOVWF delay_ms_00000_arg_del
007A  EC0BF000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6E70      	MOVWF delay_ms_00000_arg_del
0082  EC0BF000  	CALL delay_ms_00000
0086  2E5B      	DECFSZ delay_s_00000_arg_del, F
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end














01E0            __mul_32_3_00009
01E0            ; { __mul_32_32 ; function begin
01E0  6B86      	CLRF CompTempVarRet414, 1
01E2  6B87      	CLRF CompTempVarRet414+D'1', 1
01E4  6B88      	CLRF CompTempVarRet414+D'2', 1
01E6  6B89      	CLRF CompTempVarRet414+D'3', 1
01E8  6B88      	CLRF CompTempVarRet414+D'2', 1
01EA  6B89      	CLRF CompTempVarRet414+D'3', 1
01EC  507A      	MOVF __mul_32_3_00009_arg_a, W
01EE  0380      	MULWF __mul_32_3_00009_arg_b, 1
01F0  50F3      	MOVF gbl_prodl, W
01F2  6F86      	MOVWF CompTempVarRet414, 1
01F4  50F4      	MOVF gbl_prodh, W
01F6  6F87      	MOVWF CompTempVarRet414+D'1', 1
01F8  507B      	MOVF __mul_32_3_00009_arg_a+D'1', W
01FA  0380      	MULWF __mul_32_3_00009_arg_b, 1
01FC  50F3      	MOVF gbl_prodl, W
01FE  2787      	ADDWF CompTempVarRet414+D'1', F, 1
0200  50F4      	MOVF gbl_prodh, W
0202  2388      	ADDWFC CompTempVarRet414+D'2', F, 1
0204  B0D8      	BTFSC gbl_status,0
0206  2B89      	INCF CompTempVarRet414+D'3', F, 1
0208  507C      	MOVF __mul_32_3_00009_arg_a+D'2', W
020A  0380      	MULWF __mul_32_3_00009_arg_b, 1
020C  50F3      	MOVF gbl_prodl, W
020E  2788      	ADDWF CompTempVarRet414+D'2', F, 1
0210  50F4      	MOVF gbl_prodh, W
0212  2389      	ADDWFC CompTempVarRet414+D'3', F, 1
0214  507D      	MOVF __mul_32_3_00009_arg_a+D'3', W
0216  0380      	MULWF __mul_32_3_00009_arg_b, 1
0218  50F3      	MOVF gbl_prodl, W
021A  2789      	ADDWF CompTempVarRet414+D'3', F, 1
021C  507A      	MOVF __mul_32_3_00009_arg_a, W
021E  0381      	MULWF __mul_32_3_00009_arg_b+D'1', 1
0220  50F3      	MOVF gbl_prodl, W
0222  2787      	ADDWF CompTempVarRet414+D'1', F, 1
0224  50F4      	MOVF gbl_prodh, W
0226  2388      	ADDWFC CompTempVarRet414+D'2', F, 1
0228  B0D8      	BTFSC gbl_status,0
022A  2B89      	INCF CompTempVarRet414+D'3', F, 1
022C  507B      	MOVF __mul_32_3_00009_arg_a+D'1', W
022E  0381      	MULWF __mul_32_3_00009_arg_b+D'1', 1
0230  50F3      	MOVF gbl_prodl, W
0232  2788      	ADDWF CompTempVarRet414+D'2', F, 1
0234  50F4      	MOVF gbl_prodh, W
0236  2389      	ADDWFC CompTempVarRet414+D'3', F, 1
0238  507C      	MOVF __mul_32_3_00009_arg_a+D'2', W
023A  0381      	MULWF __mul_32_3_00009_arg_b+D'1', 1
023C  50F3      	MOVF gbl_prodl, W
023E  2789      	ADDWF CompTempVarRet414+D'3', F, 1
0240  507A      	MOVF __mul_32_3_00009_arg_a, W
0242  0382      	MULWF __mul_32_3_00009_arg_b+D'2', 1
0244  50F3      	MOVF gbl_prodl, W
0246  2788      	ADDWF CompTempVarRet414+D'2', F, 1
0248  50F4      	MOVF gbl_prodh, W
024A  2389      	ADDWFC CompTempVarRet414+D'3', F, 1
024C  507B      	MOVF __mul_32_3_00009_arg_a+D'1', W
024E  0382      	MULWF __mul_32_3_00009_arg_b+D'2', 1
0250  50F3      	MOVF gbl_prodl, W
0252  2789      	ADDWF CompTempVarRet414+D'3', F, 1
0254  507A      	MOVF __mul_32_3_00009_arg_a, W
0256  0383      	MULWF __mul_32_3_00009_arg_b+D'3', 1
0258  50F3      	MOVF gbl_prodl, W
025A  2789      	ADDWF CompTempVarRet414+D'3', F, 1
025C  0012      	RETURN
025E            ; } __mul_32_32 function end

025E            __div_32_3_00004
025E            ; { __div_32_32 ; function begin
025E  6B84      	CLRF __div_32_3_00004_1_r, 1
0260  6B85      	CLRF __div_32_3_00004_1_r+D'1', 1
0262  6B86      	CLRF __div_32_3_00004_1_r+D'2', 1
0264  6B87      	CLRF __div_32_3_00004_1_r+D'3', 1
0266  6B88      	CLRF CompTempVarRet172, 1
0268  6B89      	CLRF CompTempVarRet172+D'1', 1
026A  6B8A      	CLRF CompTempVarRet172+D'2', 1
026C  6B8B      	CLRF CompTempVarRet172+D'3', 1
026E  6A7E      	CLRF __div_32_3_00004_1_i
0270            label26
0270  0E20      	MOVLW 0x20
0272  147E      	ANDWF __div_32_3_00004_1_i, W
0274  6E7F      	MOVWF CompTempVar174
0276  667F      	TSTFSZ CompTempVar174
0278  0012      	RETURN
027A  90D8      	BCF STATUS,C
027C  3788      	RLCF CompTempVarRet172, F, 1
027E  3789      	RLCF CompTempVarRet172+D'1', F, 1
0280  378A      	RLCF CompTempVarRet172+D'2', F, 1
0282  378B      	RLCF CompTempVarRet172+D'3', F, 1
0284  367A      	RLCF __div_32_3_00004_arg_a, F
0286  367B      	RLCF __div_32_3_00004_arg_a+D'1', F
0288  367C      	RLCF __div_32_3_00004_arg_a+D'2', F
028A  367D      	RLCF __div_32_3_00004_arg_a+D'3', F
028C  3784      	RLCF __div_32_3_00004_1_r, F, 1
028E  3785      	RLCF __div_32_3_00004_1_r+D'1', F, 1
0290  3786      	RLCF __div_32_3_00004_1_r+D'2', F, 1
0292  3787      	RLCF __div_32_3_00004_1_r+D'3', F, 1
0294  5183      	MOVF __div_32_3_00004_arg_b+D'3', W, 1
0296  5D87      	SUBWF __div_32_3_00004_1_r+D'3', W, 1
0298  E108      	BNZ	label27
029A  5182      	MOVF __div_32_3_00004_arg_b+D'2', W, 1
029C  5D86      	SUBWF __div_32_3_00004_1_r+D'2', W, 1
029E  E105      	BNZ	label27
02A0  5181      	MOVF __div_32_3_00004_arg_b+D'1', W, 1
02A2  5D85      	SUBWF __div_32_3_00004_1_r+D'1', W, 1
02A4  E102      	BNZ	label27
02A6  5180      	MOVF __div_32_3_00004_arg_b, W, 1
02A8  5D84      	SUBWF __div_32_3_00004_1_r, W, 1
02AA            label27
02AA  E309      	BNC	label28
02AC  5180      	MOVF __div_32_3_00004_arg_b, W, 1
02AE  5F84      	SUBWF __div_32_3_00004_1_r, F, 1
02B0  5181      	MOVF __div_32_3_00004_arg_b+D'1', W, 1
02B2  5B85      	SUBWFB __div_32_3_00004_1_r+D'1', F, 1
02B4  5182      	MOVF __div_32_3_00004_arg_b+D'2', W, 1
02B6  5B86      	SUBWFB __div_32_3_00004_1_r+D'2', F, 1
02B8  5183      	MOVF __div_32_3_00004_arg_b+D'3', W, 1
02BA  5B87      	SUBWFB __div_32_3_00004_1_r+D'3', F, 1
02BC  8188      	BSF CompTempVarRet172,0, 1
02BE            label28
02BE  2A7E      	INCF __div_32_3_00004_1_i, F
02C0  D7D7      	BRA	label26
02C2            ; } __div_32_32 function end






















































































132C            _startup
132C  0ED5      	MOVLW 0xD5
132E  6E37      	MOVWF gbl_14_LSR
1330  0EC4      	MOVLW 0xC4
1332  6E38      	MOVWF gbl_14_LSR+D'1'
1334  0EBB      	MOVLW 0xBB
1336  6E39      	MOVWF gbl_14_LSR+D'2'
1338  0EDC      	MOVLW 0xDC
133A  6E3A      	MOVWF gbl_14_LSR+D'3'
133C  6A3B      	CLRF gbl_15_gbl_aSig
133E  6A3C      	CLRF gbl_15_gbl_aSig+D'1'
1340  6A3D      	CLRF gbl_15_gbl_aSig+D'2'
1342  6A3E      	CLRF gbl_15_gbl_aSig+D'3'
1344  6A3F      	CLRF gbl_15_gbl_bSig
1346  6A40      	CLRF gbl_15_gbl_bSig+D'1'
1348  6A41      	CLRF gbl_15_gbl_bSig+D'2'
134A  6A42      	CLRF gbl_15_gbl_bSig+D'3'
134C  6A43      	CLRF gbl_15_gbl_zSig
134E  6A44      	CLRF gbl_15_gbl_zSig+D'1'
1350  6A45      	CLRF gbl_15_gbl_zSig+D'2'
1352  6A46      	CLRF gbl_15_gbl_zSig+D'3'
1354  6A50      	CLRF gbl_15_gbl_aExp
1356  6A51      	CLRF gbl_15_gbl_bExp
1358  6A4B      	CLRF gbl_15_gbl_zExp
135A  6A4C      	CLRF gbl_15_gbl_zExp+D'1'
135C  6A52      	CLRF gbl_15_gbl_aSign
135E  6A53      	CLRF gbl_15_gbl_bSign
1360  6A54      	CLRF gbl_15_gbl_zSign
1362  6A55      	CLRF gbl_15_gbl_zSigZero
1364  6A47      	CLRF gbl_15_gbl_ret
1366  6A48      	CLRF gbl_15_gbl_ret+D'1'
1368  6A49      	CLRF gbl_15_gbl_ret+D'2'
136A  6A4A      	CLRF gbl_15_gbl_ret+D'3'
136C  6A4E      	CLRF gbl_float_rounding_mode
136E  6A4F      	CLRF gbl_float_exception_flags
1370  6A4D      	CLRF gbl_float_detect_tininess




137C  EF8EF009  	GOTO	main




300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  78FF      	DW 0x78FF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
