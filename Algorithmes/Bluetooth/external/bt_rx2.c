//************************************************************************************
//**  
//**  File name:     Z:\product information\PICmicro and E-blocks\EB024\EB024-00-2\Factory test routine\flowcode files\bt_rx2.c
//**  Generated by:  Flowcode v3.2.2.40
//**  Date:          Monday, October 01, 2007 15:58:02
//**  Licence:       Professional
//**  Registered to: Ben Rowland
//**  
//**  
//**  http://www.matrixmultimedia.com
//************************************************************************************


#define MX_PIC

//Defines for microcontroller
#define P16F877A
#define MX_EE
#define MX_EE_TYPE2
#define MX_EE_SIZE 256
#define MX_SPI
#define MX_SPI_C
#define MX_SPI_SDI 4
#define MX_SPI_SDO 5
#define MX_SPI_SCK 3
#define MX_UART
#define MX_UART_C
#define MX_UART_TX 6
#define MX_UART_RX 7
#define MX_I2C
#define MX_MI2C
#define MX_I2C_C
#define MX_I2C_SDA 4
#define MX_I2C_SCL 3
#define MX_PWM
#define MX_PWM_CNT 2
#define MX_PWM_TRIS1 trisc
#define MX_PWM_1 2
#define MX_PWM_TRIS2 trisc
#define MX_PWM_2 1

//Functions
#include <system.h>
#pragma CLOCK_FREQ 19660800

//Configuration data
#pragma DATA 0x2007, 0x3f3a

//Internal functions
#include "C:\Program Files\Matrix Multimedia\Flowcode V3\FCD\internals.h"

//Macro function declarations
void FCM_INTERRUPT_TMR0();
void FCM_INTERRUPT_RB0INT();
void FCM_INTERRUPT_PORTB();
void FCM_ESCAPE();


//Variable declarations
char FCV_ERR;
char FCV_LOOP;
char FCV_IN;
char FCV_CHAR;
char FCV_RET;




//LCDDisplay0: //Macro function declarations

void FCD_LCDDisplay0_GetDefines();
void FCD_LCDDisplay0_Start();
void FCD_LCDDisplay0_Clear();
void FCD_LCDDisplay0_PrintASCII(char Character);
void FCD_LCDDisplay0_Command(char in);
void FCD_LCDDisplay0_RawSend(char in, char mask);
void FCD_LCDDisplay0_Cursor(char x, char y);
void FCD_LCDDisplay0_PrintNumber(short Number);
void FCD_LCDDisplay0_PrintString(char* String, char MSZ_String);


//Bluetooth0: //Macro function declarations

void FCD_Bluetooth0_GetDefines();
void FCD_Bluetooth0_Initialize();
char FCD_Bluetooth0_CreateCommand(char ch);
char FCD_Bluetooth0_SendCommand(char bExpectEcho, char bSendCR);
char FCD_Bluetooth0_WaitForResponse(char response_code, char timeout);
char FCD_Bluetooth0_StringReceive();
char FCD_Bluetooth0_StringRead(char idx);
char FCD_Bluetooth0_SendScript(char idx);

//Supplementary defines


//Macro implementations

void FCM_INTERRUPT_TMR0()
{
	
}

void FCM_INTERRUPT_RB0INT()
{
	
}

void FCM_INTERRUPT_PORTB()
{
	
}

void FCM_ESCAPE()
{
	
	//Delay
	//Delay: 150 ms
	delay_ms(150);


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("^")
	FCV_RET = FCD_Bluetooth0_CreateCommand('^');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(0, 0)
	FCV_RET = FCD_Bluetooth0_SendCommand(0, 0);


	//Delay
	//Delay: 150 ms
	delay_ms(150);


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("^")
	FCV_RET = FCD_Bluetooth0_CreateCommand('^');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(0, 0)
	FCV_RET = FCD_Bluetooth0_SendCommand(0, 0);


	//Delay
	//Delay: 150 ms
	delay_ms(150);


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("^")
	FCV_RET = FCD_Bluetooth0_CreateCommand('^');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(0, 0)
	FCV_RET = FCD_Bluetooth0_SendCommand(0, 0);


	//Delay
	//Delay: 150 ms
	delay_ms(150);


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::WaitForResponse(1, 200)
	FCV_RET = FCD_Bluetooth0_WaitForResponse(1, 200);


}



//LCDDisplay0: //Macro implementations


void FCD_LCDDisplay0_GetDefines()
{
	
	}  //Dummy end of function to allow defines to be added correctly

	//component connections
	#define LCD_3212964_PORT    portb
	#define LCD_3212964_TRIS    trisb
	#define LCD_3212964_BIT0    0
	#define LCD_3212964_BIT1    1
	#define LCD_3212964_BIT2    2
	#define LCD_3212964_BIT3    3
	#define LCD_3212964_RS      4
	#define LCD_3212964_E       5

	#ifdef _BOOSTC
	  #define LCD_3212964_DELAY   delay_10us(10)
	#endif
	#ifdef _C2C_
	  #define LCD_3212964_DELAY   delay_us(100)
	#endif
	#ifndef LCD_3212964_DELAY
	  #define LCD_3212964_DELAY   delay_us(100)
	#endif



	//internal function prototypes
	void LCD_3212964_RawSend(char nIn, char nMask);

	//internal function implementations
	void LCD_3212964_RawSend(char nIn, char nMask)
	{
		unsigned char pt;
		unsigned char outVal;
		outVal = LCD_3212964_PORT;
		clear_bit(outVal, LCD_3212964_BIT0);
		clear_bit(outVal, LCD_3212964_BIT1);
		clear_bit(outVal, LCD_3212964_BIT2);
		clear_bit(outVal, LCD_3212964_BIT3);
		clear_bit(outVal, LCD_3212964_RS);
		clear_bit(outVal, LCD_3212964_E);
		pt = ((nIn >> 4) & 0x0f);
		if (pt & 0x01)
		    set_bit(outVal, LCD_3212964_BIT0);
		if (pt & 0x02)
		    set_bit(outVal, LCD_3212964_BIT1);
		if (pt & 0x04)
		    set_bit(outVal, LCD_3212964_BIT2);
		if (pt & 0x08)
		    set_bit(outVal, LCD_3212964_BIT3);
		if (nMask)
		    set_bit(outVal, LCD_3212964_RS);
		LCD_3212964_PORT = outVal;
		LCD_3212964_DELAY;
		set_bit (LCD_3212964_PORT, LCD_3212964_E);
		LCD_3212964_DELAY;
		clear_bit (LCD_3212964_PORT, LCD_3212964_E);
		pt = (nIn & 0x0f);
		LCD_3212964_DELAY;
		outVal = LCD_3212964_PORT;
		clear_bit(outVal, LCD_3212964_BIT0);
		clear_bit(outVal, LCD_3212964_BIT1);
		clear_bit(outVal, LCD_3212964_BIT2);
		clear_bit(outVal, LCD_3212964_BIT3);
		clear_bit(outVal, LCD_3212964_RS);
		clear_bit(outVal, LCD_3212964_E);
		if (pt & 0x01)
		    set_bit(outVal, LCD_3212964_BIT0);
		if (pt & 0x02)
		    set_bit(outVal, LCD_3212964_BIT1);
		if (pt & 0x04)
		    set_bit(outVal, LCD_3212964_BIT2);
		if (pt & 0x08)
		    set_bit(outVal, LCD_3212964_BIT3);
		if (nMask)
		    set_bit(outVal, LCD_3212964_RS);
		LCD_3212964_PORT = outVal;
		LCD_3212964_DELAY;
		set_bit (LCD_3212964_PORT, LCD_3212964_E);
		LCD_3212964_DELAY;
		clear_bit (LCD_3212964_PORT, LCD_3212964_E);
		LCD_3212964_DELAY;
	}

	// Dummy function to close the defines section off
	void LCD_3212964_Dummy_Function();
	void LCD_3212964_Dummy_Function()
	{

}

void FCD_LCDDisplay0_Start()
{
	
		clear_bit(LCD_3212964_TRIS, LCD_3212964_BIT0);
		clear_bit(LCD_3212964_TRIS, LCD_3212964_BIT1);
		clear_bit(LCD_3212964_TRIS, LCD_3212964_BIT2);
		clear_bit(LCD_3212964_TRIS, LCD_3212964_BIT3);
		clear_bit(LCD_3212964_TRIS, LCD_3212964_RS);
		clear_bit(LCD_3212964_TRIS, LCD_3212964_E);

		delay_ms(12);

		LCD_3212964_RawSend(0x33, 0);
		delay_ms(2);
		LCD_3212964_RawSend(0x32, 0);
		delay_ms(2);
		LCD_3212964_RawSend(0x2c, 0);
		delay_ms(2);
		LCD_3212964_RawSend(0x06, 0);
		delay_ms(2);
		LCD_3212964_RawSend(0x0c, 0);
		delay_ms(2);

		//clear the display
		LCD_3212964_RawSend(0x01, 0);
		delay_ms(2);
		LCD_3212964_RawSend(0x02, 0);
		delay_ms(2);

}

void FCD_LCDDisplay0_Clear()
{
	
		LCD_3212964_RawSend(0x01, 0);
		delay_ms(2);
		LCD_3212964_RawSend(0x02, 0);
		delay_ms(2);

}

void FCD_LCDDisplay0_PrintASCII(char Character)
{
	
		LCD_3212964_RawSend(Character, 0x10);

}

void FCD_LCDDisplay0_Command(char in)
{
	
		LCD_3212964_RawSend(in, 0);
		delay_ms(2);

}

void FCD_LCDDisplay0_RawSend(char in, char mask)
{
	//Error Reading Code For LCD Display::Macro_RawSend
}

void FCD_LCDDisplay0_Cursor(char x, char y)
{
	
	  #if (2 == 1)
	    y=0x80;
	  #endif

	  #if (2 == 2)
		if (y==0)
			y=0x80;
		else
			y=0xc0;
	  #endif

	  #if (2 == 4)
		if (y==0)
			y=0x80;
		else if (y==1)
			y=0xc0;
		else if (y==2)
			y=0x94;
		else
			y=0xd4;
	  #endif

		LCD_3212964_RawSend(y+x, 0);
		delay_ms(2);

}

void FCD_LCDDisplay0_PrintNumber(short Number)
{
	
		short tmp_int;
		char tmp_byte;
		if (Number < 0)
		{
			LCD_3212964_RawSend('-', 0x10);
			Number = 0 - Number;
		}

		tmp_int = Number;
		if (Number >= 10000)
		{
			tmp_byte = tmp_int / 10000;
			LCD_3212964_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10000;
				tmp_byte--;
			}
		}
		if (Number >= 1000)
		{
			tmp_byte = tmp_int / 1000;
			LCD_3212964_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 1000;
				tmp_byte--;
			}
		}
		if (Number >= 100)
		{
			tmp_byte = tmp_int / 100;
			LCD_3212964_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 100;
				tmp_byte--;
			}
		}
		if (Number >= 10)
		{
			tmp_byte = tmp_int / 10;
			LCD_3212964_RawSend('0' + tmp_byte, 0x10);

			while (tmp_byte > 0)
			{
				tmp_int = tmp_int - 10;
				tmp_byte--;
			}
		}
		LCD_3212964_RawSend('0' + tmp_int, 0x10);

}

void FCD_LCDDisplay0_PrintString(char* String, char MSZ_String)
{
	
		char idx;
		for (idx=0; idx<MSZ_String; idx++)
		{
			if (String[idx]==0)
			{
				break;
			}
			LCD_3212964_RawSend(String[idx], 0x10);
		}

}



//Bluetooth0: //Macro implementations


void FCD_Bluetooth0_GetDefines()
{
	
	}  //Dummy end of function to allow defines to be added correctly

	////////////////////////////////////////////////////
	// MX_DEFINES
	////////////////////////////////////////////////////
	#if (1 == 1)
	  #define BLU_232_HARDWARE   1
	#endif

	#define BLU_232_RTS          5
	#define BLU_232_CTS          4
	#define BLU232_BAUD          31
	//Real baud = 9600
	//Error = 0%
	#define BLU_SCRIPT_COUNT     4

	#if (4 >= 1)
	  const char* BLU_SCRIPT_1 = "\r";
	#endif
	#if (4 >= 2)
	  const char* BLU_SCRIPT_2 = "\r";
	#endif
	#if (4 >= 3)
	  const char* BLU_SCRIPT_3 = "\r";
	#endif
	#if (4 >= 4)
	  const char* BLU_SCRIPT_4 = "\r";
	#endif


	//This section details the static defines, prototypes
	//and functions.

	//#define MX_DEBUG_BLU

	#ifdef MX_UART_B
	  #define MX_UART_PORT portb
	  #define MX_UART_TRIS trisb
	#endif
	#ifdef MX_UART_C
	  #define MX_UART_PORT portc
	  #define MX_UART_TRIS trisc
	#endif

	//examples of PIC baud rate settings
	//
	// BAUD = OSC / [64 * (X+1)]
	//
	// so for BLU232_BAUD=31, BAUD = 19660800 / [64 * 32] = 9600
	//
	// rearranging gives X = [OSC / (64*BAUD)] - 1
	//
	// from which we can compile the following table (for 19.6608MHz crystals):
	//
	//  BAUD     |  BLU232_BAUD
	// ----------+--------------
	//      1200 |    255
	//      2400 |    127
	//      4800 |     63
	//      9600 |     31
	//     19200 |     15
	//     28800 |    n/a
	//     38400 |      7
	//     57600 |    n/a
	//    115200 |    n/a
	//
	// BUT REMEMBER: the blu2i module is set to communicate at
	// 9600 BAUD by default, so we will (probably) only be able
	// to access it at this BAUD rate - at least initially.
	// Therefore, we probably shouldn't allow users to change
	// the actual BAUD rate. Although they will be able to use
	// other crystals, so the BAUD rate setting should be
	// calculated by their selected crystal setting.

	#define BLU_STRING_ARRAY_SIZE 32
	//see "at info.txt" for discussion about the string array
	//size and why we have settled on 32.
	#define BLU_STRING_RESPONSE_SIZE 14

	#define BLU_RESPONSE_OK           1
	#define BLU_RESPONSE_ERROR        2
	#define BLU_RESPONSE_CONNECT      3
	#define BLU_RESPONSE_NOCARRIER    4
	#define BLU_RESPONSE_AUDIO        5
	#define BLU_RESPONSE_PAIR         6
	#define BLU_RESPONSE_RING         7

	#define BLU_CHAR_CR              13
	#define BLU_CHAR_LF              10

	#define RS_STATUS_OK              0
	#define RS_STATUS_TIMEOUT         1
	#define RS_STATUS_LOOP            2
	#define RS_STATUS_FERR            3
	#define RS_STATUS_OERR            4

	//Timeout within the <Blu_Read_BLU232_Byte> function
	#define BLU_READ_DELAY           44

	//Timeout within the <BT_Send_Command> function
	#define BLU_SENDCMD_TIMEOUT     100

	//Timeout within the <BT_Wait_For_Response> function
	#define BLU_RESPONSE_TIMEOUT     50

	//Timeout within the <BT_String_Receive> function
	#define BLU_STRINGRX_TIMEOUT     10

	//Timeout within the <BT_Send_Script> function
	#define BLU_SENDSCRIPT_TIMEOUT   10

	//common globals
	char BLU_STRING_ARRAY_TXPTR;
	char BLU_STRING_ARRAY_RXPTR;
	char BLU_STRING_ARRAY[BLU_STRING_ARRAY_SIZE];
	char BLU_RESPONSE_ARRAY[BLU_STRING_RESPONSE_SIZE];

	char BLU_TXIF_MASK;
	char BLU_RCIF_MASK;
	char BLU_RX_STATUS;

	char BLU232_TIMEOUT;


	//prototypes
	char Blu_MaskFromBit(char mybit);
	void Blu_Send_BLU232_Byte(char byte);
	char Blu_Read_BLU232_Byte(char timeout);

	//implementations
	char Blu_MaskFromBit(char mybit)
	{
	    char retVal = 0;
	    switch (mybit)
	    {
	        case 0:
	            retVal = 0x01;
	            break;

	        case 1:
	            retVal = 0x02;
	            break;

	        case 2:
	            retVal = 0x04;
	            break;

	        case 3:
	            retVal = 0x08;
	            break;

	        case 4:
	            retVal = 0x10;
	            break;

	        case 5:
	            retVal = 0x20;
	            break;

	        case 6:
	            retVal = 0x40;
	            break;

	        case 7:
	            retVal = 0x80;
	            break;
	    }
	    return (retVal);
	}


	void Blu_Send_BLU232_Byte(char byte)
	{
	    char bNotReady;

	  #ifndef MX_UART
	    #pragma error "The target microcontroller does not have a UART"
	  #endif

	    BLU232_TIMEOUT = 100;
	    bNotReady = ((pir1 & BLU_TXIF_MASK) == 0);
	    while (bNotReady)
	    {
	        bNotReady = ((pir1 & BLU_TXIF_MASK) == 0);
	        BLU232_TIMEOUT--;
	        if (BLU232_TIMEOUT == 0)
	        {
	            return;
	        }
	    }


	  #ifdef BLU_232_HARDWARE
	    //wait until CTS is high
	    BLU232_TIMEOUT = 100;
	    bNotReady = ((MX_UART_PORT & (1 << BLU_232_CTS)) != 0);
	    while (bNotReady)
	    {
	        bNotReady = ((MX_UART_PORT & (1 << BLU_232_CTS)) != 0);
	        BLU232_TIMEOUT--;
	        if (BLU232_TIMEOUT == 0)
	        {
	            return;
	        }
	    }
	  #endif

	    txreg = byte;

	}


	char Blu_Read_BLU232_Byte(char timeout)
	{
	    //NOTE: this function should timeout after <timeout x 100> microseconds
	    char reg_mask;
	    char delay1 = BLU_READ_DELAY;
	    //char delay2 = 0;
	    char dummy = 0;
	    char retVal = 255;
	    char bWaitForever = 0;

	  #ifndef MX_UART
	    #pragma error "The target microcontroller does not have a UART"
	  #endif

	    BLU_RX_STATUS = RS_STATUS_LOOP;

	  #ifdef BLU_232_HARDWARE
	    clear_bit(MX_UART_PORT, BLU_232_RTS);        //ready to accept data
	  #endif

	    if (timeout == 0xFF)
	    {
	        bWaitForever = 1;
	    }

	    while (BLU_RX_STATUS == RS_STATUS_LOOP)
	    {

	        if ((pir1 & BLU_RCIF_MASK) != 0)
	        {
	            //received a byte
	            BLU_RX_STATUS = RS_STATUS_OK;

	        } else {
	            if (bWaitForever == 0)
	            {
	                //don't wait forever, so do timeout thing...
	                if (timeout == 0)
	                {
	                    BLU_RX_STATUS = RS_STATUS_TIMEOUT;
	                    retVal = 255;

	                } else {
	                    //decrement timeout
	                    delay1--;
	                    if (delay1 == 0)
	                    {
	                        //delay2--;
	                        //if (delay2 == 0)
	                        //{
	                            timeout--;
	                        //}
	                        delay1 = BLU_READ_DELAY;
	                    }
	                }
	            }
	        }
	    }

	    if (BLU_RX_STATUS == RS_STATUS_OK)
	    {
	        reg_mask = Blu_MaskFromBit(FERR);
	        if ((rcsta & reg_mask) != 0)
	        {
	            retVal = rcreg;                        //need to read the rcreg to clear FERR
	            BLU_RX_STATUS = RS_STATUS_FERR;

	            #ifdef MX_DEBUG_BLU
	                FCD_LCDDisplay0_PrintASCII('f');
	                FCD_LCDDisplay0_PrintNumber(retVal);
	            #endif

	            //need to reset CREN
	            clear_bit(rcsta, CREN);
	            set_bit(rcsta, CREN);

	        } else {
	            reg_mask = Blu_MaskFromBit(OERR);
	            if ((rcsta & reg_mask) != 0)
	            {
	                BLU_RX_STATUS = RS_STATUS_OERR;

	                retVal = rcreg;

	                #ifdef MX_DEBUG_BLU
	                  FCD_LCDDisplay0_PrintASCII('o');
	                  FCD_LCDDisplay0_PrintNumber(retVal);
	                #endif

	                //need to reset CREN
	                clear_bit(rcsta, CREN);
	                set_bit(rcsta, CREN);

	            } else {
	                retVal = rcreg; //no error, so rx byte is valid

	              #ifdef BLU232_ECHO
	                Blu_Send_BLU232_Byte(retVal);
	              #endif
	            }
	        }
	    }

	  #ifdef BLU_232_HARDWARE
	    set_bit(MX_UART_PORT, BLU_232_RTS);        //not ready to accept data
	  #endif

	    return (retVal);
	}



	// Dummy function to close the defines section off
	void CUSTOM_Dummy_Function();
	void CUSTOM_Dummy_Function()
	{

}

void FCD_Bluetooth0_Initialize()
{
	    BLU_STRING_ARRAY_TXPTR = 0;
	    BLU_STRING_ARRAY_RXPTR = 0;

	    #ifndef MX_UART
	        #pragma error "The target microcontroller does not have a UART"
	    #endif

	    #ifdef BLU_232_HARDWARE
	        #if(BLU_232_RTS == MX_UART_TX)
	              asm error "RTS is set to TX pin"
	        #endif
	        #if(BLU_232_CTS == MX_UART_TX)
	              asm error "CTS is set to TX pin"
	        #endif
	        #if(BLU_232_RTS == MX_UART_RX)
	              asm error "RTS is set to RX pin"
	        #endif
	        #if(BLU_232_CTS == MX_UART_RX)
	              asm error "CTS is set to RX pin"
	        #endif
	    #endif

	    //set UART initial states
	    MX_UART_TRIS = 0xFF;
	    //set_bit(MX_UART_TRIS, MX_UART_RX);
	    clear_bit(MX_UART_TRIS, MX_UART_TX);

	    #ifdef BLU_232_HARDWARE
	    //set_bit(MX_UART_TRIS, BLU_232_CTS);        //CTS is an input
	    clear_bit(MX_UART_TRIS, BLU_232_RTS);        //RTS is an output
	    set_bit(MX_UART_PORT, BLU_232_RTS);          //not ready to accept data
	    #endif

	    txsta = 0;                // 8-bit, async, low speed, off
	    spbrg = BLU232_BAUD;      // set the baud rate
	    rcsta = 0;                // 8-bit, disabled
	    set_bit(rcsta, SPEN);     // turn on serial interface
	    set_bit(txsta, TXEN);
	    set_bit(rcsta, CREN);

	    BLU_TXIF_MASK = Blu_MaskFromBit(TXIF);
	    BLU_RCIF_MASK = Blu_MaskFromBit(RCIF);
}

char FCD_Bluetooth0_CreateCommand(char ch)
{
	    if (BLU_STRING_ARRAY_TXPTR < BLU_STRING_ARRAY_SIZE)
	    {
	        BLU_STRING_ARRAY[BLU_STRING_ARRAY_TXPTR] = ch;
	        BLU_STRING_ARRAY_TXPTR++;
	        return(1);
	    }
	    else
	    {
	        return(0);
	    }
}

char FCD_Bluetooth0_SendCommand(char bExpectEcho, char bSendCR)
{
	    char idx = 0;
	    char dummy;
	    if (BLU_STRING_ARRAY_TXPTR > 0)
	    {
	        while (idx < BLU_STRING_ARRAY_TXPTR)
	        {
	            Blu_Send_BLU232_Byte(BLU_STRING_ARRAY[idx]);
	            //delay_ms(1);

	            if (bExpectEcho != 0)
	            {
	                //read echoed character
	                dummy = Blu_Read_BLU232_Byte(BLU_SENDCMD_TIMEOUT);  //10ms timeout???
	            }

	            idx++;
	            //delay_ms(2);
	        }

	        if (bSendCR != 0)
	        {
	            Blu_Send_BLU232_Byte(0x0D);            //send the terminating CR
	            //delay_ms(1);

	            if (bExpectEcho != 0)
	            {
	                //read echoed character
	                dummy = Blu_Read_BLU232_Byte(BLU_SENDCMD_TIMEOUT);  //10ms timeout???
	            }
	        }

	        BLU_STRING_ARRAY_TXPTR = 0;
	        return (1);
	    }
	    else
	    {
	        return (0);
	    }
}

char FCD_Bluetooth0_WaitForResponse(char response_code, char timeout)
{
	    //returns zero for OK
	    //returns 0xFF for timeout or an illegal response code
	    //returns the number of characters received if an unexpected response is received
	    char resp_size = 0;
	    char ch;
	    char rx_ptr;
	    char crlf_flags = 0;
	    char unexpected = 0;
	    //responses always start with a <cr><lf> combination
	    BLU_RESPONSE_ARRAY[resp_size++] = BLU_CHAR_CR;
	    BLU_RESPONSE_ARRAY[resp_size++] = BLU_CHAR_LF;

	    switch (response_code)
	    {
	        case BLU_RESPONSE_OK:
	            BLU_RESPONSE_ARRAY[resp_size++] = 'O';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'K';
	            BLU_RESPONSE_ARRAY[resp_size++] = BLU_CHAR_CR;
	            BLU_RESPONSE_ARRAY[resp_size++] = BLU_CHAR_LF;
	            break;

	        case BLU_RESPONSE_ERROR:
	            BLU_RESPONSE_ARRAY[resp_size++] = 'E';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'R';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'R';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'O';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'R';
	            BLU_RESPONSE_ARRAY[resp_size++] = ' ';
	            break;

	        case BLU_RESPONSE_CONNECT:
	            BLU_RESPONSE_ARRAY[resp_size++] = 'C';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'O';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'N';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'N';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'E';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'C';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'T';
	            BLU_RESPONSE_ARRAY[resp_size++] = ' ';
	            break;

	        case BLU_RESPONSE_NOCARRIER:
	            BLU_RESPONSE_ARRAY[resp_size++] = 'N';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'O';
	            BLU_RESPONSE_ARRAY[resp_size++] = ' ';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'C';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'A';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'R';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'R';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'I';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'E';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'R';
	            BLU_RESPONSE_ARRAY[resp_size++] = BLU_CHAR_CR;
	            BLU_RESPONSE_ARRAY[resp_size++] = BLU_CHAR_LF;
	            break;

	        case BLU_RESPONSE_AUDIO:
	            BLU_RESPONSE_ARRAY[resp_size++] = 'A';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'U';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'D';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'I';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'O';
	            BLU_RESPONSE_ARRAY[resp_size++] = ' ';
	            break;

	        case BLU_RESPONSE_PAIR:
	            BLU_RESPONSE_ARRAY[resp_size++] = 'P';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'A';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'I';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'R';
	            BLU_RESPONSE_ARRAY[resp_size++] = ' ';
	            break;

	        case BLU_RESPONSE_RING:
	            BLU_RESPONSE_ARRAY[resp_size++] = 'R';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'I';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'N';
	            BLU_RESPONSE_ARRAY[resp_size++] = 'G';
	            BLU_RESPONSE_ARRAY[resp_size++] = ' ';
	            break;

	        default:
	            //unknown response - error
	            return (0xFF);
	    }
	    BLU_STRING_ARRAY_RXPTR = 0;
	    rx_ptr = 0;
	    while (crlf_flags < 0x03)
	    {
	        ch = Blu_Read_BLU232_Byte(BLU_RESPONSE_TIMEOUT);

	        //if there was a timeout, we need to carry on checking...
	        while (BLU_RX_STATUS != RS_STATUS_OK)
	        {
	            timeout--;
	            if (timeout == 0)
	            {
	                return (0xFF);
	            }

	            //TODO: may need a delay here to extend the complete timeout value
	            //delay_ms(1);
	            ch = Blu_Read_BLU232_Byte(BLU_RESPONSE_TIMEOUT);        //this should take 1ms
	        }
	        if (ch == 0x0D)
	        {
	            crlf_flags = crlf_flags | 0x01;

	        }
	        else if (ch == 0x0A)
	        {
	            crlf_flags = crlf_flags | 0x02;

	        }
	        else
	        {
	            BLU_STRING_ARRAY[BLU_STRING_ARRAY_RXPTR] = ch;
	            BLU_STRING_ARRAY_RXPTR++;
	            if (BLU_STRING_ARRAY_RXPTR >= BLU_STRING_ARRAY_SIZE)
	            {
	                //max buffer size has been reached
	                return (BLU_STRING_ARRAY_RXPTR);
	            }
	        }
	        //we have now received a legitimate character
	        //reset the clrf flags and check for expected input
	        //(if not previously received unexpected chars)
	        if (unexpected == 0)
	        {
	            crlf_flags = 0;

	            //is it expected?
	            if (ch != BLU_RESPONSE_ARRAY[rx_ptr])
	            {
	                unexpected = 1;
	            }
	            //increment the pointer
	            rx_ptr++;
	        }
	        //have we finished looking for the "expected" string
	        if ((unexpected == 0) && (rx_ptr == resp_size))
	        {
	            //yes - so return zero
	            return (0);
	        }
	    }
	    //if we get here, we have received an unexpected response
	    return (BLU_STRING_ARRAY_RXPTR);
}

char FCD_Bluetooth0_StringReceive()
{
	    //returns the number of characters received
	    char ch;
	    char crlf_flags = 0;         //when a cr and lf have been received, this will be > 3
	    char timeout = 0;

	    BLU_STRING_ARRAY_RXPTR = 0;
	    BLU_RX_STATUS = RS_STATUS_OK;

	    while (crlf_flags <= 0x02)
	    {
	        ch = Blu_Read_BLU232_Byte(BLU_STRINGRX_TIMEOUT);

	        if (BLU_RX_STATUS == RS_STATUS_OK)
	        {
	            if (ch == 0x0D)
	            {
	                crlf_flags = crlf_flags | 0x01;
	            }
	            else if (ch == 0x0A)
	            {
	                crlf_flags = crlf_flags | 0x02;
	            }
	            else
	            {
	                //not a CR or LF
	                BLU_STRING_ARRAY[BLU_STRING_ARRAY_RXPTR] = ch;
	                BLU_STRING_ARRAY_RXPTR++;
	                //reset the timeout
	                timeout = 0;
	                if (BLU_STRING_ARRAY_RXPTR >= BLU_STRING_ARRAY_SIZE)
	                {
	                    //max buffer size has been reached
	                    crlf_flags = 0xFF;
	                }
	            }
	        }
	        else
	        {
	            timeout++;
	            if (timeout > 1)
	            {
	                //no further bytes have been received
	                crlf_flags = 0xFF;
	            }
	        }
	    }
	    return (BLU_STRING_ARRAY_RXPTR);
}

char FCD_Bluetooth0_StringRead(char idx)
{
	    if (idx < BLU_STRING_ARRAY_RXPTR)
	    {
	        return (BLU_STRING_ARRAY[idx]);
	    }
	    else
	    {
	        return (0);
	    }
}

char FCD_Bluetooth0_SendScript(char idx)
{
	    char i = 0;
	    char ch = 255;

	    if ((idx < 1) || (idx > BLU_SCRIPT_COUNT))
	    {
	        return (0xFF);        //error - index out of range
	    }
	    while (ch > 0)
	    {
	        switch (idx)
	        {
	          #ifdef BLU_SCRIPT_COUNT1
	            case 1:
	                ch = BLU_SCRIPT_1[i];
	                break;
	          #endif

	          #ifdef BLU_SCRIPT_COUNT2
	            case 2:
	                ch = BLU_SCRIPT_2[i];
	                break;
	          #endif

	          #ifdef BLU_SCRIPT_COUNT3
	            case 3:
	                ch = BLU_SCRIPT_3[i];
	                break;
	          #endif

	          #ifdef BLU_SCRIPT_COUNT4
	            case 4:
	                ch = BLU_SCRIPT_4[i];
	                break;
	          #endif

	            default:
	                return (0xFF);    //should not get here
	        }
	        if (ch > 0)
	        {
	            #ifdef MX_DEBUG_BLU
	                //FCD_LCDDisplay0_PrintASCII(ch);
	            #endif

	            //send the character
	            Blu_Send_BLU232_Byte(ch);

	            //read the echo
	            Blu_Read_BLU232_Byte(BLU_SENDSCRIPT_TIMEOUT);

	            //if we sent a CR, wait for the response
	            if (ch == 13)
	            {
	                //wait until we are receiving no more chars
	                BLU_RX_STATUS = RS_STATUS_OK;
	                while (BLU_RX_STATUS == RS_STATUS_OK)
	                {
	                    ch = Blu_Read_BLU232_Byte(BLU_SENDSCRIPT_TIMEOUT);
	                    #ifdef MX_DEBUG_BLU
	                        //FCD_LCDDisplay0_PrintASCII('.');
	                    #endif
	                }
	            }
	        }
	        i++;
	    }
	    return (0);
}

//Supplementary implementations


void main()
{
	
	//Initialisation
	adcon1 = 0x07;


	//Interrupt initialisation code
	option_reg = 0xC0;


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::Start
	FCD_LCDDisplay0_Start();


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII("rx.")
	FCD_LCDDisplay0_PrintASCII('r');
	FCD_LCDDisplay0_PrintASCII('x');
	FCD_LCDDisplay0_PrintASCII('.');


	//Call Macro
	//Call Component Macro: Bluetooth(0)::Initialize
	FCD_Bluetooth0_Initialize();


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII("done.")
	FCD_LCDDisplay0_PrintASCII('d');
	FCD_LCDDisplay0_PrintASCII('o');
	FCD_LCDDisplay0_PrintASCII('n');
	FCD_LCDDisplay0_PrintASCII('e');
	FCD_LCDDisplay0_PrintASCII('.');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::StringReceive
	FCV_RET = FCD_Bluetooth0_StringReceive();


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::StringReceive
	FCV_RET = FCD_Bluetooth0_StringReceive();


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::StringReceive
	FCV_RET = FCD_Bluetooth0_StringReceive();


	//Delay
	//Delay: 1 s
	delay_s(1);


	//Calculation
	//Calculation:
	//  ERR = 0
	FCV_ERR =  0 ;
	

	//Call Macro
	//Call Component Macro: LCDDisplay(0)::Clear
	FCD_LCDDisplay0_Clear();


	//Comment:
	//Firmware reset
	//AT&F*


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("AT&f*")
	FCV_RET = FCD_Bluetooth0_CreateCommand('A');
	FCV_RET = FCD_Bluetooth0_CreateCommand('T');
	FCV_RET = FCD_Bluetooth0_CreateCommand('&');
	FCV_RET = FCD_Bluetooth0_CreateCommand('f');
	FCV_RET = FCD_Bluetooth0_CreateCommand('*');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(1, 1)
	FCV_RET = FCD_Bluetooth0_SendCommand(1, 1);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII('.')
	FCD_LCDDisplay0_PrintASCII('.');


	//Delay
	//Delay: 1 s
	delay_s(1);


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::WaitForResponse(1, 100)
	FCV_RET = FCD_Bluetooth0_WaitForResponse(1, 100);


	//Decision
	//Decision: RET <> 0?
	if( FCV_RET != 0 )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Comment:
	//Reset the device
	//ATZ


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("ATZ")
	FCV_RET = FCD_Bluetooth0_CreateCommand('A');
	FCV_RET = FCD_Bluetooth0_CreateCommand('T');
	FCV_RET = FCD_Bluetooth0_CreateCommand('Z');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(1, 1)
	FCV_RET = FCD_Bluetooth0_SendCommand(1, 1);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII('.')
	FCD_LCDDisplay0_PrintASCII('.');


	//Delay
	//Delay: 1 s
	delay_s(1);


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::WaitForResponse(1, 10)
	FCV_RET = FCD_Bluetooth0_WaitForResponse(1, 10);


	//Decision
	//Decision: RET <> 0?
	if( FCV_RET != 0 )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Comment:
	//Set the passkey
	//AT+BTK="1234"


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("AT+BTK=")
	FCV_RET = FCD_Bluetooth0_CreateCommand('A');
	FCV_RET = FCD_Bluetooth0_CreateCommand('T');
	FCV_RET = FCD_Bluetooth0_CreateCommand('+');
	FCV_RET = FCD_Bluetooth0_CreateCommand('B');
	FCV_RET = FCD_Bluetooth0_CreateCommand('T');
	FCV_RET = FCD_Bluetooth0_CreateCommand('K');
	FCV_RET = FCD_Bluetooth0_CreateCommand('=');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand(34)
	FCV_RET = FCD_Bluetooth0_CreateCommand(34);


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("1234")
	FCV_RET = FCD_Bluetooth0_CreateCommand('1');
	FCV_RET = FCD_Bluetooth0_CreateCommand('2');
	FCV_RET = FCD_Bluetooth0_CreateCommand('3');
	FCV_RET = FCD_Bluetooth0_CreateCommand('4');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand(34)
	FCV_RET = FCD_Bluetooth0_CreateCommand(34);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII('.')
	FCD_LCDDisplay0_PrintASCII('.');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(1, 1)
	FCV_RET = FCD_Bluetooth0_SendCommand(1, 1);


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::WaitForResponse(1, 10)
	FCV_RET = FCD_Bluetooth0_WaitForResponse(1, 10);


	//Decision
	//Decision: RET <> 0?
	if( FCV_RET != 0 )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Comment:
	//Pair with the tester board
	//AT+BTW00809894BA05


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("AT+BTW008098E44961")
	FCV_RET = FCD_Bluetooth0_CreateCommand('A');
	FCV_RET = FCD_Bluetooth0_CreateCommand('T');
	FCV_RET = FCD_Bluetooth0_CreateCommand('+');
	FCV_RET = FCD_Bluetooth0_CreateCommand('B');
	FCV_RET = FCD_Bluetooth0_CreateCommand('T');
	FCV_RET = FCD_Bluetooth0_CreateCommand('W');
	FCV_RET = FCD_Bluetooth0_CreateCommand('0');
	FCV_RET = FCD_Bluetooth0_CreateCommand('0');
	FCV_RET = FCD_Bluetooth0_CreateCommand('8');
	FCV_RET = FCD_Bluetooth0_CreateCommand('0');
	FCV_RET = FCD_Bluetooth0_CreateCommand('9');
	FCV_RET = FCD_Bluetooth0_CreateCommand('8');
	FCV_RET = FCD_Bluetooth0_CreateCommand('E');
	FCV_RET = FCD_Bluetooth0_CreateCommand('4');
	FCV_RET = FCD_Bluetooth0_CreateCommand('4');
	FCV_RET = FCD_Bluetooth0_CreateCommand('9');
	FCV_RET = FCD_Bluetooth0_CreateCommand('6');
	FCV_RET = FCD_Bluetooth0_CreateCommand('1');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(1, 1)
	FCV_RET = FCD_Bluetooth0_SendCommand(1, 1);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII('.')
	FCD_LCDDisplay0_PrintASCII('.');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::WaitForResponse(1, 10)
	FCV_RET = FCD_Bluetooth0_WaitForResponse(1, 10);


	//Decision
	//Decision: RET <> 0?
	if( FCV_RET != 0 )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Comment:
	//Wait until the "PAIR" notification comes through


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Delay
	//Delay: 4 s
	delay_s(4);


	//Connection Point
	//Connection Point: D
FCC_Main_D:


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::WaitForResponse(6, 250)
	FCV_RET = FCD_Bluetooth0_WaitForResponse(6, 250);


	//Decision
	//Decision: RET <> 0?
	if( FCV_RET != 0 )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Comment:
	//Next character should be a zero...
	//Make sure something else was received


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::StringReceive
	FCV_RET = FCD_Bluetooth0_StringReceive();


	//Decision
	//Decision: RET = 0?
	if( FCV_RET == 0 )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Comment:
	//Make sure it was a zero


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Call Macro
	//Call Component Macro: CHAR=Bluetooth(0)::StringRead(0)
	FCV_CHAR = FCD_Bluetooth0_StringRead(0);


	//Decision
	//Decision: CHAR <> '0'?
	if( FCV_CHAR != '0' )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Comment:
	//Receive string to flush the buffer


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::StringReceive
	FCV_RET = FCD_Bluetooth0_StringReceive();


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::StringReceive
	FCV_RET = FCD_Bluetooth0_StringReceive();


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::StringReceive
	FCV_RET = FCD_Bluetooth0_StringReceive();


	//Comment:
	//Connect to the test board
	//ATD00809894BA05


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("ATD008098E44961")
	FCV_RET = FCD_Bluetooth0_CreateCommand('A');
	FCV_RET = FCD_Bluetooth0_CreateCommand('T');
	FCV_RET = FCD_Bluetooth0_CreateCommand('D');
	FCV_RET = FCD_Bluetooth0_CreateCommand('0');
	FCV_RET = FCD_Bluetooth0_CreateCommand('0');
	FCV_RET = FCD_Bluetooth0_CreateCommand('8');
	FCV_RET = FCD_Bluetooth0_CreateCommand('0');
	FCV_RET = FCD_Bluetooth0_CreateCommand('9');
	FCV_RET = FCD_Bluetooth0_CreateCommand('8');
	FCV_RET = FCD_Bluetooth0_CreateCommand('E');
	FCV_RET = FCD_Bluetooth0_CreateCommand('4');
	FCV_RET = FCD_Bluetooth0_CreateCommand('4');
	FCV_RET = FCD_Bluetooth0_CreateCommand('9');
	FCV_RET = FCD_Bluetooth0_CreateCommand('6');
	FCV_RET = FCD_Bluetooth0_CreateCommand('1');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(1, 1)
	FCV_RET = FCD_Bluetooth0_SendCommand(1, 1);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII('.')
	FCD_LCDDisplay0_PrintASCII('.');


	//Comment:
	//Wait until the "CONNECT" notification comes through


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Delay
	//Delay: 1 s
	delay_s(1);


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::WaitForResponse(3, 100)
	FCV_RET = FCD_Bluetooth0_WaitForResponse(3, 100);


	//Decision
	//Decision: RET <> 0?
	if( FCV_RET != 0 )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII("connected")
	FCD_LCDDisplay0_PrintASCII('c');
	FCD_LCDDisplay0_PrintASCII('o');
	FCD_LCDDisplay0_PrintASCII('n');
	FCD_LCDDisplay0_PrintASCII('n');
	FCD_LCDDisplay0_PrintASCII('e');
	FCD_LCDDisplay0_PrintASCII('c');
	FCD_LCDDisplay0_PrintASCII('t');
	FCD_LCDDisplay0_PrintASCII('e');
	FCD_LCDDisplay0_PrintASCII('d');


	//Delay
	//Delay: 2 s
	delay_s(2);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::Clear
	FCD_LCDDisplay0_Clear();


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII("sending...")
	FCD_LCDDisplay0_PrintASCII('s');
	FCD_LCDDisplay0_PrintASCII('e');
	FCD_LCDDisplay0_PrintASCII('n');
	FCD_LCDDisplay0_PrintASCII('d');
	FCD_LCDDisplay0_PrintASCII('i');
	FCD_LCDDisplay0_PrintASCII('n');
	FCD_LCDDisplay0_PrintASCII('g');
	FCD_LCDDisplay0_PrintASCII('.');
	FCD_LCDDisplay0_PrintASCII('.');
	FCD_LCDDisplay0_PrintASCII('.');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("*Unit passed*")
	FCV_RET = FCD_Bluetooth0_CreateCommand('*');
	FCV_RET = FCD_Bluetooth0_CreateCommand('U');
	FCV_RET = FCD_Bluetooth0_CreateCommand('n');
	FCV_RET = FCD_Bluetooth0_CreateCommand('i');
	FCV_RET = FCD_Bluetooth0_CreateCommand('t');
	FCV_RET = FCD_Bluetooth0_CreateCommand(' ');
	FCV_RET = FCD_Bluetooth0_CreateCommand('p');
	FCV_RET = FCD_Bluetooth0_CreateCommand('a');
	FCV_RET = FCD_Bluetooth0_CreateCommand('s');
	FCV_RET = FCD_Bluetooth0_CreateCommand('s');
	FCV_RET = FCD_Bluetooth0_CreateCommand('e');
	FCV_RET = FCD_Bluetooth0_CreateCommand('d');
	FCV_RET = FCD_Bluetooth0_CreateCommand('*');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(0, 0)
	FCV_RET = FCD_Bluetooth0_SendCommand(0, 0);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::Cursor(0, 1)
	FCD_LCDDisplay0_Cursor(0, 1);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII("press A0")
	FCD_LCDDisplay0_PrintASCII('p');
	FCD_LCDDisplay0_PrintASCII('r');
	FCD_LCDDisplay0_PrintASCII('e');
	FCD_LCDDisplay0_PrintASCII('s');
	FCD_LCDDisplay0_PrintASCII('s');
	FCD_LCDDisplay0_PrintASCII(' ');
	FCD_LCDDisplay0_PrintASCII('A');
	FCD_LCDDisplay0_PrintASCII('0');


	//Connection Point
	//Connection Point: B
FCC_Main_B:


	//Input
	//Input: PORT A -> IN
	trisa = trisa | 0xff;
	FCV_IN = porta;


	//Decision
	//Decision: IN <> 1?
	if( FCV_IN != 1 )
	{
		//Goto Connection Point
		//Goto Connection Point: B
		goto FCC_Main_B;


	}


	//Comment:
	//Receive string to flush the buffer


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::StringReceive
	FCV_RET = FCD_Bluetooth0_StringReceive();


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::StringReceive
	FCV_RET = FCD_Bluetooth0_StringReceive();


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::StringReceive
	FCV_RET = FCD_Bluetooth0_StringReceive();


	//Comment:
	//Break into data mode


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Call Macro
	//Call Component Macro: LCDDisplay(0)::Start
	FCD_LCDDisplay0_Start();


	//Call Macro
	//Call Macro: ESCAPE
	FCM_ESCAPE();


	//Decision
	//Decision: RET <> 0?
	if( FCV_RET != 0 )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Comment:
	//Disconnect


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("ATH")
	FCV_RET = FCD_Bluetooth0_CreateCommand('A');
	FCV_RET = FCD_Bluetooth0_CreateCommand('T');
	FCV_RET = FCD_Bluetooth0_CreateCommand('H');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(1, 1)
	FCV_RET = FCD_Bluetooth0_SendCommand(1, 1);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII('.')
	FCD_LCDDisplay0_PrintASCII('.');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::WaitForResponse(4, 10)
	FCV_RET = FCD_Bluetooth0_WaitForResponse(4, 10);


	//Decision
	//Decision: RET <> 0?
	if( FCV_RET != 0 )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Comment:
	//Factory reset the board


	//Calculation
	//Calculation:
	//  ERR = ERR + 1
	FCV_ERR =  FCV_ERR + 1 ;
	

	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::CreateCommand("AT&f*")
	FCV_RET = FCD_Bluetooth0_CreateCommand('A');
	FCV_RET = FCD_Bluetooth0_CreateCommand('T');
	FCV_RET = FCD_Bluetooth0_CreateCommand('&');
	FCV_RET = FCD_Bluetooth0_CreateCommand('f');
	FCV_RET = FCD_Bluetooth0_CreateCommand('*');


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::SendCommand(1, 1)
	FCV_RET = FCD_Bluetooth0_SendCommand(1, 1);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII('.')
	FCD_LCDDisplay0_PrintASCII('.');


	//Delay
	//Delay: 100 ms
	delay_ms(100);


	//Call Macro
	//Call Component Macro: RET=Bluetooth(0)::WaitForResponse(1, 100)
	FCV_RET = FCD_Bluetooth0_WaitForResponse(1, 100);


	//Decision
	//Decision: RET <> 0?
	if( FCV_RET != 0 )
	{
		//Goto Connection Point
		//Goto Connection Point: A
		goto FCC_Main_A;


	}


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::Clear
	FCD_LCDDisplay0_Clear();


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII("*** DONE ***")
	FCD_LCDDisplay0_PrintASCII('*');
	FCD_LCDDisplay0_PrintASCII('*');
	FCD_LCDDisplay0_PrintASCII('*');
	FCD_LCDDisplay0_PrintASCII(' ');
	FCD_LCDDisplay0_PrintASCII('D');
	FCD_LCDDisplay0_PrintASCII('O');
	FCD_LCDDisplay0_PrintASCII('N');
	FCD_LCDDisplay0_PrintASCII('E');
	FCD_LCDDisplay0_PrintASCII(' ');
	FCD_LCDDisplay0_PrintASCII('*');
	FCD_LCDDisplay0_PrintASCII('*');
	FCD_LCDDisplay0_PrintASCII('*');


	//Connection Point
	//Connection Point: C
FCC_Main_C:


	//Goto Connection Point
	//Goto Connection Point: C
	goto FCC_Main_C;


	//Connection Point
	//Connection Point: A
FCC_Main_A:


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII("error")
	FCD_LCDDisplay0_PrintASCII('e');
	FCD_LCDDisplay0_PrintASCII('r');
	FCD_LCDDisplay0_PrintASCII('r');
	FCD_LCDDisplay0_PrintASCII('o');
	FCD_LCDDisplay0_PrintASCII('r');


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintASCII(" ")
	FCD_LCDDisplay0_PrintASCII(' ');


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::PrintNumber(ERR)
	FCD_LCDDisplay0_PrintNumber(FCV_ERR);


	//Call Macro
	//Call Component Macro: LCDDisplay(0)::Cursor(0, 1)
	FCD_LCDDisplay0_Cursor(0, 1);


	//Decision
	//Decision: RET = 255?
	if( FCV_RET == 255 )
	{
		//Call Macro
		//Call Component Macro: LCDDisplay(0)::PrintASCII("t/o")
		FCD_LCDDisplay0_PrintASCII('t');
		FCD_LCDDisplay0_PrintASCII('/');
		FCD_LCDDisplay0_PrintASCII('o');


	} else {
		//Calculation
		//Calculation:
		//  LOOP = 0
		FCV_LOOP =  0 ;
		

		//Loop
		//Loop: While LOOP < RET
		while( FCV_LOOP < FCV_RET )
		{
			//Call Macro
			//Call Component Macro: CHAR=Bluetooth(0)::StringRead(LOOP)
			FCV_CHAR = FCD_Bluetooth0_StringRead(FCV_LOOP);


			//Call Macro
			//Call Component Macro: LCDDisplay(0)::PrintASCII(CHAR)
			FCD_LCDDisplay0_PrintASCII(FCV_CHAR);


			//Calculation
			//Calculation:
			//  LOOP = LOOP + 1
			FCV_LOOP =  FCV_LOOP + 1 ;
			

		}


	}


	mainendloop: goto mainendloop;
}

void interrupt(void)
{
}



