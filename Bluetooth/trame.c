//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BOYER\PROJET\Bluetooth\trame.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Tuesday, April 04, 2017 12:20:38
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0xFB
#endif
#ifdef HI_TECH_C
__CONFIG(0xFB);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
//ICD functionality
#define USE_FLOWCODE_ICD2
#define ICD_CLK_PORT 1
#define ICD_DATA_PORT 1
#define ICD_CLK_PIN 6
#define ICD_DATA_PIN 7
#define ICD_NUM_BPS 8
signed int brk_pnt[ICD_NUM_BPS] = {-1, -1, -1, -1, -1, -1, -1, -1};
#define ICD_STACK_SIZE 8
unsigned char icd_stack[ICD_STACK_SIZE] = {0, 0, 0, 0, 0, 0, 0, 0};
#define ICD_ID0 0x19
#define ICD_ID1 0xbc
#define ICD_ID2 0xf2
#define ICD_ID3 0xb7
#define ICD_ID4 0x51
#define ICD_ID5 0x14
#define ICD_ID6 0x22
#define ICD_ID7 0xe5



/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_DATA = (0x36);


/*========================================================================*\
   Use :InjectorBase1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 portb
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 portb
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisb
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisb
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (4)
#define MX_UART_INT_1 (1)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :Bluetooth2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_0c851_Bluetooth2__STRING_ARRAY 40
#define FCV_0c851_Bluetooth2__BT_CHAR_CR (13)
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__STRING_ARRAY[FCVsz_0c851_Bluetooth2__STRING_ARRAY];
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_IDX = (0x0);
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_DONE = (0x0);
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_LENGTH = (0x0);

MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY);
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT);
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX);
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR);
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES);
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings();
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA);
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE);
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive();
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings();
MX_UINT8 FCD_0c851_Bluetooth2__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :InjectorBase1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :Bluetooth2
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the 4 digit Bluetooth pair key based on a string of numbers.
       :e.g. "1234"
       :Returns 0 to indicate success
       :
       :Param??tres pour la macro SetPairKey :
       :  PairKey[5] : Key to use as the Pair key, e.g. "1234" or "0000"
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY)
{
	//Définitions des variables locales
	#define FCLsz_COMMANDSTR 20
	MX_CHAR FCL_COMMANDSTR[FCLsz_COMMANDSTR];
	MX_UINT8 FCR_RETVAL;


	FCI_SHEAD("AT+BTK=\"",9, FCL_PAIRKEY,FCLsz_PAIRKEY, FCL_COMMANDSTR,20);
	FCI_SHEAD(FCL_COMMANDSTR,FCLsz_COMMANDSTR, "\"",2, FCL_COMMANDSTR,20);

	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand(FCL_COMMANDSTR, FCLsz_COMMANDSTR, 1);

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_COMMANDSTR
}

/*=----------------------------------------------------------------------=*\
   Use :Receives a single data byte from the Bluetooth module.
       :0xFF signifies no data available.
       :
       :Param??tres pour la macro ReceiveByte :
       :  Timeout : Amount of time to wait in milliseconds 0=Wait forever
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	FCV_0c851_Bluetooth2__RX_DONE = 0;

FCC_ReceiveByte_A:
;

	if (FCV_0c851_Bluetooth2__RX_IDX < FCV_0c851_Bluetooth2__RX_LENGTH)
	{

		FCR_RETVAL = FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_IDX];

		FCV_0c851_Bluetooth2__RX_IDX = FCV_0c851_Bluetooth2__RX_IDX + 1;

	} else {

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 40)
		{

			if ((FCL_TIMEOUT == 0) || (FCL_COUNT < FCL_TIMEOUT))
			{

				FCI_DELAYBYTE_MS(1);

				FCL_COUNT = FCL_COUNT + 1;

				goto FCC_ReceiveByte_A;

			// } else {

			}

		// } else {

		}

		FCV_0c851_Bluetooth2__RX_IDX = 0;
		FCV_0c851_Bluetooth2__RX_LENGTH = 0;

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Send an AT command script.
       :Returns 0 for fail, 1 for success and 255 for unrecognised script idx.
       :
       :Param??tres pour la macro SendScript :
       :  idx : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX)
{
	//Définitions des variables locales
	MX_UINT8 FCL_I = (0x0);
	MX_UINT8 FCL_CH = (0xff);
	#define FCLsz_SCRIPT_STR 40
	MX_CHAR FCL_SCRIPT_STR[FCLsz_SCRIPT_STR];
	MX_UINT8 FCL_LEN = (0x0);
	MX_UINT8 FCR_RETVAL;


	if ((FCL_IDX < 1) || (FCL_IDX > 1))
	{

		FCR_RETVAL = 255;

		goto FCC_SendScript_A;

	// } else {

	}

	switch (FCL_IDX)
	{
		case 1:
		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		case 2:
		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		case 3:
		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		case 4:
		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		default:
		{
			FCR_RETVAL = 255;

			goto FCC_SendScript_A;

		}
	}

	while (1)
	{

		if ((FCL_CH > 0) == 0) break;
		FCL_CH = FCL_SCRIPT_STR[FCL_I];

		if ((FCL_CH > 0) && (FCL_CH != 0x0A))
		{

			FC_CAL_UART_Send_1(FCL_CH);

			FCL_LEN = FCL_LEN + 1;

			if (FCL_CH == FCV_0c851_Bluetooth2__BT_CHAR_CR)
			{

				#if (1) // 1 == 1

					FCD_0c851_Bluetooth2__StringReceive();

				// #else

				//Le code a été optimisé par le préprocesseur
				#endif

				FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();

				FCL_LEN = 0;

			// } else {

			}

		// } else {

		}

		FCL_I = FCL_I + 1;


	}

	if (FCL_LEN > 0)
	{

		FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);

		#if (1) // 1 == 1

			FCD_0c851_Bluetooth2__StringReceive();

		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();

	// } else {

	}

FCC_SendScript_A:
;

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_SCRIPT_STR
}

/*=----------------------------------------------------------------------=*\
   Use :Sends a command string to the GSM module.
       :0 = Command sent ok, 255 = No Reply
       :
       :Param??tres pour la macro SendCommand :
       :  Command[20] : MX_CHAR (by-ref)
       :  SendCR : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_LEN;
	MX_UINT8 FCR_RETVAL;


	while (1)
	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();


		if ((FCR_RETVAL) == 0) break;
	}

	FCL_LEN = FCI_GETLENGTH(FCL_COMMAND, FCLsz_COMMAND);

	if (FCL_LEN)
	{

		while (1)
		{

			if ((FCL_IDX < FCL_LEN) == 0) break;
			FC_CAL_UART_Send_1(FCL_COMMAND[FCL_IDX]);

			FCL_IDX = FCL_IDX + 1;


		}

		if (FCL_SENDCR)
		{

			FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);

		// } else {

		}

	// } else {

	}

	#if (1) // 1 == 1

		FCD_0c851_Bluetooth2__StringReceive();

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();

	if (FCR_RETVAL == 0)
	{

		FCR_RETVAL = 255;

	} else {

		FCR_RETVAL = 0;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies the incoming data from the data string array to a local string variable.
       :
       :Param??tres pour la macro ReadString :
       :  NumBytes : MX_UINT8
       :
       :Renvoie : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);


	while (1)
	{

		if (((FCL_IDX < FCL_NUMBYTES) && (FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX] > 0)) == 0) break;
		FCR_RETVAL[FCL_IDX] = FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX];
		FCL_IDX = FCL_IDX + 1;


	}

	if (FCL_IDX < FCL_NUMBYTES)
	{

		FCR_RETVAL[FCL_IDX] = 0;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Saves the current settings to firmware using the AT&W command followed by the ATZ command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&W", 5, 1);

	if (FCR_RETVAL == 0)
	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATZ", 4, 1);

	// } else {

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sends a single data byte out to the Bluetooth module.
       :
       :Param??tres pour la macro SendByte :
       :  Data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA)
{

	FC_CAL_UART_Send_1(FCL_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the bluetooth mode to be discoverable and or connectable.
       :Returns 0 for success.
       :
       :Param??tres pour la macro SetMode :
       :  Discoverable : 0 = Not Discoverable, 1 = Discoverable
       :  Connectable : 0 = Not Connectable, 1 = Connectable
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	if (FCL_DISCOVERABLE)
	{

		if (FCL_CONNECTABLE)
		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=4", 9, 1);

		} else {

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 1);

		}

	} else {

		if (FCL_CONNECTABLE)
		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 3);

		} else {

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=0", 9, 1);

		}

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to receive a string from the GSM modem terminated with a 0x10 CR character. Used to collect the replies from commands.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive()
{
	//Définitions des variables locales
	MX_UINT8 FCL_TOUT = (0x0);
	MX_UINT8 FCL_LEN = (0x0);
	MX_UINT8 FCR_RETVAL;


	FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
	FCV_0c851_Bluetooth2__RX_DONE = 0;
	FCV_0c851_Bluetooth2__RX_LENGTH = 0;
	FCV_0c851_Bluetooth2__RX_IDX = 0;

	while (1)
	{

		if (((FCV_0c851_Bluetooth2__RX_DONE == 0) && (FCL_TOUT < 255)) == 0) break;
		FCL_TOUT = FCL_TOUT + 1;

		if (FCL_LEN != FCV_0c851_Bluetooth2__RX_LENGTH)
		{

			FCL_TOUT = 0;
			FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;

		// } else {

		}

		FCI_DELAYINT_US(500);


	}

	if (FCL_TOUT == 255)
	{

		FCV_0c851_Bluetooth2__RX_DONE = 0;
		FCV_0c851_Bluetooth2__RX_LENGTH = 0;
		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 1;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Restores the factory settings to firmware using the AT&F* command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&F*", 6, 1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets up the GSM module.
       :Returns 0 for OK, 255 for no reply and 254 for command fail.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__Initialise()
{
	//Définitions des variables locales
	#define FCLsz_CMDSTR 20
	MX_CHAR FCL_CMDSTR[FCLsz_CMDSTR];
	MX_UINT8 FCR_RETVAL;


	FCP_SET(B, C, 0x2, 0x1, 0);

	FCI_DELAYBYTE_MS(100);

	FCP_SET(B, C, 0x2, 0x1, 1);

	FCR_RETVAL = 0;

	FC_CAL_UART_Init_1();

	FCI_DELAYBYTE_MS(10);

	FCD_0c851_Bluetooth2__StringReceive();

	#if (1)

		FCD_0c851_Bluetooth2__RestoreFactorySettings();

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCI_SHEAD("AT+BTN=\"",9, "FlowBlue",9, FCL_CMDSTR,20);
	FCI_SHEAD(FCL_CMDSTR,FCLsz_CMDSTR, "\"",2, FCL_CMDSTR,20);

	FCD_0c851_Bluetooth2__SendCommand(FCL_CMDSTR, FCLsz_CMDSTR, 1);

	FCD_0c851_Bluetooth2__SetPairKey("1234", 5);

	FCD_0c851_Bluetooth2__SetMode(1, 1);

	FCR_RETVAL = FCD_0c851_Bluetooth2__SaveSettings();

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_CMDSTR
}


/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/


/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()
{
adcon1 = 0x0F;




	//Enable initial stop condition
	dbg_mode = 0x08;

	ICD_PUSH(0);


	FC_MARKER(1);

	FC_MARKER(2);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::Initialise()
	FCD_0c851_Bluetooth2__Initialise();

	FC_MARKER(6);

	// Boucle
	// Boucle: While 1
	while (1)
	{

		FC_MARKER(6);

		if ((1) == 0) break;
		FC_MARKER(4);

		// Appel de la Routine Composant
		// Appel de la Routine Composant: Bluetooth2::SendByte(42)
		FCD_0c851_Bluetooth2__SendByte(42);

		FC_MARKER(5);

		// Calcul
		// Calcul:
		//  data = data + 1
		FCV_DATA = FCV_DATA + 1;

		FC_MARKER(3);


	}

	FC_MARKER(7);

	ICD_POP();

	//Code to signal end of program to ICD
	dbg_mode = 0x08;

	FC_MARKER(-1);


	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

	MX_UART_INT_CH1_FUNC

	MX_UINT8 FCL_BT_IN;

	FCL_BT_IN = MX_UART_INT_CH1_DET;

	if (FCL_BT_IN)
	{

	FCL_BT_IN = FC_CAL_UART_Receive_1(1);

	if (FCV_0c851_Bluetooth2__RX_DONE == 0)
	{

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 40)
		{

			if (FCL_BT_IN == 0x0A)
			{

				FCV_0c851_Bluetooth2__RX_DONE = 1;
				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = 0;

			} else {

				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = FCL_BT_IN;
				FCV_0c851_Bluetooth2__RX_LENGTH = FCV_0c851_Bluetooth2__RX_LENGTH + 1;

			}

		// } else {

		}

	// } else {

	}

	MX_UART_INT_CH1_CLR;

	}

	MX_UART_INT_FUNC_END
}




