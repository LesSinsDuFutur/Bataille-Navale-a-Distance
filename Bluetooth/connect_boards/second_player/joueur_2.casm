;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

// Delay by bytes
#define FCI_DELAYBYTE_S(count)     delay_s((count))
#define FCI_DELAYBYTE_MS(count)    delay_ms((count))
#define FCI_DELAYBYTE_US(count)    delay_us((count))
// With watchdog timer
#define FCI_DELAYBYTEWDT_S(count)  Wdt_Delay_S((count))
#define FCI_DELAYBYTEWDT_MS(count) Wdt_Delay_Ms((count))
#define FCI_DELAYBYTEWDT_US(count) delay_us((count))

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)
{
    char i;
    for (i=0; i<delay; i++)
    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
        delay_ms(1);
    }
}


void FCI_DELAYINT_US(MX_UINT16 Delay)

{
  	while (Delay > 255)
012A            label14
012A  0EFF      	MOVLW 0xFF
012C  65C3      	CPFSGT FCI_DELAYI_00038_arg_Delay, 1
012E  67C4      	TSTFSZ FCI_DELAYI_00038_arg_Delay+D'1', 1
0130  D001      	BRA	label15
0132  D00C      	BRA	label16
0134            label15
014A  D7EF      	BRA	label14
014C            label16

  	{
	  	delay_us(255);
0134  69C5      	SETF delay_us_00000_arg_del, 1
0136  EC06F000  	CALL delay_us_00000

	  	Delay = Delay - 255;
013A  0EFF      	MOVLW 0xFF
013C  5DC3      	SUBWF FCI_DELAYI_00038_arg_Delay, W, 1
013E  6FC5      	MOVWF CompTempVar1836, 1
0140  59C3      	SUBWFB FCI_DELAYI_00038_arg_Delay, W, 1
0142  08FF      	SUBLW 0xFF
0144  5FC4      	SUBWF FCI_DELAYI_00038_arg_Delay+D'1', F, 1
0146  51C5      	MOVF CompTempVar1836, W, 1
0148  6FC3      	MOVWF FCI_DELAYI_00038_arg_Delay, 1

  	}
  	if (Delay > 0)
014C  0E00      	MOVLW 0x00
014E  65C3      	CPFSGT FCI_DELAYI_00038_arg_Delay, 1
0150  67C4      	TSTFSZ FCI_DELAYI_00038_arg_Delay+D'1', 1
0152  D001      	BRA	label17
0156            label17

  		delay_us(Delay & 0xFF);
0156  51C3      	MOVF FCI_DELAYI_00038_arg_Delay, W, 1
0158  6FC5      	MOVWF delay_us_00000_arg_del, 1
015A  EC06F000  	CALL delay_us_00000

}
0154  0012      	RETURN
015E  0012      	RETURN


void FCI_DELAYINT_MS(MX_UINT16 Delay)

{
  	while (Delay > 255)
0D14            label128
0D14  0EFF      	MOVLW 0xFF
0D16  6586      	CPFSGT FCI_DELAYI_00039_arg_Delay, 1
0D18  6787      	TSTFSZ FCI_DELAYI_00039_arg_Delay+D'1', 1
0D1A  D001      	BRA	label129
0D1C  D00C      	BRA	label130
0D1E            label129
0D34  D7EF      	BRA	label128
0D36            label130

  	{
	  	delay_ms(255);
0D1E  699A      	SETF delay_ms_00000_arg_del, 1
0D20  EC0BF000  	CALL delay_ms_00000

	  	Delay = Delay - 255;
0D24  0EFF      	MOVLW 0xFF
0D26  5D86      	SUBWF FCI_DELAYI_00039_arg_Delay, W, 1
0D28  6F88      	MOVWF CompTempVar1838, 1
0D2A  5986      	SUBWFB FCI_DELAYI_00039_arg_Delay, W, 1
0D2C  08FF      	SUBLW 0xFF
0D2E  5F87      	SUBWF FCI_DELAYI_00039_arg_Delay+D'1', F, 1
0D30  5188      	MOVF CompTempVar1838, W, 1
0D32  6F86      	MOVWF FCI_DELAYI_00039_arg_Delay, 1

  	}
  	if (Delay > 0)
0D36  0E00      	MOVLW 0x00
0D38  6586      	CPFSGT FCI_DELAYI_00039_arg_Delay, 1
0D3A  6787      	TSTFSZ FCI_DELAYI_00039_arg_Delay+D'1', 1
0D3C  D001      	BRA	label131
0D40            label131

  		delay_ms(Delay & 0xFF);
0D40  5186      	MOVF FCI_DELAYI_00039_arg_Delay, W, 1
0D42  6F9A      	MOVWF delay_ms_00000_arg_del, 1
0D44  EC0BF000  	CALL delay_ms_00000

}
0D3E  0012      	RETURN
0D48  0012      	RETURN


void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
0170  6BC3      	CLRF FCI_GETLEN_0003E_1_tmp, 1
0172            label19
0172  51C2      	MOVF FCI_GETLEN_0003E_arg_iStr1_len, W, 1
0174  61C3      	CPFSLT FCI_GETLEN_0003E_1_tmp, 1
0176  D009      	BRA	label20
0178  51C1      	MOVF FCI_GETLEN_0003E_arg_sStr1+D'1', W, 1
017A  6EEA      	MOVWF FSR0H
017C  51C0      	MOVF FCI_GETLEN_0003E_arg_sStr1, W, 1
017E  25C3      	ADDWF FCI_GETLEN_0003E_1_tmp, W, 1
0180  6EE9      	MOVWF FSR0L
0182  52EF      	MOVF INDF0, F
0184  E002      	BZ	label20
0186  2BC3      	INCF FCI_GETLEN_0003E_1_tmp, F, 1
0188  D7F4      	BRA	label19
018A            label20

	return (tmp);
018A  51C3      	MOVF FCI_GETLEN_0003E_1_tmp, W, 1
018C  6FC4      	MOVWF CompTempVarRet1850, 1

}
018E  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)

{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;
07E2  5192      	MOVF FCI_TOSTRI_00042_arg_iSrc1, W, 1
07E4  6F9A      	MOVWF FCI_TOSTRI_00042_1_iSrc, 1
07E6  5193      	MOVF FCI_TOSTRI_00042_arg_iSrc1+D'1', W, 1
07E8  6F9B      	MOVWF FCI_TOSTRI_00042_1_iSrc+D'1', 1
07EA  5194      	MOVF FCI_TOSTRI_00042_arg_iSrc1+D'2', W, 1
07EC  6F9C      	MOVWF FCI_TOSTRI_00042_1_iSrc+D'2', 1
07EE  5195      	MOVF FCI_TOSTRI_00042_arg_iSrc1+D'3', W, 1
07F0  6F9D      	MOVWF FCI_TOSTRI_00042_1_iSrc+D'3', 1


	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
07F2  6B9E      	CLRF FCI_TOSTRI_00042_1_top, 1
07F4  0ECA      	MOVLW 0xCA
07F6  6F9F      	MOVWF FCI_TOSTRI_00042_1_top+D'1', 1
07F8  0E9A      	MOVLW 0x9A
07FA  6FA0      	MOVWF FCI_TOSTRI_00042_1_top+D'2', 1
07FC  0E3B      	MOVLW 0x3B
07FE  6FA1      	MOVWF FCI_TOSTRI_00042_1_top+D'3', 1

	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;
0800  6BA2      	CLRF FCI_TOSTRI_00042_1_idx, 1


	if (iDst_len == 0) return sDst;
0802  5398      	MOVF FCI_TOSTRI_00042_arg_iDst_len, F, 1
0804  E105      	BNZ	label102
0806  5196      	MOVF FCI_TOSTRI_00042_arg_sDst, W, 1
0808  6FA3      	MOVWF CompTempVarRet1863, 1
080A  5197      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W, 1
080C  6FA4      	MOVWF CompTempVarRet1863+D'1', 1
0810            label102


	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
0810  AF9D      	BTFSS FCI_TOSTRI_00042_1_iSrc+D'3',7, 1
0812  D014      	BRA	label103

	{
		sDst[0] = '-';
0814  5197      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W, 1
0816  6EEA      	MOVWF FSR0H
0818  5196      	MOVF FCI_TOSTRI_00042_arg_sDst, W, 1
081A  6EE9      	MOVWF FSR0L
081C  6BA5      	CLRF CompTempVar1865, 1
081E  51A5      	MOVF CompTempVar1865, W, 1
0820  26E9      	ADDWF FSR0L, F
0822  0E2D      	MOVLW 0x2D
0824  6EEF      	MOVWF INDF0

		idx++;
0826  2BA2      	INCF FCI_TOSTRI_00042_1_idx, F, 1

		iSrc = -iSrc;
0828  1F9A      	COMF FCI_TOSTRI_00042_1_iSrc, F, 1
082A  1F9B      	COMF FCI_TOSTRI_00042_1_iSrc+D'1', F, 1
082C  1F9C      	COMF FCI_TOSTRI_00042_1_iSrc+D'2', F, 1
082E  1F9D      	COMF FCI_TOSTRI_00042_1_iSrc+D'3', F, 1
0830  3F9A      	INCFSZ FCI_TOSTRI_00042_1_iSrc, F, 1
0832  D004      	BRA	label103
0834  3F9B      	INCFSZ FCI_TOSTRI_00042_1_iSrc+D'1', F, 1
0836  D002      	BRA	label103
0838  4B9C      	INFSNZ FCI_TOSTRI_00042_1_iSrc+D'2', F, 1
083A  2B9D      	INCF FCI_TOSTRI_00042_1_iSrc+D'3', F, 1
083C            label103

	}

	tmp1 = 0;    // Nothing added yet
083C  6B99      	CLRF FCI_TOSTRI_00042_1_tmp1, 1

	if (iSrc == 0) // Force showing zero
083E  519A      	MOVF FCI_TOSTRI_00042_1_iSrc, W, 1
0840  119B      	IORWF FCI_TOSTRI_00042_1_iSrc+D'1', W, 1
0842  119C      	IORWF FCI_TOSTRI_00042_1_iSrc+D'2', W, 1
0844  119D      	IORWF FCI_TOSTRI_00042_1_iSrc+D'3', W, 1
0846  0BFF      	ANDLW 0xFF
0848  E106      	BNZ	label104
0856            label104

	{
		tmp1 = 1;
084A  0E01      	MOVLW 0x01
084C  6F99      	MOVWF FCI_TOSTRI_00042_1_tmp1, 1

		top = 1;
084E  6F9E      	MOVWF FCI_TOSTRI_00042_1_top, 1
0850  6B9F      	CLRF FCI_TOSTRI_00042_1_top+D'1', 1
0852  6BA0      	CLRF FCI_TOSTRI_00042_1_top+D'2', 1
0854  6BA1      	CLRF FCI_TOSTRI_00042_1_top+D'3', 1

	}
	while (( idx < iDst_len) && (top > 0))
0856  5198      	MOVF FCI_TOSTRI_00042_arg_iDst_len, W, 1
0858  61A2      	CPFSLT FCI_TOSTRI_00042_1_idx, 1
085A  D072      	BRA	label109
085C  51A1      	MOVF FCI_TOSTRI_00042_1_top+D'3', W, 1
085E  0800      	SUBLW 0x00
0860  E108      	BNZ	label105
0862  51A0      	MOVF FCI_TOSTRI_00042_1_top+D'2', W, 1
0864  0800      	SUBLW 0x00
0866  E105      	BNZ	label105
0868  519F      	MOVF FCI_TOSTRI_00042_1_top+D'1', W, 1
086A  0800      	SUBLW 0x00
086C  E102      	BNZ	label105
086E  519E      	MOVF FCI_TOSTRI_00042_1_top, W, 1
0870  0800      	SUBLW 0x00
0872            label105
0872  E266      	BC	label109
093E  D78B      	BRA	label104
0940            label109

	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
0874  51A1      	MOVF FCI_TOSTRI_00042_1_top+D'3', W, 1
0876  5D9D      	SUBWF FCI_TOSTRI_00042_1_iSrc+D'3', W, 1
0878  E108      	BNZ	label106
087A  51A0      	MOVF FCI_TOSTRI_00042_1_top+D'2', W, 1
087C  5D9C      	SUBWF FCI_TOSTRI_00042_1_iSrc+D'2', W, 1
087E  E105      	BNZ	label106
0880  519F      	MOVF FCI_TOSTRI_00042_1_top+D'1', W, 1
0882  5D9B      	SUBWF FCI_TOSTRI_00042_1_iSrc+D'1', W, 1
0884  E102      	BNZ	label106
0886  519E      	MOVF FCI_TOSTRI_00042_1_top, W, 1
0888  5D9A      	SUBWF FCI_TOSTRI_00042_1_iSrc, W, 1
088A            label106
088A  E202      	BC	label107
088C  5399      	MOVF FCI_TOSTRI_00042_1_tmp1, F, 1
088E  E040      	BZ	label108
0890            label107
0910            label108

		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
0890  519A      	MOVF FCI_TOSTRI_00042_1_iSrc, W, 1
0892  6FA5      	MOVWF __div_32_3_00004_arg_a, 1
0894  519B      	MOVF FCI_TOSTRI_00042_1_iSrc+D'1', W, 1
0896  6FA6      	MOVWF __div_32_3_00004_arg_a+D'1', 1
0898  519C      	MOVF FCI_TOSTRI_00042_1_iSrc+D'2', W, 1
089A  6FA7      	MOVWF __div_32_3_00004_arg_a+D'2', 1
089C  519D      	MOVF FCI_TOSTRI_00042_1_iSrc+D'3', W, 1
089E  6FA8      	MOVWF __div_32_3_00004_arg_a+D'3', 1
08A0  519E      	MOVF FCI_TOSTRI_00042_1_top, W, 1
08A2  6FA9      	MOVWF __div_32_3_00004_arg_b, 1
08A4  519F      	MOVF FCI_TOSTRI_00042_1_top+D'1', W, 1
08A6  6FAA      	MOVWF __div_32_3_00004_arg_b+D'1', 1
08A8  51A0      	MOVF FCI_TOSTRI_00042_1_top+D'2', W, 1
08AA  6FAB      	MOVWF __div_32_3_00004_arg_b+D'2', 1
08AC  51A1      	MOVF FCI_TOSTRI_00042_1_top+D'3', W, 1
08AE  6FAC      	MOVWF __div_32_3_00004_arg_b+D'3', 1
08B0  EC2FF001  	CALL __div_32_3_00004
08B4  51B3      	MOVF CompTempVarRet172, W, 1
08B6  6F99      	MOVWF FCI_TOSTRI_00042_1_tmp1, 1

			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
08B8  5199      	MOVF FCI_TOSTRI_00042_1_tmp1, W, 1
08BA  0F30      	ADDLW 0x30
08BC  6FA5      	MOVWF CompTempVar1871, 1
08BE  5197      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W, 1
08C0  6EEA      	MOVWF FSR0H
08C2  5196      	MOVF FCI_TOSTRI_00042_arg_sDst, W, 1
08C4  25A2      	ADDWF FCI_TOSTRI_00042_1_idx, W, 1
08C6  6EE9      	MOVWF FSR0L
08C8  51A5      	MOVF CompTempVar1871, W, 1
08CA  6EEF      	MOVWF INDF0

			idx++;
08CC  2BA2      	INCF FCI_TOSTRI_00042_1_idx, F, 1

			iSrc -= tmp1 * top;				// Remove digit
08CE  5199      	MOVF FCI_TOSTRI_00042_1_tmp1, W, 1
08D0  6FA5      	MOVWF __mul_32_3_00009_arg_a, 1
08D2  6BA6      	CLRF __mul_32_3_00009_arg_a+D'1', 1
08D4  6BA7      	CLRF __mul_32_3_00009_arg_a+D'2', 1
08D6  6BA8      	CLRF __mul_32_3_00009_arg_a+D'3', 1
08D8  519E      	MOVF FCI_TOSTRI_00042_1_top, W, 1
08DA  6FA9      	MOVWF __mul_32_3_00009_arg_b, 1
08DC  519F      	MOVF FCI_TOSTRI_00042_1_top+D'1', W, 1
08DE  6FAA      	MOVWF __mul_32_3_00009_arg_b+D'1', 1
08E0  51A0      	MOVF FCI_TOSTRI_00042_1_top+D'2', W, 1
08E2  6FAB      	MOVWF __mul_32_3_00009_arg_b+D'2', 1
08E4  51A1      	MOVF FCI_TOSTRI_00042_1_top+D'3', W, 1
08E6  6FAC      	MOVWF __mul_32_3_00009_arg_b+D'3', 1
08E8  ECF0F000  	CALL __mul_32_3_00009
08EC  51B1      	MOVF CompTempVarRet414, W, 1
08EE  6FAD      	MOVWF CompTempVar1872, 1
08F0  51B2      	MOVF CompTempVarRet414+D'1', W, 1
08F2  6FAE      	MOVWF CompTempVar1873, 1
08F4  51B3      	MOVF CompTempVarRet414+D'2', W, 1
08F6  6FAF      	MOVWF CompTempVar1874, 1
08F8  51B4      	MOVF CompTempVarRet414+D'3', W, 1
08FA  6FB0      	MOVWF CompTempVar1875, 1
08FC  51AD      	MOVF CompTempVar1872, W, 1
08FE  5F9A      	SUBWF FCI_TOSTRI_00042_1_iSrc, F, 1
0900  51AE      	MOVF CompTempVar1873, W, 1
0902  5B9B      	SUBWFB FCI_TOSTRI_00042_1_iSrc+D'1', F, 1
0904  51AF      	MOVF CompTempVar1874, W, 1
0906  5B9C      	SUBWFB FCI_TOSTRI_00042_1_iSrc+D'2', F, 1
0908  51B0      	MOVF CompTempVar1875, W, 1
090A  5B9D      	SUBWFB FCI_TOSTRI_00042_1_iSrc+D'3', F, 1

			tmp1 = 1;						// Add zeros now
090C  0E01      	MOVLW 0x01
090E  6F99      	MOVWF FCI_TOSTRI_00042_1_tmp1, 1

		}
		top /= 10;							// Go to next digit
0910  519E      	MOVF FCI_TOSTRI_00042_1_top, W, 1
0912  6FA5      	MOVWF __div_32_3_00004_arg_a, 1
0914  519F      	MOVF FCI_TOSTRI_00042_1_top+D'1', W, 1
0916  6FA6      	MOVWF __div_32_3_00004_arg_a+D'1', 1
0918  51A0      	MOVF FCI_TOSTRI_00042_1_top+D'2', W, 1
091A  6FA7      	MOVWF __div_32_3_00004_arg_a+D'2', 1
091C  51A1      	MOVF FCI_TOSTRI_00042_1_top+D'3', W, 1
091E  6FA8      	MOVWF __div_32_3_00004_arg_a+D'3', 1
0920  0E0A      	MOVLW 0x0A
0922  6FA9      	MOVWF __div_32_3_00004_arg_b, 1
0924  6BAA      	CLRF __div_32_3_00004_arg_b+D'1', 1
0926  6BAB      	CLRF __div_32_3_00004_arg_b+D'2', 1
0928  6BAC      	CLRF __div_32_3_00004_arg_b+D'3', 1
092A  EC2FF001  	CALL __div_32_3_00004
092E  51B3      	MOVF CompTempVarRet172, W, 1
0930  6F9E      	MOVWF FCI_TOSTRI_00042_1_top, 1
0932  51B4      	MOVF CompTempVarRet172+D'1', W, 1
0934  6F9F      	MOVWF FCI_TOSTRI_00042_1_top+D'1', 1
0936  51B5      	MOVF CompTempVarRet172+D'2', W, 1
0938  6FA0      	MOVWF FCI_TOSTRI_00042_1_top+D'2', 1
093A  51B6      	MOVF CompTempVarRet172+D'3', W, 1
093C  6FA1      	MOVWF FCI_TOSTRI_00042_1_top+D'3', 1

	}

	if (idx < iDst_len)						//add terminating null (if we can)
0940  5198      	MOVF FCI_TOSTRI_00042_arg_iDst_len, W, 1
0942  61A2      	CPFSLT FCI_TOSTRI_00042_1_idx, 1
0944  D007      	BRA	label110
0954            label110

		sDst[idx] = '\0';
0946  5197      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W, 1
0948  6EEA      	MOVWF FSR0H
094A  5196      	MOVF FCI_TOSTRI_00042_arg_sDst, W, 1
094C  25A2      	ADDWF FCI_TOSTRI_00042_1_idx, W, 1
094E  6EE9      	MOVWF FSR0L
0950  0E00      	MOVLW 0x00
0952  6EEF      	MOVWF INDF0

	return (sDst);
0954  5196      	MOVF FCI_TOSTRI_00042_arg_sDst, W, 1
0956  6FA3      	MOVWF CompTempVarRet1863, 1
0958  5197      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W, 1
095A  6FA4      	MOVWF CompTempVarRet1863+D'1', 1

}
080E  0012      	RETURN
095C  0012      	RETURN




void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];
		
		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}
		
		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}
	
	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;
	
	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		idx = 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len, strt;

  len = 0;
02C2  6BCA      	CLRF FCI_SHEAD_00000_1_len, 1

  if (sSrc2 == sDst)
02C4  51C7      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
02C6  63C4      	CPFSEQ FCI_SHEAD_00000_arg_sSrc2, 1
02C8  D08C      	BRA	label40
02CA  51C8      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
02CC  63C5      	CPFSEQ FCI_SHEAD_00000_arg_sSrc2+D'1', 1
02CE  D089      	BRA	label40
03E2            label40

  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
02D0  6BCB      	CLRF FCI_SHEAD_00000_1_strt, 1
02D2            label29
02D2  51C3      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W, 1
02D4  61CB      	CPFSLT FCI_SHEAD_00000_1_strt, 1
02D6  D009      	BRA	label30
02D8  51B9      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
02DA  6EEA      	MOVWF FSR0H
02DC  51B8      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
02DE  25CB      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
02E0  6EE9      	MOVWF FSR0L
02E2  52EF      	MOVF INDF0, F
02E4  E002      	BZ	label30
02E6  2BCB      	INCF FCI_SHEAD_00000_1_strt, F, 1
02E8  D7F4      	BRA	label29
02EA            label30
03E0  D7E0      	BRA	label39

    if (strt < iDst_len)
02EA  51C9      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
02EC  61CB      	CPFSLT FCI_SHEAD_00000_1_strt, 1
02EE  D058      	BRA	label38
03A0            label38

    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
02F0  6BCA      	CLRF FCI_SHEAD_00000_1_len, 1
02F2            label31
02F2  51C6      	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W, 1
02F4  61CA      	CPFSLT FCI_SHEAD_00000_1_len, 1
02F6  D009      	BRA	label32
02F8  51C5      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W, 1
02FA  6EEA      	MOVWF FSR0H
02FC  51C4      	MOVF FCI_SHEAD_00000_arg_sSrc2, W, 1
02FE  25CA      	ADDWF FCI_SHEAD_00000_1_len, W, 1
0300  6EE9      	MOVWF FSR0L
0302  52EF      	MOVF INDF0, F
0304  E002      	BZ	label32
0306  2BCA      	INCF FCI_SHEAD_00000_1_len, F, 1
0308  D7F4      	BRA	label31
030A            label32

      if (len > (iDst_len - strt))
030A  51CB      	MOVF FCI_SHEAD_00000_1_strt, W, 1
030C  5DC9      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
030E  6FCC      	MOVWF CompTempVar2020, 1
0310  51CA      	MOVF FCI_SHEAD_00000_1_len, W, 1
0312  61CC      	CPFSLT CompTempVar2020, 1
0314  D005      	BRA	label33
0320            label33

      {
        len = (iDst_len - strt); // Length of string to copy to
0316  51CB      	MOVF FCI_SHEAD_00000_1_strt, W, 1
0318  5DC9      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
031A  6FCD      	MOVWF CompTempVar2026, 1
031C  51CD      	MOVF CompTempVar2026, W, 1
031E  6FCA      	MOVWF FCI_SHEAD_00000_1_len, 1

      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
0320  51CA      	MOVF FCI_SHEAD_00000_1_len, W, 1
0322  25CB      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0324  6FC6      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1

      strt = len;
0326  51CA      	MOVF FCI_SHEAD_00000_1_len, W, 1
0328  6FCB      	MOVWF FCI_SHEAD_00000_1_strt, 1

      while (strt > 0)
032A            label34
032A  0E00      	MOVLW 0x00
032C  65CB      	CPFSGT FCI_SHEAD_00000_1_strt, 1
032E  D014      	BRA	label35
0356  D7E9      	BRA	label34
0358            label35

      {
        strt--;
0330  07CB      	DECF FCI_SHEAD_00000_1_strt, F, 1

        iSrc2_len--;
0332  07C6      	DECF FCI_SHEAD_00000_arg_iSrc2_len, F, 1

        sDst[iSrc2_len] = sSrc2[strt];
0334  51C5      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W, 1
0336  6EEA      	MOVWF FSR0H
0338  51C4      	MOVF FCI_SHEAD_00000_arg_sSrc2, W, 1
033A  6EE9      	MOVWF FSR0L
033C  51CB      	MOVF FCI_SHEAD_00000_1_strt, W, 1
033E  6FCD      	MOVWF CompTempVar2029, 1
0340  51CD      	MOVF CompTempVar2029, W, 1
0342  26E9      	ADDWF FSR0L, F
0344  50EF      	MOVF INDF0, W
0346  6FCE      	MOVWF CompTempVar2030, 1
0348  51C8      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
034A  6EEA      	MOVWF FSR0H
034C  51C7      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
034E  25C6      	ADDWF FCI_SHEAD_00000_arg_iSrc2_len, W, 1
0350  6EE9      	MOVWF FSR0L
0352  51CE      	MOVF CompTempVar2030, W, 1
0354  6EEF      	MOVWF INDF0

      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
0358  6BCB      	CLRF FCI_SHEAD_00000_1_strt, 1
035A            label36
035A  51C3      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W, 1
035C  61CB      	CPFSLT FCI_SHEAD_00000_1_strt, 1
035E  D01D      	BRA	label37
0360  51C9      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
0362  61CB      	CPFSLT FCI_SHEAD_00000_1_strt, 1
0364  D01A      	BRA	label37
0366  51B9      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
0368  6EEA      	MOVWF FSR0H
036A  51B8      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
036C  25CB      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
036E  6EE9      	MOVWF FSR0L
0370  52EF      	MOVF INDF0, F
0372  E013      	BZ	label37
0374  51B9      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
0376  6EEA      	MOVWF FSR0H
0378  51B8      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
037A  6EE9      	MOVWF FSR0L
037C  51CB      	MOVF FCI_SHEAD_00000_1_strt, W, 1
037E  6FCD      	MOVWF CompTempVar2033, 1
0380  51CD      	MOVF CompTempVar2033, W, 1
0382  26E9      	ADDWF FSR0L, F
0384  50EF      	MOVF INDF0, W
0386  6FCE      	MOVWF CompTempVar2034, 1
0388  51C8      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
038A  6EEA      	MOVWF FSR0H
038C  51C7      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
038E  25CB      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0390  6EE9      	MOVWF FSR0L
0392  51CE      	MOVF CompTempVar2034, W, 1
0394  6EEF      	MOVWF INDF0
0396  2BCB      	INCF FCI_SHEAD_00000_1_strt, F, 1
0398  D7E0      	BRA	label36
039A            label37

      len += strt;
039A  51CB      	MOVF FCI_SHEAD_00000_1_strt, W, 1
039C  27CA      	ADDWF FCI_SHEAD_00000_1_len, F, 1

    }
    else
039E  D075      	BRA	label45

    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
03A0  6BCA      	CLRF FCI_SHEAD_00000_1_len, 1
03A2            label39
03A2  51C3      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W, 1
03A4  61CA      	CPFSLT FCI_SHEAD_00000_1_len, 1
03A6  D071      	BRA	label45
03A8  51C9      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
03AA  61CA      	CPFSLT FCI_SHEAD_00000_1_len, 1
03AC  D06E      	BRA	label45
03AE  51B9      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
03B0  6EEA      	MOVWF FSR0H
03B2  51B8      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
03B4  25CA      	ADDWF FCI_SHEAD_00000_1_len, W, 1
03B6  6EE9      	MOVWF FSR0L
03B8  52EF      	MOVF INDF0, F
03BA  E067      	BZ	label45
03BC  51B9      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
03BE  6EEA      	MOVWF FSR0H
03C0  51B8      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
03C2  6EE9      	MOVWF FSR0L
03C4  51CA      	MOVF FCI_SHEAD_00000_1_len, W, 1
03C6  6FCC      	MOVWF CompTempVar2041, 1
03C8  51CC      	MOVF CompTempVar2041, W, 1
03CA  26E9      	ADDWF FSR0L, F
03CC  50EF      	MOVF INDF0, W
03CE  6FCD      	MOVWF CompTempVar2042, 1
03D0  51C8      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
03D2  6EEA      	MOVWF FSR0H
03D4  51C7      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
03D6  25CA      	ADDWF FCI_SHEAD_00000_1_len, W, 1
03D8  6EE9      	MOVWF FSR0L
03DA  51CD      	MOVF CompTempVar2042, W, 1
03DC  6EEF      	MOVWF INDF0
03DE  2BCA      	INCF FCI_SHEAD_00000_1_len, F, 1

    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
03E2  6BCA      	CLRF FCI_SHEAD_00000_1_len, 1
03E4            label41
03E4  51C3      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W, 1
03E6  61CA      	CPFSLT FCI_SHEAD_00000_1_len, 1
03E8  D01D      	BRA	label42
03EA  51C9      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
03EC  61CA      	CPFSLT FCI_SHEAD_00000_1_len, 1
03EE  D01A      	BRA	label42
03F0  51B9      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
03F2  6EEA      	MOVWF FSR0H
03F4  51B8      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
03F6  25CA      	ADDWF FCI_SHEAD_00000_1_len, W, 1
03F8  6EE9      	MOVWF FSR0L
03FA  52EF      	MOVF INDF0, F
03FC  E013      	BZ	label42
03FE  51B9      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
0400  6EEA      	MOVWF FSR0H
0402  51B8      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
0404  6EE9      	MOVWF FSR0L
0406  51CA      	MOVF FCI_SHEAD_00000_1_len, W, 1
0408  6FCC      	MOVWF CompTempVar2049, 1
040A  51CC      	MOVF CompTempVar2049, W, 1
040C  26E9      	ADDWF FSR0L, F
040E  50EF      	MOVF INDF0, W
0410  6FCD      	MOVWF CompTempVar2050, 1
0412  51C8      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0414  6EEA      	MOVWF FSR0H
0416  51C7      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
0418  25CA      	ADDWF FCI_SHEAD_00000_1_len, W, 1
041A  6EE9      	MOVWF FSR0L
041C  51CD      	MOVF CompTempVar2050, W, 1
041E  6EEF      	MOVWF INDF0
0420  2BCA      	INCF FCI_SHEAD_00000_1_len, F, 1
0422  D7E0      	BRA	label41
0424            label42

    // Copy second
    if (len < iDst_len)
0424  51C9      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
0426  61CA      	CPFSLT FCI_SHEAD_00000_1_len, 1
0428  D030      	BRA	label45
048A            label45

    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
042A  6BCD      	CLRF CompTempVar2056, 1
042C  51CA      	MOVF FCI_SHEAD_00000_1_len, W, 1
042E  25C7      	ADDWF FCI_SHEAD_00000_arg_sDst, W, 1
0430  6FCC      	MOVWF CompTempVar2055, 1
0432  51C8      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0434  23CD      	ADDWFC CompTempVar2056, F, 1
0436  51CC      	MOVF CompTempVar2055, W, 1
0438  6FB8      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
043A  51CD      	MOVF CompTempVar2056, W, 1
043C  6FB9      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1

      iSrc1_len = iDst_len - len;
043E  51CA      	MOVF FCI_SHEAD_00000_1_len, W, 1
0440  5DC9      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
0442  6FC3      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1

      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
0444  6BCB      	CLRF FCI_SHEAD_00000_1_strt, 1
0446            label43
0446  51C6      	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W, 1
0448  61CB      	CPFSLT FCI_SHEAD_00000_1_strt, 1
044A  D01D      	BRA	label44
044C  51C3      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W, 1
044E  61CB      	CPFSLT FCI_SHEAD_00000_1_strt, 1
0450  D01A      	BRA	label44
0452  51C5      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W, 1
0454  6EEA      	MOVWF FSR0H
0456  51C4      	MOVF FCI_SHEAD_00000_arg_sSrc2, W, 1
0458  25CB      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
045A  6EE9      	MOVWF FSR0L
045C  52EF      	MOVF INDF0, F
045E  E013      	BZ	label44
0460  51C5      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W, 1
0462  6EEA      	MOVWF FSR0H
0464  51C4      	MOVF FCI_SHEAD_00000_arg_sSrc2, W, 1
0466  6EE9      	MOVWF FSR0L
0468  51CB      	MOVF FCI_SHEAD_00000_1_strt, W, 1
046A  6FCC      	MOVWF CompTempVar2059, 1
046C  51CC      	MOVF CompTempVar2059, W, 1
046E  26E9      	ADDWF FSR0L, F
0470  50EF      	MOVF INDF0, W
0472  6FCD      	MOVWF CompTempVar2060, 1
0474  51B9      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
0476  6EEA      	MOVWF FSR0H
0478  51B8      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
047A  25CB      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
047C  6EE9      	MOVWF FSR0L
047E  51CD      	MOVF CompTempVar2060, W, 1
0480  6EEF      	MOVWF INDF0
0482  2BCB      	INCF FCI_SHEAD_00000_1_strt, F, 1
0484  D7E0      	BRA	label43
0486            label44

      len += strt;
0486  51CB      	MOVF FCI_SHEAD_00000_1_strt, W, 1
0488  27CA      	ADDWF FCI_SHEAD_00000_1_len, F, 1

    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
048A  51C9      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
048C  61CA      	CPFSLT FCI_SHEAD_00000_1_len, 1

  {
    sDst[len] = '\0';
0490  51C8      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0492  6EEA      	MOVWF FSR0H
0494  51C7      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
0496  25CA      	ADDWF FCI_SHEAD_00000_1_len, W, 1
0498  6EE9      	MOVWF FSR0L
049A  0E00      	MOVLW 0x00
049C  6EEF      	MOVWF INDF0

  }
}
048E  0012      	RETURN
049E  0012      	RETURN



/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
095E  6BDD      	CLRF FCI_SCOPY_00000_1_len, 1
0960            label111
0960  51D9      	MOVF FCI_SCOPY_00000_arg_iSrc_len, W, 1
0962  61DD      	CPFSLT FCI_SCOPY_00000_1_len, 1
0964  D01D      	BRA	label112
0966  51DC      	MOVF FCI_SCOPY_00000_arg_iDst_len, W, 1
0968  61DD      	CPFSLT FCI_SCOPY_00000_1_len, 1
096A  D01A      	BRA	label112
096C  51B3      	MOVF FCI_SCOPY_00000_arg_sSrc+D'1', W, 1
096E  6EEA      	MOVWF FSR0H
0970  51B2      	MOVF FCI_SCOPY_00000_arg_sSrc, W, 1
0972  25DD      	ADDWF FCI_SCOPY_00000_1_len, W, 1
0974  6EE9      	MOVWF FSR0L
0976  52EF      	MOVF INDF0, F
0978  E013      	BZ	label112
097A  51B3      	MOVF FCI_SCOPY_00000_arg_sSrc+D'1', W, 1
097C  6EEA      	MOVWF FSR0H
097E  51B2      	MOVF FCI_SCOPY_00000_arg_sSrc, W, 1
0980  6EE9      	MOVWF FSR0L
0982  51DD      	MOVF FCI_SCOPY_00000_1_len, W, 1
0984  6FDE      	MOVWF CompTempVar2068, 1
0986  51DE      	MOVF CompTempVar2068, W, 1
0988  26E9      	ADDWF FSR0L, F
098A  50EF      	MOVF INDF0, W
098C  6FDF      	MOVWF CompTempVar2069, 1
098E  51DB      	MOVF FCI_SCOPY_00000_arg_sDst+D'1', W, 1
0990  6EEA      	MOVWF FSR0H
0992  51DA      	MOVF FCI_SCOPY_00000_arg_sDst, W, 1
0994  25DD      	ADDWF FCI_SCOPY_00000_1_len, W, 1
0996  6EE9      	MOVWF FSR0L
0998  51DF      	MOVF CompTempVar2069, W, 1
099A  6EEF      	MOVWF INDF0
099C  2BDD      	INCF FCI_SCOPY_00000_1_len, F, 1
099E  D7E0      	BRA	label111
09A0            label112

  // Terminate (only if can)
  if (len < iDst_len)
09A0  51DC      	MOVF FCI_SCOPY_00000_arg_iDst_len, W, 1
09A2  61DD      	CPFSLT FCI_SCOPY_00000_1_len, 1

  {
    sDst[len] = '\0';
09A6  51DB      	MOVF FCI_SCOPY_00000_arg_sDst+D'1', W, 1
09A8  6EEA      	MOVWF FSR0H
09AA  51DA      	MOVF FCI_SCOPY_00000_arg_sDst, W, 1
09AC  25DD      	ADDWF FCI_SCOPY_00000_1_len, W, 1
09AE  6EE9      	MOVWF FSR0L
09B0  0E00      	MOVLW 0x00
09B2  6EEF      	MOVWF INDF0

  }
}
09A4  0012      	RETURN
09B4  0012      	RETURN





//************************************************************************************
//**  
//**  Source name:   C:\Users\Cyril\Documents\Projet\Bluetooth\connect_boards\second_player\joueur_2.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.0.0
//**  Date:          Tuesday, May 30, 2017 22:08:12
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x78
#endif
#ifdef HI_TECH_C
__CONFIG(0x78);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_TEST 20
#define FCVsz_ASCII 255
#define FCVsz_RETURN 20
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_CHAR FCV_TEST[FCVsz_TEST];
MX_GLOBAL MX_CHAR FCV_ASCII[FCVsz_ASCII];
MX_GLOBAL MX_UINT8 FCV_OCTET;
MX_GLOBAL MX_CHAR FCV_RETURN[FCVsz_RETURN];
MX_GLOBAL MX_BOOL FCV_CONN;
MX_GLOBAL MX_UINT8 FCV_RETURN_CMD = (0xff); // retour bluetooth command
1478  0100      	MOVLB 0x00
147A  6981      	SETF gbl_FCV_RETURN_CMD, 1

MX_GLOBAL MX_SINT16 FCV_LOOP;

void FCM_BT_CHECK_CONNECTION();
void FCM_INITIALISATION();
void FCM_DECRYPT_BT_RECEIVE_DATA(MX_CHAR *PFCL_RECEIVED_DATA);
void FCM_CHECK_BT_GETTING();
void FCM_SET_ASCII_CHARACTERS();
void FCM_SEND_DATA();
void FCM_BT_CONNECTION();

/*========================================================================*\
   Use :ctrl_lcd
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_eb005
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_0ad31_lcd_eb005__Clear FCD_04071_LCD__Clear
#define FCD_0ad31_lcd_eb005__PrintString FCD_04071_LCD__PrintString
#define FCD_0ad31_lcd_eb005__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0ad31_lcd_eb005__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0ad31_lcd_eb005__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0ad31_lcd_eb005__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0ad31_lcd_eb005__Cursor FCD_04071_LCD__Cursor
#define FCD_0ad31_lcd_eb005__Command FCD_04071_LCD__Command
#define FCD_0ad31_lcd_eb005__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0ad31_lcd_eb005__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0ad31_lcd_eb005__RawSend FCD_04071_LCD__RawSend
#define FCD_0ad31_lcd_eb005__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :InjectorBase1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 portb
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 portb
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisb
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisb
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (4)
#define MX_UART_INT_1 (1)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :Bluetooth2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_0c851_Bluetooth2__STRING_ARRAY 50
#define FCV_0c851_Bluetooth2__BT_CHAR_CR (13)
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__STRING_ARRAY[FCVsz_0c851_Bluetooth2__STRING_ARRAY];
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_IDX = (0x0);
147C  6B82      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX, 1

MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_DONE = (0x0);
147E  6B83      	CLRF gbl_FCV_0c851_Bluetooth2___00001, 1

MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_LENGTH = (0x0);
1480  6B84      	CLRF gbl_FCV_0c851_Bluetooth2___00002, 1


MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY);
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT);
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX);
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR);
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES);
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings();
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA);
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE);
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive();
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings();
MX_UINT8 FCD_0c851_Bluetooth2__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :ctrl_lcd
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()

{




	FCD_04071_LCD__RawSend(0x01, 0);
0C0C  0E01      	MOVLW 0x01
0C0E  0100      	MOVLB 0x00
0C10  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
0C12  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
0C14  EC88F002  	CALL FCD_04071__00063


	FCI_DELAYBYTE_MS(2);
0C18  0E02      	MOVLW 0x02
0C1A  6F9A      	MOVWF delay_ms_00000_arg_del, 1
0C1C  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x02, 0);
0C20  0E02      	MOVLW 0x02
0C22  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
0C24  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
0C26  EC88F002  	CALL FCD_04071__00063


	FCI_DELAYBYTE_MS(2);
0C2A  0E02      	MOVLW 0x02
0C2C  6F9A      	MOVWF delay_ms_00000_arg_del, 1
0C2E  EC0BF000  	CALL delay_ms_00000


}
0C32  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Param??tres pour la macro PrintString :
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
0C34  6BA3      	CLRF FCD_04071__0005D_1_FCL_IDX, 1

	MX_UINT8 FCL_COUNT;



	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);
0C36  5192      	MOVF FCD_04071__0005D_arg_FCL_TEXT, W, 1
0C38  6FC0      	MOVWF FCI_GETLEN_0003E_arg_sStr1, 1
0C3A  5193      	MOVF FCD_04071__0005D_arg_FCL_TEXT+D'1', W, 1
0C3C  6FC1      	MOVWF FCI_GETLEN_0003E_arg_sStr1+D'1', 1
0C3E  51A1      	MOVF FCD_04071__0005D_arg_FCLsz_TEXT, W, 1
0C40  6FC2      	MOVWF FCI_GETLEN_0003E_arg_iStr1_len, 1
0C42  ECB8F000  	CALL FCI_GETLEN_0003E
0C46  51C4      	MOVF CompTempVarRet1850, W, 1
0C48  6FA4      	MOVWF FCD_04071__0005D_1_FCL_COUNT, 1


	while (FCL_IDX < FCL_COUNT)
0C4A            label120
0C4A  51A4      	MOVF FCD_04071__0005D_1_FCL_COUNT, W, 1
0C4C  61A3      	CPFSLT FCD_04071__0005D_1_FCL_IDX, 1
0C68  D7F0      	BRA	label120

	{

		FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);
0C50  5193      	MOVF FCD_04071__0005D_arg_FCL_TEXT+D'1', W, 1
0C52  6EEA      	MOVWF FSR0H
0C54  5192      	MOVF FCD_04071__0005D_arg_FCL_TEXT, W, 1
0C56  25A3      	ADDWF FCD_04071__0005D_1_FCL_IDX, W, 1
0C58  6EE9      	MOVWF FSR0L
0C5A  50EF      	MOVF INDF0, W
0C5C  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
0C5E  81A6      	BSF FCD_04071__00063_arg_FCL_TYPE,0, 1
0C60  EC88F002  	CALL FCD_04071__00063


		FCL_IDX = FCL_IDX + 1;
0C64  29A3      	INCF FCD_04071__0005D_1_FCL_IDX, W, 1
0C66  6FA3      	MOVWF FCD_04071__0005D_1_FCL_IDX, 1



	}


}
0C4E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Param??tres pour la macro PrintAscii :
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)

{
	//Définitions des variables locales
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);
105C  5186      	MOVF FCD_04071__0005E_arg_FCL_NUMBER, W, 1
105E  6F92      	MOVWF FCI_TOSTRI_00042_arg_iSrc1, 1
1060  5187      	MOVF FCD_04071__0005E_arg_FCL_NUMBER+D'1', W, 1
1062  6F93      	MOVWF FCI_TOSTRI_00042_arg_iSrc1+D'1', 1
1064  6B94      	CLRF FCI_TOSTRI_00042_arg_iSrc1+D'2', 1
1066  6B95      	CLRF FCI_TOSTRI_00042_arg_iSrc1+D'3', 1
1068  AF87      	BTFSS FCD_04071__0005E_arg_FCL_NUMBER+D'1',7, 1
106A  D002      	BRA	label153
106C  0794      	DECF FCI_TOSTRI_00042_arg_iSrc1+D'2', F, 1
106E  0795      	DECF FCI_TOSTRI_00042_arg_iSrc1+D'3', F, 1
1070            label153
1070  0E00      	MOVLW HIGH(FCD_04071__0005E_1_FCL_S+D'0')
1072  6F97      	MOVWF FCI_TOSTRI_00042_arg_sDst+D'1', 1
1074  0E88      	MOVLW LOW(FCD_04071__0005E_1_FCL_S+D'0')
1076  6F96      	MOVWF FCI_TOSTRI_00042_arg_sDst, 1
1078  0E0A      	MOVLW 0x0A
107A  6F98      	MOVWF FCI_TOSTRI_00042_arg_iDst_len, 1
107C  ECF1F003  	CALL FCI_TOSTRI_00042


	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);
1080  0E00      	MOVLW HIGH(FCD_04071__0005E_1_FCL_S+D'0')
1082  6F93      	MOVWF FCD_04071__0005D_arg_FCL_TEXT+D'1', 1
1084  0E88      	MOVLW LOW(FCD_04071__0005E_1_FCL_S+D'0')
1086  6F92      	MOVWF FCD_04071__0005D_arg_FCL_TEXT, 1
1088  0E0A      	MOVLW 0x0A
108A  6FA1      	MOVWF FCD_04071__0005D_arg_FCLsz_TEXT, 1
108C  6BA2      	CLRF FCD_04071__0005D_arg_FCLsz_TEXT+D'1', 1
108E  EC1AF006  	CALL FCD_04071__0005D


	//Définitions des variables locales
	#undef FCLsz_S
}
1092  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Param??tres pour la macro RAMWrite :
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Param??tres pour la macro ClearLine :
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)

{
	//Définitions des variables locales
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
1028  0E02      	MOVLW 0x02
102A  6186      	CPFSLT FCD_04071__00061_arg_FCL_LINE, 1

	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);
102E  6B88      	CLRF FCD_04071__00062_arg_FCL_X, 1
1030  5186      	MOVF FCD_04071__00061_arg_FCL_LINE, W, 1
1032  6F89      	MOVWF FCD_04071__00062_arg_FCL_Y, 1
1034  ECF4F005  	CALL FCD_04071__00062


		FCL_X = 0;
1038  6B87      	CLRF FCD_04071__00061_1_FCL_X, 1


		while (FCL_X < 16)
103A            label151
103A  0E10      	MOVLW 0x10
103C  6187      	CPFSLT FCD_04071__00061_1_FCL_X, 1
103E  D008      	BRA	label152
104E  D7F5      	BRA	label151
1050            label152

		{


			FCD_04071_LCD__RawSend(' ', 0x10);
1040  0E20      	MOVLW 0x20
1042  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
1044  81A6      	BSF FCD_04071__00063_arg_FCL_TYPE,0, 1
1046  EC88F002  	CALL FCD_04071__00063


			FCL_X = FCL_X + 1;
104A  2987      	INCF FCD_04071__00061_1_FCL_X, W, 1
104C  6F87      	MOVWF FCD_04071__00061_1_FCL_X, 1



		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);
1050  6B88      	CLRF FCD_04071__00062_arg_FCL_X, 1
1052  5186      	MOVF FCD_04071__00061_arg_FCL_LINE, W, 1
1054  6F89      	MOVWF FCD_04071__00062_arg_FCL_Y, 1
1056  ECF4F005  	CALL FCD_04071__00062


	// } else {

	}

}
102C  0012      	RETURN
105A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Param??tres pour la macro Cursor :
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)

{



	#if (0) // 2 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
0BE8  5389      	MOVF FCD_04071__00062_arg_FCL_Y, F, 1
0BEA  E103      	BNZ	label118
0BF2            label118

		{

			FCL_Y = 0x80;
0BEC  0E80      	MOVLW 0x80
0BEE  6F89      	MOVWF FCD_04071__00062_arg_FCL_Y, 1


		} else {
0BF0  D002      	BRA	label119
0BF6            label119


			FCL_Y = 0xC0;
0BF2  0EC0      	MOVLW 0xC0
0BF4  6F89      	MOVWF FCD_04071__00062_arg_FCL_Y, 1


		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 2 == 4

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);
0BF6  5188      	MOVF FCD_04071__00062_arg_FCL_X, W, 1
0BF8  2589      	ADDWF FCD_04071__00062_arg_FCL_Y, W, 1
0BFA  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
0BFC  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
0BFE  EC88F002  	CALL FCD_04071__00063


	FCI_DELAYBYTE_MS(2);
0C02  0E02      	MOVLW 0x02
0C04  6F9A      	MOVWF delay_ms_00000_arg_del, 1
0C06  EC0BF000  	CALL delay_ms_00000


}
0C0A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Param??tres pour la macro Command :
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Param??tres pour la macro PrintFormattedNumber :
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Définitions des variables locales
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Param??tres pour la macro ScrollDisplay :
       :  Position : Holds the number of positions to shift the display
       :  direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Définitions des variables locales
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	switch (FCL_DIRECTION)
	{
		case 0:
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'l':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'L':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 1:
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'r':
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'R':
		{
			FCL_CMD = 0x1C;


			break;
		}
		// default:

	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Param??tres pour la macro RawSend :
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)

{
	//Définitions des variables locales
	MX_UINT8 FCL_NIBBLE;


	//Commentaire:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
0510  6BA8      	CLRF FCD_04071__00063_2_ptmp, 1
0512  9092      	BCF gbl_trisa,0
0514  53A8      	MOVF FCD_04071__00063_2_ptmp, F, 1
0516  E004      	BZ	label52
0518  0E01      	MOVLW 0x01
051A  1089      	IORWF gbl_lata, W
051C  6E80      	MOVWF gbl_porta
051E  D003      	BRA	label53
0520            label52
0520  0EFE      	MOVLW 0xFE
0522  1489      	ANDWF gbl_lata, W
0524  6E80      	MOVWF gbl_porta
0526            label53

		FCP_SET(B, A, 0x2, 0x1, 0);
0526  6BA8      	CLRF FCD_04071__00063_9_ptmp, 1
0528  9292      	BCF gbl_trisa,1
052A  53A8      	MOVF FCD_04071__00063_9_ptmp, F, 1
052C  E004      	BZ	label54
052E  0E02      	MOVLW 0x02
0530  1089      	IORWF gbl_lata, W
0532  6E80      	MOVWF gbl_porta
0534  D003      	BRA	label55
0536            label54
0536  0EFD      	MOVLW 0xFD
0538  1489      	ANDWF gbl_lata, W
053A  6E80      	MOVWF gbl_porta
053C            label55

		FCP_SET(B, A, 0x4, 0x2, 0);
053C  6BA8      	CLRF FCD_04071__00063_16_ptmp, 1
053E  9492      	BCF gbl_trisa,2
0540  53A8      	MOVF FCD_04071__00063_16_ptmp, F, 1
0542  E004      	BZ	label56
0544  0E04      	MOVLW 0x04
0546  1089      	IORWF gbl_lata, W
0548  6E80      	MOVWF gbl_porta
054A  D003      	BRA	label57
054C            label56
054C  0EFB      	MOVLW 0xFB
054E  1489      	ANDWF gbl_lata, W
0550  6E80      	MOVWF gbl_porta
0552            label57

		FCP_SET(B, A, 0x8, 0x3, 0);
0552  6BA8      	CLRF FCD_04071__00063_23_ptmp, 1
0554  9692      	BCF gbl_trisa,3
0556  53A8      	MOVF FCD_04071__00063_23_ptmp, F, 1
0558  E004      	BZ	label58
055A  0E08      	MOVLW 0x08
055C  1089      	IORWF gbl_lata, W
055E  6E80      	MOVWF gbl_porta
0560  D003      	BRA	label59
0562            label58
0562  0EF7      	MOVLW 0xF7
0564  1489      	ANDWF gbl_lata, W
0566  6E80      	MOVWF gbl_porta
0568            label59

		FCP_SET(B, A, 0x10, 0x4, 0);
0568  6BA8      	CLRF FCD_04071__00063_30_ptmp, 1
056A  9892      	BCF gbl_trisa,4
056C  53A8      	MOVF FCD_04071__00063_30_ptmp, F, 1
056E  E004      	BZ	label60
0570  0E10      	MOVLW 0x10
0572  1089      	IORWF gbl_lata, W
0574  6E80      	MOVWF gbl_porta
0576  D003      	BRA	label61
0578            label60
0578  0EEF      	MOVLW 0xEF
057A  1489      	ANDWF gbl_lata, W
057C  6E80      	MOVWF gbl_porta
057E            label61

		FCP_SET(B, A, 0x20, 0x5, 0);
057E  6BA8      	CLRF FCD_04071__00063_37_ptmp, 1
0580  9A92      	BCF gbl_trisa,5
0582  53A8      	MOVF FCD_04071__00063_37_ptmp, F, 1
0584  E004      	BZ	label62
0586  0E20      	MOVLW 0x20
0588  1089      	IORWF gbl_lata, W
058A  6E80      	MOVWF gbl_porta
058C  D003      	BRA	label63
058E            label62
058E  0EDF      	MOVLW 0xDF
0590  1489      	ANDWF gbl_lata, W
0592  6E80      	MOVWF gbl_porta
0594            label63


		#if (0)

		//Le code a été optimisé par le préprocesseur
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
0594  39A5      	SWAPF FCD_04071__00063_arg_FCL_DATA, W, 1
0596  0B0F      	ANDLW 0x0F
0598  6FA7      	MOVWF FCD_04071__00063_1_FCL_NIBBLE, 1

		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
059A  0E01      	MOVLW 0x01
059C  15A7      	ANDWF FCD_04071__00063_1_FCL_NIBBLE, W, 1
059E  6FA8      	MOVWF FCD_04071__00063_46_ptmp, 1
05A0  9092      	BCF gbl_trisa,0
05A2  53A8      	MOVF FCD_04071__00063_46_ptmp, F, 1
05A4  E004      	BZ	label64
05A6  0E01      	MOVLW 0x01
05A8  1089      	IORWF gbl_lata, W
05AA  6E80      	MOVWF gbl_porta
05AC  D003      	BRA	label65
05AE            label64
05AE  0EFE      	MOVLW 0xFE
05B0  1489      	ANDWF gbl_lata, W
05B2  6E80      	MOVWF gbl_porta
05B4            label65

		FCL_NIBBLE = FCL_NIBBLE >> 1;
05B4  53A7      	MOVF FCD_04071__00063_1_FCL_NIBBLE, F, 1
05B6  90D8      	BCF STATUS,C
05B8  33A7      	RRCF FCD_04071__00063_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
05BA  0E01      	MOVLW 0x01
05BC  15A7      	ANDWF FCD_04071__00063_1_FCL_NIBBLE, W, 1
05BE  6FA8      	MOVWF FCD_04071__00063_55_ptmp, 1
05C0  9292      	BCF gbl_trisa,1
05C2  53A8      	MOVF FCD_04071__00063_55_ptmp, F, 1
05C4  E004      	BZ	label66
05C6  0E02      	MOVLW 0x02
05C8  1089      	IORWF gbl_lata, W
05CA  6E80      	MOVWF gbl_porta
05CC  D003      	BRA	label67
05CE            label66
05CE  0EFD      	MOVLW 0xFD
05D0  1489      	ANDWF gbl_lata, W
05D2  6E80      	MOVWF gbl_porta
05D4            label67

		FCL_NIBBLE = FCL_NIBBLE >> 1;
05D4  53A7      	MOVF FCD_04071__00063_1_FCL_NIBBLE, F, 1
05D6  90D8      	BCF STATUS,C
05D8  33A7      	RRCF FCD_04071__00063_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
05DA  0E01      	MOVLW 0x01
05DC  15A7      	ANDWF FCD_04071__00063_1_FCL_NIBBLE, W, 1
05DE  6FA8      	MOVWF FCD_04071__00063_64_ptmp, 1
05E0  9492      	BCF gbl_trisa,2
05E2  53A8      	MOVF FCD_04071__00063_64_ptmp, F, 1
05E4  E004      	BZ	label68
05E6  0E04      	MOVLW 0x04
05E8  1089      	IORWF gbl_lata, W
05EA  6E80      	MOVWF gbl_porta
05EC  D003      	BRA	label69
05EE            label68
05EE  0EFB      	MOVLW 0xFB
05F0  1489      	ANDWF gbl_lata, W
05F2  6E80      	MOVWF gbl_porta
05F4            label69

		FCL_NIBBLE = FCL_NIBBLE >> 1;
05F4  53A7      	MOVF FCD_04071__00063_1_FCL_NIBBLE, F, 1
05F6  90D8      	BCF STATUS,C
05F8  33A7      	RRCF FCD_04071__00063_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));
05FA  0E01      	MOVLW 0x01
05FC  15A7      	ANDWF FCD_04071__00063_1_FCL_NIBBLE, W, 1
05FE  6FA8      	MOVWF FCD_04071__00063_73_ptmp, 1
0600  9692      	BCF gbl_trisa,3
0602  53A8      	MOVF FCD_04071__00063_73_ptmp, F, 1
0604  E004      	BZ	label70
0606  0E08      	MOVLW 0x08
0608  1089      	IORWF gbl_lata, W
060A  6E80      	MOVWF gbl_porta
060C  D003      	BRA	label71
060E            label70
060E  0EF7      	MOVLW 0xF7
0610  1489      	ANDWF gbl_lata, W
0612  6E80      	MOVWF gbl_porta
0614            label71


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	//Commentaire:
	//Output byte to pins

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	//Commentaire:
	//Output byte to port

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	if (FCL_TYPE)
0614  A1A6      	BTFSS FCD_04071__00063_arg_FCL_TYPE,0, 1
0616  D00C      	BRA	label73

	{

		FCP_SET(B, A, 0x10, 0x4, 1);
0618  0E01      	MOVLW 0x01
061A  6FA8      	MOVWF FCD_04071__00063_82_ptmp, 1
061C  9892      	BCF gbl_trisa,4
061E  53A8      	MOVF FCD_04071__00063_82_ptmp, F, 1
0620  E004      	BZ	label72
0622  0E10      	MOVLW 0x10
0624  1089      	IORWF gbl_lata, W
0626  6E80      	MOVWF gbl_porta
0628  D003      	BRA	label73
062A            label72
062A  0EEF      	MOVLW 0xEF
062C  1489      	ANDWF gbl_lata, W
062E  6E80      	MOVWF gbl_porta
0630            label73


	// } else {

	}

	FCI_DELAYBYTE_US(100);
0630  0E64      	MOVLW 0x64
0632  6FC5      	MOVWF delay_us_00000_arg_del, 1
0634  EC06F000  	CALL delay_us_00000


	//Commentaire:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, A, 0x20, 0x5, 1);
0638  0E01      	MOVLW 0x01
063A  6FA8      	MOVWF FCD_04071__00063_93_ptmp, 1
063C  9A92      	BCF gbl_trisa,5
063E  53A8      	MOVF FCD_04071__00063_93_ptmp, F, 1
0640  E004      	BZ	label74
0642  0E20      	MOVLW 0x20
0644  1089      	IORWF gbl_lata, W
0646  6E80      	MOVWF gbl_porta
0648  D003      	BRA	label75
064A            label74
064A  0EDF      	MOVLW 0xDF
064C  1489      	ANDWF gbl_lata, W
064E  6E80      	MOVWF gbl_porta
0650            label75


	FCI_DELAYBYTE_US(100);
0650  0E64      	MOVLW 0x64
0652  6FC5      	MOVWF delay_us_00000_arg_del, 1
0654  EC06F000  	CALL delay_us_00000


	FCP_SET(B, A, 0x20, 0x5, 0);
0658  6BA8      	CLRF FCD_04071__00063_104_ptmp, 1
065A  9A92      	BCF gbl_trisa,5
065C  53A8      	MOVF FCD_04071__00063_104_ptmp, F, 1
065E  E004      	BZ	label76
0660  0E20      	MOVLW 0x20
0662  1089      	IORWF gbl_lata, W
0664  6E80      	MOVWF gbl_porta
0666  D003      	BRA	label77
0668            label76
0668  0EDF      	MOVLW 0xDF
066A  1489      	ANDWF gbl_lata, W
066C  6E80      	MOVWF gbl_porta
066E            label77


	FCI_DELAYBYTE_US(100);
066E  0E64      	MOVLW 0x64
0670  6FC5      	MOVWF delay_us_00000_arg_del, 1
0672  EC06F000  	CALL delay_us_00000


	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
0676  6BA8      	CLRF FCD_04071__00063_115_ptmp, 1
0678  9092      	BCF gbl_trisa,0
067A  53A8      	MOVF FCD_04071__00063_115_ptmp, F, 1
067C  E004      	BZ	label78
067E  0E01      	MOVLW 0x01
0680  1089      	IORWF gbl_lata, W
0682  6E80      	MOVWF gbl_porta
0684  D003      	BRA	label79
0686            label78
0686  0EFE      	MOVLW 0xFE
0688  1489      	ANDWF gbl_lata, W
068A  6E80      	MOVWF gbl_porta
068C            label79

		FCP_SET(B, A, 0x2, 0x1, 0);
068C  6BA8      	CLRF FCD_04071__00063_122_ptmp, 1
068E  9292      	BCF gbl_trisa,1
0690  53A8      	MOVF FCD_04071__00063_122_ptmp, F, 1
0692  E004      	BZ	label80
0694  0E02      	MOVLW 0x02
0696  1089      	IORWF gbl_lata, W
0698  6E80      	MOVWF gbl_porta
069A  D003      	BRA	label81
069C            label80
069C  0EFD      	MOVLW 0xFD
069E  1489      	ANDWF gbl_lata, W
06A0  6E80      	MOVWF gbl_porta
06A2            label81

		FCP_SET(B, A, 0x4, 0x2, 0);
06A2  6BA8      	CLRF FCD_04071__00063_129_ptmp, 1
06A4  9492      	BCF gbl_trisa,2
06A6  53A8      	MOVF FCD_04071__00063_129_ptmp, F, 1
06A8  E004      	BZ	label82
06AA  0E04      	MOVLW 0x04
06AC  1089      	IORWF gbl_lata, W
06AE  6E80      	MOVWF gbl_porta
06B0  D003      	BRA	label83
06B2            label82
06B2  0EFB      	MOVLW 0xFB
06B4  1489      	ANDWF gbl_lata, W
06B6  6E80      	MOVWF gbl_porta
06B8            label83

		FCP_SET(B, A, 0x8, 0x3, 0);
06B8  6BA8      	CLRF FCD_04071__00063_136_ptmp, 1
06BA  9692      	BCF gbl_trisa,3
06BC  53A8      	MOVF FCD_04071__00063_136_ptmp, F, 1
06BE  E004      	BZ	label84
06C0  0E08      	MOVLW 0x08
06C2  1089      	IORWF gbl_lata, W
06C4  6E80      	MOVWF gbl_porta
06C6  D003      	BRA	label85
06C8            label84
06C8  0EF7      	MOVLW 0xF7
06CA  1489      	ANDWF gbl_lata, W
06CC  6E80      	MOVWF gbl_porta
06CE            label85

		FCP_SET(B, A, 0x10, 0x4, 0);
06CE  6BA8      	CLRF FCD_04071__00063_143_ptmp, 1
06D0  9892      	BCF gbl_trisa,4
06D2  53A8      	MOVF FCD_04071__00063_143_ptmp, F, 1
06D4  E004      	BZ	label86
06D6  0E10      	MOVLW 0x10
06D8  1089      	IORWF gbl_lata, W
06DA  6E80      	MOVWF gbl_porta
06DC  D003      	BRA	label87
06DE            label86
06DE  0EEF      	MOVLW 0xEF
06E0  1489      	ANDWF gbl_lata, W
06E2  6E80      	MOVWF gbl_porta
06E4            label87


		FCL_NIBBLE = (FCL_DATA & 0xf);
06E4  0E0F      	MOVLW 0x0F
06E6  15A5      	ANDWF FCD_04071__00063_arg_FCL_DATA, W, 1
06E8  6FA8      	MOVWF CompTempVar2723, 1
06EA  51A8      	MOVF CompTempVar2723, W, 1
06EC  6FA7      	MOVWF FCD_04071__00063_1_FCL_NIBBLE, 1

		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
06EE  0E01      	MOVLW 0x01
06F0  15A7      	ANDWF FCD_04071__00063_1_FCL_NIBBLE, W, 1
06F2  6FA8      	MOVWF FCD_04071__00063_152_ptmp, 1
06F4  9092      	BCF gbl_trisa,0
06F6  53A8      	MOVF FCD_04071__00063_152_ptmp, F, 1
06F8  E004      	BZ	label88
06FA  0E01      	MOVLW 0x01
06FC  1089      	IORWF gbl_lata, W
06FE  6E80      	MOVWF gbl_porta
0700  D003      	BRA	label89
0702            label88
0702  0EFE      	MOVLW 0xFE
0704  1489      	ANDWF gbl_lata, W
0706  6E80      	MOVWF gbl_porta
0708            label89

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0708  53A7      	MOVF FCD_04071__00063_1_FCL_NIBBLE, F, 1
070A  90D8      	BCF STATUS,C
070C  33A7      	RRCF FCD_04071__00063_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
070E  0E01      	MOVLW 0x01
0710  15A7      	ANDWF FCD_04071__00063_1_FCL_NIBBLE, W, 1
0712  6FA8      	MOVWF FCD_04071__00063_161_ptmp, 1
0714  9292      	BCF gbl_trisa,1
0716  53A8      	MOVF FCD_04071__00063_161_ptmp, F, 1
0718  E004      	BZ	label90
071A  0E02      	MOVLW 0x02
071C  1089      	IORWF gbl_lata, W
071E  6E80      	MOVWF gbl_porta
0720  D003      	BRA	label91
0722            label90
0722  0EFD      	MOVLW 0xFD
0724  1489      	ANDWF gbl_lata, W
0726  6E80      	MOVWF gbl_porta
0728            label91

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0728  53A7      	MOVF FCD_04071__00063_1_FCL_NIBBLE, F, 1
072A  90D8      	BCF STATUS,C
072C  33A7      	RRCF FCD_04071__00063_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
072E  0E01      	MOVLW 0x01
0730  15A7      	ANDWF FCD_04071__00063_1_FCL_NIBBLE, W, 1
0732  6FA8      	MOVWF FCD_04071__00063_170_ptmp, 1
0734  9492      	BCF gbl_trisa,2
0736  53A8      	MOVF FCD_04071__00063_170_ptmp, F, 1
0738  E004      	BZ	label92
073A  0E04      	MOVLW 0x04
073C  1089      	IORWF gbl_lata, W
073E  6E80      	MOVWF gbl_porta
0740  D003      	BRA	label93
0742            label92
0742  0EFB      	MOVLW 0xFB
0744  1489      	ANDWF gbl_lata, W
0746  6E80      	MOVWF gbl_porta
0748            label93

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0748  53A7      	MOVF FCD_04071__00063_1_FCL_NIBBLE, F, 1
074A  90D8      	BCF STATUS,C
074C  33A7      	RRCF FCD_04071__00063_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));
074E  0E01      	MOVLW 0x01
0750  15A7      	ANDWF FCD_04071__00063_1_FCL_NIBBLE, W, 1
0752  6FA8      	MOVWF FCD_04071__00063_179_ptmp, 1
0754  9692      	BCF gbl_trisa,3
0756  53A8      	MOVF FCD_04071__00063_179_ptmp, F, 1
0758  E004      	BZ	label94
075A  0E08      	MOVLW 0x08
075C  1089      	IORWF gbl_lata, W
075E  6E80      	MOVWF gbl_porta
0760  D003      	BRA	label95
0762            label94
0762  0EF7      	MOVLW 0xF7
0764  1489      	ANDWF gbl_lata, W
0766  6E80      	MOVWF gbl_porta
0768            label95


		if (FCL_TYPE)
0768  A1A6      	BTFSS FCD_04071__00063_arg_FCL_TYPE,0, 1
076A  D00C      	BRA	label97

		{

			FCP_SET(B, A, 0x10, 0x4, 1);
076C  0E01      	MOVLW 0x01
076E  6FA8      	MOVWF FCD_04071__00063_188_ptmp, 1
0770  9892      	BCF gbl_trisa,4
0772  53A8      	MOVF FCD_04071__00063_188_ptmp, F, 1
0774  E004      	BZ	label96
0776  0E10      	MOVLW 0x10
0778  1089      	IORWF gbl_lata, W
077A  6E80      	MOVWF gbl_porta
077C  D003      	BRA	label97
077E            label96
077E  0EEF      	MOVLW 0xEF
0780  1489      	ANDWF gbl_lata, W
0782  6E80      	MOVWF gbl_porta
0784            label97


		// } else {

		}

		FCI_DELAYBYTE_US(100);
0784  0E64      	MOVLW 0x64
0786  6FC5      	MOVWF delay_us_00000_arg_del, 1
0788  EC06F000  	CALL delay_us_00000


		FCP_SET(B, A, 0x20, 0x5, 1);
078C  0E01      	MOVLW 0x01
078E  6FA8      	MOVWF FCD_04071__00063_199_ptmp, 1
0790  9A92      	BCF gbl_trisa,5
0792  53A8      	MOVF FCD_04071__00063_199_ptmp, F, 1
0794  E004      	BZ	label98
0796  0E20      	MOVLW 0x20
0798  1089      	IORWF gbl_lata, W
079A  6E80      	MOVWF gbl_porta
079C  D003      	BRA	label99
079E            label98
079E  0EDF      	MOVLW 0xDF
07A0  1489      	ANDWF gbl_lata, W
07A2  6E80      	MOVWF gbl_porta
07A4            label99


		FCI_DELAYBYTE_US(100);
07A4  0E64      	MOVLW 0x64
07A6  6FC5      	MOVWF delay_us_00000_arg_del, 1
07A8  EC06F000  	CALL delay_us_00000


		FCP_SET(B, A, 0x20, 0x5, 0);
07AC  6BA8      	CLRF FCD_04071__00063_210_ptmp, 1
07AE  9A92      	BCF gbl_trisa,5
07B0  53A8      	MOVF FCD_04071__00063_210_ptmp, F, 1
07B2  E004      	BZ	label100
07B4  0E20      	MOVLW 0x20
07B6  1089      	IORWF gbl_lata, W
07B8  6E80      	MOVWF gbl_porta
07BA  D003      	BRA	label101
07BC            label100
07BC  0EDF      	MOVLW 0xDF
07BE  1489      	ANDWF gbl_lata, W
07C0  6E80      	MOVWF gbl_porta
07C2            label101


		FCI_DELAYBYTE_US(100);
07C2  0E64      	MOVLW 0x64
07C4  6FC5      	MOVWF delay_us_00000_arg_del, 1
07C6  EC06F000  	CALL delay_us_00000


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

}
07CA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()

{



	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
1094  0100      	MOVLB 0x00
1096  6B85      	CLRF FCD_04071__00050_2_ptmp, 1
1098  9092      	BCF gbl_trisa,0
109A  5385      	MOVF FCD_04071__00050_2_ptmp, F, 1
109C  E004      	BZ	label154
109E  0E01      	MOVLW 0x01
10A0  1089      	IORWF gbl_lata, W
10A2  6E80      	MOVWF gbl_porta
10A4  D003      	BRA	label155
10A6            label154
10A6  0EFE      	MOVLW 0xFE
10A8  1489      	ANDWF gbl_lata, W
10AA  6E80      	MOVWF gbl_porta
10AC            label155

		FCP_SET(B, A, 0x2, 0x1, 0);
10AC  6B85      	CLRF FCD_04071__00050_9_ptmp, 1
10AE  9292      	BCF gbl_trisa,1
10B0  5385      	MOVF FCD_04071__00050_9_ptmp, F, 1
10B2  E004      	BZ	label156
10B4  0E02      	MOVLW 0x02
10B6  1089      	IORWF gbl_lata, W
10B8  6E80      	MOVWF gbl_porta
10BA  D003      	BRA	label157
10BC            label156
10BC  0EFD      	MOVLW 0xFD
10BE  1489      	ANDWF gbl_lata, W
10C0  6E80      	MOVWF gbl_porta
10C2            label157

		FCP_SET(B, A, 0x4, 0x2, 0);
10C2  6B85      	CLRF FCD_04071__00050_16_ptmp, 1
10C4  9492      	BCF gbl_trisa,2
10C6  5385      	MOVF FCD_04071__00050_16_ptmp, F, 1
10C8  E004      	BZ	label158
10CA  0E04      	MOVLW 0x04
10CC  1089      	IORWF gbl_lata, W
10CE  6E80      	MOVWF gbl_porta
10D0  D003      	BRA	label159
10D2            label158
10D2  0EFB      	MOVLW 0xFB
10D4  1489      	ANDWF gbl_lata, W
10D6  6E80      	MOVWF gbl_porta
10D8            label159

		FCP_SET(B, A, 0x8, 0x3, 0);
10D8  6B85      	CLRF FCD_04071__00050_23_ptmp, 1
10DA  9692      	BCF gbl_trisa,3
10DC  5385      	MOVF FCD_04071__00050_23_ptmp, F, 1
10DE  E004      	BZ	label160
10E0  0E08      	MOVLW 0x08
10E2  1089      	IORWF gbl_lata, W
10E4  6E80      	MOVWF gbl_porta
10E6  D003      	BRA	label161
10E8            label160
10E8  0EF7      	MOVLW 0xF7
10EA  1489      	ANDWF gbl_lata, W
10EC  6E80      	MOVWF gbl_porta
10EE            label161

		FCP_SET(B, A, 0x10, 0x4, 0);
10EE  6B85      	CLRF FCD_04071__00050_30_ptmp, 1
10F0  9892      	BCF gbl_trisa,4
10F2  5385      	MOVF FCD_04071__00050_30_ptmp, F, 1
10F4  E004      	BZ	label162
10F6  0E10      	MOVLW 0x10
10F8  1089      	IORWF gbl_lata, W
10FA  6E80      	MOVWF gbl_porta
10FC  D003      	BRA	label163
10FE            label162
10FE  0EEF      	MOVLW 0xEF
1100  1489      	ANDWF gbl_lata, W
1102  6E80      	MOVWF gbl_porta
1104            label163

		FCP_SET(B, A, 0x20, 0x5, 0);
1104  6B85      	CLRF FCD_04071__00050_37_ptmp, 1
1106  9A92      	BCF gbl_trisa,5
1108  5385      	MOVF FCD_04071__00050_37_ptmp, F, 1
110A  E004      	BZ	label164
110C  0E20      	MOVLW 0x20
110E  1089      	IORWF gbl_lata, W
1110  6E80      	MOVWF gbl_porta
1112  D003      	BRA	label165
1114            label164
1114  0EDF      	MOVLW 0xDF
1116  1489      	ANDWF gbl_lata, W
1118  6E80      	MOVWF gbl_porta
111A            label165


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0)

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);
111A  0E0C      	MOVLW 0x0C
111C  6F9A      	MOVWF delay_ms_00000_arg_del, 1
111E  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x33, 0);
1122  0E33      	MOVLW 0x33
1124  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
1126  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
1128  EC88F002  	CALL FCD_04071__00063


	FCI_DELAYBYTE_MS(2);
112C  0E02      	MOVLW 0x02
112E  6F9A      	MOVWF delay_ms_00000_arg_del, 1
1130  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x33, 0);
1134  0E33      	MOVLW 0x33
1136  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
1138  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
113A  EC88F002  	CALL FCD_04071__00063


	FCI_DELAYBYTE_MS(2);
113E  0E02      	MOVLW 0x02
1140  6F9A      	MOVWF delay_ms_00000_arg_del, 1
1142  EC0BF000  	CALL delay_ms_00000


	#if (0) // 0 > 0

	//Le code a été optimisé par le préprocesseur
	#else

		FCD_04071_LCD__RawSend(0x32, 0);
1146  0E32      	MOVLW 0x32
1148  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
114A  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
114C  EC88F002  	CALL FCD_04071__00063


		FCI_DELAYBYTE_MS(2);
1150  0E02      	MOVLW 0x02
1152  6F9A      	MOVWF delay_ms_00000_arg_del, 1
1154  EC0BF000  	CALL delay_ms_00000


		FCD_04071_LCD__RawSend(0x2c, 0);
1158  0E2C      	MOVLW 0x2C
115A  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
115C  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
115E  EC88F002  	CALL FCD_04071__00063


	#endif

	FCI_DELAYBYTE_MS(2);
1162  0E02      	MOVLW 0x02
1164  6F9A      	MOVWF delay_ms_00000_arg_del, 1
1166  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x06, 0);
116A  0E06      	MOVLW 0x06
116C  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
116E  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
1170  EC88F002  	CALL FCD_04071__00063


	FCI_DELAYBYTE_MS(2);
1174  0E02      	MOVLW 0x02
1176  6F9A      	MOVWF delay_ms_00000_arg_del, 1
1178  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x0c, 0);
117C  0E0C      	MOVLW 0x0C
117E  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
1180  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
1182  EC88F002  	CALL FCD_04071__00063


	FCI_DELAYBYTE_MS(2);
1186  0E02      	MOVLW 0x02
1188  6F9A      	MOVWF delay_ms_00000_arg_del, 1
118A  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x01, 0);
118E  0E01      	MOVLW 0x01
1190  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
1192  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
1194  EC88F002  	CALL FCD_04071__00063


	FCI_DELAYBYTE_MS(2);
1198  0E02      	MOVLW 0x02
119A  6F9A      	MOVWF delay_ms_00000_arg_del, 1
119C  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x02, 0);
11A0  0E02      	MOVLW 0x02
11A2  6FA5      	MOVWF FCD_04071__00063_arg_FCL_DATA, 1
11A4  91A6      	BCF FCD_04071__00063_arg_FCL_TYPE,0, 1
11A6  EC88F002  	CALL FCD_04071__00063


	FCI_DELAYBYTE_MS(2);
11AA  0E02      	MOVLW 0x02
11AC  6F9A      	MOVWF delay_ms_00000_arg_del, 1
11AE  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__Clear();
11B2  EC06F006  	CALL FCD_04071__0005F


}
11B6  0012      	RETURN



/*========================================================================*\
   Use :lcd_eb005
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :InjectorBase1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :Bluetooth2
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the 4 digit Bluetooth pair key based on a string of numbers.
       :e.g. "1234"
       :Returns 0 to indicate success
       :
       :Param??tres pour la macro SetPairKey :
       :  PairKey[5] : Key to use as the Pair key, e.g. "1234" or "0000"
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY)

{
	//Définitions des variables locales
	#define FCLsz_COMMANDSTR 20
	MX_CHAR FCL_COMMANDSTR[FCLsz_COMMANDSTR];
	MX_UINT8 FCR_RETVAL;


	FCI_SHEAD("AT+BTK=\"",9, FCL_PAIRKEY,FCLsz_PAIRKEY, FCL_COMMANDSTR,20);
0B52  0E22      	MOVLW 0x22
0B54  6FC1      	MOVWF CompTempVar2744+D'7', 1
0B56  0E2B      	MOVLW 0x2B
0B58  6FBC      	MOVWF CompTempVar2744+D'2', 1
0B5A  0E3D      	MOVLW 0x3D
0B5C  6FC0      	MOVWF CompTempVar2744+D'6', 1
0B5E  0E41      	MOVLW 0x41
0B60  6FBA      	MOVWF CompTempVar2744, 1
0B62  0E42      	MOVLW 0x42
0B64  6FBD      	MOVWF CompTempVar2744+D'3', 1
0B66  0E4B      	MOVLW 0x4B
0B68  6FBF      	MOVWF CompTempVar2744+D'5', 1
0B6A  0E54      	MOVLW 0x54
0B6C  6FBB      	MOVWF CompTempVar2744+D'1', 1
0B6E  6FBE      	MOVWF CompTempVar2744+D'4', 1
0B70  6BC2      	CLRF CompTempVar2744+D'8', 1
0B72  0E00      	MOVLW HIGH(CompTempVar2744+D'0')
0B74  6FB9      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1
0B76  0EBA      	MOVLW LOW(CompTempVar2744+D'0')
0B78  6FB8      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
0B7A  0E09      	MOVLW 0x09
0B7C  6FC3      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1
0B7E  519A      	MOVF FCD_0c851__00074_arg_FCL_PAIRKEY, W, 1
0B80  6FC4      	MOVWF FCI_SHEAD_00000_arg_sSrc2, 1
0B82  519B      	MOVF FCD_0c851__00074_arg_FCL_PAIRKEY+D'1', W, 1
0B84  6FC5      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1', 1
0B86  51A1      	MOVF FCD_0c851__00074_arg_FCLsz_00075, W, 1
0B88  6FC6      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1
0B8A  0E00      	MOVLW HIGH(FCD_0c851__00074_1_FCL_COM_00076+D'0')
0B8C  6FC8      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0B8E  0EA3      	MOVLW LOW(FCD_0c851__00074_1_FCL_COM_00076+D'0')
0B90  6FC7      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0B92  0E14      	MOVLW 0x14
0B94  6FC9      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0B96  EC61F001  	CALL FCI_SHEAD_00000

	FCI_SHEAD(FCL_COMMANDSTR,FCLsz_COMMANDSTR, "\"",2, FCL_COMMANDSTR,20);
0B9A  0E00      	MOVLW HIGH(FCD_0c851__00074_1_FCL_COM_00076+D'0')
0B9C  6FB9      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1
0B9E  0EA3      	MOVLW LOW(FCD_0c851__00074_1_FCL_COM_00076+D'0')
0BA0  6FB8      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
0BA2  0E14      	MOVLW 0x14
0BA4  6FC3      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1
0BA6  0E22      	MOVLW 0x22
0BA8  6FBA      	MOVWF CompTempVar2747, 1
0BAA  6BBB      	CLRF CompTempVar2747+D'1', 1
0BAC  0E00      	MOVLW HIGH(CompTempVar2747+D'0')
0BAE  6FC5      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1', 1
0BB0  0EBA      	MOVLW LOW(CompTempVar2747+D'0')
0BB2  6FC4      	MOVWF FCI_SHEAD_00000_arg_sSrc2, 1
0BB4  0E02      	MOVLW 0x02
0BB6  6FC6      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1
0BB8  0E00      	MOVLW HIGH(FCD_0c851__00074_1_FCL_COM_00076+D'0')
0BBA  6FC8      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0BBC  0EA3      	MOVLW LOW(FCD_0c851__00074_1_FCL_COM_00076+D'0')
0BBE  6FC7      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0BC0  0E14      	MOVLW 0x14
0BC2  6FC9      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0BC4  EC61F001  	CALL FCI_SHEAD_00000


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand(FCL_COMMANDSTR, FCLsz_COMMANDSTR, 1);
0BC8  0E00      	MOVLW HIGH(FCD_0c851__00074_1_FCL_COM_00076+D'0')
0BCA  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
0BCC  0EA3      	MOVLW LOW(FCD_0c851__00074_1_FCL_COM_00076+D'0')
0BCE  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
0BD0  0E14      	MOVLW 0x14
0BD2  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
0BD4  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
0BD6  0E01      	MOVLW 0x01
0BD8  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
0BDA  EC50F002  	CALL FCD_0c851__0005B
0BDE  51C0      	MOVF CompTempVarRet2691, W, 1
0BE0  6FB7      	MOVWF FCD_0c851__00074_1_FCR_RETVAL, 1


	return (FCR_RETVAL);
0BE2  51B7      	MOVF FCD_0c851__00074_1_FCR_RETVAL, W, 1
0BE4  6FB8      	MOVWF CompTempVarRet2743, 1


	//Définitions des variables locales
	#undef FCLsz_COMMANDSTR
}
0BE6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Receives a single data byte from the Bluetooth module.
       :0xFF signifies no data available.
       :
       :Param??tres pour la macro ReceiveByte :
       :  Timeout : Amount of time to wait in milliseconds 0=Wait forever
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	FCV_0c851_Bluetooth2__RX_DONE = 0;

FCC_ReceiveByte_A:
;

	if (FCV_0c851_Bluetooth2__RX_IDX < FCV_0c851_Bluetooth2__RX_LENGTH)
	{

		FCR_RETVAL = FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_IDX];

		FCV_0c851_Bluetooth2__RX_IDX = FCV_0c851_Bluetooth2__RX_IDX + 1;

	} else {

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 50)
		{

			if ((FCL_TIMEOUT == 0) || (FCL_COUNT < FCL_TIMEOUT))
			{

				FCI_DELAYBYTE_MS(1);

				FCL_COUNT = FCL_COUNT + 1;

				goto FCC_ReceiveByte_A;

			// } else {

			}

		// } else {

		}

		FCV_0c851_Bluetooth2__RX_IDX = 0;
		FCV_0c851_Bluetooth2__RX_LENGTH = 0;

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Send an AT command script.
       :Returns 0 for fail, 1 for success and 255 for unrecognised script idx.
       :
       :Param??tres pour la macro SendScript :
       :  idx : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX)

{
	//Définitions des variables locales
	MX_UINT8 FCL_I = (0x0);
0D4A  6B86      	CLRF FCD_0c851__00052_1_FCL_I, 1

	MX_UINT8 FCL_CH = (0xff);
0D4C  6987      	SETF FCD_0c851__00052_1_FCL_CH, 1

	#define FCLsz_SCRIPT_STR 40
	MX_CHAR FCL_SCRIPT_STR[FCLsz_SCRIPT_STR];
	MX_UINT8 FCL_LEN = (0x0);
0D4E  6BB0      	CLRF FCD_0c851__00052_1_FCL_LEN, 1

	MX_UINT8 FCR_RETVAL;


	if ((FCL_IDX < 1) || (FCL_IDX > 2))
0D50  0E01      	MOVLW 0x01
0D52  6185      	CPFSLT FCD_0c851__00052_arg_FCL_IDX, 1
0D54  D001      	BRA	label132
0D56  D003      	BRA	label133
0D58            label132
0D58  0E02      	MOVLW 0x02
0D5A  6585      	CPFSGT FCD_0c851__00052_arg_FCL_IDX, 1
0D5C  D002      	BRA	label134
0D5E            label133
0D62            label134
0D7C  D07D      	BRA	label140

	{

		FCR_RETVAL = 255;
0D5E  69B1      	SETF FCD_0c851__00052_1_FCR_RETVAL, 1


		goto FCC_SendScript_A;
0D60  D0D0      	BRA	label146


	// } else {

	}

	switch (FCL_IDX)
0E9C            label142

	{
		case 1:
0D62  0585      	DECF FCD_0c851__00052_arg_FCL_IDX, W, 1
0D64  E00C      	BZ	label137
0D7E            label137

		{
			FCI_SCOPY("ATS0=1\r\nATS512=4\r\nATS536=1\r\nATS502=1",37, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0D7E  0E0A      	MOVLW 0x0A
0D80  6FBB      	MOVWF CompTempVar2644+D'7', 1
0D82  6FC5      	MOVWF CompTempVar2644+D'17', 1
0D84  6FCF      	MOVWF CompTempVar2644+D'27', 1
0D86  0E0D      	MOVLW 0x0D
0D88  6FBA      	MOVWF CompTempVar2644+D'6', 1
0D8A  6FC4      	MOVWF CompTempVar2644+D'16', 1
0D8C  6FCE      	MOVWF CompTempVar2644+D'26', 1
0D8E  0E30      	MOVLW 0x30
0D90  6FB7      	MOVWF CompTempVar2644+D'3', 1
0D92  6FD4      	MOVWF CompTempVar2644+D'32', 1
0D94  0E31      	MOVLW 0x31
0D96  6FB9      	MOVWF CompTempVar2644+D'5', 1
0D98  6FC0      	MOVWF CompTempVar2644+D'12', 1
0D9A  6FCD      	MOVWF CompTempVar2644+D'25', 1
0D9C  6FD7      	MOVWF CompTempVar2644+D'35', 1
0D9E  0E32      	MOVLW 0x32
0DA0  6FC1      	MOVWF CompTempVar2644+D'13', 1
0DA2  6FD5      	MOVWF CompTempVar2644+D'33', 1
0DA4  0E33      	MOVLW 0x33
0DA6  6FCA      	MOVWF CompTempVar2644+D'22', 1
0DA8  0E34      	MOVLW 0x34
0DAA  6FC3      	MOVWF CompTempVar2644+D'15', 1
0DAC  0E35      	MOVLW 0x35
0DAE  6FBF      	MOVWF CompTempVar2644+D'11', 1
0DB0  6FC9      	MOVWF CompTempVar2644+D'21', 1
0DB2  6FD3      	MOVWF CompTempVar2644+D'31', 1
0DB4  0E36      	MOVLW 0x36
0DB6  6FCB      	MOVWF CompTempVar2644+D'23', 1
0DB8  0E3D      	MOVLW 0x3D
0DBA  6FB8      	MOVWF CompTempVar2644+D'4', 1
0DBC  6FC2      	MOVWF CompTempVar2644+D'14', 1
0DBE  6FCC      	MOVWF CompTempVar2644+D'24', 1
0DC0  6FD6      	MOVWF CompTempVar2644+D'34', 1
0DC2  0E41      	MOVLW 0x41
0DC4  6FB4      	MOVWF CompTempVar2644, 1
0DC6  6FBC      	MOVWF CompTempVar2644+D'8', 1
0DC8  6FC6      	MOVWF CompTempVar2644+D'18', 1
0DCA  6FD0      	MOVWF CompTempVar2644+D'28', 1
0DCC  0E53      	MOVLW 0x53
0DCE  6FB6      	MOVWF CompTempVar2644+D'2', 1
0DD0  6FBE      	MOVWF CompTempVar2644+D'10', 1
0DD2  6FC8      	MOVWF CompTempVar2644+D'20', 1
0DD4  6FD2      	MOVWF CompTempVar2644+D'30', 1
0DD6  0E54      	MOVLW 0x54
0DD8  6FB5      	MOVWF CompTempVar2644+D'1', 1
0DDA  6FBD      	MOVWF CompTempVar2644+D'9', 1
0DDC  6FC7      	MOVWF CompTempVar2644+D'19', 1
0DDE  6FD1      	MOVWF CompTempVar2644+D'29', 1
0DE0  6BD8      	CLRF CompTempVar2644+D'36', 1
0DE2  0E00      	MOVLW HIGH(CompTempVar2644+D'0')
0DE4  6FB3      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1', 1
0DE6  0EB4      	MOVLW LOW(CompTempVar2644+D'0')
0DE8  6FB2      	MOVWF FCI_SCOPY_00000_arg_sSrc, 1
0DEA  0E25      	MOVLW 0x25
0DEC  6FD9      	MOVWF FCI_SCOPY_00000_arg_iSrc_len, 1
0DEE  0E00      	MOVLW HIGH(FCD_0c851__00052_1_FCL_SCR_00053+D'0')
0DF0  6FDB      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1', 1
0DF2  0E88      	MOVLW LOW(FCD_0c851__00052_1_FCL_SCR_00053+D'0')
0DF4  6FDA      	MOVWF FCI_SCOPY_00000_arg_sDst, 1
0DF6  0E28      	MOVLW 0x28
0DF8  6FDC      	MOVWF FCI_SCOPY_00000_arg_iDst_len, 1
0DFA  ECAFF004  	CALL FCI_SCOPY_00000


			break;
0DFE  D04E      	BRA	label142

		}
		case 2:
0D66  0E02      	MOVLW 0x02
0D68  6385      	CPFSEQ FCD_0c851__00052_arg_FCL_IDX, 1
0D6A  D001      	BRA	label135
0D6C  D049      	BRA	label138
0D6E            label135
0E00            label138

		{
			FCI_SCOPY("AT&W\r\nATS554=100",17, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0E00  0E0A      	MOVLW 0x0A
0E02  6FB9      	MOVWF CompTempVar2647+D'5', 1
0E04  0E0D      	MOVLW 0x0D
0E06  6FB8      	MOVWF CompTempVar2647+D'4', 1
0E08  0E26      	MOVLW 0x26
0E0A  6FB6      	MOVWF CompTempVar2647+D'2', 1
0E0C  0E30      	MOVLW 0x30
0E0E  6FC2      	MOVWF CompTempVar2647+D'14', 1
0E10  6FC3      	MOVWF CompTempVar2647+D'15', 1
0E12  0E31      	MOVLW 0x31
0E14  6FC1      	MOVWF CompTempVar2647+D'13', 1
0E16  0E34      	MOVLW 0x34
0E18  6FBF      	MOVWF CompTempVar2647+D'11', 1
0E1A  0E35      	MOVLW 0x35
0E1C  6FBD      	MOVWF CompTempVar2647+D'9', 1
0E1E  6FBE      	MOVWF CompTempVar2647+D'10', 1
0E20  0E3D      	MOVLW 0x3D
0E22  6FC0      	MOVWF CompTempVar2647+D'12', 1
0E24  0E41      	MOVLW 0x41
0E26  6FB4      	MOVWF CompTempVar2647, 1
0E28  6FBA      	MOVWF CompTempVar2647+D'6', 1
0E2A  0E53      	MOVLW 0x53
0E2C  6FBC      	MOVWF CompTempVar2647+D'8', 1
0E2E  0E54      	MOVLW 0x54
0E30  6FB5      	MOVWF CompTempVar2647+D'1', 1
0E32  6FBB      	MOVWF CompTempVar2647+D'7', 1
0E34  0E57      	MOVLW 0x57
0E36  6FB7      	MOVWF CompTempVar2647+D'3', 1
0E38  6BC4      	CLRF CompTempVar2647+D'16', 1
0E3A  0E00      	MOVLW HIGH(CompTempVar2647+D'0')
0E3C  6FB3      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1', 1
0E3E  0EB4      	MOVLW LOW(CompTempVar2647+D'0')
0E40  6FB2      	MOVWF FCI_SCOPY_00000_arg_sSrc, 1
0E42  0E11      	MOVLW 0x11
0E44  6FD9      	MOVWF FCI_SCOPY_00000_arg_iSrc_len, 1
0E46  0E00      	MOVLW HIGH(FCD_0c851__00052_1_FCL_SCR_00053+D'0')
0E48  6FDB      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1', 1
0E4A  0E88      	MOVLW LOW(FCD_0c851__00052_1_FCL_SCR_00053+D'0')
0E4C  6FDA      	MOVWF FCI_SCOPY_00000_arg_sDst, 1
0E4E  0E28      	MOVLW 0x28
0E50  6FDC      	MOVWF FCI_SCOPY_00000_arg_iDst_len, 1
0E52  ECAFF004  	CALL FCI_SCOPY_00000


			break;
0E56  D022      	BRA	label142

		}
		case 3:
0D6E  0E03      	MOVLW 0x03
0D70  6385      	CPFSEQ FCD_0c851__00052_arg_FCL_IDX, 1
0D72  D001      	BRA	label136
0D74  D071      	BRA	label139
0D76            label136
0E58            label139

		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0E58  6BB4      	CLRF CompTempVar2650, 1
0E5A  0E00      	MOVLW HIGH(CompTempVar2650+D'0')
0E5C  6FB3      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1', 1
0E5E  0EB4      	MOVLW LOW(CompTempVar2650+D'0')
0E60  6FB2      	MOVWF FCI_SCOPY_00000_arg_sSrc, 1
0E62  0E01      	MOVLW 0x01
0E64  6FD9      	MOVWF FCI_SCOPY_00000_arg_iSrc_len, 1
0E66  0E00      	MOVLW HIGH(FCD_0c851__00052_1_FCL_SCR_00053+D'0')
0E68  6FDB      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1', 1
0E6A  0E88      	MOVLW LOW(FCD_0c851__00052_1_FCL_SCR_00053+D'0')
0E6C  6FDA      	MOVWF FCI_SCOPY_00000_arg_sDst, 1
0E6E  0E28      	MOVLW 0x28
0E70  6FDC      	MOVWF FCI_SCOPY_00000_arg_iDst_len, 1
0E72  ECAFF004  	CALL FCI_SCOPY_00000


			break;
0E76  D012      	BRA	label142

		}
		case 4:
0D76  0E04      	MOVLW 0x04
0D78  6385      	CPFSEQ FCD_0c851__00052_arg_FCL_IDX, 1
0D7A  D08E      	BRA	label141
0E78            label140

		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0E78  6BB4      	CLRF CompTempVar2653, 1
0E7A  0E00      	MOVLW HIGH(CompTempVar2653+D'0')
0E7C  6FB3      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1', 1
0E7E  0EB4      	MOVLW LOW(CompTempVar2653+D'0')
0E80  6FB2      	MOVWF FCI_SCOPY_00000_arg_sSrc, 1
0E82  0E01      	MOVLW 0x01
0E84  6FD9      	MOVWF FCI_SCOPY_00000_arg_iSrc_len, 1
0E86  0E00      	MOVLW HIGH(FCD_0c851__00052_1_FCL_SCR_00053+D'0')
0E88  6FDB      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1', 1
0E8A  0E88      	MOVLW LOW(FCD_0c851__00052_1_FCL_SCR_00053+D'0')
0E8C  6FDA      	MOVWF FCI_SCOPY_00000_arg_sDst, 1
0E8E  0E28      	MOVLW 0x28
0E90  6FDC      	MOVWF FCI_SCOPY_00000_arg_iDst_len, 1
0E92  ECAFF004  	CALL FCI_SCOPY_00000


			break;
0E96  D002      	BRA	label142

		}
		default:
0E98            label141

		{
			FCR_RETVAL = 255;
0E98  69B1      	SETF FCD_0c851__00052_1_FCR_RETVAL, 1


			goto FCC_SendScript_A;
0E9A  D033      	BRA	label146


		}
	}

	while (FCL_CH > 0)
0E9C  0E00      	MOVLW 0x00
0E9E  6587      	CPFSGT FCD_0c851__00052_1_FCL_CH, 1
0EA0  D022      	BRA	label145
0EE4  D7DB      	BRA	label142
0EE6            label145

	{

		FCL_CH = FCL_SCRIPT_STR[FCL_I];
0EA2  EE00F088  	LFSR 0x00, FCD_0c851__00052_1_FCL_SCR_00053
0EA6  50E9      	MOVF FSR0L, W
0EA8  5186      	MOVF FCD_0c851__00052_1_FCL_I, W, 1
0EAA  26E9      	ADDWF FSR0L, F
0EAC  50EF      	MOVF INDF0, W
0EAE  6F87      	MOVWF FCD_0c851__00052_1_FCL_CH, 1


		if ((FCL_CH > 0) && (FCL_CH != 0x0A))
0EB0  0E00      	MOVLW 0x00
0EB2  6587      	CPFSGT FCD_0c851__00052_1_FCL_CH, 1
0EB4  D015      	BRA	label144
0EB6  0E0A      	MOVLW 0x0A
0EB8  6387      	CPFSEQ FCD_0c851__00052_1_FCL_CH, 1
0EBA  D001      	BRA	label143
0EBC  D011      	BRA	label144
0EBE            label143

		{

			FC_CAL_UART_Send_1(FCL_CH);
0EBE  5187      	MOVF FCD_0c851__00052_1_FCL_CH, W, 1
0EC0  6FC0      	MOVWF FC_CAL_UAR_00071_arg_nChar, 1
0EC2  6BC1      	CLRF FC_CAL_UAR_00071_arg_nChar+D'1', 1
0EC4  ECB0F000  	CALL FC_CAL_UAR_00071


			FCL_LEN = FCL_LEN + 1;
0EC8  29B0      	INCF FCD_0c851__00052_1_FCL_LEN, W, 1
0ECA  6FB0      	MOVWF FCD_0c851__00052_1_FCL_LEN, 1


			if (FCL_CH == FCV_0c851_Bluetooth2__BT_CHAR_CR)
0ECC  0E0D      	MOVLW 0x0D
0ECE  6387      	CPFSEQ FCD_0c851__00052_1_FCL_CH, 1
0ED0  D007      	BRA	label144
0EE0            label144

			{

				#if (1) // 1 == 1

					FCD_0c851_Bluetooth2__StringReceive();
0ED2  ECC8F000  	CALL FCD_0c851__00078


				// #else

				//Le code a été optimisé par le préprocesseur
				#endif

				FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
0ED6  ECC8F000  	CALL FCD_0c851__00078
0EDA  51C3      	MOVF CompTempVarRet2754, W, 1
0EDC  6FB1      	MOVWF FCD_0c851__00052_1_FCR_RETVAL, 1


				FCL_LEN = 0;
0EDE  6BB0      	CLRF FCD_0c851__00052_1_FCL_LEN, 1


			// } else {

			}

		// } else {

		}

		FCL_I = FCL_I + 1;
0EE0  2986      	INCF FCD_0c851__00052_1_FCL_I, W, 1
0EE2  6F86      	MOVWF FCD_0c851__00052_1_FCL_I, 1



	}

	if (FCL_LEN > 0)
0EE6  0E00      	MOVLW 0x00
0EE8  65B0      	CPFSGT FCD_0c851__00052_1_FCL_LEN, 1
0EEA  D00B      	BRA	label146
0F02            label146

	{

		FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);
0EEC  0E0D      	MOVLW 0x0D
0EEE  6FC0      	MOVWF FC_CAL_UAR_00071_arg_nChar, 1
0EF0  6BC1      	CLRF FC_CAL_UAR_00071_arg_nChar+D'1', 1
0EF2  ECB0F000  	CALL FC_CAL_UAR_00071


		#if (1) // 1 == 1

			FCD_0c851_Bluetooth2__StringReceive();
0EF6  ECC8F000  	CALL FCD_0c851__00078


		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
0EFA  ECC8F000  	CALL FCD_0c851__00078
0EFE  51C3      	MOVF CompTempVarRet2754, W, 1
0F00  6FB1      	MOVWF FCD_0c851__00052_1_FCR_RETVAL, 1


	// } else {

	}

FCC_SendScript_A:
;

	return (FCR_RETVAL);
0F02  51B1      	MOVF FCD_0c851__00052_1_FCR_RETVAL, W, 1
0F04  6FB2      	MOVWF CompTempVarRet2643, 1


	//Définitions des variables locales
	#undef FCLsz_SCRIPT_STR
}
0F06  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sends a command string to the GSM module.
       :0 = Command sent ok, 255 = No Reply
       :
       :Param??tres pour la macro SendCommand :
       :  Command[20] : MX_CHAR (by-ref)
       :  SendCR : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
04A0  6BBD      	CLRF FCD_0c851__0005B_1_FCL_IDX, 1

	MX_UINT8 FCL_LEN;
	MX_UINT8 FCR_RETVAL;


	while (1)
04A2            label46

	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
04A2  ECC8F000  	CALL FCD_0c851__00078
04A6  51C3      	MOVF CompTempVarRet2754, W, 1
04A8  6FBF      	MOVWF FCD_0c851__0005B_1_FCR_RETVAL, 1



		if ((FCR_RETVAL) == 0) break;
04AA  53BF      	MOVF FCD_0c851__0005B_1_FCR_RETVAL, F, 1
04AC  E1FA      	BNZ	label46

	}

	FCL_LEN = FCI_GETLENGTH(FCL_COMMAND, FCLsz_COMMAND);
04AE  51B8      	MOVF FCD_0c851__0005B_arg_FCL_COMMAND, W, 1
04B0  6FC0      	MOVWF FCI_GETLEN_0003E_arg_sStr1, 1
04B2  51B9      	MOVF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', W, 1
04B4  6FC1      	MOVWF FCI_GETLEN_0003E_arg_sStr1+D'1', 1
04B6  51BA      	MOVF FCD_0c851__0005B_arg_FCLsz_0005C, W, 1
04B8  6FC2      	MOVWF FCI_GETLEN_0003E_arg_iStr1_len, 1
04BA  ECB8F000  	CALL FCI_GETLEN_0003E
04BE  51C4      	MOVF CompTempVarRet1850, W, 1
04C0  6FBE      	MOVWF FCD_0c851__0005B_1_FCL_LEN, 1


	if (FCL_LEN)
04C2  53BE      	MOVF FCD_0c851__0005B_1_FCL_LEN, F, 1
04C4  E017      	BZ	label49
04C6            label47

	{

		while (FCL_IDX < FCL_LEN)
04C6  51BE      	MOVF FCD_0c851__0005B_1_FCL_LEN, W, 1
04C8  61BD      	CPFSLT FCD_0c851__0005B_1_FCL_IDX, 1
04CA  D00D      	BRA	label48
04E4  D7F0      	BRA	label47
04E6            label48

		{

			FC_CAL_UART_Send_1(FCL_COMMAND[FCL_IDX]);
04CC  51B9      	MOVF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', W, 1
04CE  6EEA      	MOVWF FSR0H
04D0  51B8      	MOVF FCD_0c851__0005B_arg_FCL_COMMAND, W, 1
04D2  25BD      	ADDWF FCD_0c851__0005B_1_FCL_IDX, W, 1
04D4  6EE9      	MOVWF FSR0L
04D6  50EF      	MOVF INDF0, W
04D8  6FC0      	MOVWF FC_CAL_UAR_00071_arg_nChar, 1
04DA  6BC1      	CLRF FC_CAL_UAR_00071_arg_nChar+D'1', 1
04DC  ECB0F000  	CALL FC_CAL_UAR_00071


			FCL_IDX = FCL_IDX + 1;
04E0  29BD      	INCF FCD_0c851__0005B_1_FCL_IDX, W, 1
04E2  6FBD      	MOVWF FCD_0c851__0005B_1_FCL_IDX, 1



		}

		if (FCL_SENDCR)
04E6  53BC      	MOVF FCD_0c851__0005B_arg_FCL_SENDCR, F, 1
04E8  E005      	BZ	label49
04F4            label49

		{

			FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);
04EA  0E0D      	MOVLW 0x0D
04EC  6FC0      	MOVWF FC_CAL_UAR_00071_arg_nChar, 1
04EE  6BC1      	CLRF FC_CAL_UAR_00071_arg_nChar+D'1', 1
04F0  ECB0F000  	CALL FC_CAL_UAR_00071


		// } else {

		}

	// } else {

	}

	#if (1) // 1 == 1

		FCD_0c851_Bluetooth2__StringReceive();
04F4  ECC8F000  	CALL FCD_0c851__00078


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
04F8  ECC8F000  	CALL FCD_0c851__00078
04FC  51C3      	MOVF CompTempVarRet2754, W, 1
04FE  6FBF      	MOVWF FCD_0c851__0005B_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 0)
0500  53BF      	MOVF FCD_0c851__0005B_1_FCR_RETVAL, F, 1
0502  E102      	BNZ	label50
0508            label50

	{

		FCR_RETVAL = 255;
0504  69BF      	SETF FCD_0c851__0005B_1_FCR_RETVAL, 1


	} else {
0506  D001      	BRA	label51
050A            label51


		FCR_RETVAL = 0;
0508  6BBF      	CLRF FCD_0c851__0005B_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
050A  51BF      	MOVF FCD_0c851__0005B_1_FCR_RETVAL, W, 1
050C  6FC0      	MOVWF CompTempVarRet2691, 1


}
050E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies the incoming data from the data string array to a local string variable.
       :
       :Param??tres pour la macro ReadString :
       :  NumBytes : MX_UINT8
       :
       :Renvoie : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);


	while ((FCL_IDX < FCL_NUMBYTES) && (FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX] > 0))
	{

		FCR_RETVAL[FCL_IDX] = FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX];
		FCL_IDX = FCL_IDX + 1;


	}

	if (FCL_IDX < FCL_NUMBYTES)
	{

		FCR_RETVAL[FCL_IDX] = 0;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Saves the current settings to firmware using the AT&W command followed by the ATZ command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&W", 5, 1);
0AF2  0E41      	MOVLW 0x41
0AF4  0100      	MOVLB 0x00
0AF6  6F9B      	MOVWF CompTempVar2762, 1
0AF8  0E54      	MOVLW 0x54
0AFA  6F9C      	MOVWF CompTempVar2762+D'1', 1
0AFC  0E26      	MOVLW 0x26
0AFE  6F9D      	MOVWF CompTempVar2762+D'2', 1
0B00  0E57      	MOVLW 0x57
0B02  6F9E      	MOVWF CompTempVar2762+D'3', 1
0B04  6B9F      	CLRF CompTempVar2762+D'4', 1
0B06  0E00      	MOVLW HIGH(CompTempVar2762+D'0')
0B08  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
0B0A  0E9B      	MOVLW LOW(CompTempVar2762+D'0')
0B0C  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
0B0E  0E05      	MOVLW 0x05
0B10  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
0B12  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
0B14  0E01      	MOVLW 0x01
0B16  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
0B18  EC50F002  	CALL FCD_0c851__0005B
0B1C  51C0      	MOVF CompTempVarRet2691, W, 1
0B1E  6F9A      	MOVWF FCD_0c851__0007C_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 0)
0B20  539A      	MOVF FCD_0c851__0007C_1_FCR_RETVAL, F, 1
0B22  E114      	BNZ	label117
0B4C            label117

	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATZ", 4, 1);
0B24  0E41      	MOVLW 0x41
0B26  6F9B      	MOVWF CompTempVar2764, 1
0B28  0E54      	MOVLW 0x54
0B2A  6F9C      	MOVWF CompTempVar2764+D'1', 1
0B2C  0E5A      	MOVLW 0x5A
0B2E  6F9D      	MOVWF CompTempVar2764+D'2', 1
0B30  6B9E      	CLRF CompTempVar2764+D'3', 1
0B32  0E00      	MOVLW HIGH(CompTempVar2764+D'0')
0B34  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
0B36  0E9B      	MOVLW LOW(CompTempVar2764+D'0')
0B38  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
0B3A  0E04      	MOVLW 0x04
0B3C  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
0B3E  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
0B40  0E01      	MOVLW 0x01
0B42  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
0B44  EC50F002  	CALL FCD_0c851__0005B
0B48  51C0      	MOVF CompTempVarRet2691, W, 1
0B4A  6F9A      	MOVWF FCD_0c851__0007C_1_FCR_RETVAL, 1


	// } else {

	}

	return (FCR_RETVAL);
0B4C  519A      	MOVF FCD_0c851__0007C_1_FCR_RETVAL, W, 1
0B4E  6F9B      	MOVWF CompTempVarRet2761, 1


}
0B50  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sends a single data byte out to the Bluetooth module.
       :
       :Param??tres pour la macro SendByte :
       :  Data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA)
{

	FC_CAL_UART_Send_1(FCL_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the bluetooth mode to be discoverable and or connectable.
       :Returns 0 for success.
       :
       :Param??tres pour la macro SetMode :
       :  Discoverable : 0 = Not Discoverable, 1 = Discoverable
       :  Connectable : 0 = Not Connectable, 1 = Connectable
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE)

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	if (FCL_DISCOVERABLE)
09EE  539A      	MOVF FCD_0c851__0007E_arg_FCL_D_0007F, F, 1
09F0  E03F      	BZ	label114
0A70            label114

	{

		if (FCL_CONNECTABLE)
09F2  539B      	MOVF FCD_0c851__0007E_arg_FCL_C_00080, F, 1
09F4  E01F      	BZ	label113
0A34            label113

		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=4", 9, 1);
09F6  0E41      	MOVLW 0x41
09F8  6F9D      	MOVWF CompTempVar2767, 1
09FA  0E54      	MOVLW 0x54
09FC  6F9E      	MOVWF CompTempVar2767+D'1', 1
09FE  0E53      	MOVLW 0x53
0A00  6F9F      	MOVWF CompTempVar2767+D'2', 1
0A02  0E35      	MOVLW 0x35
0A04  6FA0      	MOVWF CompTempVar2767+D'3', 1
0A06  0E31      	MOVLW 0x31
0A08  6FA1      	MOVWF CompTempVar2767+D'4', 1
0A0A  0E32      	MOVLW 0x32
0A0C  6FA2      	MOVWF CompTempVar2767+D'5', 1
0A0E  0E3D      	MOVLW 0x3D
0A10  6FA3      	MOVWF CompTempVar2767+D'6', 1
0A12  0E34      	MOVLW 0x34
0A14  6FA4      	MOVWF CompTempVar2767+D'7', 1
0A16  6BA5      	CLRF CompTempVar2767+D'8', 1
0A18  0E00      	MOVLW HIGH(CompTempVar2767+D'0')
0A1A  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
0A1C  0E9D      	MOVLW LOW(CompTempVar2767+D'0')
0A1E  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
0A20  0E09      	MOVLW 0x09
0A22  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
0A24  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
0A26  0E01      	MOVLW 0x01
0A28  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
0A2A  EC50F002  	CALL FCD_0c851__0005B
0A2E  51C0      	MOVF CompTempVarRet2691, W, 1
0A30  6F9C      	MOVWF FCD_0c851__0007E_1_FCR_RETVAL, 1


		} else {
0A32  D05C      	BRA	label116


			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 1);
0A34  0E31      	MOVLW 0x31
0A36  6FA1      	MOVWF CompTempVar2769+D'4', 1
0A38  0E32      	MOVLW 0x32
0A3A  6FA2      	MOVWF CompTempVar2769+D'5', 1
0A3C  6FA4      	MOVWF CompTempVar2769+D'7', 1
0A3E  0E35      	MOVLW 0x35
0A40  6FA0      	MOVWF CompTempVar2769+D'3', 1
0A42  0E3D      	MOVLW 0x3D
0A44  6FA3      	MOVWF CompTempVar2769+D'6', 1
0A46  0E41      	MOVLW 0x41
0A48  6F9D      	MOVWF CompTempVar2769, 1
0A4A  0E53      	MOVLW 0x53
0A4C  6F9F      	MOVWF CompTempVar2769+D'2', 1
0A4E  0E54      	MOVLW 0x54
0A50  6F9E      	MOVWF CompTempVar2769+D'1', 1
0A52  6BA5      	CLRF CompTempVar2769+D'8', 1
0A54  0E00      	MOVLW HIGH(CompTempVar2769+D'0')
0A56  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
0A58  0E9D      	MOVLW LOW(CompTempVar2769+D'0')
0A5A  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
0A5C  0E09      	MOVLW 0x09
0A5E  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
0A60  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
0A62  0E01      	MOVLW 0x01
0A64  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
0A66  EC50F002  	CALL FCD_0c851__0005B
0A6A  51C0      	MOVF CompTempVarRet2691, W, 1
0A6C  6F9C      	MOVWF FCD_0c851__0007E_1_FCR_RETVAL, 1


		}

	} else {
0A6E  D03E      	BRA	label116


		if (FCL_CONNECTABLE)
0A70  539B      	MOVF FCD_0c851__0007E_arg_FCL_C_00080, F, 1
0A72  E01E      	BZ	label115
0AB0            label115

		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 3);
0A74  0E31      	MOVLW 0x31
0A76  6FA1      	MOVWF CompTempVar2771+D'4', 1
0A78  0E32      	MOVLW 0x32
0A7A  6FA2      	MOVWF CompTempVar2771+D'5', 1
0A7C  6FA4      	MOVWF CompTempVar2771+D'7', 1
0A7E  0E35      	MOVLW 0x35
0A80  6FA0      	MOVWF CompTempVar2771+D'3', 1
0A82  0E3D      	MOVLW 0x3D
0A84  6FA3      	MOVWF CompTempVar2771+D'6', 1
0A86  0E41      	MOVLW 0x41
0A88  6F9D      	MOVWF CompTempVar2771, 1
0A8A  0E53      	MOVLW 0x53
0A8C  6F9F      	MOVWF CompTempVar2771+D'2', 1
0A8E  0E54      	MOVLW 0x54
0A90  6F9E      	MOVWF CompTempVar2771+D'1', 1
0A92  6BA5      	CLRF CompTempVar2771+D'8', 1
0A94  0E00      	MOVLW HIGH(CompTempVar2771+D'0')
0A96  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
0A98  0E9D      	MOVLW LOW(CompTempVar2771+D'0')
0A9A  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
0A9C  0E09      	MOVLW 0x09
0A9E  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
0AA0  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
0AA2  0E03      	MOVLW 0x03
0AA4  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
0AA6  EC50F002  	CALL FCD_0c851__0005B
0AAA  51C0      	MOVF CompTempVarRet2691, W, 1
0AAC  6F9C      	MOVWF FCD_0c851__0007E_1_FCR_RETVAL, 1


		} else {
0AAE  D01E      	BRA	label116
0AEC            label116


			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=0", 9, 1);
0AB0  0E41      	MOVLW 0x41
0AB2  6F9D      	MOVWF CompTempVar2773, 1
0AB4  0E54      	MOVLW 0x54
0AB6  6F9E      	MOVWF CompTempVar2773+D'1', 1
0AB8  0E53      	MOVLW 0x53
0ABA  6F9F      	MOVWF CompTempVar2773+D'2', 1
0ABC  0E35      	MOVLW 0x35
0ABE  6FA0      	MOVWF CompTempVar2773+D'3', 1
0AC0  0E31      	MOVLW 0x31
0AC2  6FA1      	MOVWF CompTempVar2773+D'4', 1
0AC4  0E32      	MOVLW 0x32
0AC6  6FA2      	MOVWF CompTempVar2773+D'5', 1
0AC8  0E3D      	MOVLW 0x3D
0ACA  6FA3      	MOVWF CompTempVar2773+D'6', 1
0ACC  0E30      	MOVLW 0x30
0ACE  6FA4      	MOVWF CompTempVar2773+D'7', 1
0AD0  6BA5      	CLRF CompTempVar2773+D'8', 1
0AD2  0E00      	MOVLW HIGH(CompTempVar2773+D'0')
0AD4  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
0AD6  0E9D      	MOVLW LOW(CompTempVar2773+D'0')
0AD8  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
0ADA  0E09      	MOVLW 0x09
0ADC  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
0ADE  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
0AE0  0E01      	MOVLW 0x01
0AE2  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
0AE4  EC50F002  	CALL FCD_0c851__0005B
0AE8  51C0      	MOVF CompTempVarRet2691, W, 1
0AEA  6F9C      	MOVWF FCD_0c851__0007E_1_FCR_RETVAL, 1


		}

	}

	return (FCR_RETVAL);
0AEC  519C      	MOVF FCD_0c851__0007E_1_FCR_RETVAL, W, 1
0AEE  6F9D      	MOVWF CompTempVarRet2766, 1


}
0AF0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to receive a string from the GSM modem terminated with a 0x10 CR character. Used to collect the replies from commands.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TOUT = (0x0);
0190  0100      	MOVLB 0x00
0192  6BC0      	CLRF FCD_0c851__00078_1_FCL_TOUT, 1

	MX_UINT8 FCL_LEN = (0x0);
0194  6BC1      	CLRF FCD_0c851__00078_1_FCL_LEN, 1

	MX_UINT8 FCR_RETVAL;


	FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
0196  5184      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W, 1
0198  6FC1      	MOVWF FCD_0c851__00078_1_FCL_LEN, 1

	FCV_0c851_Bluetooth2__RX_DONE = 0;
019A  6B83      	CLRF gbl_FCV_0c851_Bluetooth2___00001, 1

	FCV_0c851_Bluetooth2__RX_LENGTH = 0;
019C  6B84      	CLRF gbl_FCV_0c851_Bluetooth2___00002, 1

	FCV_0c851_Bluetooth2__RX_IDX = 0;
019E  6B82      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX, 1


	while ((FCV_0c851_Bluetooth2__RX_DONE == 0) && (FCL_TOUT < 255))
01A0            label21
01A0  5383      	MOVF gbl_FCV_0c851_Bluetooth2___00001, F, 1
01A2  E113      	BNZ	label23
01A4  0EFF      	MOVLW 0xFF
01A6  61C0      	CPFSLT FCD_0c851__00078_1_FCL_TOUT, 1
01A8  D010      	BRA	label23
01C8  D7EB      	BRA	label21
01CA            label23

	{

		FCL_TOUT = FCL_TOUT + 1;
01AA  29C0      	INCF FCD_0c851__00078_1_FCL_TOUT, W, 1
01AC  6FC0      	MOVWF FCD_0c851__00078_1_FCL_TOUT, 1


		if (FCL_LEN != FCV_0c851_Bluetooth2__RX_LENGTH)
01AE  5184      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W, 1
01B0  63C1      	CPFSEQ FCD_0c851__00078_1_FCL_LEN, 1
01B2  6384      	CPFSEQ gbl_FCV_0c851_Bluetooth2___00002, 1
01B4  D003      	BRA	label22
01BC            label22

		{

			FCL_TOUT = 0;
01B6  6BC0      	CLRF FCD_0c851__00078_1_FCL_TOUT, 1

			FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
01B8  5184      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W, 1
01BA  6FC1      	MOVWF FCD_0c851__00078_1_FCL_LEN, 1


		// } else {

		}

		FCI_DELAYINT_US(500);
01BC  0EF4      	MOVLW 0xF4
01BE  6FC3      	MOVWF FCI_DELAYI_00038_arg_Delay, 1
01C0  0E01      	MOVLW 0x01
01C2  6FC4      	MOVWF FCI_DELAYI_00038_arg_Delay+D'1', 1
01C4  EC95F000  	CALL FCI_DELAYI_00038



	}

	if (FCL_TOUT == 255)
01CA  29C0      	INCF FCD_0c851__00078_1_FCL_TOUT, W, 1
01CC  E104      	BNZ	label24
01D6            label24

	{

		FCV_0c851_Bluetooth2__RX_DONE = 0;
01CE  6B83      	CLRF gbl_FCV_0c851_Bluetooth2___00001, 1

		FCV_0c851_Bluetooth2__RX_LENGTH = 0;
01D0  6B84      	CLRF gbl_FCV_0c851_Bluetooth2___00002, 1

		FCR_RETVAL = 0;
01D2  6BC2      	CLRF FCD_0c851__00078_1_FCR_RETVAL, 1


	} else {
01D4  D002      	BRA	label25
01DA            label25


		FCR_RETVAL = 1;
01D6  0E01      	MOVLW 0x01
01D8  6FC2      	MOVWF FCD_0c851__00078_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
01DA  51C2      	MOVF FCD_0c851__00078_1_FCR_RETVAL, W, 1
01DC  6FC3      	MOVWF CompTempVarRet2754, 1


}
01DE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Restores the factory settings to firmware using the AT&F* command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&F*", 6, 1);
09B6  0E41      	MOVLW 0x41
09B8  0100      	MOVLB 0x00
09BA  6F9B      	MOVWF CompTempVar2776, 1
09BC  0E54      	MOVLW 0x54
09BE  6F9C      	MOVWF CompTempVar2776+D'1', 1
09C0  0E26      	MOVLW 0x26
09C2  6F9D      	MOVWF CompTempVar2776+D'2', 1
09C4  0E46      	MOVLW 0x46
09C6  6F9E      	MOVWF CompTempVar2776+D'3', 1
09C8  0E2A      	MOVLW 0x2A
09CA  6F9F      	MOVWF CompTempVar2776+D'4', 1
09CC  6BA0      	CLRF CompTempVar2776+D'5', 1
09CE  0E00      	MOVLW HIGH(CompTempVar2776+D'0')
09D0  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
09D2  0E9B      	MOVLW LOW(CompTempVar2776+D'0')
09D4  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
09D6  0E06      	MOVLW 0x06
09D8  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
09DA  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
09DC  0E01      	MOVLW 0x01
09DE  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
09E0  EC50F002  	CALL FCD_0c851__0005B
09E4  51C0      	MOVF CompTempVarRet2691, W, 1
09E6  6F9A      	MOVWF FCD_0c851__00081_1_FCR_RETVAL, 1


	return (FCR_RETVAL);
09E8  519A      	MOVF FCD_0c851__00081_1_FCR_RETVAL, W, 1
09EA  6F9B      	MOVWF CompTempVarRet2775, 1


}
09EC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets up the GSM module.
       :Returns 0 for OK, 255 for no reply and 254 for command fail.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__Initialise()

{
	//Définitions des variables locales
	#define FCLsz_CMDSTR 20
	MX_CHAR FCL_CMDSTR[FCLsz_CMDSTR];
	MX_UINT8 FCR_RETVAL;


	FCP_SET(B, C, 0x2, 0x1, 0);
0F08  0100      	MOVLB 0x00
0F0A  6B9A      	CLRF FCD_0c851__00051_2_ptmp, 1
0F0C  9294      	BCF gbl_trisc,1
0F0E  539A      	MOVF FCD_0c851__00051_2_ptmp, F, 1
0F10  E004      	BZ	label147
0F12  0E02      	MOVLW 0x02
0F14  108B      	IORWF gbl_latc, W
0F16  6E82      	MOVWF gbl_portc
0F18  D003      	BRA	label148
0F1A            label147
0F1A  0EFD      	MOVLW 0xFD
0F1C  148B      	ANDWF gbl_latc, W
0F1E  6E82      	MOVWF gbl_portc
0F20            label148


	FCI_DELAYBYTE_MS(100);
0F20  0E64      	MOVLW 0x64
0F22  6F9A      	MOVWF delay_ms_00000_arg_del, 1
0F24  EC0BF000  	CALL delay_ms_00000


	FCP_SET(B, C, 0x2, 0x1, 1);
0F28  0E01      	MOVLW 0x01
0F2A  6F9A      	MOVWF FCD_0c851__00051_13_ptmp, 1
0F2C  9294      	BCF gbl_trisc,1
0F2E  539A      	MOVF FCD_0c851__00051_13_ptmp, F, 1
0F30  E004      	BZ	label149
0F32  0E02      	MOVLW 0x02
0F34  108B      	IORWF gbl_latc, W
0F36  6E82      	MOVWF gbl_portc
0F38  D003      	BRA	label150
0F3A            label149
0F3A  0EFD      	MOVLW 0xFD
0F3C  148B      	ANDWF gbl_latc, W
0F3E  6E82      	MOVWF gbl_portc
0F40            label150


	FCR_RETVAL = 0;
0F40  6B99      	CLRF FCD_0c851__00051_1_FCR_RETVAL, 1


	FC_CAL_UART_Init_1();
0F42  ECE6F003  	CALL FC_CAL_UAR_00072


	FCI_DELAYBYTE_MS(10);
0F46  0E0A      	MOVLW 0x0A
0F48  6F9A      	MOVWF delay_ms_00000_arg_del, 1
0F4A  EC0BF000  	CALL delay_ms_00000


	FCD_0c851_Bluetooth2__StringReceive();
0F4E  ECC8F000  	CALL FCD_0c851__00078


	#if (1)

		FCD_0c851_Bluetooth2__RestoreFactorySettings();
0F52  ECDBF004  	CALL FCD_0c851__00081


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCI_SHEAD("AT+BTN=\"",9, "J2",3, FCL_CMDSTR,20);
0F56  0E22      	MOVLW 0x22
0F58  6FA2      	MOVWF CompTempVar2631+D'7', 1
0F5A  0E2B      	MOVLW 0x2B
0F5C  6F9D      	MOVWF CompTempVar2631+D'2', 1
0F5E  0E3D      	MOVLW 0x3D
0F60  6FA1      	MOVWF CompTempVar2631+D'6', 1
0F62  0E41      	MOVLW 0x41
0F64  6F9B      	MOVWF CompTempVar2631, 1
0F66  0E42      	MOVLW 0x42
0F68  6F9E      	MOVWF CompTempVar2631+D'3', 1
0F6A  0E4E      	MOVLW 0x4E
0F6C  6FA0      	MOVWF CompTempVar2631+D'5', 1
0F6E  0E54      	MOVLW 0x54
0F70  6F9C      	MOVWF CompTempVar2631+D'1', 1
0F72  6F9F      	MOVWF CompTempVar2631+D'4', 1
0F74  6BA3      	CLRF CompTempVar2631+D'8', 1
0F76  0E00      	MOVLW HIGH(CompTempVar2631+D'0')
0F78  6FB9      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1
0F7A  0E9B      	MOVLW LOW(CompTempVar2631+D'0')
0F7C  6FB8      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
0F7E  0E09      	MOVLW 0x09
0F80  6FC3      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1
0F82  0E4A      	MOVLW 0x4A
0F84  6FA6      	MOVWF CompTempVar2632, 1
0F86  0E32      	MOVLW 0x32
0F88  6FA7      	MOVWF CompTempVar2632+D'1', 1
0F8A  6BA8      	CLRF CompTempVar2632+D'2', 1
0F8C  0E00      	MOVLW HIGH(CompTempVar2632+D'0')
0F8E  6FC5      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1', 1
0F90  0EA6      	MOVLW LOW(CompTempVar2632+D'0')
0F92  6FC4      	MOVWF FCI_SHEAD_00000_arg_sSrc2, 1
0F94  0E03      	MOVLW 0x03
0F96  6FC6      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1
0F98  0E00      	MOVLW HIGH(FCD_0c851__00051_1_FCL_CMDSTR+D'0')
0F9A  6FC8      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0F9C  0E85      	MOVLW LOW(FCD_0c851__00051_1_FCL_CMDSTR+D'0')
0F9E  6FC7      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0FA0  0E14      	MOVLW 0x14
0FA2  6FC9      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0FA4  EC61F001  	CALL FCI_SHEAD_00000

	FCI_SHEAD(FCL_CMDSTR,FCLsz_CMDSTR, "\"",2, FCL_CMDSTR,20);
0FA8  0E00      	MOVLW HIGH(FCD_0c851__00051_1_FCL_CMDSTR+D'0')
0FAA  6FB9      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1
0FAC  0E85      	MOVLW LOW(FCD_0c851__00051_1_FCL_CMDSTR+D'0')
0FAE  6FB8      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
0FB0  0E14      	MOVLW 0x14
0FB2  6FC3      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1
0FB4  0E22      	MOVLW 0x22
0FB6  6F9B      	MOVWF CompTempVar2636, 1
0FB8  6B9C      	CLRF CompTempVar2636+D'1', 1
0FBA  0E00      	MOVLW HIGH(CompTempVar2636+D'0')
0FBC  6FC5      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1', 1
0FBE  0E9B      	MOVLW LOW(CompTempVar2636+D'0')
0FC0  6FC4      	MOVWF FCI_SHEAD_00000_arg_sSrc2, 1
0FC2  0E02      	MOVLW 0x02
0FC4  6FC6      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1
0FC6  0E00      	MOVLW HIGH(FCD_0c851__00051_1_FCL_CMDSTR+D'0')
0FC8  6FC8      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0FCA  0E85      	MOVLW LOW(FCD_0c851__00051_1_FCL_CMDSTR+D'0')
0FCC  6FC7      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0FCE  0E14      	MOVLW 0x14
0FD0  6FC9      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0FD2  EC61F001  	CALL FCI_SHEAD_00000


	FCD_0c851_Bluetooth2__SendCommand(FCL_CMDSTR, FCLsz_CMDSTR, 1);
0FD6  0E00      	MOVLW HIGH(FCD_0c851__00051_1_FCL_CMDSTR+D'0')
0FD8  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
0FDA  0E85      	MOVLW LOW(FCD_0c851__00051_1_FCL_CMDSTR+D'0')
0FDC  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
0FDE  0E14      	MOVLW 0x14
0FE0  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
0FE2  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
0FE4  0E01      	MOVLW 0x01
0FE6  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
0FE8  EC50F002  	CALL FCD_0c851__0005B


	FCD_0c851_Bluetooth2__SetPairKey("1379", 5);
0FEC  0E31      	MOVLW 0x31
0FEE  6F9C      	MOVWF CompTempVar2641, 1
0FF0  0E33      	MOVLW 0x33
0FF2  6F9D      	MOVWF CompTempVar2641+D'1', 1
0FF4  0E37      	MOVLW 0x37
0FF6  6F9E      	MOVWF CompTempVar2641+D'2', 1
0FF8  0E39      	MOVLW 0x39
0FFA  6F9F      	MOVWF CompTempVar2641+D'3', 1
0FFC  6BA0      	CLRF CompTempVar2641+D'4', 1
0FFE  0E00      	MOVLW HIGH(CompTempVar2641+D'0')
1000  6F9B      	MOVWF FCD_0c851__00074_arg_FCL_PAIRKEY+D'1', 1
1002  0E9C      	MOVLW LOW(CompTempVar2641+D'0')
1004  6F9A      	MOVWF FCD_0c851__00074_arg_FCL_PAIRKEY, 1
1006  0E05      	MOVLW 0x05
1008  6FA1      	MOVWF FCD_0c851__00074_arg_FCLsz_00075, 1
100A  6BA2      	CLRF FCD_0c851__00074_arg_FCLsz_00075+D'1', 1
100C  ECA9F005  	CALL FCD_0c851__00074


	FCD_0c851_Bluetooth2__SetMode(1, 1);
1010  0E01      	MOVLW 0x01
1012  6F9A      	MOVWF FCD_0c851__0007E_arg_FCL_D_0007F, 1
1014  6F9B      	MOVWF FCD_0c851__0007E_arg_FCL_C_00080, 1
1016  ECF7F004  	CALL FCD_0c851__0007E


	FCR_RETVAL = FCD_0c851_Bluetooth2__SaveSettings();
101A  EC79F005  	CALL FCD_0c851__0007C
101E  519B      	MOVF CompTempVarRet2761, W, 1
1020  6F99      	MOVWF FCD_0c851__00051_1_FCR_RETVAL, 1


	return (FCR_RETVAL);
1022  5199      	MOVF FCD_0c851__00051_1_FCR_RETVAL, W, 1
1024  6F9A      	MOVWF CompTempVarRet2630, 1


	//Définitions des variables locales
	#undef FCLsz_CMDSTR
}
1026  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :V??rification de la connexion des deux modules bluetooth
\*=----------------------------------------------------------------------=*/
void FCM_BT_CHECK_CONNECTION()
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_INITIALISATION()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Start()
	FCD_0ad31_lcd_eb005__Start();
1288  EC4AF008  	CALL FCD_04071__00050


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::Initialise()
	FCD_0c851_Bluetooth2__Initialise();
128C  EC84F007  	CALL FCD_0c851__00051


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendScript(1)
	FCD_0c851_Bluetooth2__SendScript(1);
1290  0E01      	MOVLW 0x01
1292  6F85      	MOVWF FCD_0c851__00052_arg_FCL_IDX, 1
1294  ECA5F006  	CALL FCD_0c851__00052


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendScript(2)
	FCD_0c851_Bluetooth2__SendScript(2);
1298  0E02      	MOVLW 0x02
129A  6F85      	MOVWF FCD_0c851__00052_arg_FCL_IDX, 1
129C  ECA5F006  	CALL FCD_0c851__00052


	// Appel d'une Macro
	// Appel d'une Macro: SET_ASCII_CHARACTERS()
	FCM_SET_ASCII_CHARACTERS();
12A0  EC65F006  	CALL FCM_SET_AS_00054


}
12A4  EF14F00A  	GOTO	label170


/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro DECRYPT_BT_RECEIVE_DATA :
       :  received_data[20] : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCM_DECRYPT_BT_RECEIVE_DATA(MX_CHAR *PFCL_RECEIVED_DATA)
{
	//Définitions des variables locales
	MX_SINT16 FCL_DATA_LENGTH; // Taille des donn??es
	MX_SINT16 FCL_LOOP = (0);


	#define FCLsz_RECEIVED_DATA 20
	MX_CHAR FCL_RECEIVED_DATA[FCLsz_RECEIVED_DATA];
	FCI_CONCATENATE(PFCL_RECEIVED_DATA,FCLsz_RECEIVED_DATA,"",0,FCL_RECEIVED_DATA,FCLsz_RECEIVED_DATA);
	// Calcul
	// Calcul:
	//  .data_length = Length$ (.received_data)
	FCL_DATA_LENGTH = FCI_GETLENGTH(FCL_RECEIVED_DATA, FCLsz_RECEIVED_DATA);

	// Boucle
	// Boucle: While .loop == .data_length
	while (!(FCL_LOOP == FCL_DATA_LENGTH))
	{

		//Commentaire:
		//Incrémentation

		// Calcul
		// Calcul:
		//  .loop = .loop + 1
		FCL_LOOP = FCL_LOOP + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_RECEIVED_DATA
}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_CHECK_BT_GETTING()
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_SET_ASCII_CHARACTERS()

{

	// Calcul
	// Calcul:
	//  // numbers
	//  ascii[48] = 0
	//  ascii[49] = 1
	//  ascii[50] = 2
	//  ascii[51] = 3
	//  ascii[52] = 4
	//  ascii[53] = 5
	//  ascii[54] = 6
	//  ascii[55] = 7
	//  ascii[56] = 8
	//  ascii[57] = 9
	//  ascii[58] = 10
	//  // letters
	//  ascii[97] = 'a'
	//  ascii[98] = 'b'
	//  ascii[99] = 'c'
	//  ascii[100] = 'd'
	//  ascii[101] = 'e'
	//  ascii[102] = 'f'
	//  // symbols
	//  ascii[43] = '+'
	FCV_ASCII[48] = 0;
0CCA  0101      	MOVLB 0x01
0CCC  6B30      	CLRF gbl_FCV_ASCII+D'48', 1

	FCV_ASCII[49] = 1;
0CCE  0E01      	MOVLW 0x01
0CD0  6F31      	MOVWF gbl_FCV_ASCII+D'49', 1

	FCV_ASCII[50] = 2;
0CD2  0E02      	MOVLW 0x02
0CD4  6F32      	MOVWF gbl_FCV_ASCII+D'50', 1

	FCV_ASCII[51] = 3;
0CD6  0E03      	MOVLW 0x03
0CD8  6F33      	MOVWF gbl_FCV_ASCII+D'51', 1

	FCV_ASCII[52] = 4;
0CDA  0E04      	MOVLW 0x04
0CDC  6F34      	MOVWF gbl_FCV_ASCII+D'52', 1

	FCV_ASCII[53] = 5;
0CDE  0E05      	MOVLW 0x05
0CE0  6F35      	MOVWF gbl_FCV_ASCII+D'53', 1

	FCV_ASCII[54] = 6;
0CE2  0E06      	MOVLW 0x06
0CE4  6F36      	MOVWF gbl_FCV_ASCII+D'54', 1

	FCV_ASCII[55] = 7;
0CE6  0E07      	MOVLW 0x07
0CE8  6F37      	MOVWF gbl_FCV_ASCII+D'55', 1

	FCV_ASCII[56] = 8;
0CEA  0E08      	MOVLW 0x08
0CEC  6F38      	MOVWF gbl_FCV_ASCII+D'56', 1

	FCV_ASCII[57] = 9;
0CEE  0E09      	MOVLW 0x09
0CF0  6F39      	MOVWF gbl_FCV_ASCII+D'57', 1

	FCV_ASCII[58] = 10;
0CF2  0E0A      	MOVLW 0x0A
0CF4  6F3A      	MOVWF gbl_FCV_ASCII+D'58', 1

	FCV_ASCII[97] = 'a';
0CF6  0E61      	MOVLW 0x61
0CF8  6F61      	MOVWF gbl_FCV_ASCII+D'97', 1

	FCV_ASCII[98] = 'b';
0CFA  0E62      	MOVLW 0x62
0CFC  6F62      	MOVWF gbl_FCV_ASCII+D'98', 1

	FCV_ASCII[99] = 'c';
0CFE  0E63      	MOVLW 0x63
0D00  6F63      	MOVWF gbl_FCV_ASCII+D'99', 1

	FCV_ASCII[100] = 'd';
0D02  0E64      	MOVLW 0x64
0D04  6F64      	MOVWF gbl_FCV_ASCII+D'100', 1

	FCV_ASCII[101] = 'e';
0D06  0E65      	MOVLW 0x65
0D08  6F65      	MOVWF gbl_FCV_ASCII+D'101', 1

	FCV_ASCII[102] = 'f';
0D0A  0E66      	MOVLW 0x66
0D0C  6F66      	MOVWF gbl_FCV_ASCII+D'102', 1

	FCV_ASCII[43] = '+';
0D0E  0E2B      	MOVLW 0x2B
0D10  6F2B      	MOVWF gbl_FCV_ASCII+D'43', 1


}
0D12  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_SEND_DATA()

{

	// Boucle
	// Boucle: While 1
	while (1)
11B8            label166
1286  D798      	BRA	label166

	{

		// Calcul
		// Calcul:
		//  octet = random ()
		//  return = "chevre_" + ToString$ (octet)
		FCV_OCTET = rand();
11B8  EC35F006  	CALL rand_00000
11BC  5187      	MOVF CompTempVarRet621, W, 1
11BE  6F80      	MOVWF gbl_FCV_OCTET, 1

		FCI_SHEAD("chevre_",8, FCI_TOSTRING(FCV_OCTET, FCI_TMP_STR,20),20, FCV_RETURN,20);
11C0  0E5F      	MOVLW 0x5F
11C2  6F8B      	MOVWF CompTempVar2683+D'6', 1
11C4  0E63      	MOVLW 0x63
11C6  6F85      	MOVWF CompTempVar2683, 1
11C8  0E65      	MOVLW 0x65
11CA  6F87      	MOVWF CompTempVar2683+D'2', 1
11CC  6F8A      	MOVWF CompTempVar2683+D'5', 1
11CE  0E68      	MOVLW 0x68
11D0  6F86      	MOVWF CompTempVar2683+D'1', 1
11D2  0E72      	MOVLW 0x72
11D4  6F89      	MOVWF CompTempVar2683+D'4', 1
11D6  0E76      	MOVLW 0x76
11D8  6F88      	MOVWF CompTempVar2683+D'3', 1
11DA  6B8C      	CLRF CompTempVar2683+D'7', 1
11DC  0E00      	MOVLW HIGH(CompTempVar2683+D'0')
11DE  6FB9      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1
11E0  0E85      	MOVLW LOW(CompTempVar2683+D'0')
11E2  6FB8      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
11E4  0E08      	MOVLW 0x08
11E6  6FC3      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1
11E8  5180      	MOVF gbl_FCV_OCTET, W, 1
11EA  6F92      	MOVWF FCI_TOSTRI_00042_arg_iSrc1, 1
11EC  6B93      	CLRF FCI_TOSTRI_00042_arg_iSrc1+D'1', 1
11EE  6B94      	CLRF FCI_TOSTRI_00042_arg_iSrc1+D'2', 1
11F0  6B95      	CLRF FCI_TOSTRI_00042_arg_iSrc1+D'3', 1
11F2  0E00      	MOVLW HIGH(gbl_FCI_TMP_STR+D'0')
11F4  6F97      	MOVWF FCI_TOSTRI_00042_arg_sDst+D'1', 1
11F6  0E37      	MOVLW LOW(gbl_FCI_TMP_STR+D'0')
11F8  6F96      	MOVWF FCI_TOSTRI_00042_arg_sDst, 1
11FA  0E14      	MOVLW 0x14
11FC  6F98      	MOVWF FCI_TOSTRI_00042_arg_iDst_len, 1
11FE  ECF1F003  	CALL FCI_TOSTRI_00042
1202  51A3      	MOVF CompTempVarRet1863, W, 1
1204  6FC4      	MOVWF FCI_SHEAD_00000_arg_sSrc2, 1
1206  51A4      	MOVF CompTempVarRet1863+D'1', W, 1
1208  6FC5      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1', 1
120A  0E14      	MOVLW 0x14
120C  6FC6      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1
120E  0E00      	MOVLW HIGH(gbl_FCV_RETURN+D'0')
1210  6FC8      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
1212  0E4B      	MOVLW LOW(gbl_FCV_RETURN+D'0')
1214  6FC7      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
1216  0E14      	MOVLW 0x14
1218  6FC9      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
121A  EC61F001  	CALL FCI_SHEAD_00000


		// Appel de la Routine Composant
		// Appel de la Routine Composant: Bluetooth2::SendCommand(return, 1)
		FCD_0c851_Bluetooth2__SendCommand(FCV_RETURN, FCVsz_RETURN, 1);
121E  0E00      	MOVLW HIGH(gbl_FCV_RETURN+D'0')
1220  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
1222  0E4B      	MOVLW LOW(gbl_FCV_RETURN+D'0')
1224  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
1226  0E14      	MOVLW 0x14
1228  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
122A  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
122C  0E01      	MOVLW 0x01
122E  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
1230  EC50F002  	CALL FCD_0c851__0005B


		#if 0 // Disabled code
		// Appel de la Routine Composant
		// Appel de la Routine Composant: Bluetooth2::SendByte(octet)
		FCD_0c851_Bluetooth2__SendByte(FCV_OCTET);

		#endif // #if 0: Disabled code
		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString("Generated: ")
		FCD_0ad31_lcd_eb005__PrintString("Generated: ", 12);
1234  0E20      	MOVLW 0x20
1236  6F8F      	MOVWF CompTempVar2689+D'10', 1
1238  0E3A      	MOVLW 0x3A
123A  6F8E      	MOVWF CompTempVar2689+D'9', 1
123C  0E47      	MOVLW 0x47
123E  6F85      	MOVWF CompTempVar2689, 1
1240  0E61      	MOVLW 0x61
1242  6F8A      	MOVWF CompTempVar2689+D'5', 1
1244  0E64      	MOVLW 0x64
1246  6F8D      	MOVWF CompTempVar2689+D'8', 1
1248  0E65      	MOVLW 0x65
124A  6F86      	MOVWF CompTempVar2689+D'1', 1
124C  6F88      	MOVWF CompTempVar2689+D'3', 1
124E  6F8C      	MOVWF CompTempVar2689+D'7', 1
1250  0E6E      	MOVLW 0x6E
1252  6F87      	MOVWF CompTempVar2689+D'2', 1
1254  0E72      	MOVLW 0x72
1256  6F89      	MOVWF CompTempVar2689+D'4', 1
1258  0E74      	MOVLW 0x74
125A  6F8B      	MOVWF CompTempVar2689+D'6', 1
125C  6B90      	CLRF CompTempVar2689+D'11', 1
125E  0E00      	MOVLW HIGH(CompTempVar2689+D'0')
1260  6F93      	MOVWF FCD_04071__0005D_arg_FCL_TEXT+D'1', 1
1262  0E85      	MOVLW LOW(CompTempVar2689+D'0')
1264  6F92      	MOVWF FCD_04071__0005D_arg_FCL_TEXT, 1
1266  0E0C      	MOVLW 0x0C
1268  6FA1      	MOVWF FCD_04071__0005D_arg_FCLsz_TEXT, 1
126A  6BA2      	CLRF FCD_04071__0005D_arg_FCLsz_TEXT+D'1', 1
126C  EC1AF006  	CALL FCD_04071__0005D


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintNumber(octet)
		FCD_0ad31_lcd_eb005__PrintNumber(FCV_OCTET);
1270  5180      	MOVF gbl_FCV_OCTET, W, 1
1272  6F86      	MOVWF FCD_04071__0005E_arg_FCL_NUMBER, 1
1274  6B87      	CLRF FCD_04071__0005E_arg_FCL_NUMBER+D'1', 1
1276  EC2EF008  	CALL FCD_04071__0005E


		// Pause
		// Pause: 20 s
		FCI_DELAYBYTE_S(20);
127A  0E14      	MOVLW 0x14
127C  6F86      	MOVWF delay_s_00000_arg_del, 1
127E  EC33F000  	CALL delay_s_00000


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();
1282  EC06F006  	CALL FCD_04071__0005F



	}

}


/*=----------------------------------------------------------------------=*\
   Use :Connexion au joueur 1
\*=----------------------------------------------------------------------=*/
void FCM_BT_CONNECTION()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: return_cmd=Bluetooth2::SendCommand("ATD0080980B938A", 1)
	FCV_RETURN_CMD = FCD_0c851_Bluetooth2__SendCommand("ATD0080980B938A", 16, 1);
12A8  0E30      	MOVLW 0x30
12AA  0100      	MOVLB 0x00
12AC  6F89      	MOVWF CompTempVar2703+D'3', 1
12AE  6F8A      	MOVWF CompTempVar2703+D'4', 1
12B0  6F8C      	MOVWF CompTempVar2703+D'6', 1
12B2  6F8F      	MOVWF CompTempVar2703+D'9', 1
12B4  0E33      	MOVLW 0x33
12B6  6F92      	MOVWF CompTempVar2703+D'12', 1
12B8  0E38      	MOVLW 0x38
12BA  6F8B      	MOVWF CompTempVar2703+D'5', 1
12BC  6F8E      	MOVWF CompTempVar2703+D'8', 1
12BE  6F93      	MOVWF CompTempVar2703+D'13', 1
12C0  0E39      	MOVLW 0x39
12C2  6F8D      	MOVWF CompTempVar2703+D'7', 1
12C4  6F91      	MOVWF CompTempVar2703+D'11', 1
12C6  0E41      	MOVLW 0x41
12C8  6F86      	MOVWF CompTempVar2703, 1
12CA  6F94      	MOVWF CompTempVar2703+D'14', 1
12CC  0E42      	MOVLW 0x42
12CE  6F90      	MOVWF CompTempVar2703+D'10', 1
12D0  0E44      	MOVLW 0x44
12D2  6F88      	MOVWF CompTempVar2703+D'2', 1
12D4  0E54      	MOVLW 0x54
12D6  6F87      	MOVWF CompTempVar2703+D'1', 1
12D8  6B95      	CLRF CompTempVar2703+D'15', 1
12DA  0E00      	MOVLW HIGH(CompTempVar2703+D'0')
12DC  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
12DE  0E86      	MOVLW LOW(CompTempVar2703+D'0')
12E0  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
12E2  0E10      	MOVLW 0x10
12E4  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
12E6  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
12E8  0E01      	MOVLW 0x01
12EA  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
12EC  EC50F002  	CALL FCD_0c851__0005B
12F0  51C0      	MOVF CompTempVarRet2691, W, 1
12F2  6F81      	MOVWF gbl_FCV_RETURN_CMD, 1


	// Pause
	// Pause: 3 s
	FCI_DELAYBYTE_S(3);
12F4  0E03      	MOVLW 0x03
12F6  6F86      	MOVWF delay_s_00000_arg_del, 1
12F8  EC33F000  	CALL delay_s_00000


	// Calcul
	// Calcul:
	//  loop = 0
	FCV_LOOP = 0;
12FC  6A75      	CLRF gbl_FCV_LOOP
12FE  6A76      	CLRF gbl_FCV_LOOP+D'1'


	// Boucle
	// Boucle: While loop == 8
	while (!(FCV_LOOP == 8))
1300            label167
1300  6B85      	CLRF CompTempVar2702, 1
1302  0E08      	MOVLW 0x08
1304  6275      	CPFSEQ gbl_FCV_LOOP
1306  D003      	BRA	label168
1308  5076      	MOVF gbl_FCV_LOOP+D'1', W
130A  B4D8      	BTFSC STATUS,Z
130C  2B85      	INCF CompTempVar2702, F, 1
130E            label168
130E  6785      	TSTFSZ CompTempVar2702, 1
1310  D073      	BRA	label169
13F6  D784      	BRA	label167
13F8            label169

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: return_cmd=Bluetooth2::SendCommand("ATD0080980B938A", 1)
		FCV_RETURN_CMD = FCD_0c851_Bluetooth2__SendCommand("ATD0080980B938A", 16, 1);
1312  0E30      	MOVLW 0x30
1314  6F89      	MOVWF CompTempVar2705+D'3', 1
1316  6F8A      	MOVWF CompTempVar2705+D'4', 1
1318  6F8C      	MOVWF CompTempVar2705+D'6', 1
131A  6F8F      	MOVWF CompTempVar2705+D'9', 1
131C  0E33      	MOVLW 0x33
131E  6F92      	MOVWF CompTempVar2705+D'12', 1
1320  0E38      	MOVLW 0x38
1322  6F8B      	MOVWF CompTempVar2705+D'5', 1
1324  6F8E      	MOVWF CompTempVar2705+D'8', 1
1326  6F93      	MOVWF CompTempVar2705+D'13', 1
1328  0E39      	MOVLW 0x39
132A  6F8D      	MOVWF CompTempVar2705+D'7', 1
132C  6F91      	MOVWF CompTempVar2705+D'11', 1
132E  0E41      	MOVLW 0x41
1330  6F86      	MOVWF CompTempVar2705, 1
1332  6F94      	MOVWF CompTempVar2705+D'14', 1
1334  0E42      	MOVLW 0x42
1336  6F90      	MOVWF CompTempVar2705+D'10', 1
1338  0E44      	MOVLW 0x44
133A  6F88      	MOVWF CompTempVar2705+D'2', 1
133C  0E54      	MOVLW 0x54
133E  6F87      	MOVWF CompTempVar2705+D'1', 1
1340  6B95      	CLRF CompTempVar2705+D'15', 1
1342  0E00      	MOVLW HIGH(CompTempVar2705+D'0')
1344  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
1346  0E86      	MOVLW LOW(CompTempVar2705+D'0')
1348  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
134A  0E10      	MOVLW 0x10
134C  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
134E  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
1350  0E01      	MOVLW 0x01
1352  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
1354  EC50F002  	CALL FCD_0c851__0005B
1358  51C0      	MOVF CompTempVarRet2691, W, 1
135A  6F81      	MOVWF gbl_FCV_RETURN_CMD, 1


		// Pause
		// Pause: 100 ms
		FCI_DELAYBYTE_MS(100);
135C  0E64      	MOVLW 0x64
135E  6F9A      	MOVWF delay_ms_00000_arg_del, 1
1360  EC0BF000  	CALL delay_ms_00000


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString("ATD return: ")
		FCD_0ad31_lcd_eb005__PrintString("ATD return: ", 13);
1364  0E20      	MOVLW 0x20
1366  6F97      	MOVWF CompTempVar2707+D'3', 1
1368  6F9F      	MOVWF CompTempVar2707+D'11', 1
136A  0E3A      	MOVLW 0x3A
136C  6F9E      	MOVWF CompTempVar2707+D'10', 1
136E  0E41      	MOVLW 0x41
1370  6F94      	MOVWF CompTempVar2707, 1
1372  0E44      	MOVLW 0x44
1374  6F96      	MOVWF CompTempVar2707+D'2', 1
1376  0E54      	MOVLW 0x54
1378  6F95      	MOVWF CompTempVar2707+D'1', 1
137A  0E65      	MOVLW 0x65
137C  6F99      	MOVWF CompTempVar2707+D'5', 1
137E  0E6E      	MOVLW 0x6E
1380  6F9D      	MOVWF CompTempVar2707+D'9', 1
1382  0E72      	MOVLW 0x72
1384  6F98      	MOVWF CompTempVar2707+D'4', 1
1386  6F9C      	MOVWF CompTempVar2707+D'8', 1
1388  0E74      	MOVLW 0x74
138A  6F9A      	MOVWF CompTempVar2707+D'6', 1
138C  0E75      	MOVLW 0x75
138E  6F9B      	MOVWF CompTempVar2707+D'7', 1
1390  6BA0      	CLRF CompTempVar2707+D'12', 1
1392  0E00      	MOVLW HIGH(CompTempVar2707+D'0')
1394  6F93      	MOVWF FCD_04071__0005D_arg_FCL_TEXT+D'1', 1
1396  0E94      	MOVLW LOW(CompTempVar2707+D'0')
1398  6F92      	MOVWF FCD_04071__0005D_arg_FCL_TEXT, 1
139A  0E0D      	MOVLW 0x0D
139C  6FA1      	MOVWF FCD_04071__0005D_arg_FCLsz_TEXT, 1
139E  6BA2      	CLRF FCD_04071__0005D_arg_FCLsz_TEXT+D'1', 1
13A0  EC1AF006  	CALL FCD_04071__0005D


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintNumber(return_cmd)
		FCD_0ad31_lcd_eb005__PrintNumber(FCV_RETURN_CMD);
13A4  5181      	MOVF gbl_FCV_RETURN_CMD, W, 1
13A6  6F86      	MOVWF FCD_04071__0005E_arg_FCL_NUMBER, 1
13A8  6B87      	CLRF FCD_04071__0005E_arg_FCL_NUMBER+D'1', 1
13AA  EC2EF008  	CALL FCD_04071__0005E


		// Pause
		// Pause: 450 ms
		FCI_DELAYINT_MS(450);
13AE  0EC2      	MOVLW 0xC2
13B0  6F86      	MOVWF FCI_DELAYI_00039_arg_Delay, 1
13B2  0E01      	MOVLW 0x01
13B4  6F87      	MOVWF FCI_DELAYI_00039_arg_Delay+D'1', 1
13B6  EC8AF006  	CALL FCI_DELAYI_00039


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::ClearLine(0)
		FCD_0ad31_lcd_eb005__ClearLine(0);
13BA  6B86      	CLRF FCD_04071__00061_arg_FCL_LINE, 1
13BC  EC14F008  	CALL FCD_04071__00061


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Cursor(loop, 1)
		FCD_0ad31_lcd_eb005__Cursor(FCV_LOOP, 1);
13C0  5075      	MOVF gbl_FCV_LOOP, W
13C2  6F88      	MOVWF FCD_04071__00062_arg_FCL_X, 1
13C4  0E01      	MOVLW 0x01
13C6  6F89      	MOVWF FCD_04071__00062_arg_FCL_Y, 1
13C8  ECF4F005  	CALL FCD_04071__00062


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString(".")
		FCD_0ad31_lcd_eb005__PrintString(".", 2);
13CC  0E2E      	MOVLW 0x2E
13CE  6F86      	MOVWF CompTempVar2709, 1
13D0  6B87      	CLRF CompTempVar2709+D'1', 1
13D2  0E00      	MOVLW HIGH(CompTempVar2709+D'0')
13D4  6F93      	MOVWF FCD_04071__0005D_arg_FCL_TEXT+D'1', 1
13D6  0E86      	MOVLW LOW(CompTempVar2709+D'0')
13D8  6F92      	MOVWF FCD_04071__0005D_arg_FCL_TEXT, 1
13DA  0E02      	MOVLW 0x02
13DC  6FA1      	MOVWF FCD_04071__0005D_arg_FCLsz_TEXT, 1
13DE  6BA2      	CLRF FCD_04071__0005D_arg_FCLsz_TEXT+D'1', 1
13E0  EC1AF006  	CALL FCD_04071__0005D


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Cursor(0, 0)
		FCD_0ad31_lcd_eb005__Cursor(0, 0);
13E4  6B88      	CLRF FCD_04071__00062_arg_FCL_X, 1
13E6  6B89      	CLRF FCD_04071__00062_arg_FCL_Y, 1
13E8  ECF4F005  	CALL FCD_04071__00062


		// Calcul
		// Calcul:
		//  loop = loop + 1
		FCV_LOOP = FCV_LOOP + 1;
13EC  5275      	MOVF gbl_FCV_LOOP, F
13EE  5276      	MOVF gbl_FCV_LOOP+D'1', F
13F0  2A75      	INCF gbl_FCV_LOOP, F
13F2  B4D8      	BTFSC STATUS,Z
13F4  2A76      	INCF gbl_FCV_LOOP+D'1', F



	}

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendCommand("ATO", 1)
	FCD_0c851_Bluetooth2__SendCommand("ATO", 4, 1);
13F8  0E41      	MOVLW 0x41
13FA  6F86      	MOVWF CompTempVar2713, 1
13FC  0E54      	MOVLW 0x54
13FE  6F87      	MOVWF CompTempVar2713+D'1', 1
1400  0E4F      	MOVLW 0x4F
1402  6F88      	MOVWF CompTempVar2713+D'2', 1
1404  6B89      	CLRF CompTempVar2713+D'3', 1
1406  0E00      	MOVLW HIGH(CompTempVar2713+D'0')
1408  6FB9      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND+D'1', 1
140A  0E86      	MOVLW LOW(CompTempVar2713+D'0')
140C  6FB8      	MOVWF FCD_0c851__0005B_arg_FCL_COMMAND, 1
140E  0E04      	MOVLW 0x04
1410  6FBA      	MOVWF FCD_0c851__0005B_arg_FCLsz_0005C, 1
1412  6BBB      	CLRF FCD_0c851__0005B_arg_FCLsz_0005C+D'1', 1
1414  0E01      	MOVLW 0x01
1416  6FBC      	MOVWF FCD_0c851__0005B_arg_FCL_SENDCR, 1
1418  EC50F002  	CALL FCD_0c851__0005B


}
141C  0012      	RETURN




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
141E  0E0F      	MOVLW 0x0F
1420  6EC1      	MOVWF gbl_adcon1





	// Appel d'une Macro
	// Appel d'une Macro: INITIALISATION()
	FCM_INITIALISATION();
1422  0E99      	MOVLW 0x99
1424  EF44F009  	GOTO	FCM_INITIA_0004F
1428            label170


	// Appel d'une Macro
	// Appel d'une Macro: BT_CONNECTION()
	FCM_BT_CONNECTION();
1428  EC54F009  	CALL FCM_BT_CON_00060


	// Appel d'une Macro
	// Appel d'une Macro: SEND_DATA()
	FCM_SEND_DATA();
142C  ECDCF008  	CALL FCM_SEND_D_0005A


	mainendloop: goto mainendloop;
1430            label171
1430  D7FF      	BRA	label171

}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

	MX_UART_INT_CH1_FUNC

	MX_UINT8 FCL_BT_IN;
1486  CFEAF001  	MOVFF FSR0H,  Int1Context
148A  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
148E  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
1492  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'


	FCL_BT_IN = MX_UART_INT_CH1_DET;
1496  0E20      	MOVLW 0x20
1498  149E      	ANDWF gbl_pir1, W
149A  0100      	MOVLB 0x00
149C  6FE2      	MOVWF CompTempVar2779, 1
149E  0E20      	MOVLW 0x20
14A0  149D      	ANDWF gbl_pie1, W
14A2  6FE1      	MOVWF CompTempVar2778, 1
14A4  6BE0      	CLRF interrupt_1_FCL_BT_IN, 1
14A6  53E1      	MOVF CompTempVar2778, F, 1
14A8  A4D8      	BTFSS STATUS,Z
14AA  53E2      	MOVF CompTempVar2779, F, 1
14AC  A4D8      	BTFSS STATUS,Z
14AE  2BE0      	INCF interrupt_1_FCL_BT_IN, F, 1


	if (FCL_BT_IN)
14B0  53E0      	MOVF interrupt_1_FCL_BT_IN, F, 1
14B2  E022      	BZ	label175
14F8            label175

	{

	FCL_BT_IN = FC_CAL_UART_Receive_1(1);
14B4  0E01      	MOVLW 0x01
14B6  6FE1      	MOVWF FC_CAL_UAR_00070_arg_nTimeout, 1
14B8  EC46F000  	CALL FC_CAL_UAR_00070
14BC  51EA      	MOVF CompTempVarRet2738, W, 1
14BE  6FE0      	MOVWF interrupt_1_FCL_BT_IN, 1


	if (FCV_0c851_Bluetooth2__RX_DONE == 0)
14C0  5383      	MOVF gbl_FCV_0c851_Bluetooth2___00001, F, 1
14C2  E119      	BNZ	label174

	{

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 50)
14C4  0E32      	MOVLW 0x32
14C6  6184      	CPFSLT gbl_FCV_0c851_Bluetooth2___00002, 1
14C8  D016      	BRA	label174

		{

			if (FCL_BT_IN == 0x0A)
14CA  0E0A      	MOVLW 0x0A
14CC  63E0      	CPFSEQ interrupt_1_FCL_BT_IN, 1
14CE  D00A      	BRA	label173
14E4            label173

			{

				FCV_0c851_Bluetooth2__RX_DONE = 1;
14D0  0E01      	MOVLW 0x01
14D2  6F83      	MOVWF gbl_FCV_0c851_Bluetooth2___00001, 1

				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = 0;
14D4  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00000
14D8  50E9      	MOVF FSR0L, W
14DA  5184      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W, 1
14DC  26E9      	ADDWF FSR0L, F
14DE  0E00      	MOVLW 0x00
14E0  6EEF      	MOVWF INDF0


			} else {
14E2  D009      	BRA	label174
14F6            label174


				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = FCL_BT_IN;
14E4  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00000
14E8  50E9      	MOVF FSR0L, W
14EA  5184      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W, 1
14EC  26E9      	ADDWF FSR0L, F
14EE  51E0      	MOVF interrupt_1_FCL_BT_IN, W, 1
14F0  6EEF      	MOVWF INDF0

				FCV_0c851_Bluetooth2__RX_LENGTH = FCV_0c851_Bluetooth2__RX_LENGTH + 1;
14F2  2984      	INCF gbl_FCV_0c851_Bluetooth2___00002, W, 1
14F4  6F84      	MOVWF gbl_FCV_0c851_Bluetooth2___00002, 1


			}

		// } else {

		}

	// } else {

	}

	MX_UART_INT_CH1_CLR;
14F6  9A9E      	BCF gbl_pir1,5


	}

	MX_UART_INT_FUNC_END
}
14F8  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
14FC  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
1500  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
1504  C001FFEA  	MOVFF Int1Context,  FSR0H
1508  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 */



#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
07CC  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
07CE  0E7F      	MOVLW 0x7F
07D0  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
07D2  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
07D4  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
07D6  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
07D8  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
07DA  8A9D      	BSF gbl_pie1,5

				st_bit(intcon, PEIE);
07DC  8CF2      	BSF gbl_intcon,6

				st_bit(intcon, GIE);
07DE  8EF2      	BSF gbl_intcon,7

			#else
				cr_bit (pie1, RCIE);
			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
07E0  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
0160            label18
0160  0E10      	MOVLW 0x10
0162  149E      	ANDWF gbl_pir1, W
0164  6FC2      	MOVWF CompTempVar2742, 1
0166  53C2      	MOVF CompTempVar2742, F, 1
0168  E0FB      	BZ	label18


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
016A  51C0      	MOVF FC_CAL_UAR_00071_arg_nChar, W, 1
016C  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
016E  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
008C  69E2      	SETF FC_CAL_UAR_00070_1_retVal, 1

  #endif

	MX_UINT8 delay1 = 0;
008E  6BE3      	CLRF FC_CAL_UAR_00070_1_delay1, 1

	MX_UINT8 regcheck = 0;
0090  6BE4      	CLRF FC_CAL_UAR_00070_1_regcheck, 1

	MX_UINT8 bWaitForever = 0;
0092  6BE5      	CLRF FC_CAL_UAR_00070_1_bWaitForever, 1

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
0094  6BE6      	CLRF FC_CAL_UAR_00070_1_rxStatus, 1

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0096  6BE9      	CLRF FC_CAL_UAR_00070_1_dummy, 1

  #endif

	if (nTimeout == 255)
0098  29E1      	INCF FC_CAL_UAR_00070_arg_nTimeout, W, 1
009A  E102      	BNZ	label5
00A0            label5

		bWaitForever = 1;
009C  0E01      	MOVLW 0x01
009E  6FE5      	MOVWF FC_CAL_UAR_00070_1_bWaitForever, 1


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00A0  53E6      	MOVF FC_CAL_UAR_00070_1_rxStatus, F, 1
00A2  E124      	BNZ	label10
00EA  D7DA      	BRA	label5
00EC            label10

	{
		if (bWaitForever == 0)
00A4  53E5      	MOVF FC_CAL_UAR_00070_1_bWaitForever, F, 1
00A6  E118      	BNZ	label9

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00A8  53E1      	MOVF FC_CAL_UAR_00070_arg_nTimeout, F, 1
00AA  E103      	BNZ	label6
00B2            label6

			{
				rxStatus = UART_STATUS_TIMEOUT;
00AC  0E01      	MOVLW 0x01
00AE  6FE6      	MOVWF FC_CAL_UAR_00070_1_rxStatus, 1

			}
			else
00B0  D013      	BRA	label9

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00B2  6BE7      	CLRF FC_CAL_UAR_00070_1_delaycnt, 1
00B4  6BE8      	CLRF FC_CAL_UAR_00070_1_delaycnt+D'1', 1
00B6            label7
00B6  0E31      	MOVLW 0x31
00B8  5DE7      	SUBWF FC_CAL_UAR_00070_1_delaycnt, W, 1
00BA  E205      	BC	label8
00BC  67E8      	TSTFSZ FC_CAL_UAR_00070_1_delaycnt+D'1', 1
00BE  D003      	BRA	label8
00C0  4BE7      	INFSNZ FC_CAL_UAR_00070_1_delaycnt, F, 1
00C2  2BE8      	INCF FC_CAL_UAR_00070_1_delaycnt+D'1', F, 1
00C4  D7F8      	BRA	label7
00C6            label8

				delay1 = delay1 + 1;
00C6  29E3      	INCF FC_CAL_UAR_00070_1_delay1, W, 1
00C8  6FE3      	MOVWF FC_CAL_UAR_00070_1_delay1, 1

				if(delay1 == 100)
00CA  0E64      	MOVLW 0x64
00CC  63E3      	CPFSEQ FC_CAL_UAR_00070_1_delay1, 1
00CE  D004      	BRA	label9
00D8            label9

				{
					nTimeout = nTimeout - 1;
00D0  05E1      	DECF FC_CAL_UAR_00070_arg_nTimeout, W, 1
00D2  6FE1      	MOVWF FC_CAL_UAR_00070_arg_nTimeout, 1

					MX_CLEAR_WATCHDOG;
00D4  0004      	CLRWDT

					delay1 = 0;
00D6  6BE3      	CLRF FC_CAL_UAR_00070_1_delay1, 1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00D8  0E20      	MOVLW 0x20
00DA  149E      	ANDWF gbl_pir1, W
00DC  6FEA      	MOVWF CompTempVar2739, 1
00DE  51EA      	MOVF CompTempVar2739, W, 1
00E0  6FE4      	MOVWF FC_CAL_UAR_00070_1_regcheck, 1

			if (regcheck != 0)
00E2  53E4      	MOVF FC_CAL_UAR_00070_1_regcheck, F, 1
00E4  E0DD      	BZ	label5

				rxStatus = UART_STATUS_RXBYTE;
00E6  0E02      	MOVLW 0x02
00E8  6FE6      	MOVWF FC_CAL_UAR_00070_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00EC  0E02      	MOVLW 0x02
00EE  63E6      	CPFSEQ FC_CAL_UAR_00070_1_rxStatus, 1
00F0  D018      	BRA	label13

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
00F2  0E04      	MOVLW 0x04
00F4  14AB      	ANDWF gbl_rcsta, W
00F6  6FEA      	MOVWF CompTempVar2740, 1
00F8  51EA      	MOVF CompTempVar2740, W, 1
00FA  6FE4      	MOVWF FC_CAL_UAR_00070_1_regcheck, 1

			if (regcheck != 0)
00FC  53E4      	MOVF FC_CAL_UAR_00070_1_regcheck, F, 1
00FE  E003      	BZ	label11
0106            label11

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0100  50AE      	MOVF gbl_rcreg, W
0102  6FE9      	MOVWF FC_CAL_UAR_00070_1_dummy, 1

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0104  D00E      	BRA	label13

			{
				regcheck = ts_bit(rcsta, OERR);
0106  0E02      	MOVLW 0x02
0108  14AB      	ANDWF gbl_rcsta, W
010A  6FEA      	MOVWF CompTempVar2741, 1
010C  51EA      	MOVF CompTempVar2741, W, 1
010E  6FE4      	MOVWF FC_CAL_UAR_00070_1_regcheck, 1

				if (regcheck != 0)
0110  53E4      	MOVF FC_CAL_UAR_00070_1_regcheck, F, 1
0112  E003      	BZ	label12
011A            label12

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0114  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0116  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0118  D004      	BRA	label13
0122            label13

				{
					retVal = 0;
011A  6BE2      	CLRF FC_CAL_UAR_00070_1_retVal, 1


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
011C  50AE      	MOVF gbl_rcreg, W
011E  11E2      	IORWF FC_CAL_UAR_00070_1_retVal, W, 1
0120  6FE2      	MOVWF FC_CAL_UAR_00070_1_retVal, 1

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0122  51E2      	MOVF FC_CAL_UAR_00070_1_retVal, W, 1
0124  6FEA      	MOVWF CompTempVarRet2738, 1
0126  6BEB      	CLRF CompTempVarRet2738+D'1', 1

}
0128  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF19F00A  	GOTO	_startup

0008  EF43F00A  	GOTO	interrupt
000C            delay_us_00000
000C            ; { delay_us ; function begin
000C            label1
000C  0000      	NOP
000E  0000      	NOP
0010  2FC5      	DECFSZ delay_us_00000_arg_del, F, 1
0012  D7FC      	BRA	label1
0014  0012      	RETURN
0016            ; } delay_us function end

0016            delay_ms_00000
0016            ; { delay_ms ; function begin
0016  539A      	MOVF delay_ms_00000_arg_del, F, 1
0018  0000      	NOP
001A  E101      	BNZ	label2
001C  0012      	RETURN
001E            label2
001E  0EF5      	MOVLW 0xF5
0020            label3
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0000      	NOP
0040  0FFF      	ADDLW 0xFF
0042  A4D8      	BTFSS STATUS,Z
0044  D7ED      	BRA	label3
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  0000      	NOP
0058  0000      	NOP
005A  0000      	NOP
005C  0000      	NOP
005E  0000      	NOP
0060  2F9A      	DECFSZ delay_ms_00000_arg_del, F, 1
0062  D7DD      	BRA	label2
0064  0012      	RETURN
0066            ; } delay_ms function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6F9A      	MOVWF delay_ms_00000_arg_del, 1
006A  EC0BF000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6F9A      	MOVWF delay_ms_00000_arg_del, 1
0072  EC0BF000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6F9A      	MOVWF delay_ms_00000_arg_del, 1
007A  EC0BF000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6F9A      	MOVWF delay_ms_00000_arg_del, 1
0082  EC0BF000  	CALL delay_ms_00000
0086  2F86      	DECFSZ delay_s_00000_arg_del, F, 1
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end














01E0            __mul_32_3_00009
01E0            ; { __mul_32_32 ; function begin
01E0  6BB1      	CLRF CompTempVarRet414, 1
01E2  6BB2      	CLRF CompTempVarRet414+D'1', 1
01E4  6BB3      	CLRF CompTempVarRet414+D'2', 1
01E6  6BB4      	CLRF CompTempVarRet414+D'3', 1
01E8  6BB3      	CLRF CompTempVarRet414+D'2', 1
01EA  6BB4      	CLRF CompTempVarRet414+D'3', 1
01EC  51A5      	MOVF __mul_32_3_00009_arg_a, W, 1
01EE  03A9      	MULWF __mul_32_3_00009_arg_b, 1
01F0  50F3      	MOVF gbl_prodl, W
01F2  6FB1      	MOVWF CompTempVarRet414, 1
01F4  50F4      	MOVF gbl_prodh, W
01F6  6FB2      	MOVWF CompTempVarRet414+D'1', 1
01F8  51A6      	MOVF __mul_32_3_00009_arg_a+D'1', W, 1
01FA  03A9      	MULWF __mul_32_3_00009_arg_b, 1
01FC  50F3      	MOVF gbl_prodl, W
01FE  27B2      	ADDWF CompTempVarRet414+D'1', F, 1
0200  50F4      	MOVF gbl_prodh, W
0202  23B3      	ADDWFC CompTempVarRet414+D'2', F, 1
0204  B0D8      	BTFSC gbl_status,0
0206  2BB4      	INCF CompTempVarRet414+D'3', F, 1
0208  51A7      	MOVF __mul_32_3_00009_arg_a+D'2', W, 1
020A  03A9      	MULWF __mul_32_3_00009_arg_b, 1
020C  50F3      	MOVF gbl_prodl, W
020E  27B3      	ADDWF CompTempVarRet414+D'2', F, 1
0210  50F4      	MOVF gbl_prodh, W
0212  23B4      	ADDWFC CompTempVarRet414+D'3', F, 1
0214  51A8      	MOVF __mul_32_3_00009_arg_a+D'3', W, 1
0216  03A9      	MULWF __mul_32_3_00009_arg_b, 1
0218  50F3      	MOVF gbl_prodl, W
021A  27B4      	ADDWF CompTempVarRet414+D'3', F, 1
021C  51A5      	MOVF __mul_32_3_00009_arg_a, W, 1
021E  03AA      	MULWF __mul_32_3_00009_arg_b+D'1', 1
0220  50F3      	MOVF gbl_prodl, W
0222  27B2      	ADDWF CompTempVarRet414+D'1', F, 1
0224  50F4      	MOVF gbl_prodh, W
0226  23B3      	ADDWFC CompTempVarRet414+D'2', F, 1
0228  B0D8      	BTFSC gbl_status,0
022A  2BB4      	INCF CompTempVarRet414+D'3', F, 1
022C  51A6      	MOVF __mul_32_3_00009_arg_a+D'1', W, 1
022E  03AA      	MULWF __mul_32_3_00009_arg_b+D'1', 1
0230  50F3      	MOVF gbl_prodl, W
0232  27B3      	ADDWF CompTempVarRet414+D'2', F, 1
0234  50F4      	MOVF gbl_prodh, W
0236  23B4      	ADDWFC CompTempVarRet414+D'3', F, 1
0238  51A7      	MOVF __mul_32_3_00009_arg_a+D'2', W, 1
023A  03AA      	MULWF __mul_32_3_00009_arg_b+D'1', 1
023C  50F3      	MOVF gbl_prodl, W
023E  27B4      	ADDWF CompTempVarRet414+D'3', F, 1
0240  51A5      	MOVF __mul_32_3_00009_arg_a, W, 1
0242  03AB      	MULWF __mul_32_3_00009_arg_b+D'2', 1
0244  50F3      	MOVF gbl_prodl, W
0246  27B3      	ADDWF CompTempVarRet414+D'2', F, 1
0248  50F4      	MOVF gbl_prodh, W
024A  23B4      	ADDWFC CompTempVarRet414+D'3', F, 1
024C  51A6      	MOVF __mul_32_3_00009_arg_a+D'1', W, 1
024E  03AB      	MULWF __mul_32_3_00009_arg_b+D'2', 1
0250  50F3      	MOVF gbl_prodl, W
0252  27B4      	ADDWF CompTempVarRet414+D'3', F, 1
0254  51A5      	MOVF __mul_32_3_00009_arg_a, W, 1
0256  03AC      	MULWF __mul_32_3_00009_arg_b+D'3', 1
0258  50F3      	MOVF gbl_prodl, W
025A  27B4      	ADDWF CompTempVarRet414+D'3', F, 1
025C  0012      	RETURN
025E            ; } __mul_32_32 function end

025E            __div_32_3_00004
025E            ; { __div_32_32 ; function begin
025E  6BAD      	CLRF __div_32_3_00004_1_r, 1
0260  6BAE      	CLRF __div_32_3_00004_1_r+D'1', 1
0262  6BAF      	CLRF __div_32_3_00004_1_r+D'2', 1
0264  6BB0      	CLRF __div_32_3_00004_1_r+D'3', 1
0266  6BB3      	CLRF CompTempVarRet172, 1
0268  6BB4      	CLRF CompTempVarRet172+D'1', 1
026A  6BB5      	CLRF CompTempVarRet172+D'2', 1
026C  6BB6      	CLRF CompTempVarRet172+D'3', 1
026E  6BB1      	CLRF __div_32_3_00004_1_i, 1
0270            label26
0270  0E20      	MOVLW 0x20
0272  15B1      	ANDWF __div_32_3_00004_1_i, W, 1
0274  6FB2      	MOVWF CompTempVar174, 1
0276  67B2      	TSTFSZ CompTempVar174, 1
0278  0012      	RETURN
027A  90D8      	BCF STATUS,C
027C  37B3      	RLCF CompTempVarRet172, F, 1
027E  37B4      	RLCF CompTempVarRet172+D'1', F, 1
0280  37B5      	RLCF CompTempVarRet172+D'2', F, 1
0282  37B6      	RLCF CompTempVarRet172+D'3', F, 1
0284  37A5      	RLCF __div_32_3_00004_arg_a, F, 1
0286  37A6      	RLCF __div_32_3_00004_arg_a+D'1', F, 1
0288  37A7      	RLCF __div_32_3_00004_arg_a+D'2', F, 1
028A  37A8      	RLCF __div_32_3_00004_arg_a+D'3', F, 1
028C  37AD      	RLCF __div_32_3_00004_1_r, F, 1
028E  37AE      	RLCF __div_32_3_00004_1_r+D'1', F, 1
0290  37AF      	RLCF __div_32_3_00004_1_r+D'2', F, 1
0292  37B0      	RLCF __div_32_3_00004_1_r+D'3', F, 1
0294  51AC      	MOVF __div_32_3_00004_arg_b+D'3', W, 1
0296  5DB0      	SUBWF __div_32_3_00004_1_r+D'3', W, 1
0298  E108      	BNZ	label27
029A  51AB      	MOVF __div_32_3_00004_arg_b+D'2', W, 1
029C  5DAF      	SUBWF __div_32_3_00004_1_r+D'2', W, 1
029E  E105      	BNZ	label27
02A0  51AA      	MOVF __div_32_3_00004_arg_b+D'1', W, 1
02A2  5DAE      	SUBWF __div_32_3_00004_1_r+D'1', W, 1
02A4  E102      	BNZ	label27
02A6  51A9      	MOVF __div_32_3_00004_arg_b, W, 1
02A8  5DAD      	SUBWF __div_32_3_00004_1_r, W, 1
02AA            label27
02AA  E309      	BNC	label28
02AC  51A9      	MOVF __div_32_3_00004_arg_b, W, 1
02AE  5FAD      	SUBWF __div_32_3_00004_1_r, F, 1
02B0  51AA      	MOVF __div_32_3_00004_arg_b+D'1', W, 1
02B2  5BAE      	SUBWFB __div_32_3_00004_1_r+D'1', F, 1
02B4  51AB      	MOVF __div_32_3_00004_arg_b+D'2', W, 1
02B6  5BAF      	SUBWFB __div_32_3_00004_1_r+D'2', F, 1
02B8  51AC      	MOVF __div_32_3_00004_arg_b+D'3', W, 1
02BA  5BB0      	SUBWFB __div_32_3_00004_1_r+D'3', F, 1
02BC  81B3      	BSF CompTempVarRet172,0, 1
02BE            label28
02BE  2BB1      	INCF __div_32_3_00004_1_i, F, 1
02C0  D7D7      	BRA	label26
02C2            ; } __div_32_32 function end
























































0C6A            rand_00000
0C6A            ; { rand ; function begin
0C6A  0100      	MOVLB 0x00
0C6C  6B85      	CLRF rand_00000_1_i, 1
0C6E  6B86      	CLRF rand_00000_1_i+D'1', 1
0C70            label121
0C70  0E04      	MOVLW 0x04
0C72  5D85      	SUBWF rand_00000_1_i, W, 1
0C74  A0D8      	BTFSS STATUS,C
0C76  6786      	TSTFSZ rand_00000_1_i+D'1', 1
0C78  D001      	BRA	label122
0C7A  D002      	BRA	label123
0C7C            label122
0C7C  AF86      	BTFSS rand_00000_1_i+D'1',7, 1
0C7E  D01E      	BRA	label127
0C80            label123
0C80  90D8      	BCF STATUS,C
0C82  3661      	RLCF gbl_14_LSR+D'2', F
0C84  3662      	RLCF gbl_14_LSR+D'3', F
0C86  AE60      	BTFSS gbl_14_LSR+D'1',7
0C88  D002      	BRA	label124
0C8A  4A61      	INFSNZ gbl_14_LSR+D'2', F
0C8C  2A62      	INCF gbl_14_LSR+D'3', F
0C8E            label124
0C8E  90D8      	BCF STATUS,C
0C90  365F      	RLCF gbl_14_LSR, F
0C92  3660      	RLCF gbl_14_LSR+D'1', F
0C94  AE62      	BTFSS gbl_14_LSR+D'3',7
0C96  D00B      	BRA	label125
0C98  0E08      	MOVLW 0x08
0C9A  145F      	ANDWF gbl_14_LSR, W
0C9C  6F87      	MOVWF CompTempVar633, 1
0C9E  6B88      	CLRF CompTempVar634, 1
0CA0  5387      	MOVF CompTempVar633, F, 1
0CA2  E109      	BNZ	label126
0CA4  6788      	TSTFSZ CompTempVar634, 1
0CA6  D007      	BRA	label126
0CA8  4A5F      	INFSNZ gbl_14_LSR, F
0CAA  2A60      	INCF gbl_14_LSR+D'1', F
0CAC  D004      	BRA	label126
0CAE            label125
0CAE  A65F      	BTFSS gbl_14_LSR,3
0CB0  D002      	BRA	label126
0CB2  4A5F      	INFSNZ gbl_14_LSR, F
0CB4  2A60      	INCF gbl_14_LSR+D'1', F
0CB6            label126
0CB6  4B85      	INFSNZ rand_00000_1_i, F, 1
0CB8  2B86      	INCF rand_00000_1_i+D'1', F, 1
0CBA  D7DA      	BRA	label121
0CBC            label127
0CBC  5061      	MOVF gbl_14_LSR+D'2', W
0CBE  185F      	XORWF gbl_14_LSR, W
0CC0  6F87      	MOVWF CompTempVarRet621, 1
0CC2  5062      	MOVF gbl_14_LSR+D'3', W
0CC4  1860      	XORWF gbl_14_LSR+D'1', W
0CC6  6F88      	MOVWF CompTempVarRet621+D'1', 1
0CC8  0012      	RETURN
0CCA            ; } rand function end































1432            _startup
1432  0ED5      	MOVLW 0xD5
1434  6E5F      	MOVWF gbl_14_LSR
1436  0EC4      	MOVLW 0xC4
1438  6E60      	MOVWF gbl_14_LSR+D'1'
143A  0EBB      	MOVLW 0xBB
143C  6E61      	MOVWF gbl_14_LSR+D'2'
143E  0EDC      	MOVLW 0xDC
1440  6E62      	MOVWF gbl_14_LSR+D'3'
1442  6A63      	CLRF gbl_15_gbl_aSig
1444  6A64      	CLRF gbl_15_gbl_aSig+D'1'
1446  6A65      	CLRF gbl_15_gbl_aSig+D'2'
1448  6A66      	CLRF gbl_15_gbl_aSig+D'3'
144A  6A67      	CLRF gbl_15_gbl_bSig
144C  6A68      	CLRF gbl_15_gbl_bSig+D'1'
144E  6A69      	CLRF gbl_15_gbl_bSig+D'2'
1450  6A6A      	CLRF gbl_15_gbl_bSig+D'3'
1452  6A6B      	CLRF gbl_15_gbl_zSig
1454  6A6C      	CLRF gbl_15_gbl_zSig+D'1'
1456  6A6D      	CLRF gbl_15_gbl_zSig+D'2'
1458  6A6E      	CLRF gbl_15_gbl_zSig+D'3'
145A  6A7A      	CLRF gbl_15_gbl_aExp
145C  6A7B      	CLRF gbl_15_gbl_bExp
145E  6A73      	CLRF gbl_15_gbl_zExp
1460  6A74      	CLRF gbl_15_gbl_zExp+D'1'
1462  6A7C      	CLRF gbl_15_gbl_aSign
1464  6A7D      	CLRF gbl_15_gbl_bSign
1466  6A7E      	CLRF gbl_15_gbl_zSign
1468  6A7F      	CLRF gbl_15_gbl_zSigZero
146A  6A6F      	CLRF gbl_15_gbl_ret
146C  6A70      	CLRF gbl_15_gbl_ret+D'1'
146E  6A71      	CLRF gbl_15_gbl_ret+D'2'
1470  6A72      	CLRF gbl_15_gbl_ret+D'3'
1472  6A78      	CLRF gbl_float_rounding_mode
1474  6A79      	CLRF gbl_float_exception_flags
1476  6A77      	CLRF gbl_float_detect_tininess




1482  EF0FF00A  	GOTO	main




300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  78FF      	DW 0x78FF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
