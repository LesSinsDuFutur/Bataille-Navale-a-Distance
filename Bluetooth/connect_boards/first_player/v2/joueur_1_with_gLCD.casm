;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
10E0  5188      	MOVF FC_CAL_Por_00045_arg_Tris+D'1', W, 1
10E2  6EEA      	MOVWF FSR0H
10E4  5187      	MOVF FC_CAL_Por_00045_arg_Tris, W, 1
10E6  6EE9      	MOVWF FSR0L
10E8  5189      	MOVF FC_CAL_Por_00045_arg_InMask, W, 1
10EA  10EF      	IORWF INDF0, W
10EC  6F8B      	MOVWF CompTempVar1825, 1
10EE  518B      	MOVF CompTempVar1825, W, 1
10F0  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
10F2  5186      	MOVF FC_CAL_Por_00045_arg_Port+D'1', W, 1
10F4  6EEA      	MOVWF FSR0H
10F6  5185      	MOVF FC_CAL_Por_00045_arg_Port, W, 1
10F8  6EE9      	MOVWF FSR0L
10FA  5189      	MOVF FC_CAL_Por_00045_arg_InMask, W, 1
10FC  14EF      	ANDWF INDF0, W
10FE  6F8B      	MOVWF CompTempVarRet1822, 1
1100  518A      	MOVF FC_CAL_Por_00045_arg_Shift, W, 1
1102  6F8C      	MOVWF CompTempVar1827, 1
1104            label186
1104  B4D8      	BTFSC STATUS,Z
1108  90D8      	BCF STATUS,C
110A  338B      	RRCF CompTempVarRet1822, F, 1
110C  078C      	DECF CompTempVar1827, F, 1
110E  D7FA      	BRA	label186

		}
1106  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

// Delay by bytes
#define FCI_DELAYBYTE_S(count)     delay_s((count))
#define FCI_DELAYBYTE_MS(count)    delay_ms((count))
#define FCI_DELAYBYTE_US(count)    delay_us((count))
// With watchdog timer
#define FCI_DELAYBYTEWDT_S(count)  Wdt_Delay_S((count))
#define FCI_DELAYBYTEWDT_MS(count) Wdt_Delay_Ms((count))
#define FCI_DELAYBYTEWDT_US(count) delay_us((count))

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)
{
    char i;
    for (i=0; i<delay; i++)
    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
        delay_ms(1);
    }
}


void FCI_DELAYINT_US(MX_UINT16 Delay)

{
  	while (Delay > 255)
0610            label85
0610  0EFF      	MOVLW 0xFF
0612  65BF      	CPFSGT FCI_DELAYI_00048_arg_Delay, 1
0614  67C0      	TSTFSZ FCI_DELAYI_00048_arg_Delay+D'1', 1
0616  D001      	BRA	label86
0618  D00E      	BRA	label87
061A            label86
0634  D7ED      	BRA	label85
0636            label87

  	{
	  	delay_us(255);
061A  0101      	MOVLB 0x01
061C  6904      	SETF delay_us_00000_arg_del, 1
061E  EC2EF000  	CALL delay_us_00000

	  	Delay = Delay - 255;
0622  0EFF      	MOVLW 0xFF
0624  0100      	MOVLB 0x00
0626  5DBF      	SUBWF FCI_DELAYI_00048_arg_Delay, W, 1
0628  6FC1      	MOVWF CompTempVar1836, 1
062A  59BF      	SUBWFB FCI_DELAYI_00048_arg_Delay, W, 1
062C  08FF      	SUBLW 0xFF
062E  5FC0      	SUBWF FCI_DELAYI_00048_arg_Delay+D'1', F, 1
0630  51C1      	MOVF CompTempVar1836, W, 1
0632  6FBF      	MOVWF FCI_DELAYI_00048_arg_Delay, 1

  	}
  	if (Delay > 0)
0636  0E00      	MOVLW 0x00
0638  65BF      	CPFSGT FCI_DELAYI_00048_arg_Delay, 1
063A  67C0      	TSTFSZ FCI_DELAYI_00048_arg_Delay+D'1', 1
063C  D001      	BRA	label88
0640            label88

  		delay_us(Delay & 0xFF);
0640  51BF      	MOVF FCI_DELAYI_00048_arg_Delay, W, 1
0642  0101      	MOVLB 0x01
0644  6F04      	MOVWF delay_us_00000_arg_del, 1
0646  EC2EF000  	CALL delay_us_00000

}
063E  0012      	RETURN
064A  0012      	RETURN


void FCI_DELAYINT_MS(MX_UINT16 Delay)

{
  	while (Delay > 255)
1110            label187
1110  0EFF      	MOVLW 0xFF
1112  6582      	CPFSGT FCI_DELAYI_00049_arg_Delay, 1
1114  6783      	TSTFSZ FCI_DELAYI_00049_arg_Delay+D'1', 1
1116  D001      	BRA	label188
1118  D00E      	BRA	label189
111A            label188
1134  D7ED      	BRA	label187
1136            label189

  	{
	  	delay_ms(255);
111A  0101      	MOVLB 0x01
111C  6905      	SETF delay_ms_00000_arg_del, 1
111E  EC06F000  	CALL delay_ms_00000

	  	Delay = Delay - 255;
1122  0EFF      	MOVLW 0xFF
1124  0100      	MOVLB 0x00
1126  5D82      	SUBWF FCI_DELAYI_00049_arg_Delay, W, 1
1128  6F84      	MOVWF CompTempVar1838, 1
112A  5982      	SUBWFB FCI_DELAYI_00049_arg_Delay, W, 1
112C  08FF      	SUBLW 0xFF
112E  5F83      	SUBWF FCI_DELAYI_00049_arg_Delay+D'1', F, 1
1130  5184      	MOVF CompTempVar1838, W, 1
1132  6F82      	MOVWF FCI_DELAYI_00049_arg_Delay, 1

  	}
  	if (Delay > 0)
1136  0E00      	MOVLW 0x00
1138  6582      	CPFSGT FCI_DELAYI_00049_arg_Delay, 1
113A  6783      	TSTFSZ FCI_DELAYI_00049_arg_Delay+D'1', 1
113C  D001      	BRA	label190
1140            label190

  		delay_ms(Delay & 0xFF);
1140  5182      	MOVF FCI_DELAYI_00049_arg_Delay, W, 1
1142  0101      	MOVLB 0x01
1144  6F05      	MOVWF delay_ms_00000_arg_del, 1
1146  EC06F000  	CALL delay_ms_00000

}
113E  0012      	RETURN
114A  0012      	RETURN


void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
032E  6BE7      	CLRF FCI_GETLEN_0004E_1_tmp, 1
0330            label44
0330  51E6      	MOVF FCI_GETLEN_0004E_arg_iStr1_len, W, 1
0332  61E7      	CPFSLT FCI_GETLEN_0004E_1_tmp, 1
0334  D009      	BRA	label45
0336  51E5      	MOVF FCI_GETLEN_0004E_arg_sStr1+D'1', W, 1
0338  6EEA      	MOVWF FSR0H
033A  51E4      	MOVF FCI_GETLEN_0004E_arg_sStr1, W, 1
033C  25E7      	ADDWF FCI_GETLEN_0004E_1_tmp, W, 1
033E  6EE9      	MOVWF FSR0L
0340  52EF      	MOVF INDF0, F
0342  E002      	BZ	label45
0344  2BE7      	INCF FCI_GETLEN_0004E_1_tmp, F, 1
0346  D7F4      	BRA	label44
0348            label45

	return (tmp);
0348  51E7      	MOVF FCI_GETLEN_0004E_1_tmp, W, 1
034A  6FE8      	MOVWF CompTempVarRet1850, 1

}
034C  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)

{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;
0CC8  518E      	MOVF FCI_TOSTRI_00052_arg_iSrc1, W, 1
0CCA  6F96      	MOVWF FCI_TOSTRI_00052_1_iSrc, 1
0CCC  518F      	MOVF FCI_TOSTRI_00052_arg_iSrc1+D'1', W, 1
0CCE  6F97      	MOVWF FCI_TOSTRI_00052_1_iSrc+D'1', 1
0CD0  5190      	MOVF FCI_TOSTRI_00052_arg_iSrc1+D'2', W, 1
0CD2  6F98      	MOVWF FCI_TOSTRI_00052_1_iSrc+D'2', 1
0CD4  5191      	MOVF FCI_TOSTRI_00052_arg_iSrc1+D'3', W, 1
0CD6  6F99      	MOVWF FCI_TOSTRI_00052_1_iSrc+D'3', 1


	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
0CD8  6B9A      	CLRF FCI_TOSTRI_00052_1_top, 1
0CDA  0ECA      	MOVLW 0xCA
0CDC  6F9B      	MOVWF FCI_TOSTRI_00052_1_top+D'1', 1
0CDE  0E9A      	MOVLW 0x9A
0CE0  6F9C      	MOVWF FCI_TOSTRI_00052_1_top+D'2', 1
0CE2  0E3B      	MOVLW 0x3B
0CE4  6F9D      	MOVWF FCI_TOSTRI_00052_1_top+D'3', 1

	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;
0CE6  6B9E      	CLRF FCI_TOSTRI_00052_1_idx, 1


	if (iDst_len == 0) return sDst;
0CE8  5394      	MOVF FCI_TOSTRI_00052_arg_iDst_len, F, 1
0CEA  E105      	BNZ	label171
0CEC  5192      	MOVF FCI_TOSTRI_00052_arg_sDst, W, 1
0CEE  6F9F      	MOVWF CompTempVarRet1863, 1
0CF0  5193      	MOVF FCI_TOSTRI_00052_arg_sDst+D'1', W, 1
0CF2  6FA0      	MOVWF CompTempVarRet1863+D'1', 1
0CF6            label171


	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
0CF6  AF99      	BTFSS FCI_TOSTRI_00052_1_iSrc+D'3',7, 1
0CF8  D014      	BRA	label172

	{
		sDst[0] = '-';
0CFA  5193      	MOVF FCI_TOSTRI_00052_arg_sDst+D'1', W, 1
0CFC  6EEA      	MOVWF FSR0H
0CFE  5192      	MOVF FCI_TOSTRI_00052_arg_sDst, W, 1
0D00  6EE9      	MOVWF FSR0L
0D02  6BA1      	CLRF CompTempVar1865, 1
0D04  51A1      	MOVF CompTempVar1865, W, 1
0D06  26E9      	ADDWF FSR0L, F
0D08  0E2D      	MOVLW 0x2D
0D0A  6EEF      	MOVWF INDF0

		idx++;
0D0C  2B9E      	INCF FCI_TOSTRI_00052_1_idx, F, 1

		iSrc = -iSrc;
0D0E  1F96      	COMF FCI_TOSTRI_00052_1_iSrc, F, 1
0D10  1F97      	COMF FCI_TOSTRI_00052_1_iSrc+D'1', F, 1
0D12  1F98      	COMF FCI_TOSTRI_00052_1_iSrc+D'2', F, 1
0D14  1F99      	COMF FCI_TOSTRI_00052_1_iSrc+D'3', F, 1
0D16  3F96      	INCFSZ FCI_TOSTRI_00052_1_iSrc, F, 1
0D18  D004      	BRA	label172
0D1A  3F97      	INCFSZ FCI_TOSTRI_00052_1_iSrc+D'1', F, 1
0D1C  D002      	BRA	label172
0D1E  4B98      	INFSNZ FCI_TOSTRI_00052_1_iSrc+D'2', F, 1
0D20  2B99      	INCF FCI_TOSTRI_00052_1_iSrc+D'3', F, 1
0D22            label172

	}

	tmp1 = 0;    // Nothing added yet
0D22  6B95      	CLRF FCI_TOSTRI_00052_1_tmp1, 1

	if (iSrc == 0) // Force showing zero
0D24  5196      	MOVF FCI_TOSTRI_00052_1_iSrc, W, 1
0D26  1197      	IORWF FCI_TOSTRI_00052_1_iSrc+D'1', W, 1
0D28  1198      	IORWF FCI_TOSTRI_00052_1_iSrc+D'2', W, 1
0D2A  1199      	IORWF FCI_TOSTRI_00052_1_iSrc+D'3', W, 1
0D2C  0BFF      	ANDLW 0xFF
0D2E  E106      	BNZ	label173
0D3C            label173

	{
		tmp1 = 1;
0D30  0E01      	MOVLW 0x01
0D32  6F95      	MOVWF FCI_TOSTRI_00052_1_tmp1, 1

		top = 1;
0D34  6F9A      	MOVWF FCI_TOSTRI_00052_1_top, 1
0D36  6B9B      	CLRF FCI_TOSTRI_00052_1_top+D'1', 1
0D38  6B9C      	CLRF FCI_TOSTRI_00052_1_top+D'2', 1
0D3A  6B9D      	CLRF FCI_TOSTRI_00052_1_top+D'3', 1

	}
	while (( idx < iDst_len) && (top > 0))
0D3C  5194      	MOVF FCI_TOSTRI_00052_arg_iDst_len, W, 1
0D3E  619E      	CPFSLT FCI_TOSTRI_00052_1_idx, 1
0D40  D072      	BRA	label178
0D42  519D      	MOVF FCI_TOSTRI_00052_1_top+D'3', W, 1
0D44  0800      	SUBLW 0x00
0D46  E108      	BNZ	label174
0D48  519C      	MOVF FCI_TOSTRI_00052_1_top+D'2', W, 1
0D4A  0800      	SUBLW 0x00
0D4C  E105      	BNZ	label174
0D4E  519B      	MOVF FCI_TOSTRI_00052_1_top+D'1', W, 1
0D50  0800      	SUBLW 0x00
0D52  E102      	BNZ	label174
0D54  519A      	MOVF FCI_TOSTRI_00052_1_top, W, 1
0D56  0800      	SUBLW 0x00
0D58            label174
0D58  E266      	BC	label178
0E24  D78B      	BRA	label173
0E26            label178

	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
0D5A  519D      	MOVF FCI_TOSTRI_00052_1_top+D'3', W, 1
0D5C  5D99      	SUBWF FCI_TOSTRI_00052_1_iSrc+D'3', W, 1
0D5E  E108      	BNZ	label175
0D60  519C      	MOVF FCI_TOSTRI_00052_1_top+D'2', W, 1
0D62  5D98      	SUBWF FCI_TOSTRI_00052_1_iSrc+D'2', W, 1
0D64  E105      	BNZ	label175
0D66  519B      	MOVF FCI_TOSTRI_00052_1_top+D'1', W, 1
0D68  5D97      	SUBWF FCI_TOSTRI_00052_1_iSrc+D'1', W, 1
0D6A  E102      	BNZ	label175
0D6C  519A      	MOVF FCI_TOSTRI_00052_1_top, W, 1
0D6E  5D96      	SUBWF FCI_TOSTRI_00052_1_iSrc, W, 1
0D70            label175
0D70  E202      	BC	label176
0D72  5395      	MOVF FCI_TOSTRI_00052_1_tmp1, F, 1
0D74  E040      	BZ	label177
0D76            label176
0DF6            label177

		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
0D76  5196      	MOVF FCI_TOSTRI_00052_1_iSrc, W, 1
0D78  6FA1      	MOVWF __div_32_3_00014_arg_a, 1
0D7A  5197      	MOVF FCI_TOSTRI_00052_1_iSrc+D'1', W, 1
0D7C  6FA2      	MOVWF __div_32_3_00014_arg_a+D'1', 1
0D7E  5198      	MOVF FCI_TOSTRI_00052_1_iSrc+D'2', W, 1
0D80  6FA3      	MOVWF __div_32_3_00014_arg_a+D'2', 1
0D82  5199      	MOVF FCI_TOSTRI_00052_1_iSrc+D'3', W, 1
0D84  6FA4      	MOVWF __div_32_3_00014_arg_a+D'3', 1
0D86  519A      	MOVF FCI_TOSTRI_00052_1_top, W, 1
0D88  6FA5      	MOVWF __div_32_3_00014_arg_b, 1
0D8A  519B      	MOVF FCI_TOSTRI_00052_1_top+D'1', W, 1
0D8C  6FA6      	MOVWF __div_32_3_00014_arg_b+D'1', 1
0D8E  519C      	MOVF FCI_TOSTRI_00052_1_top+D'2', W, 1
0D90  6FA7      	MOVWF __div_32_3_00014_arg_b+D'2', 1
0D92  519D      	MOVF FCI_TOSTRI_00052_1_top+D'3', W, 1
0D94  6FA8      	MOVWF __div_32_3_00014_arg_b+D'3', 1
0D96  EC97F003  	CALL __div_32_3_00014
0D9A  51AF      	MOVF CompTempVarRet172, W, 1
0D9C  6F95      	MOVWF FCI_TOSTRI_00052_1_tmp1, 1

			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
0D9E  5195      	MOVF FCI_TOSTRI_00052_1_tmp1, W, 1
0DA0  0F30      	ADDLW 0x30
0DA2  6FA1      	MOVWF CompTempVar1871, 1
0DA4  5193      	MOVF FCI_TOSTRI_00052_arg_sDst+D'1', W, 1
0DA6  6EEA      	MOVWF FSR0H
0DA8  5192      	MOVF FCI_TOSTRI_00052_arg_sDst, W, 1
0DAA  259E      	ADDWF FCI_TOSTRI_00052_1_idx, W, 1
0DAC  6EE9      	MOVWF FSR0L
0DAE  51A1      	MOVF CompTempVar1871, W, 1
0DB0  6EEF      	MOVWF INDF0

			idx++;
0DB2  2B9E      	INCF FCI_TOSTRI_00052_1_idx, F, 1

			iSrc -= tmp1 * top;				// Remove digit
0DB4  5195      	MOVF FCI_TOSTRI_00052_1_tmp1, W, 1
0DB6  6FA1      	MOVWF __mul_32_3_00019_arg_a, 1
0DB8  6BA2      	CLRF __mul_32_3_00019_arg_a+D'1', 1
0DBA  6BA3      	CLRF __mul_32_3_00019_arg_a+D'2', 1
0DBC  6BA4      	CLRF __mul_32_3_00019_arg_a+D'3', 1
0DBE  519A      	MOVF FCI_TOSTRI_00052_1_top, W, 1
0DC0  6FA5      	MOVWF __mul_32_3_00019_arg_b, 1
0DC2  519B      	MOVF FCI_TOSTRI_00052_1_top+D'1', W, 1
0DC4  6FA6      	MOVWF __mul_32_3_00019_arg_b+D'1', 1
0DC6  519C      	MOVF FCI_TOSTRI_00052_1_top+D'2', W, 1
0DC8  6FA7      	MOVWF __mul_32_3_00019_arg_b+D'2', 1
0DCA  519D      	MOVF FCI_TOSTRI_00052_1_top+D'3', W, 1
0DCC  6FA8      	MOVWF __mul_32_3_00019_arg_b+D'3', 1
0DCE  EC58F003  	CALL __mul_32_3_00019
0DD2  51AD      	MOVF CompTempVarRet414, W, 1
0DD4  6FA9      	MOVWF CompTempVar1872, 1
0DD6  51AE      	MOVF CompTempVarRet414+D'1', W, 1
0DD8  6FAA      	MOVWF CompTempVar1873, 1
0DDA  51AF      	MOVF CompTempVarRet414+D'2', W, 1
0DDC  6FAB      	MOVWF CompTempVar1874, 1
0DDE  51B0      	MOVF CompTempVarRet414+D'3', W, 1
0DE0  6FAC      	MOVWF CompTempVar1875, 1
0DE2  51A9      	MOVF CompTempVar1872, W, 1
0DE4  5F96      	SUBWF FCI_TOSTRI_00052_1_iSrc, F, 1
0DE6  51AA      	MOVF CompTempVar1873, W, 1
0DE8  5B97      	SUBWFB FCI_TOSTRI_00052_1_iSrc+D'1', F, 1
0DEA  51AB      	MOVF CompTempVar1874, W, 1
0DEC  5B98      	SUBWFB FCI_TOSTRI_00052_1_iSrc+D'2', F, 1
0DEE  51AC      	MOVF CompTempVar1875, W, 1
0DF0  5B99      	SUBWFB FCI_TOSTRI_00052_1_iSrc+D'3', F, 1

			tmp1 = 1;						// Add zeros now
0DF2  0E01      	MOVLW 0x01
0DF4  6F95      	MOVWF FCI_TOSTRI_00052_1_tmp1, 1

		}
		top /= 10;							// Go to next digit
0DF6  519A      	MOVF FCI_TOSTRI_00052_1_top, W, 1
0DF8  6FA1      	MOVWF __div_32_3_00014_arg_a, 1
0DFA  519B      	MOVF FCI_TOSTRI_00052_1_top+D'1', W, 1
0DFC  6FA2      	MOVWF __div_32_3_00014_arg_a+D'1', 1
0DFE  519C      	MOVF FCI_TOSTRI_00052_1_top+D'2', W, 1
0E00  6FA3      	MOVWF __div_32_3_00014_arg_a+D'2', 1
0E02  519D      	MOVF FCI_TOSTRI_00052_1_top+D'3', W, 1
0E04  6FA4      	MOVWF __div_32_3_00014_arg_a+D'3', 1
0E06  0E0A      	MOVLW 0x0A
0E08  6FA5      	MOVWF __div_32_3_00014_arg_b, 1
0E0A  6BA6      	CLRF __div_32_3_00014_arg_b+D'1', 1
0E0C  6BA7      	CLRF __div_32_3_00014_arg_b+D'2', 1
0E0E  6BA8      	CLRF __div_32_3_00014_arg_b+D'3', 1
0E10  EC97F003  	CALL __div_32_3_00014
0E14  51AF      	MOVF CompTempVarRet172, W, 1
0E16  6F9A      	MOVWF FCI_TOSTRI_00052_1_top, 1
0E18  51B0      	MOVF CompTempVarRet172+D'1', W, 1
0E1A  6F9B      	MOVWF FCI_TOSTRI_00052_1_top+D'1', 1
0E1C  51B1      	MOVF CompTempVarRet172+D'2', W, 1
0E1E  6F9C      	MOVWF FCI_TOSTRI_00052_1_top+D'2', 1
0E20  51B2      	MOVF CompTempVarRet172+D'3', W, 1
0E22  6F9D      	MOVWF FCI_TOSTRI_00052_1_top+D'3', 1

	}

	if (idx < iDst_len)						//add terminating null (if we can)
0E26  5194      	MOVF FCI_TOSTRI_00052_arg_iDst_len, W, 1
0E28  619E      	CPFSLT FCI_TOSTRI_00052_1_idx, 1
0E2A  D007      	BRA	label179
0E3A            label179

		sDst[idx] = '\0';
0E2C  5193      	MOVF FCI_TOSTRI_00052_arg_sDst+D'1', W, 1
0E2E  6EEA      	MOVWF FSR0H
0E30  5192      	MOVF FCI_TOSTRI_00052_arg_sDst, W, 1
0E32  259E      	ADDWF FCI_TOSTRI_00052_1_idx, W, 1
0E34  6EE9      	MOVWF FSR0L
0E36  0E00      	MOVLW 0x00
0E38  6EEF      	MOVWF INDF0

	return (sDst);
0E3A  5192      	MOVF FCI_TOSTRI_00052_arg_sDst, W, 1
0E3C  6F9F      	MOVWF CompTempVarRet1863, 1
0E3E  5193      	MOVF FCI_TOSTRI_00052_arg_sDst+D'1', W, 1
0E40  6FA0      	MOVWF CompTempVarRet1863+D'1', 1

}
0CF4  0012      	RETURN
0E42  0012      	RETURN




void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len, strt;

  len = 0;
0792  6BC6      	CLRF FCI_SHEAD_00000_1_len, 1

  if (sSrc2 == sDst)
0794  51C3      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
0796  63C0      	CPFSEQ FCI_SHEAD_00000_arg_sSrc2, 1
0798  D08C      	BRA	label109
079A  51C4      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
079C  63C1      	CPFSEQ FCI_SHEAD_00000_arg_sSrc2+D'1', 1
079E  D089      	BRA	label109
08B2            label109

  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
07A0  6BC7      	CLRF FCI_SHEAD_00000_1_strt, 1
07A2            label98
07A2  51BF      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W, 1
07A4  61C7      	CPFSLT FCI_SHEAD_00000_1_strt, 1
07A6  D009      	BRA	label99
07A8  51B5      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
07AA  6EEA      	MOVWF FSR0H
07AC  51B4      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
07AE  25C7      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
07B0  6EE9      	MOVWF FSR0L
07B2  52EF      	MOVF INDF0, F
07B4  E002      	BZ	label99
07B6  2BC7      	INCF FCI_SHEAD_00000_1_strt, F, 1
07B8  D7F4      	BRA	label98
07BA            label99
08B0  D7E0      	BRA	label108

    if (strt < iDst_len)
07BA  51C5      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
07BC  61C7      	CPFSLT FCI_SHEAD_00000_1_strt, 1
07BE  D058      	BRA	label107
0870            label107

    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
07C0  6BC6      	CLRF FCI_SHEAD_00000_1_len, 1
07C2            label100
07C2  51C2      	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W, 1
07C4  61C6      	CPFSLT FCI_SHEAD_00000_1_len, 1
07C6  D009      	BRA	label101
07C8  51C1      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W, 1
07CA  6EEA      	MOVWF FSR0H
07CC  51C0      	MOVF FCI_SHEAD_00000_arg_sSrc2, W, 1
07CE  25C6      	ADDWF FCI_SHEAD_00000_1_len, W, 1
07D0  6EE9      	MOVWF FSR0L
07D2  52EF      	MOVF INDF0, F
07D4  E002      	BZ	label101
07D6  2BC6      	INCF FCI_SHEAD_00000_1_len, F, 1
07D8  D7F4      	BRA	label100
07DA            label101

      if (len > (iDst_len - strt))
07DA  51C7      	MOVF FCI_SHEAD_00000_1_strt, W, 1
07DC  5DC5      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
07DE  6FC8      	MOVWF CompTempVar2023, 1
07E0  51C6      	MOVF FCI_SHEAD_00000_1_len, W, 1
07E2  61C8      	CPFSLT CompTempVar2023, 1
07E4  D005      	BRA	label102
07F0            label102

      {
        len = (iDst_len - strt); // Length of string to copy to
07E6  51C7      	MOVF FCI_SHEAD_00000_1_strt, W, 1
07E8  5DC5      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
07EA  6FC9      	MOVWF CompTempVar2029, 1
07EC  51C9      	MOVF CompTempVar2029, W, 1
07EE  6FC6      	MOVWF FCI_SHEAD_00000_1_len, 1

      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
07F0  51C6      	MOVF FCI_SHEAD_00000_1_len, W, 1
07F2  25C7      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
07F4  6FC2      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1

      strt = len;
07F6  51C6      	MOVF FCI_SHEAD_00000_1_len, W, 1
07F8  6FC7      	MOVWF FCI_SHEAD_00000_1_strt, 1

      while (strt > 0)
07FA            label103
07FA  0E00      	MOVLW 0x00
07FC  65C7      	CPFSGT FCI_SHEAD_00000_1_strt, 1
07FE  D014      	BRA	label104
0826  D7E9      	BRA	label103
0828            label104

      {
        strt--;
0800  07C7      	DECF FCI_SHEAD_00000_1_strt, F, 1

        iSrc2_len--;
0802  07C2      	DECF FCI_SHEAD_00000_arg_iSrc2_len, F, 1

        sDst[iSrc2_len] = sSrc2[strt];
0804  51C1      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W, 1
0806  6EEA      	MOVWF FSR0H
0808  51C0      	MOVF FCI_SHEAD_00000_arg_sSrc2, W, 1
080A  6EE9      	MOVWF FSR0L
080C  51C7      	MOVF FCI_SHEAD_00000_1_strt, W, 1
080E  6FC9      	MOVWF CompTempVar2032, 1
0810  51C9      	MOVF CompTempVar2032, W, 1
0812  26E9      	ADDWF FSR0L, F
0814  50EF      	MOVF INDF0, W
0816  6FCA      	MOVWF CompTempVar2033, 1
0818  51C4      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
081A  6EEA      	MOVWF FSR0H
081C  51C3      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
081E  25C2      	ADDWF FCI_SHEAD_00000_arg_iSrc2_len, W, 1
0820  6EE9      	MOVWF FSR0L
0822  51CA      	MOVF CompTempVar2033, W, 1
0824  6EEF      	MOVWF INDF0

      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
0828  6BC7      	CLRF FCI_SHEAD_00000_1_strt, 1
082A            label105
082A  51BF      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W, 1
082C  61C7      	CPFSLT FCI_SHEAD_00000_1_strt, 1
082E  D01D      	BRA	label106
0830  51C5      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
0832  61C7      	CPFSLT FCI_SHEAD_00000_1_strt, 1
0834  D01A      	BRA	label106
0836  51B5      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
0838  6EEA      	MOVWF FSR0H
083A  51B4      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
083C  25C7      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
083E  6EE9      	MOVWF FSR0L
0840  52EF      	MOVF INDF0, F
0842  E013      	BZ	label106
0844  51B5      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
0846  6EEA      	MOVWF FSR0H
0848  51B4      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
084A  6EE9      	MOVWF FSR0L
084C  51C7      	MOVF FCI_SHEAD_00000_1_strt, W, 1
084E  6FC9      	MOVWF CompTempVar2036, 1
0850  51C9      	MOVF CompTempVar2036, W, 1
0852  26E9      	ADDWF FSR0L, F
0854  50EF      	MOVF INDF0, W
0856  6FCA      	MOVWF CompTempVar2037, 1
0858  51C4      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
085A  6EEA      	MOVWF FSR0H
085C  51C3      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
085E  25C7      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0860  6EE9      	MOVWF FSR0L
0862  51CA      	MOVF CompTempVar2037, W, 1
0864  6EEF      	MOVWF INDF0
0866  2BC7      	INCF FCI_SHEAD_00000_1_strt, F, 1
0868  D7E0      	BRA	label105
086A            label106

      len += strt;
086A  51C7      	MOVF FCI_SHEAD_00000_1_strt, W, 1
086C  27C6      	ADDWF FCI_SHEAD_00000_1_len, F, 1

    }
    else
086E  D075      	BRA	label114

    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
0870  6BC6      	CLRF FCI_SHEAD_00000_1_len, 1
0872            label108
0872  51BF      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W, 1
0874  61C6      	CPFSLT FCI_SHEAD_00000_1_len, 1
0876  D071      	BRA	label114
0878  51C5      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
087A  61C6      	CPFSLT FCI_SHEAD_00000_1_len, 1
087C  D06E      	BRA	label114
087E  51B5      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
0880  6EEA      	MOVWF FSR0H
0882  51B4      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
0884  25C6      	ADDWF FCI_SHEAD_00000_1_len, W, 1
0886  6EE9      	MOVWF FSR0L
0888  52EF      	MOVF INDF0, F
088A  E067      	BZ	label114
088C  51B5      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
088E  6EEA      	MOVWF FSR0H
0890  51B4      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
0892  6EE9      	MOVWF FSR0L
0894  51C6      	MOVF FCI_SHEAD_00000_1_len, W, 1
0896  6FC8      	MOVWF CompTempVar2044, 1
0898  51C8      	MOVF CompTempVar2044, W, 1
089A  26E9      	ADDWF FSR0L, F
089C  50EF      	MOVF INDF0, W
089E  6FC9      	MOVWF CompTempVar2045, 1
08A0  51C4      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
08A2  6EEA      	MOVWF FSR0H
08A4  51C3      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
08A6  25C6      	ADDWF FCI_SHEAD_00000_1_len, W, 1
08A8  6EE9      	MOVWF FSR0L
08AA  51C9      	MOVF CompTempVar2045, W, 1
08AC  6EEF      	MOVWF INDF0
08AE  2BC6      	INCF FCI_SHEAD_00000_1_len, F, 1

    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
08B2  6BC6      	CLRF FCI_SHEAD_00000_1_len, 1
08B4            label110
08B4  51BF      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W, 1
08B6  61C6      	CPFSLT FCI_SHEAD_00000_1_len, 1
08B8  D01D      	BRA	label111
08BA  51C5      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
08BC  61C6      	CPFSLT FCI_SHEAD_00000_1_len, 1
08BE  D01A      	BRA	label111
08C0  51B5      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
08C2  6EEA      	MOVWF FSR0H
08C4  51B4      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
08C6  25C6      	ADDWF FCI_SHEAD_00000_1_len, W, 1
08C8  6EE9      	MOVWF FSR0L
08CA  52EF      	MOVF INDF0, F
08CC  E013      	BZ	label111
08CE  51B5      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
08D0  6EEA      	MOVWF FSR0H
08D2  51B4      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
08D4  6EE9      	MOVWF FSR0L
08D6  51C6      	MOVF FCI_SHEAD_00000_1_len, W, 1
08D8  6FC8      	MOVWF CompTempVar2052, 1
08DA  51C8      	MOVF CompTempVar2052, W, 1
08DC  26E9      	ADDWF FSR0L, F
08DE  50EF      	MOVF INDF0, W
08E0  6FC9      	MOVWF CompTempVar2053, 1
08E2  51C4      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
08E4  6EEA      	MOVWF FSR0H
08E6  51C3      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
08E8  25C6      	ADDWF FCI_SHEAD_00000_1_len, W, 1
08EA  6EE9      	MOVWF FSR0L
08EC  51C9      	MOVF CompTempVar2053, W, 1
08EE  6EEF      	MOVWF INDF0
08F0  2BC6      	INCF FCI_SHEAD_00000_1_len, F, 1
08F2  D7E0      	BRA	label110
08F4            label111

    // Copy second
    if (len < iDst_len)
08F4  51C5      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
08F6  61C6      	CPFSLT FCI_SHEAD_00000_1_len, 1
08F8  D030      	BRA	label114
095A            label114

    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
08FA  6BC9      	CLRF CompTempVar2059, 1
08FC  51C6      	MOVF FCI_SHEAD_00000_1_len, W, 1
08FE  25C3      	ADDWF FCI_SHEAD_00000_arg_sDst, W, 1
0900  6FC8      	MOVWF CompTempVar2058, 1
0902  51C4      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0904  23C9      	ADDWFC CompTempVar2059, F, 1
0906  51C8      	MOVF CompTempVar2058, W, 1
0908  6FB4      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
090A  51C9      	MOVF CompTempVar2059, W, 1
090C  6FB5      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1

      iSrc1_len = iDst_len - len;
090E  51C6      	MOVF FCI_SHEAD_00000_1_len, W, 1
0910  5DC5      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
0912  6FBF      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1

      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
0914  6BC7      	CLRF FCI_SHEAD_00000_1_strt, 1
0916            label112
0916  51C2      	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W, 1
0918  61C7      	CPFSLT FCI_SHEAD_00000_1_strt, 1
091A  D01D      	BRA	label113
091C  51BF      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W, 1
091E  61C7      	CPFSLT FCI_SHEAD_00000_1_strt, 1
0920  D01A      	BRA	label113
0922  51C1      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W, 1
0924  6EEA      	MOVWF FSR0H
0926  51C0      	MOVF FCI_SHEAD_00000_arg_sSrc2, W, 1
0928  25C7      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
092A  6EE9      	MOVWF FSR0L
092C  52EF      	MOVF INDF0, F
092E  E013      	BZ	label113
0930  51C1      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W, 1
0932  6EEA      	MOVWF FSR0H
0934  51C0      	MOVF FCI_SHEAD_00000_arg_sSrc2, W, 1
0936  6EE9      	MOVWF FSR0L
0938  51C7      	MOVF FCI_SHEAD_00000_1_strt, W, 1
093A  6FC8      	MOVWF CompTempVar2062, 1
093C  51C8      	MOVF CompTempVar2062, W, 1
093E  26E9      	ADDWF FSR0L, F
0940  50EF      	MOVF INDF0, W
0942  6FC9      	MOVWF CompTempVar2063, 1
0944  51B5      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W, 1
0946  6EEA      	MOVWF FSR0H
0948  51B4      	MOVF FCI_SHEAD_00000_arg_sSrc1, W, 1
094A  25C7      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
094C  6EE9      	MOVWF FSR0L
094E  51C9      	MOVF CompTempVar2063, W, 1
0950  6EEF      	MOVWF INDF0
0952  2BC7      	INCF FCI_SHEAD_00000_1_strt, F, 1
0954  D7E0      	BRA	label112
0956            label113

      len += strt;
0956  51C7      	MOVF FCI_SHEAD_00000_1_strt, W, 1
0958  27C6      	ADDWF FCI_SHEAD_00000_1_len, F, 1

    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
095A  51C5      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
095C  61C6      	CPFSLT FCI_SHEAD_00000_1_len, 1

  {
    sDst[len] = '\0';
0960  51C4      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0962  6EEA      	MOVWF FSR0H
0964  51C3      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
0966  25C6      	ADDWF FCI_SHEAD_00000_1_len, W, 1
0968  6EE9      	MOVWF FSR0L
096A  0E00      	MOVLW 0x00
096C  6EEF      	MOVWF INDF0

  }
}
095E  0012      	RETURN
096E  0012      	RETURN



/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
02D6  6BEF      	CLRF FCI_SCOPY_00000_1_len, 1
02D8            label42
02D8  51EB      	MOVF FCI_SCOPY_00000_arg_iSrc_len, W, 1
02DA  61EF      	CPFSLT FCI_SCOPY_00000_1_len, 1
02DC  D01D      	BRA	label43
02DE  51EE      	MOVF FCI_SCOPY_00000_arg_iDst_len, W, 1
02E0  61EF      	CPFSLT FCI_SCOPY_00000_1_len, 1
02E2  D01A      	BRA	label43
02E4  51EA      	MOVF FCI_SCOPY_00000_arg_sSrc+D'1', W, 1
02E6  6EEA      	MOVWF FSR0H
02E8  51E9      	MOVF FCI_SCOPY_00000_arg_sSrc, W, 1
02EA  25EF      	ADDWF FCI_SCOPY_00000_1_len, W, 1
02EC  6EE9      	MOVWF FSR0L
02EE  52EF      	MOVF INDF0, F
02F0  E013      	BZ	label43
02F2  51EA      	MOVF FCI_SCOPY_00000_arg_sSrc+D'1', W, 1
02F4  6EEA      	MOVWF FSR0H
02F6  51E9      	MOVF FCI_SCOPY_00000_arg_sSrc, W, 1
02F8  6EE9      	MOVWF FSR0L
02FA  51EF      	MOVF FCI_SCOPY_00000_1_len, W, 1
02FC  6FF0      	MOVWF CompTempVar2071, 1
02FE  51F0      	MOVF CompTempVar2071, W, 1
0300  26E9      	ADDWF FSR0L, F
0302  50EF      	MOVF INDF0, W
0304  6FF1      	MOVWF CompTempVar2072, 1
0306  51ED      	MOVF FCI_SCOPY_00000_arg_sDst+D'1', W, 1
0308  6EEA      	MOVWF FSR0H
030A  51EC      	MOVF FCI_SCOPY_00000_arg_sDst, W, 1
030C  25EF      	ADDWF FCI_SCOPY_00000_1_len, W, 1
030E  6EE9      	MOVWF FSR0L
0310  51F1      	MOVF CompTempVar2072, W, 1
0312  6EEF      	MOVWF INDF0
0314  2BEF      	INCF FCI_SCOPY_00000_1_len, F, 1
0316  D7E0      	BRA	label42
0318            label43

  // Terminate (only if can)
  if (len < iDst_len)
0318  51EE      	MOVF FCI_SCOPY_00000_arg_iDst_len, W, 1
031A  61EF      	CPFSLT FCI_SCOPY_00000_1_len, 1

  {
    sDst[len] = '\0';
031E  51ED      	MOVF FCI_SCOPY_00000_arg_sDst+D'1', W, 1
0320  6EEA      	MOVWF FSR0H
0322  51EC      	MOVF FCI_SCOPY_00000_arg_sDst, W, 1
0324  25EF      	ADDWF FCI_SCOPY_00000_1_len, W, 1
0326  6EE9      	MOVWF FSR0L
0328  0E00      	MOVLW 0x00
032A  6EEF      	MOVWF INDF0

  }
}
031C  0012      	RETURN
032C  0012      	RETURN





//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BOYER\PROJET\Bluetooth\connect_boards\first_player\v2\joueur_1_with_gLCD.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Tuesday, May 09, 2017 17:29:40
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x78
#endif
#ifdef HI_TECH_C
__CONFIG(0x78);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_ASCII 255
#define FCVsz_RETURN 20
#define FCV_FALSE (0)
#define FCV_BT_CONNECTED (255) // Indique si les deux modules bluetooth sont connectés
#define FCV_BT_COMMAND_EMPTY (255) // Résultat de la commande vide
#define FCV_BT_COMMAND_OK (0) // Succès de la commande
#define FCV_TRUE (1)
MX_GLOBAL MX_CHAR FCV_ASCII[FCVsz_ASCII];
MX_GLOBAL MX_UINT8 FCV_OCTET;
MX_GLOBAL MX_CHAR FCV_RETURN[FCVsz_RETURN];
MX_GLOBAL MX_UINT8 FCV_COMMAND_RETURN; // Retour des commandes envoyés/reçues
MX_GLOBAL MX_UINT8 FCV_BT_STATE = (0xa5); // État du bluetooth
19FA  0EA5      	MOVLW 0xA5
19FC  6E74      	MOVWF gbl_FCV_BT_STATE

MX_GLOBAL MX_SINT16 FCV_LOOP;

MX_UINT8 FCM_CONVERT_TABLE_STRING(MX_CHAR *PFCL_VAR_TABLE);
void FCM_INITIALISATION();
void FCM_BT_CHECK_CONNECTON();
void FCM_BT_DATA_RECEIVER();
MX_UINT8 FCM_CONVERT_BINARY_ASCII(MX_CHAR *PFCL_VAR_BINARY);
void FCM_SET_ASCII_CHARATERS();
void FCM_CHECK_BT_GETTING();
void FCM_BT_CONNECTION();
void FCM_INTER_RECEIVE();

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_2 trise
#define MX_UART_REF2 
#define MX_UART_RTS_PIN_2 (3)
#define MX_UART_DBITS_2 (8)
#define MX_UART_RETURN_2 (0)
#define MX_UART_RX_PORT_2 porte
#define MX_UART_RTS_PORT_2 porta
#define MX_UART_ECHO_2 (0)
#define MX_UART_FLOWEN_2 (0)
#define MX_UART_CTS_PORT_2 porta
#define MX_UART_TX_PIN_2 (1)
#define MX_UART_RX_TRIS_2 trise
#define MX_UART_RTS_TRIS_2 trisa
#define MX_UART_BAUD_2 (9600)
#define MX_UART_TX_PORT_2 porte
#define MX_UART_RX_PIN_2 (2)
#define MX_UART_CTS_TRIS_2 trisa
#define MX_UART_CHANNEL_2 (0)
#define MX_UART_CTS_PIN_2 (2)
#define MX_UART_INT_2 (0)

MX_GLOBAL MX_UINT32 FCV_05482_cal_uart__CONSOLE;

void FCD_05482_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_2(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_2(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_2(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_2();
void FC_CAL_UART_Delay_2();
void FC_CAL_UART_Uninit_2();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
19FE  0E00      	MOVLW 0x00
1A00  6E75      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
1A02  0E01      	MOVLW 0x01
1A04  6E76      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
1A06  0E02      	MOVLW 0x02
1A08  6E77      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
1A0A  0E03      	MOVLW 0x03
1A0C  6E78      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
1A0E  0E04      	MOVLW 0x04
1A10  6E79      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
1A12  0E05      	MOVLW 0x05
1A14  6E7A      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
1A16  0E06      	MOVLW 0x06
1A18  6E7B      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
1A1A  0E07      	MOVLW 0x07
1A1C  6E7C      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
1A1E  6A5F      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009
1A20  6A60      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1'
1A22  6A61      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2'
1A24  6A62      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3'

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
1A26  6A7D      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :ctrl_lcd
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_eb005
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_0ad31_lcd_eb005__Clear FCD_04071_LCD__Clear
#define FCD_0ad31_lcd_eb005__PrintString FCD_04071_LCD__PrintString
#define FCD_0ad31_lcd_eb005__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0ad31_lcd_eb005__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0ad31_lcd_eb005__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0ad31_lcd_eb005__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0ad31_lcd_eb005__Cursor FCD_04071_LCD__Cursor
#define FCD_0ad31_lcd_eb005__Command FCD_04071_LCD__Command
#define FCD_0ad31_lcd_eb005__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0ad31_lcd_eb005__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0ad31_lcd_eb005__RawSend FCD_04071_LCD__RawSend
#define FCD_0ad31_lcd_eb005__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :InjectorBase1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 portb
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 portb
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisb
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisb
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (4)
#define MX_UART_INT_1 (1)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :Bluetooth2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_0c851_Bluetooth2__STRING_ARRAY 50
#define FCV_0c851_Bluetooth2__BT_CHAR_CR (13)
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__STRING_ARRAY[FCVsz_0c851_Bluetooth2__STRING_ARRAY];
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_IDX = (0x0);
1A28  6A7E      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX

MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_DONE = (0x0);
1A2A  6A7F      	CLRF gbl_FCV_0c851_Bluetooth2___00011

MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_LENGTH = (0x0);
1A2C  0100      	MOVLB 0x00
1A2E  6B80      	CLRF gbl_FCV_0c851_Bluetooth2___00012, 1


MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY);
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT);
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX);
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR);
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES);
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings();
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA);
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE);
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive();
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings();
MX_UINT8 FCD_0c851_Bluetooth2__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05482_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x40);

	FC_CAL_UART_Send_2(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x40);

	FC_CAL_UART_Send_2(0x63);

	FC_CAL_UART_Send_2(FCL_X >> 8);

	FC_CAL_UART_Send_2(FCL_X);

	FC_CAL_UART_Send_2(FCL_Y >> 8);

	FC_CAL_UART_Send_2(FCL_Y);

	FC_CAL_UART_Send_2(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_2(FCL_WIDTH);

	FC_CAL_UART_Send_2(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_2(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_2(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_2(0);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)
{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;

	if (FCL_AXIS == 0)
	{

	} else {

		if (FCL_AXIS == 'x')
		{

		} else {

			if (FCL_AXIS == 'X')
			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;

			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;

FCC_G4D_ReadTouchCoordinatesPicaso_A:
;

	if (FCL_AXIS == 1)
	{

	} else {

		if (FCL_AXIS == 'y')
		{

		} else {

			if (FCL_AXIS == 'Y')
			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;

			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;

FCC_G4D_ReadTouchCoordinatesPicaso_B:
;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()
{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x6F);

	FC_CAL_UART_Send_2(4);

	FC_CAL_UART_Receive_2(255);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	FC_CAL_UART_Receive_2(255);

	FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL)
	{

		FC_CAL_UART_Send_2(0x6F);

		FC_CAL_UART_Send_2(5);

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_2(255);

		FCL_TEMP = FC_CAL_UART_Receive_2(255);

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_2(255);

		FCL_TEMP = FC_CAL_UART_Receive_2(255);

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;

	// } else {

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_2(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_2(0x00);

	} else {

		FC_CAL_UART_Send_2(0x01);

	}

	FC_CAL_UART_Receive_2(255);

	FC_CAL_UART_Send_2(0x43);

	FC_CAL_UART_Send_2(FCL_X >> 8);

	FC_CAL_UART_Send_2(FCL_X);

	FC_CAL_UART_Send_2(FCL_Y >> 8);

	FC_CAL_UART_Send_2(FCL_Y);

	FC_CAL_UART_Send_2(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_2(FCL_RADIUS);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_2(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FC_CAL_UART_Send_2(0x4C);

	FC_CAL_UART_Send_2(FCL_X1 >> 8);

	FC_CAL_UART_Send_2(FCL_X1);

	FC_CAL_UART_Send_2(FCL_Y1 >> 8);

	FC_CAL_UART_Send_2(FCL_Y1);

	FC_CAL_UART_Send_2(FCL_X2 >> 8);

	FC_CAL_UART_Send_2(FCL_X2);

	FC_CAL_UART_Send_2(FCL_Y2 >> 8);

	FC_CAL_UART_Send_2(FCL_Y2);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_2(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_2(0x40);

	FC_CAL_UART_Send_2(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_2(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_2(0);

	FC_CAL_UART_Send_2(FCL_X >> 8);

	FC_CAL_UART_Send_2(FCL_X);

	FC_CAL_UART_Send_2(FCL_Y >> 8);

	FC_CAL_UART_Send_2(FCL_Y);

	FC_CAL_UART_Send_2(FCL_POSH >> 8);

	FC_CAL_UART_Send_2(FCL_POSH);

	FC_CAL_UART_Send_2(FCL_POSL >> 8);

	FC_CAL_UART_Send_2(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x59);

	FC_CAL_UART_Send_2(0x05);

	FC_CAL_UART_Send_2(0x01);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_2(0x50);

	FC_CAL_UART_Send_2(FCL_X1 >> 8);

	FC_CAL_UART_Send_2(FCL_X1);

	FC_CAL_UART_Send_2(FCL_Y1 >> 8);

	FC_CAL_UART_Send_2(FCL_Y1);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_2(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_2(0x59);

	FC_CAL_UART_Send_2(0x00);

	FC_CAL_UART_Send_2(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_2(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_2(0x59);

	FC_CAL_UART_Send_2(0x01);

	FC_CAL_UART_Send_2(FCL_DISPLAY);

	FC_CAL_UART_Receive_2(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_2(0x59);

	FC_CAL_UART_Send_2(0x02);

	FC_CAL_UART_Send_2(FCL_CONTRAST);

	FC_CAL_UART_Receive_2(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x59);

	FC_CAL_UART_Send_2(0x05);

	FC_CAL_UART_Send_2(0x00);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	FC_CAL_UART_Send_2(0x59);

	FC_CAL_UART_Send_2(0x05);

	FC_CAL_UART_Send_2(0x02);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x40);

	FC_CAL_UART_Send_2(0x56);

	FC_CAL_UART_Send_2(FCL_X >> 8);

	FC_CAL_UART_Send_2(FCL_X);

	FC_CAL_UART_Send_2(FCL_Y >> 8);

	FC_CAL_UART_Send_2(FCL_Y);

	FC_CAL_UART_Send_2(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_2(FCL_WIDTH);

	FC_CAL_UART_Send_2(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_2(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_2(0x10);

	} else {

		FC_CAL_UART_Send_2(0x08);

	}

	FC_CAL_UART_Send_2(FCL_DELAY);

	FC_CAL_UART_Send_2(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_2(FCL_FRAMES);

	FC_CAL_UART_Send_2(FCL_ADDH);

	FC_CAL_UART_Send_2(FCL_ADDM);

	FC_CAL_UART_Send_2(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x76);

	FC_CAL_UART_Send_2(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_2(0x59);

	FC_CAL_UART_Send_2(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_2(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_2(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_2(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_2(0x03);

		}
	}

	FC_CAL_UART_Receive_2(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_2(0x50);

	FC_CAL_UART_Send_2(FCL_X1 >> 8);

	FC_CAL_UART_Send_2(FCL_X1);

	FC_CAL_UART_Send_2(FCL_Y1 >> 8);

	FC_CAL_UART_Send_2(FCL_Y1);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_2(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_2(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_2(0x00);

	} else {

		FC_CAL_UART_Send_2(0x01);

	}

	FC_CAL_UART_Receive_2(255);

	FC_CAL_UART_Send_2(0x65);

	FC_CAL_UART_Send_2(FCL_X >> 8);

	FC_CAL_UART_Send_2(FCL_X);

	FC_CAL_UART_Send_2(FCL_Y >> 8);

	FC_CAL_UART_Send_2(FCL_Y);

	FC_CAL_UART_Send_2(FCL_RX >> 8);

	FC_CAL_UART_Send_2(FCL_RX);

	FC_CAL_UART_Send_2(FCL_RY >> 8);

	FC_CAL_UART_Send_2(FCL_RY);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_2(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);
034E  6BE3      	CLRF FCD_0f051__0007B_1_FCL_IDX, 1



	FC_CAL_UART_Send_2(0x4F);
0350  0E4F      	MOVLW 0x4F
0352  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
0354  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
0356  0E00      	MOVLW 0x00
0358  EF73F000  	GOTO	FC_CAL_UAR_00082
035C            label46


	if (FCL_TRANSPARENT)
035C  53E1      	MOVF FCD_0f051__0007B_arg_FCL_T_0007C, F, 1
035E  E006      	BZ	label48
036C            label48

	{

		FC_CAL_UART_Send_2(0x00);
0360  6BF7      	CLRF FC_CAL_UAR_00082_arg_nChar, 1
0362  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
0364  0E04      	MOVLW 0x04
0366  EF73F000  	GOTO	FC_CAL_UAR_00082
036A            label47


	} else {
036A  D006      	BRA	label49


		FC_CAL_UART_Send_2(0x01);
036C  0E01      	MOVLW 0x01
036E  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
0370  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
0372  0E08      	MOVLW 0x08
0374  EF73F000  	GOTO	FC_CAL_UAR_00082
0378            label49


	}

	FC_CAL_UART_Receive_2(255);
0378  69F7      	SETF FC_CAL_UAR_00080_arg_nTimeout, 1
037A  0E00      	MOVLW 0x00
037C  EFBFF000  	GOTO	FC_CAL_UAR_00080
0380            label50


	FC_CAL_UART_Send_2(0x53);
0380  0E53      	MOVLW 0x53
0382  0100      	MOVLB 0x00
0384  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
0386  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
0388  0E0C      	MOVLW 0x0C
038A  EF73F000  	GOTO	FC_CAL_UAR_00082
038E            label51


	FC_CAL_UART_Send_2(FCL_X1 >> 8);
038E  51DD      	MOVF FCD_0f051__0007B_arg_FCL_X1+D'1', W, 1
0390  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
0392  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
0394  0E10      	MOVLW 0x10
0396  EF73F000  	GOTO	FC_CAL_UAR_00082
039A            label52


	FC_CAL_UART_Send_2(FCL_X1);
039A  51DC      	MOVF FCD_0f051__0007B_arg_FCL_X1, W, 1
039C  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
039E  51DD      	MOVF FCD_0f051__0007B_arg_FCL_X1+D'1', W, 1
03A0  6FF8      	MOVWF FC_CAL_UAR_00082_arg_nChar+D'1', 1
03A2  0E14      	MOVLW 0x14
03A4  EF73F000  	GOTO	FC_CAL_UAR_00082
03A8            label53


	FC_CAL_UART_Send_2(FCL_Y1 >> 8);
03A8  51DF      	MOVF FCD_0f051__0007B_arg_FCL_Y1+D'1', W, 1
03AA  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
03AC  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
03AE  0E18      	MOVLW 0x18
03B0  EF73F000  	GOTO	FC_CAL_UAR_00082
03B4            label54


	FC_CAL_UART_Send_2(FCL_Y1);
03B4  51DE      	MOVF FCD_0f051__0007B_arg_FCL_Y1, W, 1
03B6  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
03B8  51DF      	MOVF FCD_0f051__0007B_arg_FCL_Y1+D'1', W, 1
03BA  6FF8      	MOVWF FC_CAL_UAR_00082_arg_nChar+D'1', 1
03BC  0E1C      	MOVLW 0x1C
03BE  EF73F000  	GOTO	FC_CAL_UAR_00082
03C2            label55


	FC_CAL_UART_Send_2(FCL_FONT);
03C2  51E0      	MOVF FCD_0f051__0007B_arg_FCL_FONT, W, 1
03C4  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
03C6  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
03C8  0E20      	MOVLW 0x20
03CA  EF73F000  	GOTO	FC_CAL_UAR_00082
03CE            label56


	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
03CE  5068      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
03D0  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
03D2  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
03D4  0E24      	MOVLW 0x24
03D6  EF73F000  	GOTO	FC_CAL_UAR_00082
03DA            label57


	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
03DA  5067      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W
03DC  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
03DE  5068      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
03E0  6FF8      	MOVWF FC_CAL_UAR_00082_arg_nChar+D'1', 1
03E2  0E28      	MOVLW 0x28
03E4  EF73F000  	GOTO	FC_CAL_UAR_00082
03E8            label58


	FC_CAL_UART_Send_2(1);
03E8  0E01      	MOVLW 0x01
03EA  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
03EC  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
03EE  0E2C      	MOVLW 0x2C
03F0  EF73F000  	GOTO	FC_CAL_UAR_00082
03F4            label59


	FC_CAL_UART_Send_2(1);
03F4  0E01      	MOVLW 0x01
03F6  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
03F8  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
03FA  0E30      	MOVLW 0x30
03FC  EF73F000  	GOTO	FC_CAL_UAR_00082
0400            label60


	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);
0400  51D8      	MOVF FCD_0f051__0007B_arg_FCL_STR, W, 1
0402  6FE4      	MOVWF FCI_GETLEN_0004E_arg_sStr1, 1
0404  51D9      	MOVF FCD_0f051__0007B_arg_FCL_STR+D'1', W, 1
0406  6FE5      	MOVWF FCI_GETLEN_0004E_arg_sStr1+D'1', 1
0408  51DA      	MOVF FCD_0f051__0007B_arg_FCLsz_STR, W, 1
040A  6FE6      	MOVWF FCI_GETLEN_0004E_arg_iStr1_len, 1
040C  EC97F001  	CALL FCI_GETLEN_0004E
0410  51E8      	MOVF CompTempVarRet1850, W, 1
0412  6FE2      	MOVWF FCD_0f051__0007B_1_FCL_LEN_STR, 1


	while (FCL_IDX < FCL_LEN_STR)
0414            label61
0414  51E2      	MOVF FCD_0f051__0007B_1_FCL_LEN_STR, W, 1
0416  61E3      	CPFSLT FCD_0f051__0007B_1_FCL_IDX, 1
0418  D015      	BRA	label63
0442  D7E8      	BRA	label61
0444            label63

	{

		if (FCL_STR[FCL_IDX] == 0)
041A  51D9      	MOVF FCD_0f051__0007B_arg_FCL_STR+D'1', W, 1
041C  6EEA      	MOVWF FSR0H
041E  51D8      	MOVF FCD_0f051__0007B_arg_FCL_STR, W, 1
0420  25E3      	ADDWF FCD_0f051__0007B_1_FCL_IDX, W, 1
0422  6EE9      	MOVWF FSR0L
0424  52EF      	MOVF INDF0, F
0426  E00E      	BZ	label63

		{

			goto FCC_Print_A;


		// } else {

		}

		FC_CAL_UART_Send_2(FCL_STR[FCL_IDX]);
0428  51D9      	MOVF FCD_0f051__0007B_arg_FCL_STR+D'1', W, 1
042A  6EEA      	MOVWF FSR0H
042C  51D8      	MOVF FCD_0f051__0007B_arg_FCL_STR, W, 1
042E  25E3      	ADDWF FCD_0f051__0007B_1_FCL_IDX, W, 1
0430  6EE9      	MOVWF FSR0L
0432  50EF      	MOVF INDF0, W
0434  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
0436  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
0438  0E34      	MOVLW 0x34
043A  EF73F000  	GOTO	FC_CAL_UAR_00082
043E            label62


		FCL_IDX = FCL_IDX + 1;
043E  29E3      	INCF FCD_0f051__0007B_1_FCL_IDX, W, 1
0440  6FE3      	MOVWF FCD_0f051__0007B_1_FCL_IDX, 1



	}

FCC_Print_A:
;

	FC_CAL_UART_Send_2(0);
0444  6BF7      	CLRF FC_CAL_UAR_00082_arg_nChar, 1
0446  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
0448  0E38      	MOVLW 0x38
044A  EF73F000  	GOTO	FC_CAL_UAR_00082
044E            label64


	FC_CAL_UART_Receive_2(255);
044E  69F7      	SETF FC_CAL_UAR_00080_arg_nTimeout, 1
0450  0E04      	MOVLW 0x04
0452  EFBFF000  	GOTO	FC_CAL_UAR_00080
0456            label65


}
0456  EF06F003  	GOTO	label84


/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x40);

	FC_CAL_UART_Send_2(0x43);

	FC_CAL_UART_Send_2(FCL_X >> 8);

	FC_CAL_UART_Send_2(FCL_X);

	FC_CAL_UART_Send_2(FCL_Y >> 8);

	FC_CAL_UART_Send_2(FCL_Y);

	FC_CAL_UART_Send_2(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_2(FCL_WIDTH);

	FC_CAL_UART_Send_2(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_2(FCL_HEIGHT);

	FC_CAL_UART_Send_2(FCL_ADDH);

	FC_CAL_UART_Send_2(FCL_ADDM);

	FC_CAL_UART_Send_2(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x59);

	FC_CAL_UART_Send_2(0x0c);

	FC_CAL_UART_Send_2(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
0272  0100      	MOVLB 0x00
0274  6FF6      	MOVWF FCD_0f051__00076_1___retpointvar, 1
0276  6BF2      	CLRF FCD_0f051__00076_1_FCL_Y, 1
0278  6BF3      	CLRF FCD_0f051__00076_1_FCL_Y+D'1', 1

	MX_UINT16 FCL_X = (0x0);
027A  6BF4      	CLRF FCD_0f051__00076_1_FCL_X, 1
027C  6BF5      	CLRF FCD_0f051__00076_1_FCL_X+D'1', 1



	FC_CAL_UART_Send_2(0x42);
027E  0E42      	MOVLW 0x42
0280  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
0282  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
0284  0E3C      	MOVLW 0x3C
0286  EF73F000  	GOTO	FC_CAL_UAR_00082
028A            label34


	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
028A  5066      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
028C  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
028E  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
0290  0E40      	MOVLW 0x40
0292  EF73F000  	GOTO	FC_CAL_UAR_00082
0296            label35


	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
0296  5065      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W
0298  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
029A  5066      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
029C  6FF8      	MOVWF FC_CAL_UAR_00082_arg_nChar+D'1', 1
029E  0E44      	MOVLW 0x44
02A0  EF73F000  	GOTO	FC_CAL_UAR_00082
02A4            label36


	FC_CAL_UART_Receive_2(255);
02A4  69F7      	SETF FC_CAL_UAR_00080_arg_nTimeout, 1
02A6  0E08      	MOVLW 0x08
02A8  EFBFF000  	GOTO	FC_CAL_UAR_00080
02AC            label37


	FC_CAL_UART_Send_2(0x45);
02AC  0E45      	MOVLW 0x45
02AE  0100      	MOVLB 0x00
02B0  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
02B2  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
02B4  0E48      	MOVLW 0x48
02B6  EF73F000  	GOTO	FC_CAL_UAR_00082
02BA            label38


	FC_CAL_UART_Receive_2(255);
02BA  69F7      	SETF FC_CAL_UAR_00080_arg_nTimeout, 1
02BC  0E0C      	MOVLW 0x0C
02BE  EFBFF000  	GOTO	FC_CAL_UAR_00080
02C2            label39


}
02C2  D000      	BRA	label40
02C4            label40
02C4  0E02      	MOVLW	HIGH( label41 )
02C6  6EFA      	MOVWF PCLATH
02C8  0100      	MOVLB 0x00
02CA  51F6      	MOVF FCD_0f051__00076_1___retpointvar, W, 1
02CC  26F9      	ADDWF PCL, F
02CE            label41
02CE  EFE0F002  	GOTO	label82
02D2  EFC4F00C  	GOTO	label236


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x40);

	FC_CAL_UART_Send_2(0x49);

	FC_CAL_UART_Send_2(FCL_X >> 8);

	FC_CAL_UART_Send_2(FCL_X);

	FC_CAL_UART_Send_2(FCL_Y >> 8);

	FC_CAL_UART_Send_2(FCL_Y);

	FC_CAL_UART_Send_2(FCL_ADDH);

	FC_CAL_UART_Send_2(FCL_ADDM);

	FC_CAL_UART_Send_2(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_2(0x75);

	FC_CAL_UART_Send_2(FCL_X1 >> 8);

	FC_CAL_UART_Send_2(FCL_X1);

	FC_CAL_UART_Send_2(FCL_Y1 >> 8);

	FC_CAL_UART_Send_2(FCL_Y1);

	FC_CAL_UART_Send_2(FCL_X2 >> 8);

	FC_CAL_UART_Send_2(FCL_X2);

	FC_CAL_UART_Send_2(FCL_Y2 >> 8);

	FC_CAL_UART_Send_2(FCL_Y2);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_2(0x40);

	FC_CAL_UART_Send_2(0x6C);

	FC_CAL_UART_Send_2(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_2(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_2(0);

	FCR_RETVAL = FC_CAL_UART_Receive_2(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
	{

		FC_CAL_UART_Send_2(0x70);

		FC_CAL_UART_Send_2(0x00);

		FC_CAL_UART_Receive_2(255);

		FC_CAL_UART_Send_2(0x72);

		FC_CAL_UART_Send_2(FCL_X1 >> 8);

		FC_CAL_UART_Send_2(FCL_X1);

		FC_CAL_UART_Send_2(FCL_Y1 >> 8);

		FC_CAL_UART_Send_2(FCL_Y1);

		FC_CAL_UART_Send_2(FCL_X2 >> 8);

		FC_CAL_UART_Send_2(FCL_X2);

		FC_CAL_UART_Send_2(FCL_Y2 >> 8);

		FC_CAL_UART_Send_2(FCL_Y2);

		FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

		FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

		FC_CAL_UART_Receive_2(255);

	// } else {

	}

	FC_CAL_UART_Send_2(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_2(0x00);

	} else {

		FC_CAL_UART_Send_2(0x01);

	}

	FC_CAL_UART_Receive_2(255);

	FC_CAL_UART_Send_2(0x72);

	FC_CAL_UART_Send_2(FCL_X1 >> 8);

	FC_CAL_UART_Send_2(FCL_X1);

	FC_CAL_UART_Send_2(FCL_Y1 >> 8);

	FC_CAL_UART_Send_2(FCL_Y1);

	FC_CAL_UART_Send_2(FCL_X2 >> 8);

	FC_CAL_UART_Send_2(FCL_X2);

	FC_CAL_UART_Send_2(FCL_Y2 >> 8);

	FC_CAL_UART_Send_2(FCL_Y2);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_2(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_2(255);

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, E, 0x1, 0x0, 0);
1828  0100      	MOVLB 0x00
182A  6B85      	CLRF FCD_0f051__000BB_2_ptmp, 1
182C  9096      	BCF gbl_trise,0
182E  5385      	MOVF FCD_0f051__000BB_2_ptmp, F, 1
1830  E004      	BZ	label227
1832  0E01      	MOVLW 0x01
1834  108D      	IORWF gbl_late, W
1836  6E84      	MOVWF gbl_porte
1838  D003      	BRA	label228
183A            label227
183A  0EFE      	MOVLW 0xFE
183C  148D      	ANDWF gbl_late, W
183E  6E84      	MOVWF gbl_porte
1840            label228


	FC_CAL_UART_Init_2();
1840  EC6CF008  	CALL FC_CAL_UAR_00083


	FCI_DELAYBYTE_US(100);
1844  0E64      	MOVLW 0x64
1846  0101      	MOVLB 0x01
1848  6F04      	MOVWF delay_us_00000_arg_del, 1
184A  EC2EF000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, E, 0x1, 0x0);
184E  0E0F      	MOVLW HIGH(gbl_porte+D'0')
1850  0100      	MOVLB 0x00
1852  6F86      	MOVWF FC_CAL_Por_00045_arg_Port+D'1', 1
1854  0E84      	MOVLW LOW(gbl_porte+D'0')
1856  6F85      	MOVWF FC_CAL_Por_00045_arg_Port, 1
1858  0E0F      	MOVLW HIGH(gbl_trise+D'0')
185A  6F88      	MOVWF FC_CAL_Por_00045_arg_Tris+D'1', 1
185C  0E96      	MOVLW LOW(gbl_trise+D'0')
185E  6F87      	MOVWF FC_CAL_Por_00045_arg_Tris, 1
1860  0E01      	MOVLW 0x01
1862  6F89      	MOVWF FC_CAL_Por_00045_arg_InMask, 1
1864  6B8A      	CLRF FC_CAL_Por_00045_arg_Shift, 1
1866  EC70F008  	CALL FC_CAL_Por_00045
186A  518B      	MOVF CompTempVarRet1822, W, 1
186C  6F84      	MOVWF FCD_0f051__000BB_1_FCL_DUMMY, 1


	FCI_DELAYBYTE_S(3);
186E  0E03      	MOVLW 0x03
1870  6F85      	MOVWF delay_s_00000_arg_del, 1
1872  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_2(0);
1876  6BF7      	CLRF FC_CAL_UAR_00080_arg_nTimeout, 1
1878  0E10      	MOVLW 0x10
187A  EFBFF000  	GOTO	FC_CAL_UAR_00080
187E            label229


	FC_CAL_UART_Receive_2(0);
187E  0100      	MOVLB 0x00
1880  6BF7      	CLRF FC_CAL_UAR_00080_arg_nTimeout, 1
1882  0E14      	MOVLW 0x14
1884  EFBFF000  	GOTO	FC_CAL_UAR_00080
1888            label230


	FC_CAL_UART_Receive_2(0);
1888  0100      	MOVLB 0x00
188A  6BF7      	CLRF FC_CAL_UAR_00080_arg_nTimeout, 1
188C  0E18      	MOVLW 0x18
188E  EFBFF000  	GOTO	FC_CAL_UAR_00080
1892            label231


	FC_CAL_UART_Send_2(0x55);
1892  0E55      	MOVLW 0x55
1894  0100      	MOVLB 0x00
1896  6FF7      	MOVWF FC_CAL_UAR_00082_arg_nChar, 1
1898  6BF8      	CLRF FC_CAL_UAR_00082_arg_nChar+D'1', 1
189A  0E4C      	MOVLW 0x4C
189C  EF73F000  	GOTO	FC_CAL_UAR_00082
18A0            label232


	FC_CAL_UART_Receive_2(255);
18A0  69F7      	SETF FC_CAL_UAR_00080_arg_nTimeout, 1
18A2  0E1C      	MOVLW 0x1C
18A4  EFBFF000  	GOTO	FC_CAL_UAR_00080
18A8            label233


	#if (1) // 1 == 1

		#if (0) // 0 != 0

		//Le code a été optimisé par le préprocesseur
		// #else

		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_2(10);
18A8  0E0A      	MOVLW 0x0A
18AA  0100      	MOVLB 0x00
18AC  6FF7      	MOVWF FC_CAL_UAR_00080_arg_nTimeout, 1
18AE  0E20      	MOVLW 0x20
18B0  EFBFF000  	GOTO	FC_CAL_UAR_00080
18B4            label234


	FC_CAL_UART_Receive_2(10);
18B4  0E0A      	MOVLW 0x0A
18B6  0100      	MOVLB 0x00
18B8  6FF7      	MOVWF FC_CAL_UAR_00080_arg_nTimeout, 1
18BA  0E24      	MOVLW 0x24
18BC  EFBFF000  	GOTO	FC_CAL_UAR_00080
18C0            label235


	FCL_RED = 0 & 0xFF;
18C0  0100      	MOVLB 0x00
18C2  6B81      	CLRF FCD_0f051__000BB_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
18C4  3381      	RRCF FCD_0f051__000BB_1_FCL_RED, F, 1
18C6  3381      	RRCF FCD_0f051__000BB_1_FCL_RED, F, 1
18C8  3381      	RRCF FCD_0f051__000BB_1_FCL_RED, F, 1
18CA  0E1F      	MOVLW 0x1F
18CC  1781      	ANDWF FCD_0f051__000BB_1_FCL_RED, F, 1

	FCL_GREEN = (0 >> 8) & 0xFF;
18CE  6B82      	CLRF FCD_0f051__000BB_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
18D0  3382      	RRCF FCD_0f051__000BB_1_FCL_GREEN, F, 1
18D2  3382      	RRCF FCD_0f051__000BB_1_FCL_GREEN, F, 1
18D4  0E3F      	MOVLW 0x3F
18D6  1782      	ANDWF FCD_0f051__000BB_1_FCL_GREEN, F, 1

	FCL_BLUE = (0 >> 16) & 0xFF;
18D8  6B83      	CLRF FCD_0f051__000BB_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
18DA  3383      	RRCF FCD_0f051__000BB_1_FCL_BLUE, F, 1
18DC  3383      	RRCF FCD_0f051__000BB_1_FCL_BLUE, F, 1
18DE  3383      	RRCF FCD_0f051__000BB_1_FCL_BLUE, F, 1
18E0  0E1F      	MOVLW 0x1F
18E2  1783      	ANDWF FCD_0f051__000BB_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
18E4  5182      	MOVF FCD_0f051__000BB_1_FCL_GREEN, W, 1
18E6  6F85      	MOVWF CompTempVar3039, 1
18E8  6A68      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1'
18EA  3785      	RLCF CompTempVar3039, F, 1
18EC  3668      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
18EE  3785      	RLCF CompTempVar3039, F, 1
18F0  3668      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
18F2  3785      	RLCF CompTempVar3039, F, 1
18F4  3668      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
18F6  3785      	RLCF CompTempVar3039, F, 1
18F8  3668      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
18FA  3785      	RLCF CompTempVar3039, F, 1
18FC  3668      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
18FE  0EE0      	MOVLW 0xE0
1900  1785      	ANDWF CompTempVar3039, F, 1
1902  5185      	MOVF CompTempVar3039, W, 1
1904  1183      	IORWF FCD_0f051__000BB_1_FCL_BLUE, W, 1
1906  6E67      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
1908  6B85      	CLRF CompTempVar3043, 1
190A  5181      	MOVF FCD_0f051__000BB_1_FCL_RED, W, 1
190C  6F86      	MOVWF CompTempVar3044, 1
190E  90D8      	BCF STATUS,C
1910  3786      	RLCF CompTempVar3044, F, 1
1912  90D8      	BCF STATUS,C
1914  3786      	RLCF CompTempVar3044, F, 1
1916  90D8      	BCF STATUS,C
1918  3786      	RLCF CompTempVar3044, F, 1
191A  5185      	MOVF CompTempVar3043, W, 1
191C  1267      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F
191E  5186      	MOVF CompTempVar3044, W, 1
1920  1268      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F

	FCL_RED = 16777215 & 0xFF;
1922  6981      	SETF FCD_0f051__000BB_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
1924  3381      	RRCF FCD_0f051__000BB_1_FCL_RED, F, 1
1926  3381      	RRCF FCD_0f051__000BB_1_FCL_RED, F, 1
1928  3381      	RRCF FCD_0f051__000BB_1_FCL_RED, F, 1
192A  0E1F      	MOVLW 0x1F
192C  1781      	ANDWF FCD_0f051__000BB_1_FCL_RED, F, 1

	FCL_GREEN = (16777215 >> 8) & 0xFF;
192E  6982      	SETF FCD_0f051__000BB_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
1930  3382      	RRCF FCD_0f051__000BB_1_FCL_GREEN, F, 1
1932  3382      	RRCF FCD_0f051__000BB_1_FCL_GREEN, F, 1
1934  0E3F      	MOVLW 0x3F
1936  1782      	ANDWF FCD_0f051__000BB_1_FCL_GREEN, F, 1

	FCL_BLUE = (16777215 >> 16) & 0xFF;
1938  6983      	SETF FCD_0f051__000BB_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
193A  3383      	RRCF FCD_0f051__000BB_1_FCL_BLUE, F, 1
193C  3383      	RRCF FCD_0f051__000BB_1_FCL_BLUE, F, 1
193E  3383      	RRCF FCD_0f051__000BB_1_FCL_BLUE, F, 1
1940  0E1F      	MOVLW 0x1F
1942  1783      	ANDWF FCD_0f051__000BB_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
1944  5182      	MOVF FCD_0f051__000BB_1_FCL_GREEN, W, 1
1946  6F85      	MOVWF CompTempVar3050, 1
1948  6A66      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1'
194A  3785      	RLCF CompTempVar3050, F, 1
194C  3666      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
194E  3785      	RLCF CompTempVar3050, F, 1
1950  3666      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
1952  3785      	RLCF CompTempVar3050, F, 1
1954  3666      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
1956  3785      	RLCF CompTempVar3050, F, 1
1958  3666      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
195A  3785      	RLCF CompTempVar3050, F, 1
195C  3666      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
195E  0EE0      	MOVLW 0xE0
1960  1785      	ANDWF CompTempVar3050, F, 1
1962  5185      	MOVF CompTempVar3050, W, 1
1964  1183      	IORWF FCD_0f051__000BB_1_FCL_BLUE, W, 1
1966  6E65      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
1968  6B85      	CLRF CompTempVar3054, 1
196A  5181      	MOVF FCD_0f051__000BB_1_FCL_RED, W, 1
196C  6F86      	MOVWF CompTempVar3055, 1
196E  90D8      	BCF STATUS,C
1970  3786      	RLCF CompTempVar3055, F, 1
1972  90D8      	BCF STATUS,C
1974  3786      	RLCF CompTempVar3055, F, 1
1976  90D8      	BCF STATUS,C
1978  3786      	RLCF CompTempVar3055, F, 1
197A  5185      	MOVF CompTempVar3054, W, 1
197C  1265      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F
197E  5186      	MOVF CompTempVar3055, W, 1
1980  1266      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
1982  0E04      	MOVLW 0x04
1984  EF39F001  	GOTO	FCD_0f051__00076
1988            label236


	FC_CAL_UART_Receive_2(10);
1988  0E0A      	MOVLW 0x0A
198A  6FF7      	MOVWF FC_CAL_UAR_00080_arg_nTimeout, 1
198C  0E28      	MOVLW 0x28
198E  EFBFF000  	GOTO	FC_CAL_UAR_00080
1992            label237


	FC_CAL_UART_Receive_2(10);
1992  0E0A      	MOVLW 0x0A
1994  0100      	MOVLB 0x00
1996  6FF7      	MOVWF FC_CAL_UAR_00080_arg_nTimeout, 1
1998  0E2C      	MOVLW 0x2C
199A  EFBFF000  	GOTO	FC_CAL_UAR_00080
199E            label238


}
199E  0012      	RETURN



/*========================================================================*\
   Use :ctrl_lcd
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()

{




	FCD_04071_LCD__RawSend(0x01, 0);
1076  0E01      	MOVLW 0x01
1078  0100      	MOVLB 0x00
107A  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
107C  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
107E  ECF0F004  	CALL FCD_04071__000BC


	FCI_DELAYBYTE_MS(2);
1082  0E02      	MOVLW 0x02
1084  6F05      	MOVWF delay_ms_00000_arg_del, 1
1086  EC06F000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x02, 0);
108A  0E02      	MOVLW 0x02
108C  0100      	MOVLB 0x00
108E  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
1090  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
1092  ECF0F004  	CALL FCD_04071__000BC


	FCI_DELAYBYTE_MS(2);
1096  0E02      	MOVLW 0x02
1098  6F05      	MOVWF delay_ms_00000_arg_del, 1
109A  EC06F000  	CALL delay_ms_00000


}
109E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Param??tres pour la macro PrintString :
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
10A0  6BA4      	CLRF FCD_04071__00064_1_FCL_IDX, 1

	MX_UINT8 FCL_COUNT;



	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);
10A2  518E      	MOVF FCD_04071__00064_arg_FCL_TEXT, W, 1
10A4  6FE4      	MOVWF FCI_GETLEN_0004E_arg_sStr1, 1
10A6  518F      	MOVF FCD_04071__00064_arg_FCL_TEXT+D'1', W, 1
10A8  6FE5      	MOVWF FCI_GETLEN_0004E_arg_sStr1+D'1', 1
10AA  51A2      	MOVF FCD_04071__00064_arg_FCLsz_TEXT, W, 1
10AC  6FE6      	MOVWF FCI_GETLEN_0004E_arg_iStr1_len, 1
10AE  EC97F001  	CALL FCI_GETLEN_0004E
10B2  51E8      	MOVF CompTempVarRet1850, W, 1
10B4  6FA5      	MOVWF FCD_04071__00064_1_FCL_COUNT, 1


	while (FCL_IDX < FCL_COUNT)
10B6            label185
10B6  51A5      	MOVF FCD_04071__00064_1_FCL_COUNT, W, 1
10B8  61A4      	CPFSLT FCD_04071__00064_1_FCL_IDX, 1
10D6  D7EF      	BRA	label185

	{

		FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);
10BC  518F      	MOVF FCD_04071__00064_arg_FCL_TEXT+D'1', W, 1
10BE  6EEA      	MOVWF FSR0H
10C0  518E      	MOVF FCD_04071__00064_arg_FCL_TEXT, W, 1
10C2  25A4      	ADDWF FCD_04071__00064_1_FCL_IDX, W, 1
10C4  6EE9      	MOVWF FSR0L
10C6  50EF      	MOVF INDF0, W
10C8  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
10CA  81A7      	BSF FCD_04071__000BC_arg_FCL_TYPE,0, 1
10CC  ECF0F004  	CALL FCD_04071__000BC


		FCL_IDX = FCL_IDX + 1;
10D0  0100      	MOVLB 0x00
10D2  29A4      	INCF FCD_04071__00064_1_FCL_IDX, W, 1
10D4  6FA4      	MOVWF FCD_04071__00064_1_FCL_IDX, 1



	}


}
10BA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Param??tres pour la macro PrintAscii :
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)

{
	//Définitions des variables locales
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);
1454  5182      	MOVF FCD_04071__00074_arg_FCL_NUMBER, W, 1
1456  6F8E      	MOVWF FCI_TOSTRI_00052_arg_iSrc1, 1
1458  5183      	MOVF FCD_04071__00074_arg_FCL_NUMBER+D'1', W, 1
145A  6F8F      	MOVWF FCI_TOSTRI_00052_arg_iSrc1+D'1', 1
145C  6B90      	CLRF FCI_TOSTRI_00052_arg_iSrc1+D'2', 1
145E  6B91      	CLRF FCI_TOSTRI_00052_arg_iSrc1+D'3', 1
1460  AF83      	BTFSS FCD_04071__00074_arg_FCL_NUMBER+D'1',7, 1
1462  D002      	BRA	label210
1464  0790      	DECF FCI_TOSTRI_00052_arg_iSrc1+D'2', F, 1
1466  0791      	DECF FCI_TOSTRI_00052_arg_iSrc1+D'3', F, 1
1468            label210
1468  0E00      	MOVLW HIGH(FCD_04071__00074_1_FCL_S+D'0')
146A  6F93      	MOVWF FCI_TOSTRI_00052_arg_sDst+D'1', 1
146C  0E84      	MOVLW LOW(FCD_04071__00074_1_FCL_S+D'0')
146E  6F92      	MOVWF FCI_TOSTRI_00052_arg_sDst, 1
1470  0E0A      	MOVLW 0x0A
1472  6F94      	MOVWF FCI_TOSTRI_00052_arg_iDst_len, 1
1474  EC64F006  	CALL FCI_TOSTRI_00052


	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);
1478  0E00      	MOVLW HIGH(FCD_04071__00074_1_FCL_S+D'0')
147A  6F8F      	MOVWF FCD_04071__00064_arg_FCL_TEXT+D'1', 1
147C  0E84      	MOVLW LOW(FCD_04071__00074_1_FCL_S+D'0')
147E  6F8E      	MOVWF FCD_04071__00064_arg_FCL_TEXT, 1
1480  0E0A      	MOVLW 0x0A
1482  6FA2      	MOVWF FCD_04071__00064_arg_FCLsz_TEXT, 1
1484  6BA3      	CLRF FCD_04071__00064_arg_FCLsz_TEXT+D'1', 1
1486  EC50F008  	CALL FCD_04071__00064


	//Définitions des variables locales
	#undef FCLsz_S
}
148A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Param??tres pour la macro RAMWrite :
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Param??tres pour la macro ClearLine :
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Param??tres pour la macro Cursor :
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)

{



	#if (0) // 2 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
148C  5383      	MOVF FCD_04071__00067_arg_FCL_Y, F, 1
148E  E103      	BNZ	label211
1496            label211

		{

			FCL_Y = 0x80;
1490  0E80      	MOVLW 0x80
1492  6F83      	MOVWF FCD_04071__00067_arg_FCL_Y, 1


		} else {
1494  D002      	BRA	label212
149A            label212


			FCL_Y = 0xC0;
1496  0EC0      	MOVLW 0xC0
1498  6F83      	MOVWF FCD_04071__00067_arg_FCL_Y, 1


		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 2 == 4

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);
149A  5182      	MOVF FCD_04071__00067_arg_FCL_X, W, 1
149C  2583      	ADDWF FCD_04071__00067_arg_FCL_Y, W, 1
149E  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
14A0  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
14A2  ECF0F004  	CALL FCD_04071__000BC


	FCI_DELAYBYTE_MS(2);
14A6  0E02      	MOVLW 0x02
14A8  6F05      	MOVWF delay_ms_00000_arg_del, 1
14AA  EC06F000  	CALL delay_ms_00000


}
14AE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Param??tres pour la macro Command :
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Param??tres pour la macro PrintFormattedNumber :
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Définitions des variables locales
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Param??tres pour la macro ScrollDisplay :
       :  Position : Holds the number of positions to shift the display
       :  direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Définitions des variables locales
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	switch (FCL_DIRECTION)
	{
		case 0:
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'l':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'L':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 1:
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'r':
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'R':
		{
			FCL_CMD = 0x1C;


			break;
		}
		// default:

	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Param??tres pour la macro RawSend :
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)

{
	//Définitions des variables locales
	MX_UINT8 FCL_NIBBLE;


	//Commentaire:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
09E0  6BA9      	CLRF FCD_04071__000BC_2_ptmp, 1
09E2  9092      	BCF gbl_trisa,0
09E4  53A9      	MOVF FCD_04071__000BC_2_ptmp, F, 1
09E6  E004      	BZ	label121
09E8  0E01      	MOVLW 0x01
09EA  1089      	IORWF gbl_lata, W
09EC  6E80      	MOVWF gbl_porta
09EE  D003      	BRA	label122
09F0            label121
09F0  0EFE      	MOVLW 0xFE
09F2  1489      	ANDWF gbl_lata, W
09F4  6E80      	MOVWF gbl_porta
09F6            label122

		FCP_SET(B, A, 0x2, 0x1, 0);
09F6  6BA9      	CLRF FCD_04071__000BC_9_ptmp, 1
09F8  9292      	BCF gbl_trisa,1
09FA  53A9      	MOVF FCD_04071__000BC_9_ptmp, F, 1
09FC  E004      	BZ	label123
09FE  0E02      	MOVLW 0x02
0A00  1089      	IORWF gbl_lata, W
0A02  6E80      	MOVWF gbl_porta
0A04  D003      	BRA	label124
0A06            label123
0A06  0EFD      	MOVLW 0xFD
0A08  1489      	ANDWF gbl_lata, W
0A0A  6E80      	MOVWF gbl_porta
0A0C            label124

		FCP_SET(B, A, 0x4, 0x2, 0);
0A0C  6BA9      	CLRF FCD_04071__000BC_16_ptmp, 1
0A0E  9492      	BCF gbl_trisa,2
0A10  53A9      	MOVF FCD_04071__000BC_16_ptmp, F, 1
0A12  E004      	BZ	label125
0A14  0E04      	MOVLW 0x04
0A16  1089      	IORWF gbl_lata, W
0A18  6E80      	MOVWF gbl_porta
0A1A  D003      	BRA	label126
0A1C            label125
0A1C  0EFB      	MOVLW 0xFB
0A1E  1489      	ANDWF gbl_lata, W
0A20  6E80      	MOVWF gbl_porta
0A22            label126

		FCP_SET(B, A, 0x8, 0x3, 0);
0A22  6BA9      	CLRF FCD_04071__000BC_23_ptmp, 1
0A24  9692      	BCF gbl_trisa,3
0A26  53A9      	MOVF FCD_04071__000BC_23_ptmp, F, 1
0A28  E004      	BZ	label127
0A2A  0E08      	MOVLW 0x08
0A2C  1089      	IORWF gbl_lata, W
0A2E  6E80      	MOVWF gbl_porta
0A30  D003      	BRA	label128
0A32            label127
0A32  0EF7      	MOVLW 0xF7
0A34  1489      	ANDWF gbl_lata, W
0A36  6E80      	MOVWF gbl_porta
0A38            label128

		FCP_SET(B, A, 0x10, 0x4, 0);
0A38  6BA9      	CLRF FCD_04071__000BC_30_ptmp, 1
0A3A  9892      	BCF gbl_trisa,4
0A3C  53A9      	MOVF FCD_04071__000BC_30_ptmp, F, 1
0A3E  E004      	BZ	label129
0A40  0E10      	MOVLW 0x10
0A42  1089      	IORWF gbl_lata, W
0A44  6E80      	MOVWF gbl_porta
0A46  D003      	BRA	label130
0A48            label129
0A48  0EEF      	MOVLW 0xEF
0A4A  1489      	ANDWF gbl_lata, W
0A4C  6E80      	MOVWF gbl_porta
0A4E            label130

		FCP_SET(B, A, 0x20, 0x5, 0);
0A4E  6BA9      	CLRF FCD_04071__000BC_37_ptmp, 1
0A50  9A92      	BCF gbl_trisa,5
0A52  53A9      	MOVF FCD_04071__000BC_37_ptmp, F, 1
0A54  E004      	BZ	label131
0A56  0E20      	MOVLW 0x20
0A58  1089      	IORWF gbl_lata, W
0A5A  6E80      	MOVWF gbl_porta
0A5C  D003      	BRA	label132
0A5E            label131
0A5E  0EDF      	MOVLW 0xDF
0A60  1489      	ANDWF gbl_lata, W
0A62  6E80      	MOVWF gbl_porta
0A64            label132


		#if (0)

		//Le code a été optimisé par le préprocesseur
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
0A64  39A6      	SWAPF FCD_04071__000BC_arg_FCL_DATA, W, 1
0A66  0B0F      	ANDLW 0x0F
0A68  6FA8      	MOVWF FCD_04071__000BC_1_FCL_NIBBLE, 1

		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
0A6A  0E01      	MOVLW 0x01
0A6C  15A8      	ANDWF FCD_04071__000BC_1_FCL_NIBBLE, W, 1
0A6E  6FA9      	MOVWF FCD_04071__000BC_46_ptmp, 1
0A70  9092      	BCF gbl_trisa,0
0A72  53A9      	MOVF FCD_04071__000BC_46_ptmp, F, 1
0A74  E004      	BZ	label133
0A76  0E01      	MOVLW 0x01
0A78  1089      	IORWF gbl_lata, W
0A7A  6E80      	MOVWF gbl_porta
0A7C  D003      	BRA	label134
0A7E            label133
0A7E  0EFE      	MOVLW 0xFE
0A80  1489      	ANDWF gbl_lata, W
0A82  6E80      	MOVWF gbl_porta
0A84            label134

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0A84  53A8      	MOVF FCD_04071__000BC_1_FCL_NIBBLE, F, 1
0A86  90D8      	BCF STATUS,C
0A88  33A8      	RRCF FCD_04071__000BC_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
0A8A  0E01      	MOVLW 0x01
0A8C  15A8      	ANDWF FCD_04071__000BC_1_FCL_NIBBLE, W, 1
0A8E  6FA9      	MOVWF FCD_04071__000BC_55_ptmp, 1
0A90  9292      	BCF gbl_trisa,1
0A92  53A9      	MOVF FCD_04071__000BC_55_ptmp, F, 1
0A94  E004      	BZ	label135
0A96  0E02      	MOVLW 0x02
0A98  1089      	IORWF gbl_lata, W
0A9A  6E80      	MOVWF gbl_porta
0A9C  D003      	BRA	label136
0A9E            label135
0A9E  0EFD      	MOVLW 0xFD
0AA0  1489      	ANDWF gbl_lata, W
0AA2  6E80      	MOVWF gbl_porta
0AA4            label136

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0AA4  53A8      	MOVF FCD_04071__000BC_1_FCL_NIBBLE, F, 1
0AA6  90D8      	BCF STATUS,C
0AA8  33A8      	RRCF FCD_04071__000BC_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
0AAA  0E01      	MOVLW 0x01
0AAC  15A8      	ANDWF FCD_04071__000BC_1_FCL_NIBBLE, W, 1
0AAE  6FA9      	MOVWF FCD_04071__000BC_64_ptmp, 1
0AB0  9492      	BCF gbl_trisa,2
0AB2  53A9      	MOVF FCD_04071__000BC_64_ptmp, F, 1
0AB4  E004      	BZ	label137
0AB6  0E04      	MOVLW 0x04
0AB8  1089      	IORWF gbl_lata, W
0ABA  6E80      	MOVWF gbl_porta
0ABC  D003      	BRA	label138
0ABE            label137
0ABE  0EFB      	MOVLW 0xFB
0AC0  1489      	ANDWF gbl_lata, W
0AC2  6E80      	MOVWF gbl_porta
0AC4            label138

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0AC4  53A8      	MOVF FCD_04071__000BC_1_FCL_NIBBLE, F, 1
0AC6  90D8      	BCF STATUS,C
0AC8  33A8      	RRCF FCD_04071__000BC_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));
0ACA  0E01      	MOVLW 0x01
0ACC  15A8      	ANDWF FCD_04071__000BC_1_FCL_NIBBLE, W, 1
0ACE  6FA9      	MOVWF FCD_04071__000BC_73_ptmp, 1
0AD0  9692      	BCF gbl_trisa,3
0AD2  53A9      	MOVF FCD_04071__000BC_73_ptmp, F, 1
0AD4  E004      	BZ	label139
0AD6  0E08      	MOVLW 0x08
0AD8  1089      	IORWF gbl_lata, W
0ADA  6E80      	MOVWF gbl_porta
0ADC  D003      	BRA	label140
0ADE            label139
0ADE  0EF7      	MOVLW 0xF7
0AE0  1489      	ANDWF gbl_lata, W
0AE2  6E80      	MOVWF gbl_porta
0AE4            label140


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	//Commentaire:
	//Output byte to pins

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	//Commentaire:
	//Output byte to port

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	if (FCL_TYPE)
0AE4  A1A7      	BTFSS FCD_04071__000BC_arg_FCL_TYPE,0, 1
0AE6  D00C      	BRA	label142

	{

		FCP_SET(B, A, 0x10, 0x4, 1);
0AE8  0E01      	MOVLW 0x01
0AEA  6FA9      	MOVWF FCD_04071__000BC_82_ptmp, 1
0AEC  9892      	BCF gbl_trisa,4
0AEE  53A9      	MOVF FCD_04071__000BC_82_ptmp, F, 1
0AF0  E004      	BZ	label141
0AF2  0E10      	MOVLW 0x10
0AF4  1089      	IORWF gbl_lata, W
0AF6  6E80      	MOVWF gbl_porta
0AF8  D003      	BRA	label142
0AFA            label141
0AFA  0EEF      	MOVLW 0xEF
0AFC  1489      	ANDWF gbl_lata, W
0AFE  6E80      	MOVWF gbl_porta
0B00            label142


	// } else {

	}

	FCI_DELAYBYTE_US(100);
0B00  0E64      	MOVLW 0x64
0B02  0101      	MOVLB 0x01
0B04  6F04      	MOVWF delay_us_00000_arg_del, 1
0B06  EC2EF000  	CALL delay_us_00000


	//Commentaire:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, A, 0x20, 0x5, 1);
0B0A  0E01      	MOVLW 0x01
0B0C  0100      	MOVLB 0x00
0B0E  6FA9      	MOVWF FCD_04071__000BC_93_ptmp, 1
0B10  9A92      	BCF gbl_trisa,5
0B12  53A9      	MOVF FCD_04071__000BC_93_ptmp, F, 1
0B14  E004      	BZ	label143
0B16  0E20      	MOVLW 0x20
0B18  1089      	IORWF gbl_lata, W
0B1A  6E80      	MOVWF gbl_porta
0B1C  D003      	BRA	label144
0B1E            label143
0B1E  0EDF      	MOVLW 0xDF
0B20  1489      	ANDWF gbl_lata, W
0B22  6E80      	MOVWF gbl_porta
0B24            label144


	FCI_DELAYBYTE_US(100);
0B24  0E64      	MOVLW 0x64
0B26  0101      	MOVLB 0x01
0B28  6F04      	MOVWF delay_us_00000_arg_del, 1
0B2A  EC2EF000  	CALL delay_us_00000


	FCP_SET(B, A, 0x20, 0x5, 0);
0B2E  0100      	MOVLB 0x00
0B30  6BA9      	CLRF FCD_04071__000BC_104_ptmp, 1
0B32  9A92      	BCF gbl_trisa,5
0B34  53A9      	MOVF FCD_04071__000BC_104_ptmp, F, 1
0B36  E004      	BZ	label145
0B38  0E20      	MOVLW 0x20
0B3A  1089      	IORWF gbl_lata, W
0B3C  6E80      	MOVWF gbl_porta
0B3E  D003      	BRA	label146
0B40            label145
0B40  0EDF      	MOVLW 0xDF
0B42  1489      	ANDWF gbl_lata, W
0B44  6E80      	MOVWF gbl_porta
0B46            label146


	FCI_DELAYBYTE_US(100);
0B46  0E64      	MOVLW 0x64
0B48  0101      	MOVLB 0x01
0B4A  6F04      	MOVWF delay_us_00000_arg_del, 1
0B4C  EC2EF000  	CALL delay_us_00000


	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
0B50  0100      	MOVLB 0x00
0B52  6BA9      	CLRF FCD_04071__000BC_115_ptmp, 1
0B54  9092      	BCF gbl_trisa,0
0B56  53A9      	MOVF FCD_04071__000BC_115_ptmp, F, 1
0B58  E004      	BZ	label147
0B5A  0E01      	MOVLW 0x01
0B5C  1089      	IORWF gbl_lata, W
0B5E  6E80      	MOVWF gbl_porta
0B60  D003      	BRA	label148
0B62            label147
0B62  0EFE      	MOVLW 0xFE
0B64  1489      	ANDWF gbl_lata, W
0B66  6E80      	MOVWF gbl_porta
0B68            label148

		FCP_SET(B, A, 0x2, 0x1, 0);
0B68  6BA9      	CLRF FCD_04071__000BC_122_ptmp, 1
0B6A  9292      	BCF gbl_trisa,1
0B6C  53A9      	MOVF FCD_04071__000BC_122_ptmp, F, 1
0B6E  E004      	BZ	label149
0B70  0E02      	MOVLW 0x02
0B72  1089      	IORWF gbl_lata, W
0B74  6E80      	MOVWF gbl_porta
0B76  D003      	BRA	label150
0B78            label149
0B78  0EFD      	MOVLW 0xFD
0B7A  1489      	ANDWF gbl_lata, W
0B7C  6E80      	MOVWF gbl_porta
0B7E            label150

		FCP_SET(B, A, 0x4, 0x2, 0);
0B7E  6BA9      	CLRF FCD_04071__000BC_129_ptmp, 1
0B80  9492      	BCF gbl_trisa,2
0B82  53A9      	MOVF FCD_04071__000BC_129_ptmp, F, 1
0B84  E004      	BZ	label151
0B86  0E04      	MOVLW 0x04
0B88  1089      	IORWF gbl_lata, W
0B8A  6E80      	MOVWF gbl_porta
0B8C  D003      	BRA	label152
0B8E            label151
0B8E  0EFB      	MOVLW 0xFB
0B90  1489      	ANDWF gbl_lata, W
0B92  6E80      	MOVWF gbl_porta
0B94            label152

		FCP_SET(B, A, 0x8, 0x3, 0);
0B94  6BA9      	CLRF FCD_04071__000BC_136_ptmp, 1
0B96  9692      	BCF gbl_trisa,3
0B98  53A9      	MOVF FCD_04071__000BC_136_ptmp, F, 1
0B9A  E004      	BZ	label153
0B9C  0E08      	MOVLW 0x08
0B9E  1089      	IORWF gbl_lata, W
0BA0  6E80      	MOVWF gbl_porta
0BA2  D003      	BRA	label154
0BA4            label153
0BA4  0EF7      	MOVLW 0xF7
0BA6  1489      	ANDWF gbl_lata, W
0BA8  6E80      	MOVWF gbl_porta
0BAA            label154

		FCP_SET(B, A, 0x10, 0x4, 0);
0BAA  6BA9      	CLRF FCD_04071__000BC_143_ptmp, 1
0BAC  9892      	BCF gbl_trisa,4
0BAE  53A9      	MOVF FCD_04071__000BC_143_ptmp, F, 1
0BB0  E004      	BZ	label155
0BB2  0E10      	MOVLW 0x10
0BB4  1089      	IORWF gbl_lata, W
0BB6  6E80      	MOVWF gbl_porta
0BB8  D003      	BRA	label156
0BBA            label155
0BBA  0EEF      	MOVLW 0xEF
0BBC  1489      	ANDWF gbl_lata, W
0BBE  6E80      	MOVWF gbl_porta
0BC0            label156


		FCL_NIBBLE = (FCL_DATA & 0xf);
0BC0  0E0F      	MOVLW 0x0F
0BC2  15A6      	ANDWF FCD_04071__000BC_arg_FCL_DATA, W, 1
0BC4  6FA9      	MOVWF CompTempVar3066, 1
0BC6  51A9      	MOVF CompTempVar3066, W, 1
0BC8  6FA8      	MOVWF FCD_04071__000BC_1_FCL_NIBBLE, 1

		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
0BCA  0E01      	MOVLW 0x01
0BCC  15A8      	ANDWF FCD_04071__000BC_1_FCL_NIBBLE, W, 1
0BCE  6FA9      	MOVWF FCD_04071__000BC_152_ptmp, 1
0BD0  9092      	BCF gbl_trisa,0
0BD2  53A9      	MOVF FCD_04071__000BC_152_ptmp, F, 1
0BD4  E004      	BZ	label157
0BD6  0E01      	MOVLW 0x01
0BD8  1089      	IORWF gbl_lata, W
0BDA  6E80      	MOVWF gbl_porta
0BDC  D003      	BRA	label158
0BDE            label157
0BDE  0EFE      	MOVLW 0xFE
0BE0  1489      	ANDWF gbl_lata, W
0BE2  6E80      	MOVWF gbl_porta
0BE4            label158

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0BE4  53A8      	MOVF FCD_04071__000BC_1_FCL_NIBBLE, F, 1
0BE6  90D8      	BCF STATUS,C
0BE8  33A8      	RRCF FCD_04071__000BC_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
0BEA  0E01      	MOVLW 0x01
0BEC  15A8      	ANDWF FCD_04071__000BC_1_FCL_NIBBLE, W, 1
0BEE  6FA9      	MOVWF FCD_04071__000BC_161_ptmp, 1
0BF0  9292      	BCF gbl_trisa,1
0BF2  53A9      	MOVF FCD_04071__000BC_161_ptmp, F, 1
0BF4  E004      	BZ	label159
0BF6  0E02      	MOVLW 0x02
0BF8  1089      	IORWF gbl_lata, W
0BFA  6E80      	MOVWF gbl_porta
0BFC  D003      	BRA	label160
0BFE            label159
0BFE  0EFD      	MOVLW 0xFD
0C00  1489      	ANDWF gbl_lata, W
0C02  6E80      	MOVWF gbl_porta
0C04            label160

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0C04  53A8      	MOVF FCD_04071__000BC_1_FCL_NIBBLE, F, 1
0C06  90D8      	BCF STATUS,C
0C08  33A8      	RRCF FCD_04071__000BC_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
0C0A  0E01      	MOVLW 0x01
0C0C  15A8      	ANDWF FCD_04071__000BC_1_FCL_NIBBLE, W, 1
0C0E  6FA9      	MOVWF FCD_04071__000BC_170_ptmp, 1
0C10  9492      	BCF gbl_trisa,2
0C12  53A9      	MOVF FCD_04071__000BC_170_ptmp, F, 1
0C14  E004      	BZ	label161
0C16  0E04      	MOVLW 0x04
0C18  1089      	IORWF gbl_lata, W
0C1A  6E80      	MOVWF gbl_porta
0C1C  D003      	BRA	label162
0C1E            label161
0C1E  0EFB      	MOVLW 0xFB
0C20  1489      	ANDWF gbl_lata, W
0C22  6E80      	MOVWF gbl_porta
0C24            label162

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0C24  53A8      	MOVF FCD_04071__000BC_1_FCL_NIBBLE, F, 1
0C26  90D8      	BCF STATUS,C
0C28  33A8      	RRCF FCD_04071__000BC_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));
0C2A  0E01      	MOVLW 0x01
0C2C  15A8      	ANDWF FCD_04071__000BC_1_FCL_NIBBLE, W, 1
0C2E  6FA9      	MOVWF FCD_04071__000BC_179_ptmp, 1
0C30  9692      	BCF gbl_trisa,3
0C32  53A9      	MOVF FCD_04071__000BC_179_ptmp, F, 1
0C34  E004      	BZ	label163
0C36  0E08      	MOVLW 0x08
0C38  1089      	IORWF gbl_lata, W
0C3A  6E80      	MOVWF gbl_porta
0C3C  D003      	BRA	label164
0C3E            label163
0C3E  0EF7      	MOVLW 0xF7
0C40  1489      	ANDWF gbl_lata, W
0C42  6E80      	MOVWF gbl_porta
0C44            label164


		if (FCL_TYPE)
0C44  A1A7      	BTFSS FCD_04071__000BC_arg_FCL_TYPE,0, 1
0C46  D00C      	BRA	label166

		{

			FCP_SET(B, A, 0x10, 0x4, 1);
0C48  0E01      	MOVLW 0x01
0C4A  6FA9      	MOVWF FCD_04071__000BC_188_ptmp, 1
0C4C  9892      	BCF gbl_trisa,4
0C4E  53A9      	MOVF FCD_04071__000BC_188_ptmp, F, 1
0C50  E004      	BZ	label165
0C52  0E10      	MOVLW 0x10
0C54  1089      	IORWF gbl_lata, W
0C56  6E80      	MOVWF gbl_porta
0C58  D003      	BRA	label166
0C5A            label165
0C5A  0EEF      	MOVLW 0xEF
0C5C  1489      	ANDWF gbl_lata, W
0C5E  6E80      	MOVWF gbl_porta
0C60            label166


		// } else {

		}

		FCI_DELAYBYTE_US(100);
0C60  0E64      	MOVLW 0x64
0C62  0101      	MOVLB 0x01
0C64  6F04      	MOVWF delay_us_00000_arg_del, 1
0C66  EC2EF000  	CALL delay_us_00000


		FCP_SET(B, A, 0x20, 0x5, 1);
0C6A  0E01      	MOVLW 0x01
0C6C  0100      	MOVLB 0x00
0C6E  6FA9      	MOVWF FCD_04071__000BC_199_ptmp, 1
0C70  9A92      	BCF gbl_trisa,5
0C72  53A9      	MOVF FCD_04071__000BC_199_ptmp, F, 1
0C74  E004      	BZ	label167
0C76  0E20      	MOVLW 0x20
0C78  1089      	IORWF gbl_lata, W
0C7A  6E80      	MOVWF gbl_porta
0C7C  D003      	BRA	label168
0C7E            label167
0C7E  0EDF      	MOVLW 0xDF
0C80  1489      	ANDWF gbl_lata, W
0C82  6E80      	MOVWF gbl_porta
0C84            label168


		FCI_DELAYBYTE_US(100);
0C84  0E64      	MOVLW 0x64
0C86  0101      	MOVLB 0x01
0C88  6F04      	MOVWF delay_us_00000_arg_del, 1
0C8A  EC2EF000  	CALL delay_us_00000


		FCP_SET(B, A, 0x20, 0x5, 0);
0C8E  0100      	MOVLB 0x00
0C90  6BA9      	CLRF FCD_04071__000BC_210_ptmp, 1
0C92  9A92      	BCF gbl_trisa,5
0C94  53A9      	MOVF FCD_04071__000BC_210_ptmp, F, 1
0C96  E004      	BZ	label169
0C98  0E20      	MOVLW 0x20
0C9A  1089      	IORWF gbl_lata, W
0C9C  6E80      	MOVWF gbl_porta
0C9E  D003      	BRA	label170
0CA0            label169
0CA0  0EDF      	MOVLW 0xDF
0CA2  1489      	ANDWF gbl_lata, W
0CA4  6E80      	MOVWF gbl_porta
0CA6            label170


		FCI_DELAYBYTE_US(100);
0CA6  0E64      	MOVLW 0x64
0CA8  0101      	MOVLB 0x01
0CAA  6F04      	MOVWF delay_us_00000_arg_del, 1
0CAC  EC2EF000  	CALL delay_us_00000


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

}
0CB0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()

{



	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
14B0  0100      	MOVLB 0x00
14B2  6B81      	CLRF FCD_04071__00063_2_ptmp, 1
14B4  9092      	BCF gbl_trisa,0
14B6  5381      	MOVF FCD_04071__00063_2_ptmp, F, 1
14B8  E004      	BZ	label213
14BA  0E01      	MOVLW 0x01
14BC  1089      	IORWF gbl_lata, W
14BE  6E80      	MOVWF gbl_porta
14C0  D003      	BRA	label214
14C2            label213
14C2  0EFE      	MOVLW 0xFE
14C4  1489      	ANDWF gbl_lata, W
14C6  6E80      	MOVWF gbl_porta
14C8            label214

		FCP_SET(B, A, 0x2, 0x1, 0);
14C8  6B81      	CLRF FCD_04071__00063_9_ptmp, 1
14CA  9292      	BCF gbl_trisa,1
14CC  5381      	MOVF FCD_04071__00063_9_ptmp, F, 1
14CE  E004      	BZ	label215
14D0  0E02      	MOVLW 0x02
14D2  1089      	IORWF gbl_lata, W
14D4  6E80      	MOVWF gbl_porta
14D6  D003      	BRA	label216
14D8            label215
14D8  0EFD      	MOVLW 0xFD
14DA  1489      	ANDWF gbl_lata, W
14DC  6E80      	MOVWF gbl_porta
14DE            label216

		FCP_SET(B, A, 0x4, 0x2, 0);
14DE  6B81      	CLRF FCD_04071__00063_16_ptmp, 1
14E0  9492      	BCF gbl_trisa,2
14E2  5381      	MOVF FCD_04071__00063_16_ptmp, F, 1
14E4  E004      	BZ	label217
14E6  0E04      	MOVLW 0x04
14E8  1089      	IORWF gbl_lata, W
14EA  6E80      	MOVWF gbl_porta
14EC  D003      	BRA	label218
14EE            label217
14EE  0EFB      	MOVLW 0xFB
14F0  1489      	ANDWF gbl_lata, W
14F2  6E80      	MOVWF gbl_porta
14F4            label218

		FCP_SET(B, A, 0x8, 0x3, 0);
14F4  6B81      	CLRF FCD_04071__00063_23_ptmp, 1
14F6  9692      	BCF gbl_trisa,3
14F8  5381      	MOVF FCD_04071__00063_23_ptmp, F, 1
14FA  E004      	BZ	label219
14FC  0E08      	MOVLW 0x08
14FE  1089      	IORWF gbl_lata, W
1500  6E80      	MOVWF gbl_porta
1502  D003      	BRA	label220
1504            label219
1504  0EF7      	MOVLW 0xF7
1506  1489      	ANDWF gbl_lata, W
1508  6E80      	MOVWF gbl_porta
150A            label220

		FCP_SET(B, A, 0x10, 0x4, 0);
150A  6B81      	CLRF FCD_04071__00063_30_ptmp, 1
150C  9892      	BCF gbl_trisa,4
150E  5381      	MOVF FCD_04071__00063_30_ptmp, F, 1
1510  E004      	BZ	label221
1512  0E10      	MOVLW 0x10
1514  1089      	IORWF gbl_lata, W
1516  6E80      	MOVWF gbl_porta
1518  D003      	BRA	label222
151A            label221
151A  0EEF      	MOVLW 0xEF
151C  1489      	ANDWF gbl_lata, W
151E  6E80      	MOVWF gbl_porta
1520            label222

		FCP_SET(B, A, 0x20, 0x5, 0);
1520  6B81      	CLRF FCD_04071__00063_37_ptmp, 1
1522  9A92      	BCF gbl_trisa,5
1524  5381      	MOVF FCD_04071__00063_37_ptmp, F, 1
1526  E004      	BZ	label223
1528  0E20      	MOVLW 0x20
152A  1089      	IORWF gbl_lata, W
152C  6E80      	MOVWF gbl_porta
152E  D003      	BRA	label224
1530            label223
1530  0EDF      	MOVLW 0xDF
1532  1489      	ANDWF gbl_lata, W
1534  6E80      	MOVWF gbl_porta
1536            label224


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0)

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);
1536  0E0C      	MOVLW 0x0C
1538  0101      	MOVLB 0x01
153A  6F05      	MOVWF delay_ms_00000_arg_del, 1
153C  EC06F000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x33, 0);
1540  0E33      	MOVLW 0x33
1542  0100      	MOVLB 0x00
1544  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
1546  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
1548  ECF0F004  	CALL FCD_04071__000BC


	FCI_DELAYBYTE_MS(2);
154C  0E02      	MOVLW 0x02
154E  6F05      	MOVWF delay_ms_00000_arg_del, 1
1550  EC06F000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x33, 0);
1554  0E33      	MOVLW 0x33
1556  0100      	MOVLB 0x00
1558  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
155A  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
155C  ECF0F004  	CALL FCD_04071__000BC


	FCI_DELAYBYTE_MS(2);
1560  0E02      	MOVLW 0x02
1562  6F05      	MOVWF delay_ms_00000_arg_del, 1
1564  EC06F000  	CALL delay_ms_00000


	#if (0) // 0 > 0

	//Le code a été optimisé par le préprocesseur
	#else

		FCD_04071_LCD__RawSend(0x32, 0);
1568  0E32      	MOVLW 0x32
156A  0100      	MOVLB 0x00
156C  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
156E  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
1570  ECF0F004  	CALL FCD_04071__000BC


		FCI_DELAYBYTE_MS(2);
1574  0E02      	MOVLW 0x02
1576  6F05      	MOVWF delay_ms_00000_arg_del, 1
1578  EC06F000  	CALL delay_ms_00000


		FCD_04071_LCD__RawSend(0x2c, 0);
157C  0E2C      	MOVLW 0x2C
157E  0100      	MOVLB 0x00
1580  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
1582  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
1584  ECF0F004  	CALL FCD_04071__000BC


	#endif

	FCI_DELAYBYTE_MS(2);
1588  0E02      	MOVLW 0x02
158A  6F05      	MOVWF delay_ms_00000_arg_del, 1
158C  EC06F000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x06, 0);
1590  0E06      	MOVLW 0x06
1592  0100      	MOVLB 0x00
1594  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
1596  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
1598  ECF0F004  	CALL FCD_04071__000BC


	FCI_DELAYBYTE_MS(2);
159C  0E02      	MOVLW 0x02
159E  6F05      	MOVWF delay_ms_00000_arg_del, 1
15A0  EC06F000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x0c, 0);
15A4  0E0C      	MOVLW 0x0C
15A6  0100      	MOVLB 0x00
15A8  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
15AA  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
15AC  ECF0F004  	CALL FCD_04071__000BC


	FCI_DELAYBYTE_MS(2);
15B0  0E02      	MOVLW 0x02
15B2  6F05      	MOVWF delay_ms_00000_arg_del, 1
15B4  EC06F000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x01, 0);
15B8  0E01      	MOVLW 0x01
15BA  0100      	MOVLB 0x00
15BC  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
15BE  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
15C0  ECF0F004  	CALL FCD_04071__000BC


	FCI_DELAYBYTE_MS(2);
15C4  0E02      	MOVLW 0x02
15C6  6F05      	MOVWF delay_ms_00000_arg_del, 1
15C8  EC06F000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x02, 0);
15CC  0E02      	MOVLW 0x02
15CE  0100      	MOVLB 0x00
15D0  6FA6      	MOVWF FCD_04071__000BC_arg_FCL_DATA, 1
15D2  91A7      	BCF FCD_04071__000BC_arg_FCL_TYPE,0, 1
15D4  ECF0F004  	CALL FCD_04071__000BC


	FCI_DELAYBYTE_MS(2);
15D8  0E02      	MOVLW 0x02
15DA  6F05      	MOVWF delay_ms_00000_arg_del, 1
15DC  EC06F000  	CALL delay_ms_00000


	FCD_04071_LCD__Clear();
15E0  EC3BF008  	CALL FCD_04071__00071


}
15E4  0012      	RETURN



/*========================================================================*\
   Use :lcd_eb005
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :InjectorBase1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :Bluetooth2
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the 4 digit Bluetooth pair key based on a string of numbers.
       :e.g. "1234"
       :Returns 0 to indicate success
       :
       :Param??tres pour la macro SetPairKey :
       :  PairKey[5] : Key to use as the Pair key, e.g. "1234" or "0000"
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY)

{
	//Définitions des variables locales
	#define FCLsz_COMMANDSTR 20
	MX_CHAR FCL_COMMANDSTR[FCLsz_COMMANDSTR];
	MX_UINT8 FCR_RETVAL;


	FCI_SHEAD("AT+BTK=\"",9, FCL_PAIRKEY,FCLsz_PAIRKEY, FCL_COMMANDSTR,20);
0FE0  0E22      	MOVLW 0x22
0FE2  6FBD      	MOVWF CompTempVar3087+D'7', 1
0FE4  0E2B      	MOVLW 0x2B
0FE6  6FB8      	MOVWF CompTempVar3087+D'2', 1
0FE8  0E3D      	MOVLW 0x3D
0FEA  6FBC      	MOVWF CompTempVar3087+D'6', 1
0FEC  0E41      	MOVLW 0x41
0FEE  6FB6      	MOVWF CompTempVar3087, 1
0FF0  0E42      	MOVLW 0x42
0FF2  6FB9      	MOVWF CompTempVar3087+D'3', 1
0FF4  0E4B      	MOVLW 0x4B
0FF6  6FBB      	MOVWF CompTempVar3087+D'5', 1
0FF8  0E54      	MOVLW 0x54
0FFA  6FB7      	MOVWF CompTempVar3087+D'1', 1
0FFC  6FBA      	MOVWF CompTempVar3087+D'4', 1
0FFE  6BBE      	CLRF CompTempVar3087+D'8', 1
1000  0E00      	MOVLW HIGH(CompTempVar3087+D'0')
1002  6FB5      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1
1004  0EB6      	MOVLW LOW(CompTempVar3087+D'0')
1006  6FB4      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
1008  0E09      	MOVLW 0x09
100A  6FBF      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1
100C  5196      	MOVF FCD_0c851__000CE_arg_FCL_PAIRKEY, W, 1
100E  6FC0      	MOVWF FCI_SHEAD_00000_arg_sSrc2, 1
1010  5197      	MOVF FCD_0c851__000CE_arg_FCL_PAIRKEY+D'1', W, 1
1012  6FC1      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1', 1
1014  519D      	MOVF FCD_0c851__000CE_arg_FCLsz_000CF, W, 1
1016  6FC2      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1
1018  0E00      	MOVLW HIGH(FCD_0c851__000CE_1_FCL_COM_000D0+D'0')
101A  6FC4      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
101C  0E9F      	MOVLW LOW(FCD_0c851__000CE_1_FCL_COM_000D0+D'0')
101E  6FC3      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
1020  0E14      	MOVLW 0x14
1022  6FC5      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
1024  ECC9F003  	CALL FCI_SHEAD_00000

	FCI_SHEAD(FCL_COMMANDSTR,FCLsz_COMMANDSTR, "\"",2, FCL_COMMANDSTR,20);
1028  0E00      	MOVLW HIGH(FCD_0c851__000CE_1_FCL_COM_000D0+D'0')
102A  6FB5      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1
102C  0E9F      	MOVLW LOW(FCD_0c851__000CE_1_FCL_COM_000D0+D'0')
102E  6FB4      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
1030  0E14      	MOVLW 0x14
1032  6FBF      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1
1034  0E22      	MOVLW 0x22
1036  6FB6      	MOVWF CompTempVar3090, 1
1038  6BB7      	CLRF CompTempVar3090+D'1', 1
103A  0E00      	MOVLW HIGH(CompTempVar3090+D'0')
103C  6FC1      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1', 1
103E  0EB6      	MOVLW LOW(CompTempVar3090+D'0')
1040  6FC0      	MOVWF FCI_SHEAD_00000_arg_sSrc2, 1
1042  0E02      	MOVLW 0x02
1044  6FC2      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1
1046  0E00      	MOVLW HIGH(FCD_0c851__000CE_1_FCL_COM_000D0+D'0')
1048  6FC4      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
104A  0E9F      	MOVLW LOW(FCD_0c851__000CE_1_FCL_COM_000D0+D'0')
104C  6FC3      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
104E  0E14      	MOVLW 0x14
1050  6FC5      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
1052  ECC9F003  	CALL FCI_SHEAD_00000


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand(FCL_COMMANDSTR, FCLsz_COMMANDSTR, 1);
1056  0E00      	MOVLW HIGH(FCD_0c851__000CE_1_FCL_COM_000D0+D'0')
1058  6FB5      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND+D'1', 1
105A  0E9F      	MOVLW LOW(FCD_0c851__000CE_1_FCL_COM_000D0+D'0')
105C  6FB4      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND, 1
105E  0E14      	MOVLW 0x14
1060  6FB6      	MOVWF FCD_0c851__00072_arg_FCLsz_00073, 1
1062  6BB7      	CLRF FCD_0c851__00072_arg_FCLsz_00073+D'1', 1
1064  0E01      	MOVLW 0x01
1066  6FB8      	MOVWF FCD_0c851__00072_arg_FCL_SENDCR, 1
1068  ECB8F004  	CALL FCD_0c851__00072
106C  51BC      	MOVF CompTempVarRet2687, W, 1
106E  6FB3      	MOVWF FCD_0c851__000CE_1_FCR_RETVAL, 1


	return (FCR_RETVAL);
1070  51B3      	MOVF FCD_0c851__000CE_1_FCR_RETVAL, W, 1
1072  6FB4      	MOVWF CompTempVarRet3086, 1


	//Définitions des variables locales
	#undef FCLsz_COMMANDSTR
}
1074  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Receives a single data byte from the Bluetooth module.
       :0xFF signifies no data available.
       :
       :Param??tres pour la macro ReceiveByte :
       :  Timeout : Amount of time to wait in milliseconds 0=Wait forever
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_COUNT = (0x0);
04AE  6BD9      	CLRF FCD_0c851__00077_1_FCL_COUNT, 1

	MX_UINT8 FCR_RETVAL;


	FCV_0c851_Bluetooth2__RX_DONE = 0;
04B0  6A7F      	CLRF gbl_FCV_0c851_Bluetooth2___00011


FCC_ReceiveByte_A:
04B2            label68

;

	if (FCV_0c851_Bluetooth2__RX_IDX < FCV_0c851_Bluetooth2__RX_LENGTH)
04B2  5180      	MOVF gbl_FCV_0c851_Bluetooth2___00012, W, 1
04B4  607E      	CPFSLT gbl_FCV_0c851_Bluetooth2__RX_IDX
04B6  D00A      	BRA	label69
04CC            label69

	{

		FCR_RETVAL = FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_IDX];
04B8  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00010
04BC  50E9      	MOVF FSR0L, W
04BE  507E      	MOVF gbl_FCV_0c851_Bluetooth2__RX_IDX, W
04C0  26E9      	ADDWF FSR0L, F
04C2  50EF      	MOVF INDF0, W
04C4  6FDA      	MOVWF FCD_0c851__00077_1_FCR_RETVAL, 1


		FCV_0c851_Bluetooth2__RX_IDX = FCV_0c851_Bluetooth2__RX_IDX + 1;
04C6  287E      	INCF gbl_FCV_0c851_Bluetooth2__RX_IDX, W
04C8  6E7E      	MOVWF gbl_FCV_0c851_Bluetooth2__RX_IDX


	} else {
04CA  D014      	BRA	label72
04F4            label72


		if (FCV_0c851_Bluetooth2__RX_LENGTH < 50)
04CC  0E32      	MOVLW 0x32
04CE  6180      	CPFSLT gbl_FCV_0c851_Bluetooth2___00012, 1
04D0  D00E      	BRA	label71

		{

			if ((FCL_TIMEOUT == 0) || (FCL_COUNT < FCL_TIMEOUT))
04D2  53D8      	MOVF FCD_0c851__00077_arg_FCL_TIMEOUT, F, 1
04D4  E003      	BZ	label70
04D6  51D8      	MOVF FCD_0c851__00077_arg_FCL_TIMEOUT, W, 1
04D8  61D9      	CPFSLT FCD_0c851__00077_1_FCL_COUNT, 1
04DA  D009      	BRA	label71
04DC            label70
04EE            label71

			{

				FCI_DELAYBYTE_MS(1);
04DC  0E01      	MOVLW 0x01
04DE  0101      	MOVLB 0x01
04E0  6F05      	MOVWF delay_ms_00000_arg_del, 1
04E2  EC06F000  	CALL delay_ms_00000


				FCL_COUNT = FCL_COUNT + 1;
04E6  0100      	MOVLB 0x00
04E8  29D9      	INCF FCD_0c851__00077_1_FCL_COUNT, W, 1
04EA  6FD9      	MOVWF FCD_0c851__00077_1_FCL_COUNT, 1


				goto FCC_ReceiveByte_A;
04EC  D7E2      	BRA	label68


			// } else {

			}

		// } else {

		}

		FCV_0c851_Bluetooth2__RX_IDX = 0;
04EE  6A7E      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX

		FCV_0c851_Bluetooth2__RX_LENGTH = 0;
04F0  6B80      	CLRF gbl_FCV_0c851_Bluetooth2___00012, 1


		FCR_RETVAL = 255;
04F2  69DA      	SETF FCD_0c851__00077_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
04F4  51DA      	MOVF FCD_0c851__00077_1_FCR_RETVAL, W, 1
04F6  6FDB      	MOVWF CompTempVarRet2701, 1


}
04F8  EFE5F002  	GOTO	label83


/*=----------------------------------------------------------------------=*\
   Use :Send an AT command script.
       :Returns 0 for fail, 1 for success and 255 for unrecognised script idx.
       :
       :Param??tres pour la macro SendScript :
       :  idx : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX)

{
	//Définitions des variables locales
	MX_UINT8 FCL_I = (0x0);
114C  6B82      	CLRF FCD_0c851__00065_1_FCL_I, 1

	MX_UINT8 FCL_CH = (0xff);
114E  6983      	SETF FCD_0c851__00065_1_FCL_CH, 1

	#define FCLsz_SCRIPT_STR 40
	MX_CHAR FCL_SCRIPT_STR[FCLsz_SCRIPT_STR];
	MX_UINT8 FCL_LEN = (0x0);
1150  6BAC      	CLRF FCD_0c851__00065_1_FCL_LEN, 1

	MX_UINT8 FCR_RETVAL;


	if ((FCL_IDX < 1) || (FCL_IDX > 2))
1152  0E01      	MOVLW 0x01
1154  6181      	CPFSLT FCD_0c851__00065_arg_FCL_IDX, 1
1156  D001      	BRA	label191
1158  D003      	BRA	label192
115A            label191
115A  0E02      	MOVLW 0x02
115C  6581      	CPFSGT FCD_0c851__00065_arg_FCL_IDX, 1
115E  D002      	BRA	label193
1160            label192
1164            label193
117E  D08D      	BRA	label199

	{

		FCR_RETVAL = 255;
1160  69AD      	SETF FCD_0c851__00065_1_FCR_RETVAL, 1


		goto FCC_SendScript_A;
1162  D0E0      	BRA	label205


	// } else {

	}

	switch (FCL_IDX)
12BE            label201

	{
		case 1:
1164  0581      	DECF FCD_0c851__00065_arg_FCL_IDX, W, 1
1166  E00C      	BZ	label196
1180            label196

		{
			FCI_SCOPY("ATS0=1\r\nATR\r\nATS512=7\r\nATS536=1\r\nATS502=",41, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
1180  0E0A      	MOVLW 0x0A
1182  6FB5      	MOVWF CompTempVar2658+D'7', 1
1184  6FBA      	MOVWF CompTempVar2658+D'12', 1
1186  6FC4      	MOVWF CompTempVar2658+D'22', 1
1188  6FCE      	MOVWF CompTempVar2658+D'32', 1
118A  0E0D      	MOVLW 0x0D
118C  6FB4      	MOVWF CompTempVar2658+D'6', 1
118E  6FB9      	MOVWF CompTempVar2658+D'11', 1
1190  6FC3      	MOVWF CompTempVar2658+D'21', 1
1192  6FCD      	MOVWF CompTempVar2658+D'31', 1
1194  0E30      	MOVLW 0x30
1196  6FB1      	MOVWF CompTempVar2658+D'3', 1
1198  6FD3      	MOVWF CompTempVar2658+D'37', 1
119A  0E31      	MOVLW 0x31
119C  6FB3      	MOVWF CompTempVar2658+D'5', 1
119E  6FBF      	MOVWF CompTempVar2658+D'17', 1
11A0  6FCC      	MOVWF CompTempVar2658+D'30', 1
11A2  0E32      	MOVLW 0x32
11A4  6FC0      	MOVWF CompTempVar2658+D'18', 1
11A6  6FD4      	MOVWF CompTempVar2658+D'38', 1
11A8  0E33      	MOVLW 0x33
11AA  6FC9      	MOVWF CompTempVar2658+D'27', 1
11AC  0E35      	MOVLW 0x35
11AE  6FBE      	MOVWF CompTempVar2658+D'16', 1
11B0  6FC8      	MOVWF CompTempVar2658+D'26', 1
11B2  6FD2      	MOVWF CompTempVar2658+D'36', 1
11B4  0E36      	MOVLW 0x36
11B6  6FCA      	MOVWF CompTempVar2658+D'28', 1
11B8  0E37      	MOVLW 0x37
11BA  6FC2      	MOVWF CompTempVar2658+D'20', 1
11BC  0E3D      	MOVLW 0x3D
11BE  6FB2      	MOVWF CompTempVar2658+D'4', 1
11C0  6FC1      	MOVWF CompTempVar2658+D'19', 1
11C2  6FCB      	MOVWF CompTempVar2658+D'29', 1
11C4  6FD5      	MOVWF CompTempVar2658+D'39', 1
11C6  0E41      	MOVLW 0x41
11C8  6FAE      	MOVWF CompTempVar2658, 1
11CA  6FB6      	MOVWF CompTempVar2658+D'8', 1
11CC  6FBB      	MOVWF CompTempVar2658+D'13', 1
11CE  6FC5      	MOVWF CompTempVar2658+D'23', 1
11D0  6FCF      	MOVWF CompTempVar2658+D'33', 1
11D2  0E52      	MOVLW 0x52
11D4  6FB8      	MOVWF CompTempVar2658+D'10', 1
11D6  0E53      	MOVLW 0x53
11D8  6FB0      	MOVWF CompTempVar2658+D'2', 1
11DA  6FBD      	MOVWF CompTempVar2658+D'15', 1
11DC  6FC7      	MOVWF CompTempVar2658+D'25', 1
11DE  6FD1      	MOVWF CompTempVar2658+D'35', 1
11E0  0E54      	MOVLW 0x54
11E2  6FAF      	MOVWF CompTempVar2658+D'1', 1
11E4  6FB7      	MOVWF CompTempVar2658+D'9', 1
11E6  6FBC      	MOVWF CompTempVar2658+D'14', 1
11E8  6FC6      	MOVWF CompTempVar2658+D'24', 1
11EA  6FD0      	MOVWF CompTempVar2658+D'34', 1
11EC  6BD6      	CLRF CompTempVar2658+D'40', 1
11EE  0E00      	MOVLW HIGH(CompTempVar2658+D'0')
11F0  6FEA      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1', 1
11F2  0EAE      	MOVLW LOW(CompTempVar2658+D'0')
11F4  6FE9      	MOVWF FCI_SCOPY_00000_arg_sSrc, 1
11F6  0E29      	MOVLW 0x29
11F8  6FEB      	MOVWF FCI_SCOPY_00000_arg_iSrc_len, 1
11FA  0E00      	MOVLW HIGH(FCD_0c851__00065_1_FCL_SCR_00066+D'0')
11FC  6FED      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1', 1
11FE  0E84      	MOVLW LOW(FCD_0c851__00065_1_FCL_SCR_00066+D'0')
1200  6FEC      	MOVWF FCI_SCOPY_00000_arg_sDst, 1
1202  0E28      	MOVLW 0x28
1204  6FEE      	MOVWF FCI_SCOPY_00000_arg_iDst_len, 1
1206  EC6BF001  	CALL FCI_SCOPY_00000


			break;
120A  D059      	BRA	label201

		}
		case 2:
1168  0E02      	MOVLW 0x02
116A  6381      	CPFSEQ FCD_0c851__00065_arg_FCL_IDX, 1
116C  D001      	BRA	label194
116E  D04E      	BRA	label197
1170            label194
120C            label197

		{
			FCI_SCOPY("ATS531=2\r\nATA\r\nAT&W\r\nATZ0",26, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
120C  0E0A      	MOVLW 0x0A
120E  6FB7      	MOVWF CompTempVar2661+D'9', 1
1210  6FBC      	MOVWF CompTempVar2661+D'14', 1
1212  6FC2      	MOVWF CompTempVar2661+D'20', 1
1214  0E0D      	MOVLW 0x0D
1216  6FB6      	MOVWF CompTempVar2661+D'8', 1
1218  6FBB      	MOVWF CompTempVar2661+D'13', 1
121A  6FC1      	MOVWF CompTempVar2661+D'19', 1
121C  0E26      	MOVLW 0x26
121E  6FBF      	MOVWF CompTempVar2661+D'17', 1
1220  0E30      	MOVLW 0x30
1222  6FC6      	MOVWF CompTempVar2661+D'24', 1
1224  0E31      	MOVLW 0x31
1226  6FB3      	MOVWF CompTempVar2661+D'5', 1
1228  0E32      	MOVLW 0x32
122A  6FB5      	MOVWF CompTempVar2661+D'7', 1
122C  0E33      	MOVLW 0x33
122E  6FB2      	MOVWF CompTempVar2661+D'4', 1
1230  0E35      	MOVLW 0x35
1232  6FB1      	MOVWF CompTempVar2661+D'3', 1
1234  0E3D      	MOVLW 0x3D
1236  6FB4      	MOVWF CompTempVar2661+D'6', 1
1238  0E41      	MOVLW 0x41
123A  6FAE      	MOVWF CompTempVar2661, 1
123C  6FB8      	MOVWF CompTempVar2661+D'10', 1
123E  6FBA      	MOVWF CompTempVar2661+D'12', 1
1240  6FBD      	MOVWF CompTempVar2661+D'15', 1
1242  6FC3      	MOVWF CompTempVar2661+D'21', 1
1244  0E53      	MOVLW 0x53
1246  6FB0      	MOVWF CompTempVar2661+D'2', 1
1248  0E54      	MOVLW 0x54
124A  6FAF      	MOVWF CompTempVar2661+D'1', 1
124C  6FB9      	MOVWF CompTempVar2661+D'11', 1
124E  6FBE      	MOVWF CompTempVar2661+D'16', 1
1250  6FC4      	MOVWF CompTempVar2661+D'22', 1
1252  0E57      	MOVLW 0x57
1254  6FC0      	MOVWF CompTempVar2661+D'18', 1
1256  0E5A      	MOVLW 0x5A
1258  6FC5      	MOVWF CompTempVar2661+D'23', 1
125A  6BC7      	CLRF CompTempVar2661+D'25', 1
125C  0E00      	MOVLW HIGH(CompTempVar2661+D'0')
125E  6FEA      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1', 1
1260  0EAE      	MOVLW LOW(CompTempVar2661+D'0')
1262  6FE9      	MOVWF FCI_SCOPY_00000_arg_sSrc, 1
1264  0E1A      	MOVLW 0x1A
1266  6FEB      	MOVWF FCI_SCOPY_00000_arg_iSrc_len, 1
1268  0E00      	MOVLW HIGH(FCD_0c851__00065_1_FCL_SCR_00066+D'0')
126A  6FED      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1', 1
126C  0E84      	MOVLW LOW(FCD_0c851__00065_1_FCL_SCR_00066+D'0')
126E  6FEC      	MOVWF FCI_SCOPY_00000_arg_sDst, 1
1270  0E28      	MOVLW 0x28
1272  6FEE      	MOVWF FCI_SCOPY_00000_arg_iDst_len, 1
1274  EC6BF001  	CALL FCI_SCOPY_00000


			break;
1278  D022      	BRA	label201

		}
		case 3:
1170  0E03      	MOVLW 0x03
1172  6381      	CPFSEQ FCD_0c851__00065_arg_FCL_IDX, 1
1174  D001      	BRA	label195
1176  D081      	BRA	label198
1178            label195
127A            label198

		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
127A  6BAE      	CLRF CompTempVar2664, 1
127C  0E00      	MOVLW HIGH(CompTempVar2664+D'0')
127E  6FEA      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1', 1
1280  0EAE      	MOVLW LOW(CompTempVar2664+D'0')
1282  6FE9      	MOVWF FCI_SCOPY_00000_arg_sSrc, 1
1284  0E01      	MOVLW 0x01
1286  6FEB      	MOVWF FCI_SCOPY_00000_arg_iSrc_len, 1
1288  0E00      	MOVLW HIGH(FCD_0c851__00065_1_FCL_SCR_00066+D'0')
128A  6FED      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1', 1
128C  0E84      	MOVLW LOW(FCD_0c851__00065_1_FCL_SCR_00066+D'0')
128E  6FEC      	MOVWF FCI_SCOPY_00000_arg_sDst, 1
1290  0E28      	MOVLW 0x28
1292  6FEE      	MOVWF FCI_SCOPY_00000_arg_iDst_len, 1
1294  EC6BF001  	CALL FCI_SCOPY_00000


			break;
1298  D012      	BRA	label201

		}
		case 4:
1178  0E04      	MOVLW 0x04
117A  6381      	CPFSEQ FCD_0c851__00065_arg_FCL_IDX, 1
117C  D09E      	BRA	label200
129A            label199

		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
129A  6BAE      	CLRF CompTempVar2667, 1
129C  0E00      	MOVLW HIGH(CompTempVar2667+D'0')
129E  6FEA      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1', 1
12A0  0EAE      	MOVLW LOW(CompTempVar2667+D'0')
12A2  6FE9      	MOVWF FCI_SCOPY_00000_arg_sSrc, 1
12A4  0E01      	MOVLW 0x01
12A6  6FEB      	MOVWF FCI_SCOPY_00000_arg_iSrc_len, 1
12A8  0E00      	MOVLW HIGH(FCD_0c851__00065_1_FCL_SCR_00066+D'0')
12AA  6FED      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1', 1
12AC  0E84      	MOVLW LOW(FCD_0c851__00065_1_FCL_SCR_00066+D'0')
12AE  6FEC      	MOVWF FCI_SCOPY_00000_arg_sDst, 1
12B0  0E28      	MOVLW 0x28
12B2  6FEE      	MOVWF FCI_SCOPY_00000_arg_iDst_len, 1
12B4  EC6BF001  	CALL FCI_SCOPY_00000


			break;
12B8  D002      	BRA	label201

		}
		default:
12BA            label200

		{
			FCR_RETVAL = 255;
12BA  69AD      	SETF FCD_0c851__00065_1_FCR_RETVAL, 1


			goto FCC_SendScript_A;
12BC  D033      	BRA	label205


		}
	}

	while (FCL_CH > 0)
12BE  0E00      	MOVLW 0x00
12C0  6583      	CPFSGT FCD_0c851__00065_1_FCL_CH, 1
12C2  D022      	BRA	label204
1306  D7DB      	BRA	label201
1308            label204

	{

		FCL_CH = FCL_SCRIPT_STR[FCL_I];
12C4  EE00F084  	LFSR 0x00, FCD_0c851__00065_1_FCL_SCR_00066
12C8  50E9      	MOVF FSR0L, W
12CA  5182      	MOVF FCD_0c851__00065_1_FCL_I, W, 1
12CC  26E9      	ADDWF FSR0L, F
12CE  50EF      	MOVF INDF0, W
12D0  6F83      	MOVWF FCD_0c851__00065_1_FCL_CH, 1


		if ((FCL_CH > 0) && (FCL_CH != 0x0A))
12D2  0E00      	MOVLW 0x00
12D4  6583      	CPFSGT FCD_0c851__00065_1_FCL_CH, 1
12D6  D015      	BRA	label203
12D8  0E0A      	MOVLW 0x0A
12DA  6383      	CPFSEQ FCD_0c851__00065_1_FCL_CH, 1
12DC  D001      	BRA	label202
12DE  D011      	BRA	label203
12E0            label202

		{

			FC_CAL_UART_Send_1(FCL_CH);
12E0  5183      	MOVF FCD_0c851__00065_1_FCL_CH, W, 1
12E2  6FBC      	MOVWF FC_CAL_UAR_000CB_arg_nChar, 1
12E4  6BBD      	CLRF FC_CAL_UAR_000CB_arg_nChar+D'1', 1
12E6  EC26F003  	CALL FC_CAL_UAR_000CB


			FCL_LEN = FCL_LEN + 1;
12EA  29AC      	INCF FCD_0c851__00065_1_FCL_LEN, W, 1
12EC  6FAC      	MOVWF FCD_0c851__00065_1_FCL_LEN, 1


			if (FCL_CH == FCV_0c851_Bluetooth2__BT_CHAR_CR)
12EE  0E0D      	MOVLW 0x0D
12F0  6383      	CPFSEQ FCD_0c851__00065_1_FCL_CH, 1
12F2  D007      	BRA	label203
1302            label203

			{

				#if (1) // 1 == 1

					FCD_0c851_Bluetooth2__StringReceive();
12F4  EC2EF003  	CALL FCD_0c851__000D1


				// #else

				//Le code a été optimisé par le préprocesseur
				#endif

				FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
12F8  EC2EF003  	CALL FCD_0c851__000D1
12FC  51BF      	MOVF CompTempVarRet3095, W, 1
12FE  6FAD      	MOVWF FCD_0c851__00065_1_FCR_RETVAL, 1


				FCL_LEN = 0;
1300  6BAC      	CLRF FCD_0c851__00065_1_FCL_LEN, 1


			// } else {

			}

		// } else {

		}

		FCL_I = FCL_I + 1;
1302  2982      	INCF FCD_0c851__00065_1_FCL_I, W, 1
1304  6F82      	MOVWF FCD_0c851__00065_1_FCL_I, 1



	}

	if (FCL_LEN > 0)
1308  0E00      	MOVLW 0x00
130A  65AC      	CPFSGT FCD_0c851__00065_1_FCL_LEN, 1
130C  D00B      	BRA	label205
1324            label205

	{

		FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);
130E  0E0D      	MOVLW 0x0D
1310  6FBC      	MOVWF FC_CAL_UAR_000CB_arg_nChar, 1
1312  6BBD      	CLRF FC_CAL_UAR_000CB_arg_nChar+D'1', 1
1314  EC26F003  	CALL FC_CAL_UAR_000CB


		#if (1) // 1 == 1

			FCD_0c851_Bluetooth2__StringReceive();
1318  EC2EF003  	CALL FCD_0c851__000D1


		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
131C  EC2EF003  	CALL FCD_0c851__000D1
1320  51BF      	MOVF CompTempVarRet3095, W, 1
1322  6FAD      	MOVWF FCD_0c851__00065_1_FCR_RETVAL, 1


	// } else {

	}

FCC_SendScript_A:
;

	return (FCR_RETVAL);
1324  51AD      	MOVF FCD_0c851__00065_1_FCR_RETVAL, W, 1
1326  6FAE      	MOVWF CompTempVarRet2657, 1


	//Définitions des variables locales
	#undef FCLsz_SCRIPT_STR
}
1328  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sends a command string to the GSM module.
       :0 = Command sent ok, 255 = No Reply
       :
       :Param??tres pour la macro SendCommand :
       :  Command[20] : MX_CHAR (by-ref)
       :  SendCR : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
0970  6BB9      	CLRF FCD_0c851__00072_1_FCL_IDX, 1

	MX_UINT8 FCL_LEN;
	MX_UINT8 FCR_RETVAL;


	while (1)
0972            label115

	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
0972  EC2EF003  	CALL FCD_0c851__000D1
0976  51BF      	MOVF CompTempVarRet3095, W, 1
0978  6FBB      	MOVWF FCD_0c851__00072_1_FCR_RETVAL, 1



		if ((FCR_RETVAL) == 0) break;
097A  53BB      	MOVF FCD_0c851__00072_1_FCR_RETVAL, F, 1
097C  E1FA      	BNZ	label115

	}

	FCL_LEN = FCI_GETLENGTH(FCL_COMMAND, FCLsz_COMMAND);
097E  51B4      	MOVF FCD_0c851__00072_arg_FCL_COMMAND, W, 1
0980  6FE4      	MOVWF FCI_GETLEN_0004E_arg_sStr1, 1
0982  51B5      	MOVF FCD_0c851__00072_arg_FCL_COMMAND+D'1', W, 1
0984  6FE5      	MOVWF FCI_GETLEN_0004E_arg_sStr1+D'1', 1
0986  51B6      	MOVF FCD_0c851__00072_arg_FCLsz_00073, W, 1
0988  6FE6      	MOVWF FCI_GETLEN_0004E_arg_iStr1_len, 1
098A  EC97F001  	CALL FCI_GETLEN_0004E
098E  51E8      	MOVF CompTempVarRet1850, W, 1
0990  6FBA      	MOVWF FCD_0c851__00072_1_FCL_LEN, 1


	if (FCL_LEN)
0992  53BA      	MOVF FCD_0c851__00072_1_FCL_LEN, F, 1
0994  E017      	BZ	label118
0996            label116

	{

		while (FCL_IDX < FCL_LEN)
0996  51BA      	MOVF FCD_0c851__00072_1_FCL_LEN, W, 1
0998  61B9      	CPFSLT FCD_0c851__00072_1_FCL_IDX, 1
099A  D00D      	BRA	label117
09B4  D7F0      	BRA	label116
09B6            label117

		{

			FC_CAL_UART_Send_1(FCL_COMMAND[FCL_IDX]);
099C  51B5      	MOVF FCD_0c851__00072_arg_FCL_COMMAND+D'1', W, 1
099E  6EEA      	MOVWF FSR0H
09A0  51B4      	MOVF FCD_0c851__00072_arg_FCL_COMMAND, W, 1
09A2  25B9      	ADDWF FCD_0c851__00072_1_FCL_IDX, W, 1
09A4  6EE9      	MOVWF FSR0L
09A6  50EF      	MOVF INDF0, W
09A8  6FBC      	MOVWF FC_CAL_UAR_000CB_arg_nChar, 1
09AA  6BBD      	CLRF FC_CAL_UAR_000CB_arg_nChar+D'1', 1
09AC  EC26F003  	CALL FC_CAL_UAR_000CB


			FCL_IDX = FCL_IDX + 1;
09B0  29B9      	INCF FCD_0c851__00072_1_FCL_IDX, W, 1
09B2  6FB9      	MOVWF FCD_0c851__00072_1_FCL_IDX, 1



		}

		if (FCL_SENDCR)
09B6  53B8      	MOVF FCD_0c851__00072_arg_FCL_SENDCR, F, 1
09B8  E005      	BZ	label118
09C4            label118

		{

			FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);
09BA  0E0D      	MOVLW 0x0D
09BC  6FBC      	MOVWF FC_CAL_UAR_000CB_arg_nChar, 1
09BE  6BBD      	CLRF FC_CAL_UAR_000CB_arg_nChar+D'1', 1
09C0  EC26F003  	CALL FC_CAL_UAR_000CB


		// } else {

		}

	// } else {

	}

	#if (1) // 1 == 1

		FCD_0c851_Bluetooth2__StringReceive();
09C4  EC2EF003  	CALL FCD_0c851__000D1


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
09C8  EC2EF003  	CALL FCD_0c851__000D1
09CC  51BF      	MOVF CompTempVarRet3095, W, 1
09CE  6FBB      	MOVWF FCD_0c851__00072_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 0)
09D0  53BB      	MOVF FCD_0c851__00072_1_FCR_RETVAL, F, 1
09D2  E102      	BNZ	label119
09D8            label119

	{

		FCR_RETVAL = 255;
09D4  69BB      	SETF FCD_0c851__00072_1_FCR_RETVAL, 1


	} else {
09D6  D001      	BRA	label120
09DA            label120


		FCR_RETVAL = 0;
09D8  6BBB      	CLRF FCD_0c851__00072_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
09DA  51BB      	MOVF FCD_0c851__00072_1_FCR_RETVAL, W, 1
09DC  6FBC      	MOVWF CompTempVarRet2687, 1


}
09DE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies the incoming data from the data string array to a local string variable.
       :
       :Param??tres pour la macro ReadString :
       :  NumBytes : MX_UINT8
       :
       :Renvoie : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
045A  6BDD      	CLRF FCD_0c851__00078_1_FCL_IDX, 1



	while ((FCL_IDX < FCL_NUMBYTES) && (FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX] > 0))
045C            label66
045C  51DC      	MOVF FCD_0c851__00078_arg_FCL_N_0007A, W, 1
045E  61DD      	CPFSLT FCD_0c851__00078_1_FCL_IDX, 1
0460  D01B      	BRA	label67
0462  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00010
0466  50E9      	MOVF FSR0L, W
0468  51DD      	MOVF FCD_0c851__00078_1_FCL_IDX, W, 1
046A  26E9      	ADDWF FSR0L, F
046C  0E00      	MOVLW 0x00
046E  64EF      	CPFSGT INDF0
0470  D013      	BRA	label67
0496  D7E2      	BRA	label66
0498            label67

	{

		FCR_RETVAL[FCL_IDX] = FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX];
0472  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00010
0476  50E9      	MOVF FSR0L, W
0478  51DD      	MOVF FCD_0c851__00078_1_FCL_IDX, W, 1
047A  6FDE      	MOVWF CompTempVar2706, 1
047C  51DE      	MOVF CompTempVar2706, W, 1
047E  26E9      	ADDWF FSR0L, F
0480  50EF      	MOVF INDF0, W
0482  6FDF      	MOVWF CompTempVar2707, 1
0484  51D9      	MOVF FCD_0c851__00078_arg_FCR_RETVAL+D'1', W, 1
0486  6EEA      	MOVWF FSR0H
0488  51D8      	MOVF FCD_0c851__00078_arg_FCR_RETVAL, W, 1
048A  25DD      	ADDWF FCD_0c851__00078_1_FCL_IDX, W, 1
048C  6EE9      	MOVWF FSR0L
048E  51DF      	MOVF CompTempVar2707, W, 1
0490  6EEF      	MOVWF INDF0

		FCL_IDX = FCL_IDX + 1;
0492  29DD      	INCF FCD_0c851__00078_1_FCL_IDX, W, 1
0494  6FDD      	MOVWF FCD_0c851__00078_1_FCL_IDX, 1



	}

	if (FCL_IDX < FCL_NUMBYTES)
0498  51DC      	MOVF FCD_0c851__00078_arg_FCL_N_0007A, W, 1
049A  61DD      	CPFSLT FCD_0c851__00078_1_FCL_IDX, 1

	{

		FCR_RETVAL[FCL_IDX] = 0;
049E  51D9      	MOVF FCD_0c851__00078_arg_FCR_RETVAL+D'1', W, 1
04A0  6EEA      	MOVWF FSR0H
04A2  51D8      	MOVF FCD_0c851__00078_arg_FCR_RETVAL, W, 1
04A4  25DD      	ADDWF FCD_0c851__00078_1_FCL_IDX, W, 1
04A6  6EE9      	MOVWF FSR0L
04A8  0E00      	MOVLW 0x00
04AA  6EEF      	MOVWF INDF0


	// } else {

	}

}
049C  0012      	RETURN
04AC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Saves the current settings to firmware using the AT&W command followed by the ATZ command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&W", 5, 1);
0F80  0E41      	MOVLW 0x41
0F82  0100      	MOVLB 0x00
0F84  6F97      	MOVWF CompTempVar3097, 1
0F86  0E54      	MOVLW 0x54
0F88  6F98      	MOVWF CompTempVar3097+D'1', 1
0F8A  0E26      	MOVLW 0x26
0F8C  6F99      	MOVWF CompTempVar3097+D'2', 1
0F8E  0E57      	MOVLW 0x57
0F90  6F9A      	MOVWF CompTempVar3097+D'3', 1
0F92  6B9B      	CLRF CompTempVar3097+D'4', 1
0F94  0E00      	MOVLW HIGH(CompTempVar3097+D'0')
0F96  6FB5      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND+D'1', 1
0F98  0E97      	MOVLW LOW(CompTempVar3097+D'0')
0F9A  6FB4      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND, 1
0F9C  0E05      	MOVLW 0x05
0F9E  6FB6      	MOVWF FCD_0c851__00072_arg_FCLsz_00073, 1
0FA0  6BB7      	CLRF FCD_0c851__00072_arg_FCLsz_00073+D'1', 1
0FA2  0E01      	MOVLW 0x01
0FA4  6FB8      	MOVWF FCD_0c851__00072_arg_FCL_SENDCR, 1
0FA6  ECB8F004  	CALL FCD_0c851__00072
0FAA  51BC      	MOVF CompTempVarRet2687, W, 1
0FAC  6F96      	MOVWF FCD_0c851__000D2_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 0)
0FAE  5396      	MOVF FCD_0c851__000D2_1_FCR_RETVAL, F, 1
0FB0  E114      	BNZ	label184
0FDA            label184

	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATZ", 4, 1);
0FB2  0E41      	MOVLW 0x41
0FB4  6F97      	MOVWF CompTempVar3099, 1
0FB6  0E54      	MOVLW 0x54
0FB8  6F98      	MOVWF CompTempVar3099+D'1', 1
0FBA  0E5A      	MOVLW 0x5A
0FBC  6F99      	MOVWF CompTempVar3099+D'2', 1
0FBE  6B9A      	CLRF CompTempVar3099+D'3', 1
0FC0  0E00      	MOVLW HIGH(CompTempVar3099+D'0')
0FC2  6FB5      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND+D'1', 1
0FC4  0E97      	MOVLW LOW(CompTempVar3099+D'0')
0FC6  6FB4      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND, 1
0FC8  0E04      	MOVLW 0x04
0FCA  6FB6      	MOVWF FCD_0c851__00072_arg_FCLsz_00073, 1
0FCC  6BB7      	CLRF FCD_0c851__00072_arg_FCLsz_00073+D'1', 1
0FCE  0E01      	MOVLW 0x01
0FD0  6FB8      	MOVWF FCD_0c851__00072_arg_FCL_SENDCR, 1
0FD2  ECB8F004  	CALL FCD_0c851__00072
0FD6  51BC      	MOVF CompTempVarRet2687, W, 1
0FD8  6F96      	MOVWF FCD_0c851__000D2_1_FCR_RETVAL, 1


	// } else {

	}

	return (FCR_RETVAL);
0FDA  5196      	MOVF FCD_0c851__000D2_1_FCR_RETVAL, W, 1
0FDC  6F97      	MOVWF CompTempVarRet3096, 1


}
0FDE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sends a single data byte out to the Bluetooth module.
       :
       :Param??tres pour la macro SendByte :
       :  Data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA)
{

	FC_CAL_UART_Send_1(FCL_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the bluetooth mode to be discoverable and or connectable.
       :Returns 0 for success.
       :
       :Param??tres pour la macro SetMode :
       :  Discoverable : 0 = Not Discoverable, 1 = Discoverable
       :  Connectable : 0 = Not Connectable, 1 = Connectable
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE)

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	if (FCL_DISCOVERABLE)
0E7C  5396      	MOVF FCD_0c851__000D4_arg_FCL_D_000D5, F, 1
0E7E  E03F      	BZ	label181
0EFE            label181

	{

		if (FCL_CONNECTABLE)
0E80  5397      	MOVF FCD_0c851__000D4_arg_FCL_C_000D6, F, 1
0E82  E01F      	BZ	label180
0EC2            label180

		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=4", 9, 1);
0E84  0E41      	MOVLW 0x41
0E86  6F99      	MOVWF CompTempVar3102, 1
0E88  0E54      	MOVLW 0x54
0E8A  6F9A      	MOVWF CompTempVar3102+D'1', 1
0E8C  0E53      	MOVLW 0x53
0E8E  6F9B      	MOVWF CompTempVar3102+D'2', 1
0E90  0E35      	MOVLW 0x35
0E92  6F9C      	MOVWF CompTempVar3102+D'3', 1
0E94  0E31      	MOVLW 0x31
0E96  6F9D      	MOVWF CompTempVar3102+D'4', 1
0E98  0E32      	MOVLW 0x32
0E9A  6F9E      	MOVWF CompTempVar3102+D'5', 1
0E9C  0E3D      	MOVLW 0x3D
0E9E  6F9F      	MOVWF CompTempVar3102+D'6', 1
0EA0  0E34      	MOVLW 0x34
0EA2  6FA0      	MOVWF CompTempVar3102+D'7', 1
0EA4  6BA1      	CLRF CompTempVar3102+D'8', 1
0EA6  0E00      	MOVLW HIGH(CompTempVar3102+D'0')
0EA8  6FB5      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND+D'1', 1
0EAA  0E99      	MOVLW LOW(CompTempVar3102+D'0')
0EAC  6FB4      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND, 1
0EAE  0E09      	MOVLW 0x09
0EB0  6FB6      	MOVWF FCD_0c851__00072_arg_FCLsz_00073, 1
0EB2  6BB7      	CLRF FCD_0c851__00072_arg_FCLsz_00073+D'1', 1
0EB4  0E01      	MOVLW 0x01
0EB6  6FB8      	MOVWF FCD_0c851__00072_arg_FCL_SENDCR, 1
0EB8  ECB8F004  	CALL FCD_0c851__00072
0EBC  51BC      	MOVF CompTempVarRet2687, W, 1
0EBE  6F98      	MOVWF FCD_0c851__000D4_1_FCR_RETVAL, 1


		} else {
0EC0  D05C      	BRA	label183


			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 1);
0EC2  0E31      	MOVLW 0x31
0EC4  6F9D      	MOVWF CompTempVar3104+D'4', 1
0EC6  0E32      	MOVLW 0x32
0EC8  6F9E      	MOVWF CompTempVar3104+D'5', 1
0ECA  6FA0      	MOVWF CompTempVar3104+D'7', 1
0ECC  0E35      	MOVLW 0x35
0ECE  6F9C      	MOVWF CompTempVar3104+D'3', 1
0ED0  0E3D      	MOVLW 0x3D
0ED2  6F9F      	MOVWF CompTempVar3104+D'6', 1
0ED4  0E41      	MOVLW 0x41
0ED6  6F99      	MOVWF CompTempVar3104, 1
0ED8  0E53      	MOVLW 0x53
0EDA  6F9B      	MOVWF CompTempVar3104+D'2', 1
0EDC  0E54      	MOVLW 0x54
0EDE  6F9A      	MOVWF CompTempVar3104+D'1', 1
0EE0  6BA1      	CLRF CompTempVar3104+D'8', 1
0EE2  0E00      	MOVLW HIGH(CompTempVar3104+D'0')
0EE4  6FB5      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND+D'1', 1
0EE6  0E99      	MOVLW LOW(CompTempVar3104+D'0')
0EE8  6FB4      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND, 1
0EEA  0E09      	MOVLW 0x09
0EEC  6FB6      	MOVWF FCD_0c851__00072_arg_FCLsz_00073, 1
0EEE  6BB7      	CLRF FCD_0c851__00072_arg_FCLsz_00073+D'1', 1
0EF0  0E01      	MOVLW 0x01
0EF2  6FB8      	MOVWF FCD_0c851__00072_arg_FCL_SENDCR, 1
0EF4  ECB8F004  	CALL FCD_0c851__00072
0EF8  51BC      	MOVF CompTempVarRet2687, W, 1
0EFA  6F98      	MOVWF FCD_0c851__000D4_1_FCR_RETVAL, 1


		}

	} else {
0EFC  D03E      	BRA	label183


		if (FCL_CONNECTABLE)
0EFE  5397      	MOVF FCD_0c851__000D4_arg_FCL_C_000D6, F, 1
0F00  E01E      	BZ	label182
0F3E            label182

		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 3);
0F02  0E31      	MOVLW 0x31
0F04  6F9D      	MOVWF CompTempVar3106+D'4', 1
0F06  0E32      	MOVLW 0x32
0F08  6F9E      	MOVWF CompTempVar3106+D'5', 1
0F0A  6FA0      	MOVWF CompTempVar3106+D'7', 1
0F0C  0E35      	MOVLW 0x35
0F0E  6F9C      	MOVWF CompTempVar3106+D'3', 1
0F10  0E3D      	MOVLW 0x3D
0F12  6F9F      	MOVWF CompTempVar3106+D'6', 1
0F14  0E41      	MOVLW 0x41
0F16  6F99      	MOVWF CompTempVar3106, 1
0F18  0E53      	MOVLW 0x53
0F1A  6F9B      	MOVWF CompTempVar3106+D'2', 1
0F1C  0E54      	MOVLW 0x54
0F1E  6F9A      	MOVWF CompTempVar3106+D'1', 1
0F20  6BA1      	CLRF CompTempVar3106+D'8', 1
0F22  0E00      	MOVLW HIGH(CompTempVar3106+D'0')
0F24  6FB5      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND+D'1', 1
0F26  0E99      	MOVLW LOW(CompTempVar3106+D'0')
0F28  6FB4      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND, 1
0F2A  0E09      	MOVLW 0x09
0F2C  6FB6      	MOVWF FCD_0c851__00072_arg_FCLsz_00073, 1
0F2E  6BB7      	CLRF FCD_0c851__00072_arg_FCLsz_00073+D'1', 1
0F30  0E03      	MOVLW 0x03
0F32  6FB8      	MOVWF FCD_0c851__00072_arg_FCL_SENDCR, 1
0F34  ECB8F004  	CALL FCD_0c851__00072
0F38  51BC      	MOVF CompTempVarRet2687, W, 1
0F3A  6F98      	MOVWF FCD_0c851__000D4_1_FCR_RETVAL, 1


		} else {
0F3C  D01E      	BRA	label183
0F7A            label183


			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=0", 9, 1);
0F3E  0E41      	MOVLW 0x41
0F40  6F99      	MOVWF CompTempVar3108, 1
0F42  0E54      	MOVLW 0x54
0F44  6F9A      	MOVWF CompTempVar3108+D'1', 1
0F46  0E53      	MOVLW 0x53
0F48  6F9B      	MOVWF CompTempVar3108+D'2', 1
0F4A  0E35      	MOVLW 0x35
0F4C  6F9C      	MOVWF CompTempVar3108+D'3', 1
0F4E  0E31      	MOVLW 0x31
0F50  6F9D      	MOVWF CompTempVar3108+D'4', 1
0F52  0E32      	MOVLW 0x32
0F54  6F9E      	MOVWF CompTempVar3108+D'5', 1
0F56  0E3D      	MOVLW 0x3D
0F58  6F9F      	MOVWF CompTempVar3108+D'6', 1
0F5A  0E30      	MOVLW 0x30
0F5C  6FA0      	MOVWF CompTempVar3108+D'7', 1
0F5E  6BA1      	CLRF CompTempVar3108+D'8', 1
0F60  0E00      	MOVLW HIGH(CompTempVar3108+D'0')
0F62  6FB5      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND+D'1', 1
0F64  0E99      	MOVLW LOW(CompTempVar3108+D'0')
0F66  6FB4      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND, 1
0F68  0E09      	MOVLW 0x09
0F6A  6FB6      	MOVWF FCD_0c851__00072_arg_FCLsz_00073, 1
0F6C  6BB7      	CLRF FCD_0c851__00072_arg_FCLsz_00073+D'1', 1
0F6E  0E01      	MOVLW 0x01
0F70  6FB8      	MOVWF FCD_0c851__00072_arg_FCL_SENDCR, 1
0F72  ECB8F004  	CALL FCD_0c851__00072
0F76  51BC      	MOVF CompTempVarRet2687, W, 1
0F78  6F98      	MOVWF FCD_0c851__000D4_1_FCR_RETVAL, 1


		}

	}

	return (FCR_RETVAL);
0F7A  5198      	MOVF FCD_0c851__000D4_1_FCR_RETVAL, W, 1
0F7C  6F99      	MOVWF CompTempVarRet3101, 1


}
0F7E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to receive a string from the GSM modem terminated with a 0x10 CR character. Used to collect the replies from commands.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TOUT = (0x0);
065C  0100      	MOVLB 0x00
065E  6BBC      	CLRF FCD_0c851__000D1_1_FCL_TOUT, 1

	MX_UINT8 FCL_LEN = (0x0);
0660  6BBD      	CLRF FCD_0c851__000D1_1_FCL_LEN, 1

	MX_UINT8 FCR_RETVAL;


	FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
0662  5180      	MOVF gbl_FCV_0c851_Bluetooth2___00012, W, 1
0664  6FBD      	MOVWF FCD_0c851__000D1_1_FCL_LEN, 1

	FCV_0c851_Bluetooth2__RX_DONE = 0;
0666  6A7F      	CLRF gbl_FCV_0c851_Bluetooth2___00011

	FCV_0c851_Bluetooth2__RX_LENGTH = 0;
0668  6B80      	CLRF gbl_FCV_0c851_Bluetooth2___00012, 1

	FCV_0c851_Bluetooth2__RX_IDX = 0;
066A  6A7E      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX


	while ((FCV_0c851_Bluetooth2__RX_DONE == 0) && (FCL_TOUT < 255))
066C            label90
066C  527F      	MOVF gbl_FCV_0c851_Bluetooth2___00011, F
066E  E114      	BNZ	label92
0670  0EFF      	MOVLW 0xFF
0672  0100      	MOVLB 0x00
0674  61BC      	CPFSLT FCD_0c851__000D1_1_FCL_TOUT, 1
0676  D010      	BRA	label92
0696  D7EA      	BRA	label90
0698            label92

	{

		FCL_TOUT = FCL_TOUT + 1;
0678  29BC      	INCF FCD_0c851__000D1_1_FCL_TOUT, W, 1
067A  6FBC      	MOVWF FCD_0c851__000D1_1_FCL_TOUT, 1


		if (FCL_LEN != FCV_0c851_Bluetooth2__RX_LENGTH)
067C  5180      	MOVF gbl_FCV_0c851_Bluetooth2___00012, W, 1
067E  63BD      	CPFSEQ FCD_0c851__000D1_1_FCL_LEN, 1
0680  6380      	CPFSEQ gbl_FCV_0c851_Bluetooth2___00012, 1
0682  D003      	BRA	label91
068A            label91

		{

			FCL_TOUT = 0;
0684  6BBC      	CLRF FCD_0c851__000D1_1_FCL_TOUT, 1

			FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
0686  5180      	MOVF gbl_FCV_0c851_Bluetooth2___00012, W, 1
0688  6FBD      	MOVWF FCD_0c851__000D1_1_FCL_LEN, 1


		// } else {

		}

		FCI_DELAYINT_US(500);
068A  0EF4      	MOVLW 0xF4
068C  6FBF      	MOVWF FCI_DELAYI_00048_arg_Delay, 1
068E  0E01      	MOVLW 0x01
0690  6FC0      	MOVWF FCI_DELAYI_00048_arg_Delay+D'1', 1
0692  EC08F003  	CALL FCI_DELAYI_00048



	}

	if (FCL_TOUT == 255)
0698  0100      	MOVLB 0x00
069A  29BC      	INCF FCD_0c851__000D1_1_FCL_TOUT, W, 1
069C  E104      	BNZ	label93
06A6            label93

	{

		FCV_0c851_Bluetooth2__RX_DONE = 0;
069E  6A7F      	CLRF gbl_FCV_0c851_Bluetooth2___00011

		FCV_0c851_Bluetooth2__RX_LENGTH = 0;
06A0  6B80      	CLRF gbl_FCV_0c851_Bluetooth2___00012, 1

		FCR_RETVAL = 0;
06A2  6BBE      	CLRF FCD_0c851__000D1_1_FCR_RETVAL, 1


	} else {
06A4  D002      	BRA	label94
06AA            label94


		FCR_RETVAL = 1;
06A6  0E01      	MOVLW 0x01
06A8  6FBE      	MOVWF FCD_0c851__000D1_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
06AA  51BE      	MOVF FCD_0c851__000D1_1_FCR_RETVAL, W, 1
06AC  6FBF      	MOVWF CompTempVarRet3095, 1


}
06AE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Restores the factory settings to firmware using the AT&F* command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&F*", 6, 1);
0E44  0E41      	MOVLW 0x41
0E46  0100      	MOVLB 0x00
0E48  6F97      	MOVWF CompTempVar3111, 1
0E4A  0E54      	MOVLW 0x54
0E4C  6F98      	MOVWF CompTempVar3111+D'1', 1
0E4E  0E26      	MOVLW 0x26
0E50  6F99      	MOVWF CompTempVar3111+D'2', 1
0E52  0E46      	MOVLW 0x46
0E54  6F9A      	MOVWF CompTempVar3111+D'3', 1
0E56  0E2A      	MOVLW 0x2A
0E58  6F9B      	MOVWF CompTempVar3111+D'4', 1
0E5A  6B9C      	CLRF CompTempVar3111+D'5', 1
0E5C  0E00      	MOVLW HIGH(CompTempVar3111+D'0')
0E5E  6FB5      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND+D'1', 1
0E60  0E97      	MOVLW LOW(CompTempVar3111+D'0')
0E62  6FB4      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND, 1
0E64  0E06      	MOVLW 0x06
0E66  6FB6      	MOVWF FCD_0c851__00072_arg_FCLsz_00073, 1
0E68  6BB7      	CLRF FCD_0c851__00072_arg_FCLsz_00073+D'1', 1
0E6A  0E01      	MOVLW 0x01
0E6C  6FB8      	MOVWF FCD_0c851__00072_arg_FCL_SENDCR, 1
0E6E  ECB8F004  	CALL FCD_0c851__00072
0E72  51BC      	MOVF CompTempVarRet2687, W, 1
0E74  6F96      	MOVWF FCD_0c851__000D7_1_FCR_RETVAL, 1


	return (FCR_RETVAL);
0E76  5196      	MOVF FCD_0c851__000D7_1_FCR_RETVAL, W, 1
0E78  6F97      	MOVWF CompTempVarRet3110, 1


}
0E7A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets up the GSM module.
       :Returns 0 for OK, 255 for no reply and 254 for command fail.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__Initialise()

{
	//Définitions des variables locales
	#define FCLsz_CMDSTR 20
	MX_CHAR FCL_CMDSTR[FCLsz_CMDSTR];
	MX_UINT8 FCR_RETVAL;


	FCP_SET(B, C, 0x2, 0x1, 0);
132A  0100      	MOVLB 0x00
132C  6B96      	CLRF FCD_0c851__00062_2_ptmp, 1
132E  9294      	BCF gbl_trisc,1
1330  5396      	MOVF FCD_0c851__00062_2_ptmp, F, 1
1332  E004      	BZ	label206
1334  0E02      	MOVLW 0x02
1336  108B      	IORWF gbl_latc, W
1338  6E82      	MOVWF gbl_portc
133A  D003      	BRA	label207
133C            label206
133C  0EFD      	MOVLW 0xFD
133E  148B      	ANDWF gbl_latc, W
1340  6E82      	MOVWF gbl_portc
1342            label207


	FCI_DELAYBYTE_MS(100);
1342  0E64      	MOVLW 0x64
1344  0101      	MOVLB 0x01
1346  6F05      	MOVWF delay_ms_00000_arg_del, 1
1348  EC06F000  	CALL delay_ms_00000


	FCP_SET(B, C, 0x2, 0x1, 1);
134C  0E01      	MOVLW 0x01
134E  0100      	MOVLB 0x00
1350  6F96      	MOVWF FCD_0c851__00062_13_ptmp, 1
1352  9294      	BCF gbl_trisc,1
1354  5396      	MOVF FCD_0c851__00062_13_ptmp, F, 1
1356  E004      	BZ	label208
1358  0E02      	MOVLW 0x02
135A  108B      	IORWF gbl_latc, W
135C  6E82      	MOVWF gbl_portc
135E  D003      	BRA	label209
1360            label208
1360  0EFD      	MOVLW 0xFD
1362  148B      	ANDWF gbl_latc, W
1364  6E82      	MOVWF gbl_portc
1366            label209


	FCR_RETVAL = 0;
1366  6B95      	CLRF FCD_0c851__00062_1_FCR_RETVAL, 1


	FC_CAL_UART_Init_1();
1368  EC59F006  	CALL FC_CAL_UAR_000CC


	FCI_DELAYBYTE_MS(10);
136C  0E0A      	MOVLW 0x0A
136E  0101      	MOVLB 0x01
1370  6F05      	MOVWF delay_ms_00000_arg_del, 1
1372  EC06F000  	CALL delay_ms_00000


	FCD_0c851_Bluetooth2__StringReceive();
1376  EC2EF003  	CALL FCD_0c851__000D1


	#if (1)

		FCD_0c851_Bluetooth2__RestoreFactorySettings();
137A  EC22F007  	CALL FCD_0c851__000D7


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCI_SHEAD("AT+BTN=\"",9, "lool",5, FCL_CMDSTR,20);
137E  0E22      	MOVLW 0x22
1380  6F9E      	MOVWF CompTempVar2642+D'7', 1
1382  0E2B      	MOVLW 0x2B
1384  6F99      	MOVWF CompTempVar2642+D'2', 1
1386  0E3D      	MOVLW 0x3D
1388  6F9D      	MOVWF CompTempVar2642+D'6', 1
138A  0E41      	MOVLW 0x41
138C  6F97      	MOVWF CompTempVar2642, 1
138E  0E42      	MOVLW 0x42
1390  6F9A      	MOVWF CompTempVar2642+D'3', 1
1392  0E4E      	MOVLW 0x4E
1394  6F9C      	MOVWF CompTempVar2642+D'5', 1
1396  0E54      	MOVLW 0x54
1398  6F98      	MOVWF CompTempVar2642+D'1', 1
139A  6F9B      	MOVWF CompTempVar2642+D'4', 1
139C  6B9F      	CLRF CompTempVar2642+D'8', 1
139E  0E00      	MOVLW HIGH(CompTempVar2642+D'0')
13A0  6FB5      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1
13A2  0E97      	MOVLW LOW(CompTempVar2642+D'0')
13A4  6FB4      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
13A6  0E09      	MOVLW 0x09
13A8  6FBF      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1
13AA  0E6C      	MOVLW 0x6C
13AC  6FA2      	MOVWF CompTempVar2643, 1
13AE  6FA5      	MOVWF CompTempVar2643+D'3', 1
13B0  0E6F      	MOVLW 0x6F
13B2  6FA3      	MOVWF CompTempVar2643+D'1', 1
13B4  6FA4      	MOVWF CompTempVar2643+D'2', 1
13B6  6BA6      	CLRF CompTempVar2643+D'4', 1
13B8  0E00      	MOVLW HIGH(CompTempVar2643+D'0')
13BA  6FC1      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1', 1
13BC  0EA2      	MOVLW LOW(CompTempVar2643+D'0')
13BE  6FC0      	MOVWF FCI_SHEAD_00000_arg_sSrc2, 1
13C0  0E05      	MOVLW 0x05
13C2  6FC2      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1
13C4  0E00      	MOVLW HIGH(FCD_0c851__00062_1_FCL_CMDSTR+D'0')
13C6  6FC4      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
13C8  0E81      	MOVLW LOW(FCD_0c851__00062_1_FCL_CMDSTR+D'0')
13CA  6FC3      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
13CC  0E14      	MOVLW 0x14
13CE  6FC5      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
13D0  ECC9F003  	CALL FCI_SHEAD_00000

	FCI_SHEAD(FCL_CMDSTR,FCLsz_CMDSTR, "\"",2, FCL_CMDSTR,20);
13D4  0E00      	MOVLW HIGH(FCD_0c851__00062_1_FCL_CMDSTR+D'0')
13D6  6FB5      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1', 1
13D8  0E81      	MOVLW LOW(FCD_0c851__00062_1_FCL_CMDSTR+D'0')
13DA  6FB4      	MOVWF FCI_SHEAD_00000_arg_sSrc1, 1
13DC  0E14      	MOVLW 0x14
13DE  6FBF      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len, 1
13E0  0E22      	MOVLW 0x22
13E2  6F97      	MOVWF CompTempVar2647, 1
13E4  6B98      	CLRF CompTempVar2647+D'1', 1
13E6  0E00      	MOVLW HIGH(CompTempVar2647+D'0')
13E8  6FC1      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1', 1
13EA  0E97      	MOVLW LOW(CompTempVar2647+D'0')
13EC  6FC0      	MOVWF FCI_SHEAD_00000_arg_sSrc2, 1
13EE  0E02      	MOVLW 0x02
13F0  6FC2      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len, 1
13F2  0E00      	MOVLW HIGH(FCD_0c851__00062_1_FCL_CMDSTR+D'0')
13F4  6FC4      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
13F6  0E81      	MOVLW LOW(FCD_0c851__00062_1_FCL_CMDSTR+D'0')
13F8  6FC3      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
13FA  0E14      	MOVLW 0x14
13FC  6FC5      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
13FE  ECC9F003  	CALL FCI_SHEAD_00000


	FCD_0c851_Bluetooth2__SendCommand(FCL_CMDSTR, FCLsz_CMDSTR, 1);
1402  0E00      	MOVLW HIGH(FCD_0c851__00062_1_FCL_CMDSTR+D'0')
1404  6FB5      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND+D'1', 1
1406  0E81      	MOVLW LOW(FCD_0c851__00062_1_FCL_CMDSTR+D'0')
1408  6FB4      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND, 1
140A  0E14      	MOVLW 0x14
140C  6FB6      	MOVWF FCD_0c851__00072_arg_FCLsz_00073, 1
140E  6BB7      	CLRF FCD_0c851__00072_arg_FCLsz_00073+D'1', 1
1410  0E01      	MOVLW 0x01
1412  6FB8      	MOVWF FCD_0c851__00072_arg_FCL_SENDCR, 1
1414  ECB8F004  	CALL FCD_0c851__00072


	FCD_0c851_Bluetooth2__SetPairKey("1379", 5);
1418  0E31      	MOVLW 0x31
141A  6F98      	MOVWF CompTempVar2652, 1
141C  0E33      	MOVLW 0x33
141E  6F99      	MOVWF CompTempVar2652+D'1', 1
1420  0E37      	MOVLW 0x37
1422  6F9A      	MOVWF CompTempVar2652+D'2', 1
1424  0E39      	MOVLW 0x39
1426  6F9B      	MOVWF CompTempVar2652+D'3', 1
1428  6B9C      	CLRF CompTempVar2652+D'4', 1
142A  0E00      	MOVLW HIGH(CompTempVar2652+D'0')
142C  6F97      	MOVWF FCD_0c851__000CE_arg_FCL_PAIRKEY+D'1', 1
142E  0E98      	MOVLW LOW(CompTempVar2652+D'0')
1430  6F96      	MOVWF FCD_0c851__000CE_arg_FCL_PAIRKEY, 1
1432  0E05      	MOVLW 0x05
1434  6F9D      	MOVWF FCD_0c851__000CE_arg_FCLsz_000CF, 1
1436  6B9E      	CLRF FCD_0c851__000CE_arg_FCLsz_000CF+D'1', 1
1438  ECF0F007  	CALL FCD_0c851__000CE


	FCD_0c851_Bluetooth2__SetMode(1, 1);
143C  0E01      	MOVLW 0x01
143E  6F96      	MOVWF FCD_0c851__000D4_arg_FCL_D_000D5, 1
1440  6F97      	MOVWF FCD_0c851__000D4_arg_FCL_C_000D6, 1
1442  EC3EF007  	CALL FCD_0c851__000D4


	FCR_RETVAL = FCD_0c851_Bluetooth2__SaveSettings();
1446  ECC0F007  	CALL FCD_0c851__000D2
144A  5197      	MOVF CompTempVarRet3096, W, 1
144C  6F95      	MOVWF FCD_0c851__00062_1_FCR_RETVAL, 1


	return (FCR_RETVAL);
144E  5195      	MOVF FCD_0c851__00062_1_FCR_RETVAL, W, 1
1450  6F96      	MOVWF CompTempVarRet2641, 1


	//Définitions des variables locales
	#undef FCLsz_CMDSTR
}
1452  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Convertir un tableau de donn??e en cha??ne de caract??res
       :
       :Param??tres pour la macro CONVERT_TABLE_STRING :
       :  var_table[255] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCM_CONVERT_TABLE_STRING(MX_CHAR *PFCL_VAR_TABLE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_VAR_ASCII_RETURN;
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_VAR_TABLE 255
	MX_CHAR FCL_VAR_TABLE[FCLsz_VAR_TABLE];
	FCI_CONCATENATE(PFCL_VAR_TABLE,FCLsz_VAR_TABLE,"",0,FCL_VAR_TABLE,FCLsz_VAR_TABLE);
	// Calcul
	// Calcul:

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_VAR_TABLE
}

/*=----------------------------------------------------------------------=*\
   Use :Initialisation de tout les modules tel que le Bluetooth ou encore de LCD etc...
\*=----------------------------------------------------------------------=*/
void FCM_INITIALISATION()

{

	//Commentaire:
	//BT4

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::Initialise()
	FCD_0c851_Bluetooth2__Initialise();
15E6  EC95F009  	CALL FCD_0c851__00062


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Start()
	FCD_0ad31_lcd_eb005__Start();
15EA  EC58F00A  	CALL FCD_04071__00063


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Initialisation...")
	FCD_0ad31_lcd_eb005__PrintString("Initialisation...", 18);
15EE  0E2E      	MOVLW 0x2E
15F0  0100      	MOVLB 0x00
15F2  6F9E      	MOVWF CompTempVar2637+D'14', 1
15F4  6F9F      	MOVWF CompTempVar2637+D'15', 1
15F6  6FA0      	MOVWF CompTempVar2637+D'16', 1
15F8  0E49      	MOVLW 0x49
15FA  6F90      	MOVWF CompTempVar2637, 1
15FC  0E61      	MOVLW 0x61
15FE  6F95      	MOVWF CompTempVar2637+D'5', 1
1600  6F99      	MOVWF CompTempVar2637+D'9', 1
1602  0E69      	MOVLW 0x69
1604  6F92      	MOVWF CompTempVar2637+D'2', 1
1606  6F94      	MOVWF CompTempVar2637+D'4', 1
1608  6F97      	MOVWF CompTempVar2637+D'7', 1
160A  6F9B      	MOVWF CompTempVar2637+D'11', 1
160C  0E6C      	MOVLW 0x6C
160E  6F96      	MOVWF CompTempVar2637+D'6', 1
1610  0E6E      	MOVLW 0x6E
1612  6F91      	MOVWF CompTempVar2637+D'1', 1
1614  6F9D      	MOVWF CompTempVar2637+D'13', 1
1616  0E6F      	MOVLW 0x6F
1618  6F9C      	MOVWF CompTempVar2637+D'12', 1
161A  0E73      	MOVLW 0x73
161C  6F98      	MOVWF CompTempVar2637+D'8', 1
161E  0E74      	MOVLW 0x74
1620  6F93      	MOVWF CompTempVar2637+D'3', 1
1622  6F9A      	MOVWF CompTempVar2637+D'10', 1
1624  6BA1      	CLRF CompTempVar2637+D'17', 1
1626  0E00      	MOVLW HIGH(CompTempVar2637+D'0')
1628  6F8F      	MOVWF FCD_04071__00064_arg_FCL_TEXT+D'1', 1
162A  0E90      	MOVLW LOW(CompTempVar2637+D'0')
162C  6F8E      	MOVWF FCD_04071__00064_arg_FCL_TEXT, 1
162E  0E12      	MOVLW 0x12
1630  6FA2      	MOVWF FCD_04071__00064_arg_FCLsz_TEXT, 1
1632  6BA3      	CLRF FCD_04071__00064_arg_FCLsz_TEXT+D'1', 1
1634  EC50F008  	CALL FCD_04071__00064


	// Pause
	// Pause: 1 s
	FCI_DELAYBYTE_S(1);
1638  0E01      	MOVLW 0x01
163A  6F85      	MOVWF delay_s_00000_arg_del, 1
163C  EC33F000  	CALL delay_s_00000


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendScript(1)
	FCD_0c851_Bluetooth2__SendScript(1);
1640  0E01      	MOVLW 0x01
1642  6F81      	MOVWF FCD_0c851__00065_arg_FCL_IDX, 1
1644  ECA6F008  	CALL FCD_0c851__00065


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendScript(2)
	FCD_0c851_Bluetooth2__SendScript(2);
1648  0E02      	MOVLW 0x02
164A  6F81      	MOVWF FCD_0c851__00065_arg_FCL_IDX, 1
164C  ECA6F008  	CALL FCD_0c851__00065


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Cursor(0, 1)
	FCD_0ad31_lcd_eb005__Cursor(0, 1);
1650  6B82      	CLRF FCD_04071__00067_arg_FCL_X, 1
1652  0E01      	MOVLW 0x01
1654  6F83      	MOVWF FCD_04071__00067_arg_FCL_Y, 1
1656  EC46F00A  	CALL FCD_04071__00067


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Player (1)")
	FCD_0ad31_lcd_eb005__PrintString("Player (1)", 11);
165A  0E50      	MOVLW 0x50
165C  0100      	MOVLB 0x00
165E  6F90      	MOVWF CompTempVar2639, 1
1660  0E6C      	MOVLW 0x6C
1662  6F91      	MOVWF CompTempVar2639+D'1', 1
1664  0E61      	MOVLW 0x61
1666  6F92      	MOVWF CompTempVar2639+D'2', 1
1668  0E79      	MOVLW 0x79
166A  6F93      	MOVWF CompTempVar2639+D'3', 1
166C  0E65      	MOVLW 0x65
166E  6F94      	MOVWF CompTempVar2639+D'4', 1
1670  0E72      	MOVLW 0x72
1672  6F95      	MOVWF CompTempVar2639+D'5', 1
1674  0E20      	MOVLW 0x20
1676  6F96      	MOVWF CompTempVar2639+D'6', 1
1678  0E28      	MOVLW 0x28
167A  6F97      	MOVWF CompTempVar2639+D'7', 1
167C  0E31      	MOVLW 0x31
167E  6F98      	MOVWF CompTempVar2639+D'8', 1
1680  0E29      	MOVLW 0x29
1682  6F99      	MOVWF CompTempVar2639+D'9', 1
1684  6B9A      	CLRF CompTempVar2639+D'10', 1
1686  0E00      	MOVLW HIGH(CompTempVar2639+D'0')
1688  6F8F      	MOVWF FCD_04071__00064_arg_FCL_TEXT+D'1', 1
168A  0E90      	MOVLW LOW(CompTempVar2639+D'0')
168C  6F8E      	MOVWF FCD_04071__00064_arg_FCL_TEXT, 1
168E  0E0B      	MOVLW 0x0B
1690  6FA2      	MOVWF FCD_04071__00064_arg_FCLsz_TEXT, 1
1692  6BA3      	CLRF FCD_04071__00064_arg_FCLsz_TEXT+D'1', 1
1694  EC50F008  	CALL FCD_04071__00064


	// Reception Bluetooth
	// Interruption: Activer RXINT0
	st_bit(intcon, GIE);
1698  8EF2      	BSF gbl_intcon,7

	st_bit(intcon, PEIE);
169A  8CF2      	BSF gbl_intcon,6

	st_bit(pie1, RCIE);
169C  8A9D      	BSF gbl_pie1,5


}
169E  EFD7F00C  	GOTO	label239


/*=----------------------------------------------------------------------=*\
   Use :V??rification de la connexion entre les deux modules bluetooth
\*=----------------------------------------------------------------------=*/
void FCM_BT_CHECK_CONNECTON()
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_BT_DATA_RECEIVER()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Convertir une valeur binaire en caract??re ascii
       :
       :Param??tres pour la macro CONVERT_BINARY_ASCII :
       :  var_binary[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCM_CONVERT_BINARY_ASCII(MX_CHAR *PFCL_VAR_BINARY)
{
	//Définitions des variables locales
	MX_UINT8 FCL_VAR_ASCII_RETURN;
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_VAR_BINARY 20
	MX_CHAR FCL_VAR_BINARY[FCLsz_VAR_BINARY];
	FCI_CONCATENATE(PFCL_VAR_BINARY,FCLsz_VAR_BINARY,"",0,FCL_VAR_BINARY,FCLsz_VAR_BINARY);
	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_VAR_BINARY
}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_SET_ASCII_CHARATERS()
{

	//Commentaire:
	//a => "numero_case + type_de_bateau"
	//b => "variable_a_changer + valeur_(ou_calcul)"

	#if 0 // Disabled code
	// Calcul
	// Calcul:
	//  // numbers
	//  ascii[48] = '0'
	//  ascii[49] = '1'
	//  ascii[50] = '2'
	//  ascii[51] = '3'
	//  ascii[52] = '4'
	//  ascii[53] = '5'
	//  ascii[54] = '6'
	//  ascii[55] = '7'
	//  ascii[56] = '8'
	//  ascii[57] = '9'
	//  ascii[58] = '10'
	//  // letters
	//  ascii[97] = 'a'
	//  ascii[98] = 'b'
	//  ascii[99] = 'c'
	//  ascii[100] = 'd'
	//  ascii[101] = 'e'
	//  ascii[102] = 'f'
	//  // symbols
	//  ascii[43] = '+'
	FCV_ASCII[48] = '0';
	FCV_ASCII[49] = '1';
	FCV_ASCII[50] = '2';
	FCV_ASCII[51] = '3';
	FCV_ASCII[52] = '4';
	FCV_ASCII[53] = '5';
	FCV_ASCII[54] = '6';
	FCV_ASCII[55] = '7';
	FCV_ASCII[56] = '8';
	FCV_ASCII[57] = '9';
	FCV_ASCII[58] = '10';
	FCV_ASCII[97] = 'a';
	FCV_ASCII[98] = 'b';
	FCV_ASCII[99] = 'c';
	FCV_ASCII[100] = 'd';
	FCV_ASCII[101] = 'e';
	FCV_ASCII[102] = 'f';
	FCV_ASCII[43] = '+';

	#endif // #if 0: Disabled code
}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_CHECK_BT_GETTING()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Connection des deux modules entre eux
\*=----------------------------------------------------------------------=*/
void FCM_BT_CONNECTION()

{

	// Boucle
	// Boucle: While bt_state == BT_COMMAND_OK
	while (!(FCV_BT_STATE == FCV_BT_COMMAND_OK))
16A2            label225
16A2  0100      	MOVLB 0x00
16A4  6B81      	CLRF CompTempVar2676, 1
16A6  2B81      	INCF CompTempVar2676, F, 1
16A8  6674      	TSTFSZ gbl_FCV_BT_STATE
16AA  9181      	BCF CompTempVar2676,0, 1
16AC  6781      	TSTFSZ CompTempVar2676, 1
16AE  D06C      	BRA	label226
1786  D78D      	BRA	label225
1788            label226

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();
16B0  EC3BF008  	CALL FCD_04071__00071


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString("Connection...")
		FCD_0ad31_lcd_eb005__PrintString("Connection...", 14);
16B4  0E2E      	MOVLW 0x2E
16B6  0100      	MOVLB 0x00
16B8  6F9A      	MOVWF CompTempVar2677+D'10', 1
16BA  6F9B      	MOVWF CompTempVar2677+D'11', 1
16BC  6F9C      	MOVWF CompTempVar2677+D'12', 1
16BE  0E43      	MOVLW 0x43
16C0  6F90      	MOVWF CompTempVar2677, 1
16C2  0E63      	MOVLW 0x63
16C4  6F95      	MOVWF CompTempVar2677+D'5', 1
16C6  0E65      	MOVLW 0x65
16C8  6F94      	MOVWF CompTempVar2677+D'4', 1
16CA  0E69      	MOVLW 0x69
16CC  6F97      	MOVWF CompTempVar2677+D'7', 1
16CE  0E6E      	MOVLW 0x6E
16D0  6F92      	MOVWF CompTempVar2677+D'2', 1
16D2  6F93      	MOVWF CompTempVar2677+D'3', 1
16D4  6F99      	MOVWF CompTempVar2677+D'9', 1
16D6  0E6F      	MOVLW 0x6F
16D8  6F91      	MOVWF CompTempVar2677+D'1', 1
16DA  6F98      	MOVWF CompTempVar2677+D'8', 1
16DC  0E74      	MOVLW 0x74
16DE  6F96      	MOVWF CompTempVar2677+D'6', 1
16E0  6B9D      	CLRF CompTempVar2677+D'13', 1
16E2  0E00      	MOVLW HIGH(CompTempVar2677+D'0')
16E4  6F8F      	MOVWF FCD_04071__00064_arg_FCL_TEXT+D'1', 1
16E6  0E90      	MOVLW LOW(CompTempVar2677+D'0')
16E8  6F8E      	MOVWF FCD_04071__00064_arg_FCL_TEXT, 1
16EA  0E0E      	MOVLW 0x0E
16EC  6FA2      	MOVWF FCD_04071__00064_arg_FCLsz_TEXT, 1
16EE  6BA3      	CLRF FCD_04071__00064_arg_FCLsz_TEXT+D'1', 1
16F0  EC50F008  	CALL FCD_04071__00064


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Cursor(0, 1)
		FCD_0ad31_lcd_eb005__Cursor(0, 1);
16F4  6B82      	CLRF FCD_04071__00067_arg_FCL_X, 1
16F6  0E01      	MOVLW 0x01
16F8  6F83      	MOVWF FCD_04071__00067_arg_FCL_Y, 1
16FA  EC46F00A  	CALL FCD_04071__00067


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString("Please wait...")
		FCD_0ad31_lcd_eb005__PrintString("Please wait...", 15);
16FE  0E20      	MOVLW 0x20
1700  0100      	MOVLB 0x00
1702  6F96      	MOVWF CompTempVar2679+D'6', 1
1704  0E2E      	MOVLW 0x2E
1706  6F9B      	MOVWF CompTempVar2679+D'11', 1
1708  6F9C      	MOVWF CompTempVar2679+D'12', 1
170A  6F9D      	MOVWF CompTempVar2679+D'13', 1
170C  0E50      	MOVLW 0x50
170E  6F90      	MOVWF CompTempVar2679, 1
1710  0E61      	MOVLW 0x61
1712  6F93      	MOVWF CompTempVar2679+D'3', 1
1714  6F98      	MOVWF CompTempVar2679+D'8', 1
1716  0E65      	MOVLW 0x65
1718  6F92      	MOVWF CompTempVar2679+D'2', 1
171A  6F95      	MOVWF CompTempVar2679+D'5', 1
171C  0E69      	MOVLW 0x69
171E  6F99      	MOVWF CompTempVar2679+D'9', 1
1720  0E6C      	MOVLW 0x6C
1722  6F91      	MOVWF CompTempVar2679+D'1', 1
1724  0E73      	MOVLW 0x73
1726  6F94      	MOVWF CompTempVar2679+D'4', 1
1728  0E74      	MOVLW 0x74
172A  6F9A      	MOVWF CompTempVar2679+D'10', 1
172C  0E77      	MOVLW 0x77
172E  6F97      	MOVWF CompTempVar2679+D'7', 1
1730  6B9E      	CLRF CompTempVar2679+D'14', 1
1732  0E00      	MOVLW HIGH(CompTempVar2679+D'0')
1734  6F8F      	MOVWF FCD_04071__00064_arg_FCL_TEXT+D'1', 1
1736  0E90      	MOVLW LOW(CompTempVar2679+D'0')
1738  6F8E      	MOVWF FCD_04071__00064_arg_FCL_TEXT, 1
173A  0E0F      	MOVLW 0x0F
173C  6FA2      	MOVWF FCD_04071__00064_arg_FCLsz_TEXT, 1
173E  6BA3      	CLRF FCD_04071__00064_arg_FCLsz_TEXT+D'1', 1
1740  EC50F008  	CALL FCD_04071__00064


		//Commentaire:
		//On attend la connexion du joueur 2

		// Appel de la Routine Composant
		// Appel de la Routine Composant: command_return=Bluetooth2::SendCommand("ATA", 1)
		FCV_COMMAND_RETURN = FCD_0c851_Bluetooth2__SendCommand("ATA", 4, 1);
1744  0E41      	MOVLW 0x41
1746  6F82      	MOVWF CompTempVar2681, 1
1748  6F84      	MOVWF CompTempVar2681+D'2', 1
174A  0E54      	MOVLW 0x54
174C  6F83      	MOVWF CompTempVar2681+D'1', 1
174E  6B85      	CLRF CompTempVar2681+D'3', 1
1750  0E00      	MOVLW HIGH(CompTempVar2681+D'0')
1752  6FB5      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND+D'1', 1
1754  0E82      	MOVLW LOW(CompTempVar2681+D'0')
1756  6FB4      	MOVWF FCD_0c851__00072_arg_FCL_COMMAND, 1
1758  0E04      	MOVLW 0x04
175A  6FB6      	MOVWF FCD_0c851__00072_arg_FCLsz_00073, 1
175C  6BB7      	CLRF FCD_0c851__00072_arg_FCLsz_00073+D'1', 1
175E  0E01      	MOVLW 0x01
1760  6FB8      	MOVWF FCD_0c851__00072_arg_FCL_SENDCR, 1
1762  ECB8F004  	CALL FCD_0c851__00072
1766  51BC      	MOVF CompTempVarRet2687, W, 1
1768  6E73      	MOVWF gbl_FCV_COMMAND_RETURN


		// Pause
		// Pause: 5 s
		FCI_DELAYBYTE_S(5);
176A  0E05      	MOVLW 0x05
176C  6F85      	MOVWF delay_s_00000_arg_del, 1
176E  EC33F000  	CALL delay_s_00000


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();
1772  EC3BF008  	CALL FCD_04071__00071


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintNumber(command_return)
		FCD_0ad31_lcd_eb005__PrintNumber(FCV_COMMAND_RETURN);
1776  5073      	MOVF gbl_FCV_COMMAND_RETURN, W
1778  0100      	MOVLB 0x00
177A  6F82      	MOVWF FCD_04071__00074_arg_FCL_NUMBER, 1
177C  6B83      	CLRF FCD_04071__00074_arg_FCL_NUMBER+D'1', 1
177E  EC2AF00A  	CALL FCD_04071__00074


		// Calcul
		// Calcul:
		//  bt_state = command_return
		FCV_BT_STATE = FCV_COMMAND_RETURN;
1782  5073      	MOVF gbl_FCV_COMMAND_RETURN, W
1784  6E74      	MOVWF gbl_FCV_BT_STATE



	}

	// Pause
	// Pause: 500 ms
	FCI_DELAYINT_MS(500);
1788  0EF4      	MOVLW 0xF4
178A  6F82      	MOVWF FCI_DELAYI_00049_arg_Delay, 1
178C  0E01      	MOVLW 0x01
178E  6F83      	MOVWF FCI_DELAYI_00049_arg_Delay+D'1', 1
1790  EC88F008  	CALL FCI_DELAYI_00049


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Clear()
	FCD_0ad31_lcd_eb005__Clear();
1794  EC3BF008  	CALL FCD_04071__00071


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Connected to")
	FCD_0ad31_lcd_eb005__PrintString("Connected to", 13);
1798  0E20      	MOVLW 0x20
179A  0100      	MOVLB 0x00
179C  6F99      	MOVWF CompTempVar2683+D'9', 1
179E  0E43      	MOVLW 0x43
17A0  6F90      	MOVWF CompTempVar2683, 1
17A2  0E63      	MOVLW 0x63
17A4  6F95      	MOVWF CompTempVar2683+D'5', 1
17A6  0E64      	MOVLW 0x64
17A8  6F98      	MOVWF CompTempVar2683+D'8', 1
17AA  0E65      	MOVLW 0x65
17AC  6F94      	MOVWF CompTempVar2683+D'4', 1
17AE  6F97      	MOVWF CompTempVar2683+D'7', 1
17B0  0E6E      	MOVLW 0x6E
17B2  6F92      	MOVWF CompTempVar2683+D'2', 1
17B4  6F93      	MOVWF CompTempVar2683+D'3', 1
17B6  0E6F      	MOVLW 0x6F
17B8  6F91      	MOVWF CompTempVar2683+D'1', 1
17BA  6F9B      	MOVWF CompTempVar2683+D'11', 1
17BC  0E74      	MOVLW 0x74
17BE  6F96      	MOVWF CompTempVar2683+D'6', 1
17C0  6F9A      	MOVWF CompTempVar2683+D'10', 1
17C2  6B9C      	CLRF CompTempVar2683+D'12', 1
17C4  0E00      	MOVLW HIGH(CompTempVar2683+D'0')
17C6  6F8F      	MOVWF FCD_04071__00064_arg_FCL_TEXT+D'1', 1
17C8  0E90      	MOVLW LOW(CompTempVar2683+D'0')
17CA  6F8E      	MOVWF FCD_04071__00064_arg_FCL_TEXT, 1
17CC  0E0D      	MOVLW 0x0D
17CE  6FA2      	MOVWF FCD_04071__00064_arg_FCLsz_TEXT, 1
17D0  6BA3      	CLRF FCD_04071__00064_arg_FCLsz_TEXT+D'1', 1
17D2  EC50F008  	CALL FCD_04071__00064


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Cursor(0, 1)
	FCD_0ad31_lcd_eb005__Cursor(0, 1);
17D6  6B82      	CLRF FCD_04071__00067_arg_FCL_X, 1
17D8  0E01      	MOVLW 0x01
17DA  6F83      	MOVWF FCD_04071__00067_arg_FCL_Y, 1
17DC  EC46F00A  	CALL FCD_04071__00067


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("player (2)")
	FCD_0ad31_lcd_eb005__PrintString("player (2)", 11);
17E0  0E70      	MOVLW 0x70
17E2  0100      	MOVLB 0x00
17E4  6F82      	MOVWF CompTempVar2685, 1
17E6  0E6C      	MOVLW 0x6C
17E8  6F83      	MOVWF CompTempVar2685+D'1', 1
17EA  0E61      	MOVLW 0x61
17EC  6F84      	MOVWF CompTempVar2685+D'2', 1
17EE  0E79      	MOVLW 0x79
17F0  6F85      	MOVWF CompTempVar2685+D'3', 1
17F2  0E65      	MOVLW 0x65
17F4  6F86      	MOVWF CompTempVar2685+D'4', 1
17F6  0E72      	MOVLW 0x72
17F8  6F87      	MOVWF CompTempVar2685+D'5', 1
17FA  0E20      	MOVLW 0x20
17FC  6F88      	MOVWF CompTempVar2685+D'6', 1
17FE  0E28      	MOVLW 0x28
1800  6F89      	MOVWF CompTempVar2685+D'7', 1
1802  0E32      	MOVLW 0x32
1804  6F8A      	MOVWF CompTempVar2685+D'8', 1
1806  0E29      	MOVLW 0x29
1808  6F8B      	MOVWF CompTempVar2685+D'9', 1
180A  6B8C      	CLRF CompTempVar2685+D'10', 1
180C  0E00      	MOVLW HIGH(CompTempVar2685+D'0')
180E  6F8F      	MOVWF FCD_04071__00064_arg_FCL_TEXT+D'1', 1
1810  0E82      	MOVLW LOW(CompTempVar2685+D'0')
1812  6F8E      	MOVWF FCD_04071__00064_arg_FCL_TEXT, 1
1814  0E0B      	MOVLW 0x0B
1816  6FA2      	MOVWF FCD_04071__00064_arg_FCLsz_TEXT, 1
1818  6BA3      	CLRF FCD_04071__00064_arg_FCLsz_TEXT+D'1', 1
181A  EC50F008  	CALL FCD_04071__00064


	// Pause
	// Pause: 1 s
	FCI_DELAYBYTE_S(1);
181E  0E01      	MOVLW 0x01
1820  6F85      	MOVWF delay_s_00000_arg_del, 1
1822  EC33F000  	CALL delay_s_00000


	#if 0 // Disabled code
	//Commentaire:
	//DEBUG

	#endif // #if 0: Disabled code
	#if 0 // Disabled code
	// Boucle
	// Boucle: While 1
	while (1)
	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: command_return=Bluetooth2::ReceiveByte(0)
		FCV_COMMAND_RETURN = FCD_0c851_Bluetooth2__ReceiveByte(0);

		// Calcul
		// Calcul:


	}

	#endif // #if 0: Disabled code
}
1826  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Reception des donn??es dans une interruption
\*=----------------------------------------------------------------------=*/
void FCM_INTER_RECEIVE()

{

	// Calcul
	// Calcul:
	//  return = ""
	FCI_SCOPY("",1, FCV_RETURN,FCVsz_RETURN);
059A  0100      	MOVLB 0x00
059C  6BD8      	CLRF CompTempVar2694, 1
059E  0E00      	MOVLW HIGH(CompTempVar2694+D'0')
05A0  6FEA      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1', 1
05A2  0ED8      	MOVLW LOW(CompTempVar2694+D'0')
05A4  6FE9      	MOVWF FCI_SCOPY_00000_arg_sSrc, 1
05A6  0E01      	MOVLW 0x01
05A8  6FEB      	MOVWF FCI_SCOPY_00000_arg_iSrc_len, 1
05AA  0E00      	MOVLW HIGH(gbl_FCV_RETURN+D'0')
05AC  6FED      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1', 1
05AE  0E37      	MOVLW LOW(gbl_FCV_RETURN+D'0')
05B0  6FEC      	MOVWF FCI_SCOPY_00000_arg_sDst, 1
05B2  0E14      	MOVLW 0x14
05B4  6FEE      	MOVWF FCI_SCOPY_00000_arg_iDst_len, 1
05B6  EC6BF001  	CALL FCI_SCOPY_00000


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
05BA  0E00      	MOVLW 0x00
05BC  EF39F001  	GOTO	FCD_0f051__00076
05C0            label82


	// Appel de la Routine Composant
	// Appel de la Routine Composant: octet=Bluetooth2::ReceiveByte(1)
	FCV_OCTET = FCD_0c851_Bluetooth2__ReceiveByte(1);
05C0  0E01      	MOVLW 0x01
05C2  6FD8      	MOVWF FCD_0c851__00077_arg_FCL_TIMEOUT, 1
05C4  0E99      	MOVLW 0x99
05C6  EF57F002  	GOTO	FCD_0c851__00077
05CA            label83
05CA  51DB      	MOVF CompTempVarRet2701, W, 1
05CC  6E72      	MOVWF gbl_FCV_OCTET


	// Appel de la Routine Composant
	// Appel de la Routine Composant: return=Bluetooth2::ReadString(octet)
	FCD_0c851_Bluetooth2__ReadString(FCV_RETURN,20, FCV_OCTET);
05CE  0E00      	MOVLW HIGH(gbl_FCV_RETURN+D'0')
05D0  6FD9      	MOVWF FCD_0c851__00078_arg_FCR_RETVAL+D'1', 1
05D2  0E37      	MOVLW LOW(gbl_FCV_RETURN+D'0')
05D4  6FD8      	MOVWF FCD_0c851__00078_arg_FCR_RETVAL, 1
05D6  0E14      	MOVLW 0x14
05D8  6FDA      	MOVWF FCD_0c851__00078_arg_FCRsz_00079, 1
05DA  6BDB      	CLRF FCD_0c851__00078_arg_FCRsz_00079+D'1', 1
05DC  5072      	MOVF gbl_FCV_OCTET, W
05DE  6FDC      	MOVWF FCD_0c851__00078_arg_FCL_N_0007A, 1
05E0  EC2DF002  	CALL FCD_0c851__00078


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print(return, 50, 100, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print(FCV_RETURN, FCVsz_RETURN, 50, 100, 2, 1);
05E4  0E00      	MOVLW HIGH(gbl_FCV_RETURN+D'0')
05E6  6FD9      	MOVWF FCD_0f051__0007B_arg_FCL_STR+D'1', 1
05E8  0E37      	MOVLW LOW(gbl_FCV_RETURN+D'0')
05EA  6FD8      	MOVWF FCD_0f051__0007B_arg_FCL_STR, 1
05EC  0E14      	MOVLW 0x14
05EE  6FDA      	MOVWF FCD_0f051__0007B_arg_FCLsz_STR, 1
05F0  6BDB      	CLRF FCD_0f051__0007B_arg_FCLsz_STR+D'1', 1
05F2  0E32      	MOVLW 0x32
05F4  6FDC      	MOVWF FCD_0f051__0007B_arg_FCL_X1, 1
05F6  6BDD      	CLRF FCD_0f051__0007B_arg_FCL_X1+D'1', 1
05F8  0E64      	MOVLW 0x64
05FA  6FDE      	MOVWF FCD_0f051__0007B_arg_FCL_Y1, 1
05FC  6BDF      	CLRF FCD_0f051__0007B_arg_FCL_Y1+D'1', 1
05FE  0E02      	MOVLW 0x02
0600  6FE0      	MOVWF FCD_0f051__0007B_arg_FCL_FONT, 1
0602  0E01      	MOVLW 0x01
0604  6FE1      	MOVWF FCD_0f051__0007B_arg_FCL_T_0007C, 1
0606  0E99      	MOVLW 0x99
0608  EFA7F001  	GOTO	FCD_0f051__0007B
060C            label84


	#if 0 // Disabled code
	// Pause
	// Pause: 5 s
	FCI_DELAYBYTE_S(5);

	#endif // #if 0: Disabled code
}
060C  EF29F00D  	GOTO	label242




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
19A0  0E0F      	MOVLW 0x0F
19A2  6EC1      	MOVWF gbl_adcon1





	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
19A4  EC14F00C  	CALL FCD_0f051__000BB


	// Appel d'une Macro
	// Appel d'une Macro: INITIALISATION()
	FCM_INITIALISATION();
19A8  0E99      	MOVLW 0x99
19AA  EFF3F00A  	GOTO	FCM_INITIA_00061
19AE            label239


	// Appel d'une Macro
	// Appel d'une Macro: BT_CONNECTION()
	FCM_BT_CONNECTION();
19AE  EC51F00B  	CALL FCM_BT_CON_00070


	mainendloop: goto mainendloop;
19B2            label240
19B2  D7FF      	BRA	label240

}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

	//Handler code for [RXINT0]
	#ifndef MX_INTHANDLER_pir1_RCIF
	#define MX_INTHANDLER_pir1_RCIF
	if (ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE))
1A34  CFEAF001  	MOVFF FSR0H,  Int1Context
1A38  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1A3C  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
1A40  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
1A44  AA9E      	BTFSS gbl_pir1,5
1A46  D006      	BRA	label243
1A48  AA9D      	BTFSS gbl_pie1,5
1A4A  D004      	BRA	label243
1A54            label243

	{
		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 1;
		#endif
		FCM_INTER_RECEIVE();
1A4C  0E99      	MOVLW 0x99
1A4E  EFCDF002  	GOTO	FCM_INTER__00075
1A52            label242

		cr_bit(pir1, RCIF);
1A52  9A9E      	BCF gbl_pir1,5

		#ifdef USE_FLOWCODE_ICD
			extern char ICD_Interrupt_Enable = 0;
		#endif	
	}
	#else
	#warning "This interrupt has previously been enabled, so the macro <INTER_RECEIVE> may never get called."
	#endif

	MX_UART_INT_CH1_FUNC

	MX_UINT8 FCL_BT_IN;

	FCL_BT_IN = MX_UART_INT_CH1_DET;
1A54  0E20      	MOVLW 0x20
1A56  149E      	ANDWF gbl_pir1, W
1A58  0100      	MOVLB 0x00
1A5A  6FD9      	MOVWF CompTempVar3114, 1
1A5C  0E20      	MOVLW 0x20
1A5E  149D      	ANDWF gbl_pie1, W
1A60  6FD8      	MOVWF CompTempVar3113, 1
1A62  6BD7      	CLRF interrupt_1_FCL_BT_IN, 1
1A64  53D8      	MOVF CompTempVar3113, F, 1
1A66  A4D8      	BTFSS STATUS,Z
1A68  53D9      	MOVF CompTempVar3114, F, 1
1A6A  A4D8      	BTFSS STATUS,Z
1A6C  2BD7      	INCF interrupt_1_FCL_BT_IN, F, 1


	if (FCL_BT_IN)
1A6E  53D7      	MOVF interrupt_1_FCL_BT_IN, F, 1
1A70  E022      	BZ	label246
1AB6            label246

	{

	FCL_BT_IN = FC_CAL_UART_Receive_1(1);
1A72  0E01      	MOVLW 0x01
1A74  6FD8      	MOVWF FC_CAL_UAR_000CA_arg_nTimeout, 1
1A76  EC7EF002  	CALL FC_CAL_UAR_000CA
1A7A  51E1      	MOVF CompTempVarRet3081, W, 1
1A7C  6FD7      	MOVWF interrupt_1_FCL_BT_IN, 1


	if (FCV_0c851_Bluetooth2__RX_DONE == 0)
1A7E  527F      	MOVF gbl_FCV_0c851_Bluetooth2___00011, F
1A80  E119      	BNZ	label245

	{

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 50)
1A82  0E32      	MOVLW 0x32
1A84  6180      	CPFSLT gbl_FCV_0c851_Bluetooth2___00012, 1
1A86  D016      	BRA	label245

		{

			if (FCL_BT_IN == 0x0A)
1A88  0E0A      	MOVLW 0x0A
1A8A  63D7      	CPFSEQ interrupt_1_FCL_BT_IN, 1
1A8C  D00A      	BRA	label244
1AA2            label244

			{

				FCV_0c851_Bluetooth2__RX_DONE = 1;
1A8E  0E01      	MOVLW 0x01
1A90  6E7F      	MOVWF gbl_FCV_0c851_Bluetooth2___00011

				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = 0;
1A92  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00010
1A96  50E9      	MOVF FSR0L, W
1A98  5180      	MOVF gbl_FCV_0c851_Bluetooth2___00012, W, 1
1A9A  26E9      	ADDWF FSR0L, F
1A9C  0E00      	MOVLW 0x00
1A9E  6EEF      	MOVWF INDF0


			} else {
1AA0  D009      	BRA	label245
1AB4            label245


				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = FCL_BT_IN;
1AA2  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00010
1AA6  50E9      	MOVF FSR0L, W
1AA8  5180      	MOVF gbl_FCV_0c851_Bluetooth2___00012, W, 1
1AAA  26E9      	ADDWF FSR0L, F
1AAC  51D7      	MOVF interrupt_1_FCL_BT_IN, W, 1
1AAE  6EEF      	MOVWF INDF0

				FCV_0c851_Bluetooth2__RX_LENGTH = FCV_0c851_Bluetooth2__RX_LENGTH + 1;
1AB0  2980      	INCF gbl_FCV_0c851_Bluetooth2___00012, W, 1
1AB2  6F80      	MOVWF gbl_FCV_0c851_Bluetooth2___00012, 1


			}

		// } else {

		}

	// } else {

	}

	MX_UART_INT_CH1_CLR;
1AB4  9A9E      	BCF gbl_pir1,5


	}

	MX_UART_INT_FUNC_END
}
1AB6  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
1ABA  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
1ABE  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
1AC2  C001FFEA  	MOVFF Int1Context,  FSR0H
1AC6  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
10D8  8496      	BSF gbl_trise,2

		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
10DA  9296      	BCF gbl_trise,1
10DC  8284      	BSF gbl_porte,1

	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
0CB2  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
0CB4  0E7F      	MOVLW 0x7F
0CB6  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0CB8  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0CBA  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
0CBC  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
0CBE  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
0CC0  8A9D      	BSF gbl_pie1,5

				st_bit(intcon, PEIE);
0CC2  8CF2      	BSF gbl_intcon,6

				st_bit(intcon, GIE);
0CC4  8EF2      	BSF gbl_intcon,7

			#else
				cr_bit (pie1, RCIE);
			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0CC6  0012      	RETURN
10DE  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
00E6  6FFA      	MOVWF FC_CAL_UAR_00082_1___retpointvar, 1
00E8  9284      	BCF gbl_porte,1

		UART_Delay_CAL();
00EA  0E08      	MOVLW 0x08
00EC  EF48F000  	GOTO	FC_CAL_UAR_00081
00F0            label10

		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
00F0  0100      	MOVLB 0x00
00F2  6BF9      	CLRF FC_CAL_UAR_00082_1_idx, 1
00F4            label11
00F4  0E08      	MOVLW 0x08
00F6  61F9      	CPFSLT FC_CAL_UAR_00082_1_idx, 1
00F8  D010      	BRA	label15
0116  2BF9      	INCF FC_CAL_UAR_00082_1_idx, F, 1
0118  D7ED      	BRA	label11
011A            label15

		{
			if (nChar & 0x01)														// Mask off data bit
00FA  A1F7      	BTFSS FC_CAL_UAR_00082_arg_nChar,0, 1
00FC  D002      	BRA	label12
0102            label12

				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
00FE  8284      	BSF gbl_porte,1

			else
0100  D001      	BRA	label13
0104            label13

				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
0102  9284      	BCF gbl_porte,1

			UART_Delay_CAL();
0104  0E0C      	MOVLW 0x0C
0106  EF48F000  	GOTO	FC_CAL_UAR_00081
010A            label14

			nChar = nChar >> 1;														// Move to next data bit
010A  0100      	MOVLB 0x00
010C  53F7      	MOVF FC_CAL_UAR_00082_arg_nChar, F, 1
010E  53F8      	MOVF FC_CAL_UAR_00082_arg_nChar+D'1', F, 1
0110  90D8      	BCF STATUS,C
0112  33F8      	RRCF FC_CAL_UAR_00082_arg_nChar+D'1', F, 1
0114  33F7      	RRCF FC_CAL_UAR_00082_arg_nChar, F, 1

		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
011A  8284      	BSF gbl_porte,1

		UART_Delay_CAL();
011C  0E10      	MOVLW 0x10
011E  EF48F000  	GOTO	FC_CAL_UAR_00081
0122            label16

	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
064C            label89
064C  0E10      	MOVLW 0x10
064E  149E      	ANDWF gbl_pir1, W
0650  6FBE      	MOVWF CompTempVar3085, 1
0652  53BE      	MOVF CompTempVar3085, F, 1
0654  E0FB      	BZ	label89


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0656  51BC      	MOVF FC_CAL_UAR_000CB_arg_nChar, W, 1
0658  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
0122  D000      	BRA	label17
0124            label17
0124  0E01      	MOVLW	HIGH( label18 )
0126  6EFA      	MOVWF PCLATH
0128  0100      	MOVLB 0x00
012A  51FA      	MOVF FC_CAL_UAR_00082_1___retpointvar, W, 1
012C  26F9      	ADDWF PCL, F
012E            label18
012E  EFAEF001  	GOTO	label46
0132  EFB5F001  	GOTO	label47
0136  EFBCF001  	GOTO	label49
013A  EFC7F001  	GOTO	label51
013E  EFCDF001  	GOTO	label52
0142  EFD4F001  	GOTO	label53
0146  EFDAF001  	GOTO	label54
014A  EFE1F001  	GOTO	label55
014E  EFE7F001  	GOTO	label56
0152  EFEDF001  	GOTO	label57
0156  EFF4F001  	GOTO	label58
015A  EFFAF001  	GOTO	label59
015E  EF00F002  	GOTO	label60
0162  EF1FF002  	GOTO	label62
0166  EF27F002  	GOTO	label64
016A  EF45F001  	GOTO	label34
016E  EF4BF001  	GOTO	label35
0172  EF52F001  	GOTO	label36
0176  EF5DF001  	GOTO	label38
017A  EF50F00C  	GOTO	label232
065A  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
017E  0101      	MOVLB 0x01
0180  6F00      	MOVWF FC_CAL_UAR_00080_1___retpointvar, 1
0182  0100      	MOVLB 0x00
0184  69F8      	SETF FC_CAL_UAR_00080_1_retVal, 1
04FC  69D9      	SETF FC_CAL_UAR_000CA_1_retVal, 1

  #endif

	MX_UINT8 delay1 = 0;
0186  6BF9      	CLRF FC_CAL_UAR_00080_1_delay1, 1
04FE  6BDA      	CLRF FC_CAL_UAR_000CA_1_delay1, 1

	MX_UINT8 regcheck = 0;
0188  6BFA      	CLRF FC_CAL_UAR_00080_1_regcheck, 1
0500  6BDB      	CLRF FC_CAL_UAR_000CA_1_regcheck, 1

	MX_UINT8 bWaitForever = 0;
018A  6BFB      	CLRF FC_CAL_UAR_00080_1_bWaitForever, 1
0502  6BDC      	CLRF FC_CAL_UAR_000CA_1_bWaitForever, 1

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
018C  6BFC      	CLRF FC_CAL_UAR_00080_1_rxStatus, 1
0504  6BDD      	CLRF FC_CAL_UAR_000CA_1_rxStatus, 1

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0506  6BE0      	CLRF FC_CAL_UAR_000CA_1_dummy, 1

  #endif

	if (nTimeout == 255)
018E  29F7      	INCF FC_CAL_UAR_00080_arg_nTimeout, W, 1
0190  E102      	BNZ	label19
0196            label19
0508  29D8      	INCF FC_CAL_UAR_000CA_arg_nTimeout, W, 1
050A  E102      	BNZ	label73
0510            label73

		bWaitForever = 1;
0192  0E01      	MOVLW 0x01
0194  6FFB      	MOVWF FC_CAL_UAR_00080_1_bWaitForever, 1
050C  0E01      	MOVLW 0x01
050E  6FDC      	MOVWF FC_CAL_UAR_000CA_1_bWaitForever, 1


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
0196  53FC      	MOVF FC_CAL_UAR_00080_1_rxStatus, F, 1
0198  E126      	BNZ	label24
01E4  D7D8      	BRA	label19
01E6            label24
0510  53DD      	MOVF FC_CAL_UAR_000CA_1_rxStatus, F, 1
0512  E124      	BNZ	label78
055A  D7DA      	BRA	label73
055C            label78

	{
		if (bWaitForever == 0)
019A  53FB      	MOVF FC_CAL_UAR_00080_1_bWaitForever, F, 1
019C  E118      	BNZ	label23
0514  53DC      	MOVF FC_CAL_UAR_000CA_1_bWaitForever, F, 1
0516  E118      	BNZ	label77

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
019E  53F7      	MOVF FC_CAL_UAR_00080_arg_nTimeout, F, 1
01A0  E103      	BNZ	label20
01A8            label20
0518  53D8      	MOVF FC_CAL_UAR_000CA_arg_nTimeout, F, 1
051A  E103      	BNZ	label74
0522            label74

			{
				rxStatus = UART_STATUS_TIMEOUT;
01A2  0E01      	MOVLW 0x01
01A4  6FFC      	MOVWF FC_CAL_UAR_00080_1_rxStatus, 1
051C  0E01      	MOVLW 0x01
051E  6FDD      	MOVWF FC_CAL_UAR_000CA_1_rxStatus, 1

			}
			else
01A6  D013      	BRA	label23
0520  D013      	BRA	label77

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
01A8  6BFD      	CLRF FC_CAL_UAR_00080_1_delaycnt, 1
01AA  6BFE      	CLRF FC_CAL_UAR_00080_1_delaycnt+D'1', 1
01AC            label21
01AC  0E31      	MOVLW 0x31
01AE  5DFD      	SUBWF FC_CAL_UAR_00080_1_delaycnt, W, 1
01B0  E205      	BC	label22
01B2  67FE      	TSTFSZ FC_CAL_UAR_00080_1_delaycnt+D'1', 1
01B4  D003      	BRA	label22
01B6  4BFD      	INFSNZ FC_CAL_UAR_00080_1_delaycnt, F, 1
01B8  2BFE      	INCF FC_CAL_UAR_00080_1_delaycnt+D'1', F, 1
01BA  D7F8      	BRA	label21
01BC            label22
0522  6BDE      	CLRF FC_CAL_UAR_000CA_1_delaycnt, 1
0524  6BDF      	CLRF FC_CAL_UAR_000CA_1_delaycnt+D'1', 1
0526            label75
0526  0E31      	MOVLW 0x31
0528  5DDE      	SUBWF FC_CAL_UAR_000CA_1_delaycnt, W, 1
052A  E205      	BC	label76
052C  67DF      	TSTFSZ FC_CAL_UAR_000CA_1_delaycnt+D'1', 1
052E  D003      	BRA	label76
0530  4BDE      	INFSNZ FC_CAL_UAR_000CA_1_delaycnt, F, 1
0532  2BDF      	INCF FC_CAL_UAR_000CA_1_delaycnt+D'1', F, 1
0534  D7F8      	BRA	label75
0536            label76

				delay1 = delay1 + 1;
01BC  29F9      	INCF FC_CAL_UAR_00080_1_delay1, W, 1
01BE  6FF9      	MOVWF FC_CAL_UAR_00080_1_delay1, 1
0536  29DA      	INCF FC_CAL_UAR_000CA_1_delay1, W, 1
0538  6FDA      	MOVWF FC_CAL_UAR_000CA_1_delay1, 1

				if(delay1 == 100)
01C0  0E64      	MOVLW 0x64
01C2  63F9      	CPFSEQ FC_CAL_UAR_00080_1_delay1, 1
01C4  D004      	BRA	label23
01CE            label23
053A  0E64      	MOVLW 0x64
053C  63DA      	CPFSEQ FC_CAL_UAR_000CA_1_delay1, 1
053E  D004      	BRA	label77
0548            label77

				{
					nTimeout = nTimeout - 1;
01C6  05F7      	DECF FC_CAL_UAR_00080_arg_nTimeout, W, 1
01C8  6FF7      	MOVWF FC_CAL_UAR_00080_arg_nTimeout, 1
0540  05D8      	DECF FC_CAL_UAR_000CA_arg_nTimeout, W, 1
0542  6FD8      	MOVWF FC_CAL_UAR_000CA_arg_nTimeout, 1

					MX_CLEAR_WATCHDOG;
01CA  0004      	CLRWDT
0544  0004      	CLRWDT

					delay1 = 0;
01CC  6BF9      	CLRF FC_CAL_UAR_00080_1_delay1, 1
0546  6BDA      	CLRF FC_CAL_UAR_000CA_1_delay1, 1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
01CE  0E04      	MOVLW 0x04
01D0  1484      	ANDWF gbl_porte, W
01D2  0101      	MOVLB 0x01
01D4  6F01      	MOVWF CompTempVar2720, 1
01D6  5101      	MOVF CompTempVar2720, W, 1
01D8  0100      	MOVLB 0x00
01DA  6FFA      	MOVWF FC_CAL_UAR_00080_1_regcheck, 1

			if (regcheck == 0)
01DC  53FA      	MOVF FC_CAL_UAR_00080_1_regcheck, F, 1
01DE  E1DB      	BNZ	label19

				rxStatus = UART_STATUS_RXBYTE;
01E0  0E02      	MOVLW 0x02
01E2  6FFC      	MOVWF FC_CAL_UAR_00080_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
0548  0E20      	MOVLW 0x20
054A  149E      	ANDWF gbl_pir1, W
054C  6FE1      	MOVWF CompTempVar3082, 1
054E  51E1      	MOVF CompTempVar3082, W, 1
0550  6FDB      	MOVWF FC_CAL_UAR_000CA_1_regcheck, 1

			if (regcheck != 0)
0552  53DB      	MOVF FC_CAL_UAR_000CA_1_regcheck, F, 1
0554  E0DD      	BZ	label73

				rxStatus = UART_STATUS_RXBYTE;
0556  0E02      	MOVLW 0x02
0558  6FDD      	MOVWF FC_CAL_UAR_000CA_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
01E6  0E02      	MOVLW 0x02
01E8  63FC      	CPFSEQ FC_CAL_UAR_00080_1_rxStatus, 1
01EA  D022      	BRA	label31
055C  0E02      	MOVLW 0x02
055E  63DD      	CPFSEQ FC_CAL_UAR_000CA_1_rxStatus, 1
0560  D018      	BRA	label81

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
01EC  6BF8      	CLRF FC_CAL_UAR_00080_1_retVal, 1

			UART_Delay_CAL();
01EE  0E00      	MOVLW 0x00
01F0  EF48F000  	GOTO	FC_CAL_UAR_00081
01F4            label25


			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
01F4  0100      	MOVLB 0x00
01F6  6BFF      	CLRF FC_CAL_UAR_00080_1_idx, 1
01F8            label26
01F8  0E08      	MOVLW 0x08
01FA  61FF      	CPFSLT FC_CAL_UAR_00080_1_idx, 1
01FC  D019      	BRA	label31
022A  0100      	MOVLB 0x00
022C  2BFF      	INCF FC_CAL_UAR_00080_1_idx, F, 1
022E  D7E4      	BRA	label26
0230            label31

			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
01FE  A484      	BTFSS gbl_porte,2
0200  D011      	BRA	label29
0224            label29

					retVal = retVal | (0x01 << idx);
0202  0E01      	MOVLW 0x01
0204  0101      	MOVLB 0x01
0206  6F01      	MOVWF CompTempVar2721, 1
0208  0100      	MOVLB 0x00
020A  51FF      	MOVF FC_CAL_UAR_00080_1_idx, W, 1
020C            label27
020C  0BFF      	ANDLW 0xFF
020E  E005      	BZ	label28
0210  90D8      	BCF STATUS,C
0212  0101      	MOVLB 0x01
0214  3701      	RLCF CompTempVar2721, F, 1
0216  0FFF      	ADDLW 0xFF
0218  D7F9      	BRA	label27
021A            label28
021A  0101      	MOVLB 0x01
021C  5101      	MOVF CompTempVar2721, W, 1
021E  0100      	MOVLB 0x00
0220  11F8      	IORWF FC_CAL_UAR_00080_1_retVal, W, 1
0222  6FF8      	MOVWF FC_CAL_UAR_00080_1_retVal, 1


				UART_Delay_CAL();
0224  0E04      	MOVLW 0x04
0226  EF48F000  	GOTO	FC_CAL_UAR_00081
022A            label30

			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0562  0E04      	MOVLW 0x04
0564  14AB      	ANDWF gbl_rcsta, W
0566  6FE1      	MOVWF CompTempVar3083, 1
0568  51E1      	MOVF CompTempVar3083, W, 1
056A  6FDB      	MOVWF FC_CAL_UAR_000CA_1_regcheck, 1

			if (regcheck != 0)
056C  53DB      	MOVF FC_CAL_UAR_000CA_1_regcheck, F, 1
056E  E003      	BZ	label79
0576            label79

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0570  50AE      	MOVF gbl_rcreg, W
0572  6FE0      	MOVWF FC_CAL_UAR_000CA_1_dummy, 1

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0574  D00E      	BRA	label81

			{
				regcheck = ts_bit(rcsta, OERR);
0576  0E02      	MOVLW 0x02
0578  14AB      	ANDWF gbl_rcsta, W
057A  6FE1      	MOVWF CompTempVar3084, 1
057C  51E1      	MOVF CompTempVar3084, W, 1
057E  6FDB      	MOVWF FC_CAL_UAR_000CA_1_regcheck, 1

				if (regcheck != 0)
0580  53DB      	MOVF FC_CAL_UAR_000CA_1_regcheck, F, 1
0582  E003      	BZ	label80
058A            label80

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0584  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0586  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0588  D004      	BRA	label81
0592            label81

				{
					retVal = 0;
058A  6BD9      	CLRF FC_CAL_UAR_000CA_1_retVal, 1


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
058C  50AE      	MOVF gbl_rcreg, W
058E  11D9      	IORWF FC_CAL_UAR_000CA_1_retVal, W, 1
0590  6FD9      	MOVWF FC_CAL_UAR_000CA_1_retVal, 1

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0230  51F8      	MOVF FC_CAL_UAR_00080_1_retVal, W, 1
0232  0101      	MOVLB 0x01
0234  6F01      	MOVWF CompTempVarRet2719, 1
0236  6B02      	CLRF CompTempVarRet2719+D'1', 1
0592  51D9      	MOVF FC_CAL_UAR_000CA_1_retVal, W, 1
0594  6FE1      	MOVWF CompTempVarRet3081, 1
0596  6BE2      	CLRF CompTempVarRet3081+D'1', 1

}
0238  D000      	BRA	label32
023A            label32
023A  0E02      	MOVLW	HIGH( label33 )
023C  6EFA      	MOVWF PCLATH
023E  5100      	MOVF FC_CAL_UAR_00080_1___retpointvar, W, 1
0240  26F9      	ADDWF PCL, F
0242            label33
0242  EFC0F001  	GOTO	label50
0246  EF2BF002  	GOTO	label65
024A  EF56F001  	GOTO	label37
024E  EF61F001  	GOTO	label39
0252  EF3FF00C  	GOTO	label229
0256  EF44F00C  	GOTO	label230
025A  EF49F00C  	GOTO	label231
025E  EF54F00C  	GOTO	label233
0262  EF5AF00C  	GOTO	label234
0266  EF60F00C  	GOTO	label235
026A  EFC9F00C  	GOTO	label237
026E  EFCFF00C  	GOTO	label238
0598  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))

{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;
0090  0101      	MOVLB 0x01
0092  6F03      	MOVWF FC_CAL_UAR_00081_1___retpointvar, 1
0094  0E5F      	MOVLW 0x5F
0096  6F01      	MOVWF FC_CAL_UAR_00081_1_delay, 1
0098  6B02      	CLRF FC_CAL_UAR_00081_1_delay+D'1', 1


	while (delay > 255)
009A            label5
009A  0EFF      	MOVLW 0xFF
009C  6501      	CPFSGT FC_CAL_UAR_00081_1_delay, 1
009E  6702      	TSTFSZ FC_CAL_UAR_00081_1_delay+D'1', 1
00A0  D001      	BRA	label6
00A2  D00D      	BRA	label7
00A4            label6
00BC  D7EE      	BRA	label5
00BE            label7

	{
		delay_us(255);
00A4  6904      	SETF delay_us_00000_arg_del, 1
00A6  EC2EF000  	CALL delay_us_00000

		delay = delay - 255;
00AA  0EFF      	MOVLW 0xFF
00AC  5D01      	SUBWF FC_CAL_UAR_00081_1_delay, W, 1
00AE  6F04      	MOVWF CompTempVar2723, 1
00B0  5901      	SUBWFB FC_CAL_UAR_00081_1_delay, W, 1
00B2  08FF      	SUBLW 0xFF
00B4  5F02      	SUBWF FC_CAL_UAR_00081_1_delay+D'1', F, 1
00B6  5104      	MOVF CompTempVar2723, W, 1
00B8  6F01      	MOVWF FC_CAL_UAR_00081_1_delay, 1

		MX_CLEAR_WATCHDOG;
00BA  0004      	CLRWDT

	}
	delay_us(delay);
00BE  5101      	MOVF FC_CAL_UAR_00081_1_delay, W, 1
00C0  6F04      	MOVWF delay_us_00000_arg_del, 1
00C2  EC2EF000  	CALL delay_us_00000

	MX_CLEAR_WATCHDOG;
00C6  0004      	CLRWDT


  #endif
}
00C8  D000      	BRA	label8
00CA            label8
00CA  0E00      	MOVLW	HIGH( label9 )
00CC  6EFA      	MOVWF PCLATH
00CE  5103      	MOVF FC_CAL_UAR_00081_1___retpointvar, W, 1
00D0  26F9      	ADDWF PCL, F
00D2            label9
00D2  EFFAF000  	GOTO	label25
00D6  EF15F001  	GOTO	label30
00DA  EF78F000  	GOTO	label10
00DE  EF85F000  	GOTO	label14
00E2  EF91F000  	GOTO	label16



CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EFDAF00C  	GOTO	_startup

0008  EF1AF00D  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  5305      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF5      	MOVLW 0xF5
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0FFF      	ADDLW 0xFF
0038  A4D8      	BTFSS STATUS,Z
003A  D7ED      	BRA	label2
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  2F05      	DECFSZ delay_ms_00000_arg_del, F, 1
0058  D7DD      	BRA	label1
005A  0012      	RETURN
005C            ; } delay_ms function end

005C            delay_us_00000
005C            ; { delay_us ; function begin
005C            label3
005C  0000      	NOP
005E  0000      	NOP
0060  2F04      	DECFSZ delay_us_00000_arg_del, F, 1
0062  D7FC      	BRA	label3
0064  0012      	RETURN
0066            ; } delay_us function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  0101      	MOVLB 0x01
006A  6F05      	MOVWF delay_ms_00000_arg_del, 1
006C  EC06F000  	CALL delay_ms_00000
0070  0EFA      	MOVLW 0xFA
0072  6F05      	MOVWF delay_ms_00000_arg_del, 1
0074  EC06F000  	CALL delay_ms_00000
0078  0EFA      	MOVLW 0xFA
007A  6F05      	MOVWF delay_ms_00000_arg_del, 1
007C  EC06F000  	CALL delay_ms_00000
0080  0EFA      	MOVLW 0xFA
0082  6F05      	MOVWF delay_ms_00000_arg_del, 1
0084  EC06F000  	CALL delay_ms_00000
0088  0100      	MOVLB 0x00
008A  2F85      	DECFSZ delay_s_00000_arg_del, F, 1
008C  D7EC      	BRA	label4
008E  0012      	RETURN
0090            ; } delay_s function end

































06B0            __mul_32_3_00019
06B0            ; { __mul_32_32 ; function begin
06B0  6BAD      	CLRF CompTempVarRet414, 1
06B2  6BAE      	CLRF CompTempVarRet414+D'1', 1
06B4  6BAF      	CLRF CompTempVarRet414+D'2', 1
06B6  6BB0      	CLRF CompTempVarRet414+D'3', 1
06B8  6BAF      	CLRF CompTempVarRet414+D'2', 1
06BA  6BB0      	CLRF CompTempVarRet414+D'3', 1
06BC  51A1      	MOVF __mul_32_3_00019_arg_a, W, 1
06BE  03A5      	MULWF __mul_32_3_00019_arg_b, 1
06C0  50F3      	MOVF gbl_prodl, W
06C2  6FAD      	MOVWF CompTempVarRet414, 1
06C4  50F4      	MOVF gbl_prodh, W
06C6  6FAE      	MOVWF CompTempVarRet414+D'1', 1
06C8  51A2      	MOVF __mul_32_3_00019_arg_a+D'1', W, 1
06CA  03A5      	MULWF __mul_32_3_00019_arg_b, 1
06CC  50F3      	MOVF gbl_prodl, W
06CE  27AE      	ADDWF CompTempVarRet414+D'1', F, 1
06D0  50F4      	MOVF gbl_prodh, W
06D2  23AF      	ADDWFC CompTempVarRet414+D'2', F, 1
06D4  B0D8      	BTFSC gbl_status,0
06D6  2BB0      	INCF CompTempVarRet414+D'3', F, 1
06D8  51A3      	MOVF __mul_32_3_00019_arg_a+D'2', W, 1
06DA  03A5      	MULWF __mul_32_3_00019_arg_b, 1
06DC  50F3      	MOVF gbl_prodl, W
06DE  27AF      	ADDWF CompTempVarRet414+D'2', F, 1
06E0  50F4      	MOVF gbl_prodh, W
06E2  23B0      	ADDWFC CompTempVarRet414+D'3', F, 1
06E4  51A4      	MOVF __mul_32_3_00019_arg_a+D'3', W, 1
06E6  03A5      	MULWF __mul_32_3_00019_arg_b, 1
06E8  50F3      	MOVF gbl_prodl, W
06EA  27B0      	ADDWF CompTempVarRet414+D'3', F, 1
06EC  51A1      	MOVF __mul_32_3_00019_arg_a, W, 1
06EE  03A6      	MULWF __mul_32_3_00019_arg_b+D'1', 1
06F0  50F3      	MOVF gbl_prodl, W
06F2  27AE      	ADDWF CompTempVarRet414+D'1', F, 1
06F4  50F4      	MOVF gbl_prodh, W
06F6  23AF      	ADDWFC CompTempVarRet414+D'2', F, 1
06F8  B0D8      	BTFSC gbl_status,0
06FA  2BB0      	INCF CompTempVarRet414+D'3', F, 1
06FC  51A2      	MOVF __mul_32_3_00019_arg_a+D'1', W, 1
06FE  03A6      	MULWF __mul_32_3_00019_arg_b+D'1', 1
0700  50F3      	MOVF gbl_prodl, W
0702  27AF      	ADDWF CompTempVarRet414+D'2', F, 1
0704  50F4      	MOVF gbl_prodh, W
0706  23B0      	ADDWFC CompTempVarRet414+D'3', F, 1
0708  51A3      	MOVF __mul_32_3_00019_arg_a+D'2', W, 1
070A  03A6      	MULWF __mul_32_3_00019_arg_b+D'1', 1
070C  50F3      	MOVF gbl_prodl, W
070E  27B0      	ADDWF CompTempVarRet414+D'3', F, 1
0710  51A1      	MOVF __mul_32_3_00019_arg_a, W, 1
0712  03A7      	MULWF __mul_32_3_00019_arg_b+D'2', 1
0714  50F3      	MOVF gbl_prodl, W
0716  27AF      	ADDWF CompTempVarRet414+D'2', F, 1
0718  50F4      	MOVF gbl_prodh, W
071A  23B0      	ADDWFC CompTempVarRet414+D'3', F, 1
071C  51A2      	MOVF __mul_32_3_00019_arg_a+D'1', W, 1
071E  03A7      	MULWF __mul_32_3_00019_arg_b+D'2', 1
0720  50F3      	MOVF gbl_prodl, W
0722  27B0      	ADDWF CompTempVarRet414+D'3', F, 1
0724  51A1      	MOVF __mul_32_3_00019_arg_a, W, 1
0726  03A8      	MULWF __mul_32_3_00019_arg_b+D'3', 1
0728  50F3      	MOVF gbl_prodl, W
072A  27B0      	ADDWF CompTempVarRet414+D'3', F, 1
072C  0012      	RETURN
072E            ; } __mul_32_32 function end

072E            __div_32_3_00014
072E            ; { __div_32_32 ; function begin
072E  6BA9      	CLRF __div_32_3_00014_1_r, 1
0730  6BAA      	CLRF __div_32_3_00014_1_r+D'1', 1
0732  6BAB      	CLRF __div_32_3_00014_1_r+D'2', 1
0734  6BAC      	CLRF __div_32_3_00014_1_r+D'3', 1
0736  6BAF      	CLRF CompTempVarRet172, 1
0738  6BB0      	CLRF CompTempVarRet172+D'1', 1
073A  6BB1      	CLRF CompTempVarRet172+D'2', 1
073C  6BB2      	CLRF CompTempVarRet172+D'3', 1
073E  6BAD      	CLRF __div_32_3_00014_1_i, 1
0740            label95
0740  0E20      	MOVLW 0x20
0742  15AD      	ANDWF __div_32_3_00014_1_i, W, 1
0744  6FAE      	MOVWF CompTempVar174, 1
0746  67AE      	TSTFSZ CompTempVar174, 1
0748  0012      	RETURN
074A  90D8      	BCF STATUS,C
074C  37AF      	RLCF CompTempVarRet172, F, 1
074E  37B0      	RLCF CompTempVarRet172+D'1', F, 1
0750  37B1      	RLCF CompTempVarRet172+D'2', F, 1
0752  37B2      	RLCF CompTempVarRet172+D'3', F, 1
0754  37A1      	RLCF __div_32_3_00014_arg_a, F, 1
0756  37A2      	RLCF __div_32_3_00014_arg_a+D'1', F, 1
0758  37A3      	RLCF __div_32_3_00014_arg_a+D'2', F, 1
075A  37A4      	RLCF __div_32_3_00014_arg_a+D'3', F, 1
075C  37A9      	RLCF __div_32_3_00014_1_r, F, 1
075E  37AA      	RLCF __div_32_3_00014_1_r+D'1', F, 1
0760  37AB      	RLCF __div_32_3_00014_1_r+D'2', F, 1
0762  37AC      	RLCF __div_32_3_00014_1_r+D'3', F, 1
0764  51A8      	MOVF __div_32_3_00014_arg_b+D'3', W, 1
0766  5DAC      	SUBWF __div_32_3_00014_1_r+D'3', W, 1
0768  E108      	BNZ	label96
076A  51A7      	MOVF __div_32_3_00014_arg_b+D'2', W, 1
076C  5DAB      	SUBWF __div_32_3_00014_1_r+D'2', W, 1
076E  E105      	BNZ	label96
0770  51A6      	MOVF __div_32_3_00014_arg_b+D'1', W, 1
0772  5DAA      	SUBWF __div_32_3_00014_1_r+D'1', W, 1
0774  E102      	BNZ	label96
0776  51A5      	MOVF __div_32_3_00014_arg_b, W, 1
0778  5DA9      	SUBWF __div_32_3_00014_1_r, W, 1
077A            label96
077A  E309      	BNC	label97
077C  51A5      	MOVF __div_32_3_00014_arg_b, W, 1
077E  5FA9      	SUBWF __div_32_3_00014_1_r, F, 1
0780  51A6      	MOVF __div_32_3_00014_arg_b+D'1', W, 1
0782  5BAA      	SUBWFB __div_32_3_00014_1_r+D'1', F, 1
0784  51A7      	MOVF __div_32_3_00014_arg_b+D'2', W, 1
0786  5BAB      	SUBWFB __div_32_3_00014_1_r+D'2', F, 1
0788  51A8      	MOVF __div_32_3_00014_arg_b+D'3', W, 1
078A  5BAC      	SUBWFB __div_32_3_00014_1_r+D'3', F, 1
078C  81AF      	BSF CompTempVarRet172,0, 1
078E            label97
078E  2BAD      	INCF __div_32_3_00014_1_i, F, 1
0790  D7D7      	BRA	label95
0792            ; } __div_32_32 function end







































































































19B4            _startup
19B4  0ED5      	MOVLW 0xD5
19B6  6E4B      	MOVWF gbl_14_LSR
19B8  0EC4      	MOVLW 0xC4
19BA  6E4C      	MOVWF gbl_14_LSR+D'1'
19BC  0EBB      	MOVLW 0xBB
19BE  6E4D      	MOVWF gbl_14_LSR+D'2'
19C0  0EDC      	MOVLW 0xDC
19C2  6E4E      	MOVWF gbl_14_LSR+D'3'
19C4  6A4F      	CLRF gbl_15_gbl_aSig
19C6  6A50      	CLRF gbl_15_gbl_aSig+D'1'
19C8  6A51      	CLRF gbl_15_gbl_aSig+D'2'
19CA  6A52      	CLRF gbl_15_gbl_aSig+D'3'
19CC  6A53      	CLRF gbl_15_gbl_bSig
19CE  6A54      	CLRF gbl_15_gbl_bSig+D'1'
19D0  6A55      	CLRF gbl_15_gbl_bSig+D'2'
19D2  6A56      	CLRF gbl_15_gbl_bSig+D'3'
19D4  6A57      	CLRF gbl_15_gbl_zSig
19D6  6A58      	CLRF gbl_15_gbl_zSig+D'1'
19D8  6A59      	CLRF gbl_15_gbl_zSig+D'2'
19DA  6A5A      	CLRF gbl_15_gbl_zSig+D'3'
19DC  6A6C      	CLRF gbl_15_gbl_aExp
19DE  6A6D      	CLRF gbl_15_gbl_bExp
19E0  6A63      	CLRF gbl_15_gbl_zExp
19E2  6A64      	CLRF gbl_15_gbl_zExp+D'1'
19E4  6A6E      	CLRF gbl_15_gbl_aSign
19E6  6A6F      	CLRF gbl_15_gbl_bSign
19E8  6A70      	CLRF gbl_15_gbl_zSign
19EA  6A71      	CLRF gbl_15_gbl_zSigZero
19EC  6A5B      	CLRF gbl_15_gbl_ret
19EE  6A5C      	CLRF gbl_15_gbl_ret+D'1'
19F0  6A5D      	CLRF gbl_15_gbl_ret+D'2'
19F2  6A5E      	CLRF gbl_15_gbl_ret+D'3'
19F4  6A6A      	CLRF gbl_float_rounding_mode
19F6  6A6B      	CLRF gbl_float_exception_flags
19F8  6A69      	CLRF gbl_float_detect_tininess






1A30  EFD0F00C  	GOTO	main







300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  78FF      	DW 0x78FF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
