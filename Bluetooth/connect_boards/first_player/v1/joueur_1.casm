;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

// Delay by bytes
#define FCI_DELAYBYTE_S(count)     delay_s((count))
#define FCI_DELAYBYTE_MS(count)    delay_ms((count))
#define FCI_DELAYBYTE_US(count)    delay_us((count))
// With watchdog timer
#define FCI_DELAYBYTEWDT_S(count)  Wdt_Delay_S((count))
#define FCI_DELAYBYTEWDT_MS(count) Wdt_Delay_Ms((count))
#define FCI_DELAYBYTEWDT_US(count) delay_us((count))

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)
{
    char i;
    for (i=0; i<delay; i++)
    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
        delay_ms(1);
    }
}


void FCI_DELAYINT_US(MX_UINT16 Delay)

{
  	while (Delay > 255)
012A            label14
012A  0EFF      	MOVLW 0xFF
012C  65AB      	CPFSGT FCI_DELAYI_00038_arg_Delay, 1
012E  67AC      	TSTFSZ FCI_DELAYI_00038_arg_Delay+D'1', 1
0130  D001      	BRA	label15
0132  D00C      	BRA	label16
0134            label15
014A  D7EF      	BRA	label14
014C            label16

  	{
	  	delay_us(255);
0134  69AD      	SETF delay_us_00000_arg_del, 1
0136  EC06F000  	CALL delay_us_00000

	  	Delay = Delay - 255;
013A  0EFF      	MOVLW 0xFF
013C  5DAB      	SUBWF FCI_DELAYI_00038_arg_Delay, W, 1
013E  6FAD      	MOVWF CompTempVar1836, 1
0140  59AB      	SUBWFB FCI_DELAYI_00038_arg_Delay, W, 1
0142  08FF      	SUBLW 0xFF
0144  5FAC      	SUBWF FCI_DELAYI_00038_arg_Delay+D'1', F, 1
0146  51AD      	MOVF CompTempVar1836, W, 1
0148  6FAB      	MOVWF FCI_DELAYI_00038_arg_Delay, 1

  	}
  	if (Delay > 0)
014C  0E00      	MOVLW 0x00
014E  65AB      	CPFSGT FCI_DELAYI_00038_arg_Delay, 1
0150  67AC      	TSTFSZ FCI_DELAYI_00038_arg_Delay+D'1', 1
0152  D001      	BRA	label17
0156            label17

  		delay_us(Delay & 0xFF);
0156  51AB      	MOVF FCI_DELAYI_00038_arg_Delay, W, 1
0158  6FAD      	MOVWF delay_us_00000_arg_del, 1
015A  EC06F000  	CALL delay_us_00000

}
0154  0012      	RETURN
015E  0012      	RETURN


void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
0170  6B99      	CLRF FCI_GETLEN_0003E_1_tmp, 1
0172            label19
0172  5198      	MOVF FCI_GETLEN_0003E_arg_iStr1_len, W, 1
0174  6199      	CPFSLT FCI_GETLEN_0003E_1_tmp, 1
0176  D009      	BRA	label20
0178  5197      	MOVF FCI_GETLEN_0003E_arg_sStr1+D'1', W, 1
017A  6EEA      	MOVWF FSR0H
017C  5196      	MOVF FCI_GETLEN_0003E_arg_sStr1, W, 1
017E  2599      	ADDWF FCI_GETLEN_0003E_1_tmp, W, 1
0180  6EE9      	MOVWF FSR0L
0182  52EF      	MOVF INDF0, F
0184  E002      	BZ	label20
0186  2B99      	INCF FCI_GETLEN_0003E_1_tmp, F, 1
0188  D7F4      	BRA	label19
018A            label20

	return (tmp);
018A  5199      	MOVF FCI_GETLEN_0003E_1_tmp, W, 1
018C  6F9A      	MOVWF CompTempVarRet1850, 1

}
018E  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)

{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;
0ACA  5067      	MOVF FCI_TOSTRI_00042_arg_iSrc1, W
0ACC  6E6F      	MOVWF FCI_TOSTRI_00042_1_iSrc
0ACE  5068      	MOVF FCI_TOSTRI_00042_arg_iSrc1+D'1', W
0AD0  6E70      	MOVWF FCI_TOSTRI_00042_1_iSrc+D'1'
0AD2  5069      	MOVF FCI_TOSTRI_00042_arg_iSrc1+D'2', W
0AD4  6E71      	MOVWF FCI_TOSTRI_00042_1_iSrc+D'2'
0AD6  506A      	MOVF FCI_TOSTRI_00042_arg_iSrc1+D'3', W
0AD8  6E72      	MOVWF FCI_TOSTRI_00042_1_iSrc+D'3'


	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
0ADA  6A73      	CLRF FCI_TOSTRI_00042_1_top
0ADC  0ECA      	MOVLW 0xCA
0ADE  6E74      	MOVWF FCI_TOSTRI_00042_1_top+D'1'
0AE0  0E9A      	MOVLW 0x9A
0AE2  6E75      	MOVWF FCI_TOSTRI_00042_1_top+D'2'
0AE4  0E3B      	MOVLW 0x3B
0AE6  6E76      	MOVWF FCI_TOSTRI_00042_1_top+D'3'

	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;
0AE8  6A77      	CLRF FCI_TOSTRI_00042_1_idx


	if (iDst_len == 0) return sDst;
0AEA  526D      	MOVF FCI_TOSTRI_00042_arg_iDst_len, F
0AEC  E105      	BNZ	label109
0AEE  506B      	MOVF FCI_TOSTRI_00042_arg_sDst, W
0AF0  6E78      	MOVWF CompTempVarRet1863
0AF2  506C      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W
0AF4  6E79      	MOVWF CompTempVarRet1863+D'1'
0AF8            label109


	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
0AF8  AE72      	BTFSS FCI_TOSTRI_00042_1_iSrc+D'3',7
0AFA  D014      	BRA	label110

	{
		sDst[0] = '-';
0AFC  506C      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W
0AFE  6EEA      	MOVWF FSR0H
0B00  506B      	MOVF FCI_TOSTRI_00042_arg_sDst, W
0B02  6EE9      	MOVWF FSR0L
0B04  6A7A      	CLRF CompTempVar1865
0B06  507A      	MOVF CompTempVar1865, W
0B08  26E9      	ADDWF FSR0L, F
0B0A  0E2D      	MOVLW 0x2D
0B0C  6EEF      	MOVWF INDF0

		idx++;
0B0E  2A77      	INCF FCI_TOSTRI_00042_1_idx, F

		iSrc = -iSrc;
0B10  1E6F      	COMF FCI_TOSTRI_00042_1_iSrc, F
0B12  1E70      	COMF FCI_TOSTRI_00042_1_iSrc+D'1', F
0B14  1E71      	COMF FCI_TOSTRI_00042_1_iSrc+D'2', F
0B16  1E72      	COMF FCI_TOSTRI_00042_1_iSrc+D'3', F
0B18  3E6F      	INCFSZ FCI_TOSTRI_00042_1_iSrc, F
0B1A  D004      	BRA	label110
0B1C  3E70      	INCFSZ FCI_TOSTRI_00042_1_iSrc+D'1', F
0B1E  D002      	BRA	label110
0B20  4A71      	INFSNZ FCI_TOSTRI_00042_1_iSrc+D'2', F
0B22  2A72      	INCF FCI_TOSTRI_00042_1_iSrc+D'3', F
0B24            label110

	}

	tmp1 = 0;    // Nothing added yet
0B24  6A6E      	CLRF FCI_TOSTRI_00042_1_tmp1

	if (iSrc == 0) // Force showing zero
0B26  506F      	MOVF FCI_TOSTRI_00042_1_iSrc, W
0B28  1070      	IORWF FCI_TOSTRI_00042_1_iSrc+D'1', W
0B2A  1071      	IORWF FCI_TOSTRI_00042_1_iSrc+D'2', W
0B2C  1072      	IORWF FCI_TOSTRI_00042_1_iSrc+D'3', W
0B2E  0BFF      	ANDLW 0xFF
0B30  E106      	BNZ	label111
0B3E            label111

	{
		tmp1 = 1;
0B32  0E01      	MOVLW 0x01
0B34  6E6E      	MOVWF FCI_TOSTRI_00042_1_tmp1

		top = 1;
0B36  6E73      	MOVWF FCI_TOSTRI_00042_1_top
0B38  6A74      	CLRF FCI_TOSTRI_00042_1_top+D'1'
0B3A  6A75      	CLRF FCI_TOSTRI_00042_1_top+D'2'
0B3C  6A76      	CLRF FCI_TOSTRI_00042_1_top+D'3'

	}
	while (( idx < iDst_len) && (top > 0))
0B3E  506D      	MOVF FCI_TOSTRI_00042_arg_iDst_len, W
0B40  6077      	CPFSLT FCI_TOSTRI_00042_1_idx
0B42  D074      	BRA	label116
0B44  5076      	MOVF FCI_TOSTRI_00042_1_top+D'3', W
0B46  0800      	SUBLW 0x00
0B48  E108      	BNZ	label112
0B4A  5075      	MOVF FCI_TOSTRI_00042_1_top+D'2', W
0B4C  0800      	SUBLW 0x00
0B4E  E105      	BNZ	label112
0B50  5074      	MOVF FCI_TOSTRI_00042_1_top+D'1', W
0B52  0800      	SUBLW 0x00
0B54  E102      	BNZ	label112
0B56  5073      	MOVF FCI_TOSTRI_00042_1_top, W
0B58  0800      	SUBLW 0x00
0B5A            label112
0B5A  E268      	BC	label116
0C2A  D789      	BRA	label111
0C2C            label116

	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
0B5C  5076      	MOVF FCI_TOSTRI_00042_1_top+D'3', W
0B5E  5C72      	SUBWF FCI_TOSTRI_00042_1_iSrc+D'3', W
0B60  E108      	BNZ	label113
0B62  5075      	MOVF FCI_TOSTRI_00042_1_top+D'2', W
0B64  5C71      	SUBWF FCI_TOSTRI_00042_1_iSrc+D'2', W
0B66  E105      	BNZ	label113
0B68  5074      	MOVF FCI_TOSTRI_00042_1_top+D'1', W
0B6A  5C70      	SUBWF FCI_TOSTRI_00042_1_iSrc+D'1', W
0B6C  E102      	BNZ	label113
0B6E  5073      	MOVF FCI_TOSTRI_00042_1_top, W
0B70  5C6F      	SUBWF FCI_TOSTRI_00042_1_iSrc, W
0B72            label113
0B72  E202      	BC	label114
0B74  526E      	MOVF FCI_TOSTRI_00042_1_tmp1, F
0B76  E041      	BZ	label115
0B78            label114
0BFA            label115

		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
0B78  506F      	MOVF FCI_TOSTRI_00042_1_iSrc, W
0B7A  6E7A      	MOVWF __div_32_3_00004_arg_a
0B7C  5070      	MOVF FCI_TOSTRI_00042_1_iSrc+D'1', W
0B7E  6E7B      	MOVWF __div_32_3_00004_arg_a+D'1'
0B80  5071      	MOVF FCI_TOSTRI_00042_1_iSrc+D'2', W
0B82  6E7C      	MOVWF __div_32_3_00004_arg_a+D'2'
0B84  5072      	MOVF FCI_TOSTRI_00042_1_iSrc+D'3', W
0B86  6E7D      	MOVWF __div_32_3_00004_arg_a+D'3'
0B88  5073      	MOVF FCI_TOSTRI_00042_1_top, W
0B8A  0100      	MOVLB 0x00
0B8C  6F80      	MOVWF __div_32_3_00004_arg_b, 1
0B8E  5074      	MOVF FCI_TOSTRI_00042_1_top+D'1', W
0B90  6F81      	MOVWF __div_32_3_00004_arg_b+D'1', 1
0B92  5075      	MOVF FCI_TOSTRI_00042_1_top+D'2', W
0B94  6F82      	MOVWF __div_32_3_00004_arg_b+D'2', 1
0B96  5076      	MOVF FCI_TOSTRI_00042_1_top+D'3', W
0B98  6F83      	MOVWF __div_32_3_00004_arg_b+D'3', 1
0B9A  ECB4F003  	CALL __div_32_3_00004
0B9E  5188      	MOVF CompTempVarRet172, W, 1
0BA0  6E6E      	MOVWF FCI_TOSTRI_00042_1_tmp1

			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
0BA2  506E      	MOVF FCI_TOSTRI_00042_1_tmp1, W
0BA4  0F30      	ADDLW 0x30
0BA6  6E7A      	MOVWF CompTempVar1871
0BA8  506C      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W
0BAA  6EEA      	MOVWF FSR0H
0BAC  506B      	MOVF FCI_TOSTRI_00042_arg_sDst, W
0BAE  2477      	ADDWF FCI_TOSTRI_00042_1_idx, W
0BB0  6EE9      	MOVWF FSR0L
0BB2  507A      	MOVF CompTempVar1871, W
0BB4  6EEF      	MOVWF INDF0

			idx++;
0BB6  2A77      	INCF FCI_TOSTRI_00042_1_idx, F

			iSrc -= tmp1 * top;				// Remove digit
0BB8  506E      	MOVF FCI_TOSTRI_00042_1_tmp1, W
0BBA  6E7A      	MOVWF __mul_32_3_00009_arg_a
0BBC  6A7B      	CLRF __mul_32_3_00009_arg_a+D'1'
0BBE  6A7C      	CLRF __mul_32_3_00009_arg_a+D'2'
0BC0  6A7D      	CLRF __mul_32_3_00009_arg_a+D'3'
0BC2  5073      	MOVF FCI_TOSTRI_00042_1_top, W
0BC4  6F80      	MOVWF __mul_32_3_00009_arg_b, 1
0BC6  5074      	MOVF FCI_TOSTRI_00042_1_top+D'1', W
0BC8  6F81      	MOVWF __mul_32_3_00009_arg_b+D'1', 1
0BCA  5075      	MOVF FCI_TOSTRI_00042_1_top+D'2', W
0BCC  6F82      	MOVWF __mul_32_3_00009_arg_b+D'2', 1
0BCE  5076      	MOVF FCI_TOSTRI_00042_1_top+D'3', W
0BD0  6F83      	MOVWF __mul_32_3_00009_arg_b+D'3', 1
0BD2  EC75F003  	CALL __mul_32_3_00009
0BD6  5186      	MOVF CompTempVarRet414, W, 1
0BD8  6E7E      	MOVWF CompTempVar1872
0BDA  5187      	MOVF CompTempVarRet414+D'1', W, 1
0BDC  6E7F      	MOVWF CompTempVar1873
0BDE  5188      	MOVF CompTempVarRet414+D'2', W, 1
0BE0  6F84      	MOVWF CompTempVar1874, 1
0BE2  5189      	MOVF CompTempVarRet414+D'3', W, 1
0BE4  6F85      	MOVWF CompTempVar1875, 1
0BE6  507E      	MOVF CompTempVar1872, W
0BE8  5E6F      	SUBWF FCI_TOSTRI_00042_1_iSrc, F
0BEA  507F      	MOVF CompTempVar1873, W
0BEC  5A70      	SUBWFB FCI_TOSTRI_00042_1_iSrc+D'1', F
0BEE  5184      	MOVF CompTempVar1874, W, 1
0BF0  5A71      	SUBWFB FCI_TOSTRI_00042_1_iSrc+D'2', F
0BF2  5185      	MOVF CompTempVar1875, W, 1
0BF4  5A72      	SUBWFB FCI_TOSTRI_00042_1_iSrc+D'3', F

			tmp1 = 1;						// Add zeros now
0BF6  0E01      	MOVLW 0x01
0BF8  6E6E      	MOVWF FCI_TOSTRI_00042_1_tmp1

		}
		top /= 10;							// Go to next digit
0BFA  5073      	MOVF FCI_TOSTRI_00042_1_top, W
0BFC  6E7A      	MOVWF __div_32_3_00004_arg_a
0BFE  5074      	MOVF FCI_TOSTRI_00042_1_top+D'1', W
0C00  6E7B      	MOVWF __div_32_3_00004_arg_a+D'1'
0C02  5075      	MOVF FCI_TOSTRI_00042_1_top+D'2', W
0C04  6E7C      	MOVWF __div_32_3_00004_arg_a+D'2'
0C06  5076      	MOVF FCI_TOSTRI_00042_1_top+D'3', W
0C08  6E7D      	MOVWF __div_32_3_00004_arg_a+D'3'
0C0A  0E0A      	MOVLW 0x0A
0C0C  0100      	MOVLB 0x00
0C0E  6F80      	MOVWF __div_32_3_00004_arg_b, 1
0C10  6B81      	CLRF __div_32_3_00004_arg_b+D'1', 1
0C12  6B82      	CLRF __div_32_3_00004_arg_b+D'2', 1
0C14  6B83      	CLRF __div_32_3_00004_arg_b+D'3', 1
0C16  ECB4F003  	CALL __div_32_3_00004
0C1A  5188      	MOVF CompTempVarRet172, W, 1
0C1C  6E73      	MOVWF FCI_TOSTRI_00042_1_top
0C1E  5189      	MOVF CompTempVarRet172+D'1', W, 1
0C20  6E74      	MOVWF FCI_TOSTRI_00042_1_top+D'1'
0C22  518A      	MOVF CompTempVarRet172+D'2', W, 1
0C24  6E75      	MOVWF FCI_TOSTRI_00042_1_top+D'2'
0C26  518B      	MOVF CompTempVarRet172+D'3', W, 1
0C28  6E76      	MOVWF FCI_TOSTRI_00042_1_top+D'3'

	}

	if (idx < iDst_len)						//add terminating null (if we can)
0C2C  506D      	MOVF FCI_TOSTRI_00042_arg_iDst_len, W
0C2E  6077      	CPFSLT FCI_TOSTRI_00042_1_idx
0C30  D007      	BRA	label117
0C40            label117

		sDst[idx] = '\0';
0C32  506C      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W
0C34  6EEA      	MOVWF FSR0H
0C36  506B      	MOVF FCI_TOSTRI_00042_arg_sDst, W
0C38  2477      	ADDWF FCI_TOSTRI_00042_1_idx, W
0C3A  6EE9      	MOVWF FSR0L
0C3C  0E00      	MOVLW 0x00
0C3E  6EEF      	MOVWF INDF0

	return (sDst);
0C40  506B      	MOVF FCI_TOSTRI_00042_arg_sDst, W
0C42  6E78      	MOVWF CompTempVarRet1863
0C44  506C      	MOVF FCI_TOSTRI_00042_arg_sDst+D'1', W
0C46  6E79      	MOVWF CompTempVarRet1863+D'1'

}
0AF6  0012      	RETURN
0C48  0012      	RETURN




void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len, strt;

  len = 0;
01E0  6BA0      	CLRF FCI_SHEAD_00000_1_len, 1

  if (sSrc2 == sDst)
01E2  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
01E4  627D      	CPFSEQ FCI_SHEAD_00000_arg_sSrc2
01E6  D08C      	BRA	label37
01E8  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
01EA  627E      	CPFSEQ FCI_SHEAD_00000_arg_sSrc2+D'1'
01EC  D089      	BRA	label37
0300            label37

  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
01EE  6BA1      	CLRF FCI_SHEAD_00000_1_strt, 1
01F0            label26
01F0  507C      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
01F2  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
01F4  D009      	BRA	label27
01F6  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
01F8  6EEA      	MOVWF FSR0H
01FA  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
01FC  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
01FE  6EE9      	MOVWF FSR0L
0200  52EF      	MOVF INDF0, F
0202  E002      	BZ	label27
0204  2BA1      	INCF FCI_SHEAD_00000_1_strt, F, 1
0206  D7F4      	BRA	label26
0208            label27
02FE  D7E0      	BRA	label36

    if (strt < iDst_len)
0208  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
020A  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
020C  D058      	BRA	label35
02BE            label35

    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
020E  6BA0      	CLRF FCI_SHEAD_00000_1_len, 1
0210            label28
0210  507F      	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W
0212  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
0214  D009      	BRA	label29
0216  507E      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
0218  6EEA      	MOVWF FSR0H
021A  507D      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
021C  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
021E  6EE9      	MOVWF FSR0L
0220  52EF      	MOVF INDF0, F
0222  E002      	BZ	label29
0224  2BA0      	INCF FCI_SHEAD_00000_1_len, F, 1
0226  D7F4      	BRA	label28
0228            label29

      if (len > (iDst_len - strt))
0228  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
022A  5D9F      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
022C  6FA2      	MOVWF CompTempVar2023, 1
022E  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
0230  61A2      	CPFSLT CompTempVar2023, 1
0232  D005      	BRA	label30
023E            label30

      {
        len = (iDst_len - strt); // Length of string to copy to
0234  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
0236  5D9F      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
0238  6FA3      	MOVWF CompTempVar2029, 1
023A  51A3      	MOVF CompTempVar2029, W, 1
023C  6FA0      	MOVWF FCI_SHEAD_00000_1_len, 1

      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
023E  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
0240  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0242  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len

      strt = len;
0244  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
0246  6FA1      	MOVWF FCI_SHEAD_00000_1_strt, 1

      while (strt > 0)
0248            label31
0248  0E00      	MOVLW 0x00
024A  65A1      	CPFSGT FCI_SHEAD_00000_1_strt, 1
024C  D014      	BRA	label32
0274  D7E9      	BRA	label31
0276            label32

      {
        strt--;
024E  07A1      	DECF FCI_SHEAD_00000_1_strt, F, 1

        iSrc2_len--;
0250  067F      	DECF FCI_SHEAD_00000_arg_iSrc2_len, F

        sDst[iSrc2_len] = sSrc2[strt];
0252  507E      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
0254  6EEA      	MOVWF FSR0H
0256  507D      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
0258  6EE9      	MOVWF FSR0L
025A  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
025C  6FA3      	MOVWF CompTempVar2032, 1
025E  51A3      	MOVF CompTempVar2032, W, 1
0260  26E9      	ADDWF FSR0L, F
0262  50EF      	MOVF INDF0, W
0264  6FA4      	MOVWF CompTempVar2033, 1
0266  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0268  6EEA      	MOVWF FSR0H
026A  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
026C  247F      	ADDWF FCI_SHEAD_00000_arg_iSrc2_len, W
026E  6EE9      	MOVWF FSR0L
0270  51A4      	MOVF CompTempVar2033, W, 1
0272  6EEF      	MOVWF INDF0

      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
0276  6BA1      	CLRF FCI_SHEAD_00000_1_strt, 1
0278            label33
0278  507C      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
027A  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
027C  D01D      	BRA	label34
027E  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
0280  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
0282  D01A      	BRA	label34
0284  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0286  6EEA      	MOVWF FSR0H
0288  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
028A  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
028C  6EE9      	MOVWF FSR0L
028E  52EF      	MOVF INDF0, F
0290  E013      	BZ	label34
0292  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0294  6EEA      	MOVWF FSR0H
0296  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0298  6EE9      	MOVWF FSR0L
029A  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
029C  6FA3      	MOVWF CompTempVar2036, 1
029E  51A3      	MOVF CompTempVar2036, W, 1
02A0  26E9      	ADDWF FSR0L, F
02A2  50EF      	MOVF INDF0, W
02A4  6FA4      	MOVWF CompTempVar2037, 1
02A6  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
02A8  6EEA      	MOVWF FSR0H
02AA  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
02AC  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
02AE  6EE9      	MOVWF FSR0L
02B0  51A4      	MOVF CompTempVar2037, W, 1
02B2  6EEF      	MOVWF INDF0
02B4  2BA1      	INCF FCI_SHEAD_00000_1_strt, F, 1
02B6  D7E0      	BRA	label33
02B8            label34

      len += strt;
02B8  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
02BA  27A0      	ADDWF FCI_SHEAD_00000_1_len, F, 1

    }
    else
02BC  D075      	BRA	label42

    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
02BE  6BA0      	CLRF FCI_SHEAD_00000_1_len, 1
02C0            label36
02C0  507C      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
02C2  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
02C4  D071      	BRA	label42
02C6  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
02C8  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
02CA  D06E      	BRA	label42
02CC  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
02CE  6EEA      	MOVWF FSR0H
02D0  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
02D2  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
02D4  6EE9      	MOVWF FSR0L
02D6  52EF      	MOVF INDF0, F
02D8  E067      	BZ	label42
02DA  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
02DC  6EEA      	MOVWF FSR0H
02DE  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
02E0  6EE9      	MOVWF FSR0L
02E2  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
02E4  6FA2      	MOVWF CompTempVar2044, 1
02E6  51A2      	MOVF CompTempVar2044, W, 1
02E8  26E9      	ADDWF FSR0L, F
02EA  50EF      	MOVF INDF0, W
02EC  6FA3      	MOVWF CompTempVar2045, 1
02EE  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
02F0  6EEA      	MOVWF FSR0H
02F2  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
02F4  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
02F6  6EE9      	MOVWF FSR0L
02F8  51A3      	MOVF CompTempVar2045, W, 1
02FA  6EEF      	MOVWF INDF0
02FC  2BA0      	INCF FCI_SHEAD_00000_1_len, F, 1

    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
0300  6BA0      	CLRF FCI_SHEAD_00000_1_len, 1
0302            label38
0302  507C      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
0304  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
0306  D01D      	BRA	label39
0308  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
030A  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
030C  D01A      	BRA	label39
030E  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0310  6EEA      	MOVWF FSR0H
0312  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0314  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
0316  6EE9      	MOVWF FSR0L
0318  52EF      	MOVF INDF0, F
031A  E013      	BZ	label39
031C  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
031E  6EEA      	MOVWF FSR0H
0320  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0322  6EE9      	MOVWF FSR0L
0324  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
0326  6FA2      	MOVWF CompTempVar2052, 1
0328  51A2      	MOVF CompTempVar2052, W, 1
032A  26E9      	ADDWF FSR0L, F
032C  50EF      	MOVF INDF0, W
032E  6FA3      	MOVWF CompTempVar2053, 1
0330  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0332  6EEA      	MOVWF FSR0H
0334  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
0336  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
0338  6EE9      	MOVWF FSR0L
033A  51A3      	MOVF CompTempVar2053, W, 1
033C  6EEF      	MOVWF INDF0
033E  2BA0      	INCF FCI_SHEAD_00000_1_len, F, 1
0340  D7E0      	BRA	label38
0342            label39

    // Copy second
    if (len < iDst_len)
0342  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
0344  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1
0346  D030      	BRA	label42
03A8            label42

    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
0348  6BA3      	CLRF CompTempVar2059, 1
034A  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
034C  259D      	ADDWF FCI_SHEAD_00000_arg_sDst, W, 1
034E  6FA2      	MOVWF CompTempVar2058, 1
0350  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0352  23A3      	ADDWFC CompTempVar2059, F, 1
0354  51A2      	MOVF CompTempVar2058, W, 1
0356  6E7A      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0358  51A3      	MOVF CompTempVar2059, W, 1
035A  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'

      iSrc1_len = iDst_len - len;
035C  51A0      	MOVF FCI_SHEAD_00000_1_len, W, 1
035E  5D9F      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
0360  6E7C      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len

      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
0362  6BA1      	CLRF FCI_SHEAD_00000_1_strt, 1
0364            label40
0364  507F      	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W
0366  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
0368  D01D      	BRA	label41
036A  507C      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
036C  61A1      	CPFSLT FCI_SHEAD_00000_1_strt, 1
036E  D01A      	BRA	label41
0370  507E      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
0372  6EEA      	MOVWF FSR0H
0374  507D      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
0376  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0378  6EE9      	MOVWF FSR0L
037A  52EF      	MOVF INDF0, F
037C  E013      	BZ	label41
037E  507E      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
0380  6EEA      	MOVWF FSR0H
0382  507D      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
0384  6EE9      	MOVWF FSR0L
0386  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
0388  6FA2      	MOVWF CompTempVar2062, 1
038A  51A2      	MOVF CompTempVar2062, W, 1
038C  26E9      	ADDWF FSR0L, F
038E  50EF      	MOVF INDF0, W
0390  6FA3      	MOVWF CompTempVar2063, 1
0392  507B      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0394  6EEA      	MOVWF FSR0H
0396  507A      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0398  25A1      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
039A  6EE9      	MOVWF FSR0L
039C  51A3      	MOVF CompTempVar2063, W, 1
039E  6EEF      	MOVWF INDF0
03A0  2BA1      	INCF FCI_SHEAD_00000_1_strt, F, 1
03A2  D7E0      	BRA	label40
03A4            label41

      len += strt;
03A4  51A1      	MOVF FCI_SHEAD_00000_1_strt, W, 1
03A6  27A0      	ADDWF FCI_SHEAD_00000_1_len, F, 1

    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
03A8  519F      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
03AA  61A0      	CPFSLT FCI_SHEAD_00000_1_len, 1

  {
    sDst[len] = '\0';
03AE  519E      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
03B0  6EEA      	MOVWF FSR0H
03B2  519D      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
03B4  25A0      	ADDWF FCI_SHEAD_00000_1_len, W, 1
03B6  6EE9      	MOVWF FSR0L
03B8  0E00      	MOVLW 0x00
03BA  6EEF      	MOVWF INDF0

  }
}
03AC  0012      	RETURN
03BC  0012      	RETURN



/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
07E2  0100      	MOVLB 0x00
07E4  6BD1      	CLRF FCI_SCOPY_00000_1_len, 1
07E6            label102
07E6  507C      	MOVF FCI_SCOPY_00000_arg_iSrc_len, W
07E8  61D1      	CPFSLT FCI_SCOPY_00000_1_len, 1
07EA  D01D      	BRA	label103
07EC  507F      	MOVF FCI_SCOPY_00000_arg_iDst_len, W
07EE  61D1      	CPFSLT FCI_SCOPY_00000_1_len, 1
07F0  D01A      	BRA	label103
07F2  5061      	MOVF FCI_SCOPY_00000_arg_sSrc+D'1', W
07F4  6EEA      	MOVWF FSR0H
07F6  5060      	MOVF FCI_SCOPY_00000_arg_sSrc, W
07F8  25D1      	ADDWF FCI_SCOPY_00000_1_len, W, 1
07FA  6EE9      	MOVWF FSR0L
07FC  52EF      	MOVF INDF0, F
07FE  E013      	BZ	label103
0800  5061      	MOVF FCI_SCOPY_00000_arg_sSrc+D'1', W
0802  6EEA      	MOVWF FSR0H
0804  5060      	MOVF FCI_SCOPY_00000_arg_sSrc, W
0806  6EE9      	MOVWF FSR0L
0808  51D1      	MOVF FCI_SCOPY_00000_1_len, W, 1
080A  6FD2      	MOVWF CompTempVar2071, 1
080C  51D2      	MOVF CompTempVar2071, W, 1
080E  26E9      	ADDWF FSR0L, F
0810  50EF      	MOVF INDF0, W
0812  6FD3      	MOVWF CompTempVar2072, 1
0814  507E      	MOVF FCI_SCOPY_00000_arg_sDst+D'1', W
0816  6EEA      	MOVWF FSR0H
0818  507D      	MOVF FCI_SCOPY_00000_arg_sDst, W
081A  25D1      	ADDWF FCI_SCOPY_00000_1_len, W, 1
081C  6EE9      	MOVWF FSR0L
081E  51D3      	MOVF CompTempVar2072, W, 1
0820  6EEF      	MOVWF INDF0
0822  2BD1      	INCF FCI_SCOPY_00000_1_len, F, 1
0824  D7E0      	BRA	label102
0826            label103

  // Terminate (only if can)
  if (len < iDst_len)
0826  507F      	MOVF FCI_SCOPY_00000_arg_iDst_len, W
0828  61D1      	CPFSLT FCI_SCOPY_00000_1_len, 1

  {
    sDst[len] = '\0';
082C  507E      	MOVF FCI_SCOPY_00000_arg_sDst+D'1', W
082E  6EEA      	MOVWF FSR0H
0830  507D      	MOVF FCI_SCOPY_00000_arg_sDst, W
0832  25D1      	ADDWF FCI_SCOPY_00000_1_len, W, 1
0834  6EE9      	MOVWF FSR0L
0836  0E00      	MOVLW 0x00
0838  6EEF      	MOVWF INDF0

  }
}
082A  0012      	RETURN
083A  0012      	RETURN





//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BOYER\PROJET\Bluetooth\connect_boards\first_player\joueur_1.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Monday, March 27, 2017 17:43:00
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x78
#endif
#ifdef HI_TECH_C
__CONFIG(0x78);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_ASCII 255
#define FCVsz_RETURN 20
#define FCV_FALSE (0)
#define FCV_BT_CONNECTED (255) // Indique si les deux modules bluetooth sont connectés
#define FCV_BT_COMMAND_EMPTY (255) // Résultat de la commande vide
#define FCV_BT_COMMAND_OK (0) // Succès de la commande
#define FCV_TRUE (1)
MX_GLOBAL MX_CHAR FCV_ASCII[FCVsz_ASCII];
MX_GLOBAL MX_UINT8 FCV_OCTET;
MX_GLOBAL MX_CHAR FCV_RETURN[FCVsz_RETURN];
MX_GLOBAL MX_UINT8 FCV_COMMAND_RETURN; // Retour des commandes envoyés/reçues
MX_GLOBAL MX_UINT8 FCV_BT_STATE = (0xa5); // État du bluetooth
1276  0EA5      	MOVLW 0xA5
1278  6E57      	MOVWF gbl_FCV_BT_STATE

MX_GLOBAL MX_SINT16 FCV_LOOP;

MX_UINT8 FCM_CONVERT_TABLE_STRING(MX_CHAR *PFCL_VAR_TABLE);
void FCM_INITIALISATION();
void FCM_BT_CHECK_CONNECTON();
void FCM_BT_DATA_RECEIVER();
MX_UINT8 FCM_CONVERT_BINARY_ASCII(MX_CHAR *PFCL_VAR_BINARY);
void FCM_SET_ASCII_CHARATERS();
void FCM_CHECK_BT_GETTING();
void FCM_BT_CONNECTION();

/*========================================================================*\
   Use :ctrl_lcd
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_eb005
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_0ad31_lcd_eb005__Clear FCD_04071_LCD__Clear
#define FCD_0ad31_lcd_eb005__PrintString FCD_04071_LCD__PrintString
#define FCD_0ad31_lcd_eb005__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0ad31_lcd_eb005__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0ad31_lcd_eb005__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0ad31_lcd_eb005__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0ad31_lcd_eb005__Cursor FCD_04071_LCD__Cursor
#define FCD_0ad31_lcd_eb005__Command FCD_04071_LCD__Command
#define FCD_0ad31_lcd_eb005__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0ad31_lcd_eb005__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0ad31_lcd_eb005__RawSend FCD_04071_LCD__RawSend
#define FCD_0ad31_lcd_eb005__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :InjectorBase1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 portb
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 portb
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisb
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisb
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (4)
#define MX_UART_INT_1 (1)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :Bluetooth2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_0c851_Bluetooth2__STRING_ARRAY 50
#define FCV_0c851_Bluetooth2__BT_CHAR_CR (13)
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__STRING_ARRAY[FCVsz_0c851_Bluetooth2__STRING_ARRAY];
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_IDX = (0x0);
127A  6A58      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX

MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_DONE = (0x0);
127C  6A59      	CLRF gbl_FCV_0c851_Bluetooth2___00001

MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_LENGTH = (0x0);
127E  6A5A      	CLRF gbl_FCV_0c851_Bluetooth2___00002


MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY);
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT);
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX);
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR);
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES);
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings();
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA);
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE);
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive();
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings();
MX_UINT8 FCD_0c851_Bluetooth2__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :ctrl_lcd
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()

{




	FCD_04071_LCD__RawSend(0x01, 0);
0A74  0E01      	MOVLW 0x01
0A76  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
0A78  0100      	MOVLB 0x00
0A7A  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
0A7C  EC17F002  	CALL FCD_04071__00066


	FCI_DELAYBYTE_MS(2);
0A80  0E02      	MOVLW 0x02
0A82  6E70      	MOVWF delay_ms_00000_arg_del
0A84  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x02, 0);
0A88  0E02      	MOVLW 0x02
0A8A  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
0A8C  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
0A8E  EC17F002  	CALL FCD_04071__00066


	FCI_DELAYBYTE_MS(2);
0A92  0E02      	MOVLW 0x02
0A94  6E70      	MOVWF delay_ms_00000_arg_del
0A96  EC0BF000  	CALL delay_ms_00000


}
0A9A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Param??tres pour la macro PrintString :
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
0F72  6A7D      	CLRF FCD_04071__00056_1_FCL_IDX

	MX_UINT8 FCL_COUNT;



	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);
0F74  5067      	MOVF FCD_04071__00056_arg_FCL_TEXT, W
0F76  0100      	MOVLB 0x00
0F78  6F96      	MOVWF FCI_GETLEN_0003E_arg_sStr1, 1
0F7A  5068      	MOVF FCD_04071__00056_arg_FCL_TEXT+D'1', W
0F7C  6F97      	MOVWF FCI_GETLEN_0003E_arg_sStr1+D'1', 1
0F7E  507B      	MOVF FCD_04071__00056_arg_FCLsz_TEXT, W
0F80  6F98      	MOVWF FCI_GETLEN_0003E_arg_iStr1_len, 1
0F82  ECB8F000  	CALL FCI_GETLEN_0003E
0F86  519A      	MOVF CompTempVarRet1850, W, 1
0F88  6E7E      	MOVWF FCD_04071__00056_1_FCL_COUNT


	while (FCL_IDX < FCL_COUNT)
0F8A            label139
0F8A  507E      	MOVF FCD_04071__00056_1_FCL_COUNT, W
0F8C  607D      	CPFSLT FCD_04071__00056_1_FCL_IDX
0FA8  D7F0      	BRA	label139

	{

		FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);
0F90  5068      	MOVF FCD_04071__00056_arg_FCL_TEXT+D'1', W
0F92  6EEA      	MOVWF FSR0H
0F94  5067      	MOVF FCD_04071__00056_arg_FCL_TEXT, W
0F96  247D      	ADDWF FCD_04071__00056_1_FCL_IDX, W
0F98  6EE9      	MOVWF FSR0L
0F9A  50EF      	MOVF INDF0, W
0F9C  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
0F9E  8180      	BSF FCD_04071__00066_arg_FCL_TYPE,0, 1
0FA0  EC17F002  	CALL FCD_04071__00066


		FCL_IDX = FCL_IDX + 1;
0FA4  287D      	INCF FCD_04071__00056_1_FCL_IDX, W
0FA6  6E7D      	MOVWF FCD_04071__00056_1_FCL_IDX



	}


}
0F8E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Param??tres pour la macro PrintAscii :
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)

{
	//Définitions des variables locales
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);
11CC  505B      	MOVF FCD_04071__00064_arg_FCL_NUMBER, W
11CE  6E67      	MOVWF FCI_TOSTRI_00042_arg_iSrc1
11D0  505C      	MOVF FCD_04071__00064_arg_FCL_NUMBER+D'1', W
11D2  6E68      	MOVWF FCI_TOSTRI_00042_arg_iSrc1+D'1'
11D4  6A69      	CLRF FCI_TOSTRI_00042_arg_iSrc1+D'2'
11D6  6A6A      	CLRF FCI_TOSTRI_00042_arg_iSrc1+D'3'
11D8  AE5C      	BTFSS FCD_04071__00064_arg_FCL_NUMBER+D'1',7
11DA  D002      	BRA	label157
11DC  0669      	DECF FCI_TOSTRI_00042_arg_iSrc1+D'2', F
11DE  066A      	DECF FCI_TOSTRI_00042_arg_iSrc1+D'3', F
11E0            label157
11E0  0E00      	MOVLW HIGH(FCD_04071__00064_1_FCL_S+D'0')
11E2  6E6C      	MOVWF FCI_TOSTRI_00042_arg_sDst+D'1'
11E4  0E5D      	MOVLW LOW(FCD_04071__00064_1_FCL_S+D'0')
11E6  6E6B      	MOVWF FCI_TOSTRI_00042_arg_sDst
11E8  0E0A      	MOVLW 0x0A
11EA  6E6D      	MOVWF FCI_TOSTRI_00042_arg_iDst_len
11EC  EC65F005  	CALL FCI_TOSTRI_00042


	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);
11F0  0E00      	MOVLW HIGH(FCD_04071__00064_1_FCL_S+D'0')
11F2  6E68      	MOVWF FCD_04071__00056_arg_FCL_TEXT+D'1'
11F4  0E5D      	MOVLW LOW(FCD_04071__00064_1_FCL_S+D'0')
11F6  6E67      	MOVWF FCD_04071__00056_arg_FCL_TEXT
11F8  0E0A      	MOVLW 0x0A
11FA  6E7B      	MOVWF FCD_04071__00056_arg_FCLsz_TEXT
11FC  6A7C      	CLRF FCD_04071__00056_arg_FCLsz_TEXT+D'1'
11FE  ECB9F007  	CALL FCD_04071__00056


	//Définitions des variables locales
	#undef FCLsz_S
}
1202  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Param??tres pour la macro RAMWrite :
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Param??tres pour la macro ClearLine :
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Param??tres pour la macro Cursor :
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)

{



	#if (0) // 2 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
0F4C  525C      	MOVF FCD_04071__00057_arg_FCL_Y, F
0F4E  E103      	BNZ	label137
0F56            label137

		{

			FCL_Y = 0x80;
0F50  0E80      	MOVLW 0x80
0F52  6E5C      	MOVWF FCD_04071__00057_arg_FCL_Y


		} else {
0F54  D002      	BRA	label138
0F5A            label138


			FCL_Y = 0xC0;
0F56  0EC0      	MOVLW 0xC0
0F58  6E5C      	MOVWF FCD_04071__00057_arg_FCL_Y


		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 2 == 4

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);
0F5A  505B      	MOVF FCD_04071__00057_arg_FCL_X, W
0F5C  245C      	ADDWF FCD_04071__00057_arg_FCL_Y, W
0F5E  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
0F60  0100      	MOVLB 0x00
0F62  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
0F64  EC17F002  	CALL FCD_04071__00066


	FCI_DELAYBYTE_MS(2);
0F68  0E02      	MOVLW 0x02
0F6A  6E70      	MOVWF delay_ms_00000_arg_del
0F6C  EC0BF000  	CALL delay_ms_00000


}
0F70  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Param??tres pour la macro Command :
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Param??tres pour la macro PrintFormattedNumber :
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Définitions des variables locales
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Param??tres pour la macro ScrollDisplay :
       :  Position : Holds the number of positions to shift the display
       :  direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Définitions des variables locales
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	switch (FCL_DIRECTION)
	{
		case 0:
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'l':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'L':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 1:
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'r':
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'R':
		{
			FCL_CMD = 0x1C;


			break;
		}
		// default:

	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Param??tres pour la macro RawSend :
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)

{
	//Définitions des variables locales
	MX_UINT8 FCL_NIBBLE;


	//Commentaire:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
042E  6B82      	CLRF FCD_04071__00066_2_ptmp, 1
0430  9092      	BCF gbl_trisa,0
0432  5382      	MOVF FCD_04071__00066_2_ptmp, F, 1
0434  E004      	BZ	label49
0436  0E01      	MOVLW 0x01
0438  1089      	IORWF gbl_lata, W
043A  6E80      	MOVWF gbl_porta
043C  D003      	BRA	label50
043E            label49
043E  0EFE      	MOVLW 0xFE
0440  1489      	ANDWF gbl_lata, W
0442  6E80      	MOVWF gbl_porta
0444            label50

		FCP_SET(B, A, 0x2, 0x1, 0);
0444  6B82      	CLRF FCD_04071__00066_9_ptmp, 1
0446  9292      	BCF gbl_trisa,1
0448  5382      	MOVF FCD_04071__00066_9_ptmp, F, 1
044A  E004      	BZ	label51
044C  0E02      	MOVLW 0x02
044E  1089      	IORWF gbl_lata, W
0450  6E80      	MOVWF gbl_porta
0452  D003      	BRA	label52
0454            label51
0454  0EFD      	MOVLW 0xFD
0456  1489      	ANDWF gbl_lata, W
0458  6E80      	MOVWF gbl_porta
045A            label52

		FCP_SET(B, A, 0x4, 0x2, 0);
045A  6B82      	CLRF FCD_04071__00066_16_ptmp, 1
045C  9492      	BCF gbl_trisa,2
045E  5382      	MOVF FCD_04071__00066_16_ptmp, F, 1
0460  E004      	BZ	label53
0462  0E04      	MOVLW 0x04
0464  1089      	IORWF gbl_lata, W
0466  6E80      	MOVWF gbl_porta
0468  D003      	BRA	label54
046A            label53
046A  0EFB      	MOVLW 0xFB
046C  1489      	ANDWF gbl_lata, W
046E  6E80      	MOVWF gbl_porta
0470            label54

		FCP_SET(B, A, 0x8, 0x3, 0);
0470  6B82      	CLRF FCD_04071__00066_23_ptmp, 1
0472  9692      	BCF gbl_trisa,3
0474  5382      	MOVF FCD_04071__00066_23_ptmp, F, 1
0476  E004      	BZ	label55
0478  0E08      	MOVLW 0x08
047A  1089      	IORWF gbl_lata, W
047C  6E80      	MOVWF gbl_porta
047E  D003      	BRA	label56
0480            label55
0480  0EF7      	MOVLW 0xF7
0482  1489      	ANDWF gbl_lata, W
0484  6E80      	MOVWF gbl_porta
0486            label56

		FCP_SET(B, A, 0x10, 0x4, 0);
0486  6B82      	CLRF FCD_04071__00066_30_ptmp, 1
0488  9892      	BCF gbl_trisa,4
048A  5382      	MOVF FCD_04071__00066_30_ptmp, F, 1
048C  E004      	BZ	label57
048E  0E10      	MOVLW 0x10
0490  1089      	IORWF gbl_lata, W
0492  6E80      	MOVWF gbl_porta
0494  D003      	BRA	label58
0496            label57
0496  0EEF      	MOVLW 0xEF
0498  1489      	ANDWF gbl_lata, W
049A  6E80      	MOVWF gbl_porta
049C            label58

		FCP_SET(B, A, 0x20, 0x5, 0);
049C  6B82      	CLRF FCD_04071__00066_37_ptmp, 1
049E  9A92      	BCF gbl_trisa,5
04A0  5382      	MOVF FCD_04071__00066_37_ptmp, F, 1
04A2  E004      	BZ	label59
04A4  0E20      	MOVLW 0x20
04A6  1089      	IORWF gbl_lata, W
04A8  6E80      	MOVWF gbl_porta
04AA  D003      	BRA	label60
04AC            label59
04AC  0EDF      	MOVLW 0xDF
04AE  1489      	ANDWF gbl_lata, W
04B0  6E80      	MOVWF gbl_porta
04B2            label60


		#if (0)

		//Le code a été optimisé par le préprocesseur
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
04B2  387F      	SWAPF FCD_04071__00066_arg_FCL_DATA, W
04B4  0B0F      	ANDLW 0x0F
04B6  6F81      	MOVWF FCD_04071__00066_1_FCL_NIBBLE, 1

		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
04B8  0E01      	MOVLW 0x01
04BA  1581      	ANDWF FCD_04071__00066_1_FCL_NIBBLE, W, 1
04BC  6F82      	MOVWF FCD_04071__00066_46_ptmp, 1
04BE  9092      	BCF gbl_trisa,0
04C0  5382      	MOVF FCD_04071__00066_46_ptmp, F, 1
04C2  E004      	BZ	label61
04C4  0E01      	MOVLW 0x01
04C6  1089      	IORWF gbl_lata, W
04C8  6E80      	MOVWF gbl_porta
04CA  D003      	BRA	label62
04CC            label61
04CC  0EFE      	MOVLW 0xFE
04CE  1489      	ANDWF gbl_lata, W
04D0  6E80      	MOVWF gbl_porta
04D2            label62

		FCL_NIBBLE = FCL_NIBBLE >> 1;
04D2  5381      	MOVF FCD_04071__00066_1_FCL_NIBBLE, F, 1
04D4  90D8      	BCF STATUS,C
04D6  3381      	RRCF FCD_04071__00066_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
04D8  0E01      	MOVLW 0x01
04DA  1581      	ANDWF FCD_04071__00066_1_FCL_NIBBLE, W, 1
04DC  6F82      	MOVWF FCD_04071__00066_55_ptmp, 1
04DE  9292      	BCF gbl_trisa,1
04E0  5382      	MOVF FCD_04071__00066_55_ptmp, F, 1
04E2  E004      	BZ	label63
04E4  0E02      	MOVLW 0x02
04E6  1089      	IORWF gbl_lata, W
04E8  6E80      	MOVWF gbl_porta
04EA  D003      	BRA	label64
04EC            label63
04EC  0EFD      	MOVLW 0xFD
04EE  1489      	ANDWF gbl_lata, W
04F0  6E80      	MOVWF gbl_porta
04F2            label64

		FCL_NIBBLE = FCL_NIBBLE >> 1;
04F2  5381      	MOVF FCD_04071__00066_1_FCL_NIBBLE, F, 1
04F4  90D8      	BCF STATUS,C
04F6  3381      	RRCF FCD_04071__00066_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
04F8  0E01      	MOVLW 0x01
04FA  1581      	ANDWF FCD_04071__00066_1_FCL_NIBBLE, W, 1
04FC  6F82      	MOVWF FCD_04071__00066_64_ptmp, 1
04FE  9492      	BCF gbl_trisa,2
0500  5382      	MOVF FCD_04071__00066_64_ptmp, F, 1
0502  E004      	BZ	label65
0504  0E04      	MOVLW 0x04
0506  1089      	IORWF gbl_lata, W
0508  6E80      	MOVWF gbl_porta
050A  D003      	BRA	label66
050C            label65
050C  0EFB      	MOVLW 0xFB
050E  1489      	ANDWF gbl_lata, W
0510  6E80      	MOVWF gbl_porta
0512            label66

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0512  5381      	MOVF FCD_04071__00066_1_FCL_NIBBLE, F, 1
0514  90D8      	BCF STATUS,C
0516  3381      	RRCF FCD_04071__00066_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));
0518  0E01      	MOVLW 0x01
051A  1581      	ANDWF FCD_04071__00066_1_FCL_NIBBLE, W, 1
051C  6F82      	MOVWF FCD_04071__00066_73_ptmp, 1
051E  9692      	BCF gbl_trisa,3
0520  5382      	MOVF FCD_04071__00066_73_ptmp, F, 1
0522  E004      	BZ	label67
0524  0E08      	MOVLW 0x08
0526  1089      	IORWF gbl_lata, W
0528  6E80      	MOVWF gbl_porta
052A  D003      	BRA	label68
052C            label67
052C  0EF7      	MOVLW 0xF7
052E  1489      	ANDWF gbl_lata, W
0530  6E80      	MOVWF gbl_porta
0532            label68


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	//Commentaire:
	//Output byte to pins

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	//Commentaire:
	//Output byte to port

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	if (FCL_TYPE)
0532  A180      	BTFSS FCD_04071__00066_arg_FCL_TYPE,0, 1
0534  D00C      	BRA	label70

	{

		FCP_SET(B, A, 0x10, 0x4, 1);
0536  0E01      	MOVLW 0x01
0538  6F82      	MOVWF FCD_04071__00066_82_ptmp, 1
053A  9892      	BCF gbl_trisa,4
053C  5382      	MOVF FCD_04071__00066_82_ptmp, F, 1
053E  E004      	BZ	label69
0540  0E10      	MOVLW 0x10
0542  1089      	IORWF gbl_lata, W
0544  6E80      	MOVWF gbl_porta
0546  D003      	BRA	label70
0548            label69
0548  0EEF      	MOVLW 0xEF
054A  1489      	ANDWF gbl_lata, W
054C  6E80      	MOVWF gbl_porta
054E            label70


	// } else {

	}

	FCI_DELAYBYTE_US(100);
054E  0E64      	MOVLW 0x64
0550  6FAD      	MOVWF delay_us_00000_arg_del, 1
0552  EC06F000  	CALL delay_us_00000


	//Commentaire:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, A, 0x20, 0x5, 1);
0556  0E01      	MOVLW 0x01
0558  6F82      	MOVWF FCD_04071__00066_93_ptmp, 1
055A  9A92      	BCF gbl_trisa,5
055C  5382      	MOVF FCD_04071__00066_93_ptmp, F, 1
055E  E004      	BZ	label71
0560  0E20      	MOVLW 0x20
0562  1089      	IORWF gbl_lata, W
0564  6E80      	MOVWF gbl_porta
0566  D003      	BRA	label72
0568            label71
0568  0EDF      	MOVLW 0xDF
056A  1489      	ANDWF gbl_lata, W
056C  6E80      	MOVWF gbl_porta
056E            label72


	FCI_DELAYBYTE_US(100);
056E  0E64      	MOVLW 0x64
0570  6FAD      	MOVWF delay_us_00000_arg_del, 1
0572  EC06F000  	CALL delay_us_00000


	FCP_SET(B, A, 0x20, 0x5, 0);
0576  6B82      	CLRF FCD_04071__00066_104_ptmp, 1
0578  9A92      	BCF gbl_trisa,5
057A  5382      	MOVF FCD_04071__00066_104_ptmp, F, 1
057C  E004      	BZ	label73
057E  0E20      	MOVLW 0x20
0580  1089      	IORWF gbl_lata, W
0582  6E80      	MOVWF gbl_porta
0584  D003      	BRA	label74
0586            label73
0586  0EDF      	MOVLW 0xDF
0588  1489      	ANDWF gbl_lata, W
058A  6E80      	MOVWF gbl_porta
058C            label74


	FCI_DELAYBYTE_US(100);
058C  0E64      	MOVLW 0x64
058E  6FAD      	MOVWF delay_us_00000_arg_del, 1
0590  EC06F000  	CALL delay_us_00000


	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
0594  6B82      	CLRF FCD_04071__00066_115_ptmp, 1
0596  9092      	BCF gbl_trisa,0
0598  5382      	MOVF FCD_04071__00066_115_ptmp, F, 1
059A  E004      	BZ	label75
059C  0E01      	MOVLW 0x01
059E  1089      	IORWF gbl_lata, W
05A0  6E80      	MOVWF gbl_porta
05A2  D003      	BRA	label76
05A4            label75
05A4  0EFE      	MOVLW 0xFE
05A6  1489      	ANDWF gbl_lata, W
05A8  6E80      	MOVWF gbl_porta
05AA            label76

		FCP_SET(B, A, 0x2, 0x1, 0);
05AA  6B82      	CLRF FCD_04071__00066_122_ptmp, 1
05AC  9292      	BCF gbl_trisa,1
05AE  5382      	MOVF FCD_04071__00066_122_ptmp, F, 1
05B0  E004      	BZ	label77
05B2  0E02      	MOVLW 0x02
05B4  1089      	IORWF gbl_lata, W
05B6  6E80      	MOVWF gbl_porta
05B8  D003      	BRA	label78
05BA            label77
05BA  0EFD      	MOVLW 0xFD
05BC  1489      	ANDWF gbl_lata, W
05BE  6E80      	MOVWF gbl_porta
05C0            label78

		FCP_SET(B, A, 0x4, 0x2, 0);
05C0  6B82      	CLRF FCD_04071__00066_129_ptmp, 1
05C2  9492      	BCF gbl_trisa,2
05C4  5382      	MOVF FCD_04071__00066_129_ptmp, F, 1
05C6  E004      	BZ	label79
05C8  0E04      	MOVLW 0x04
05CA  1089      	IORWF gbl_lata, W
05CC  6E80      	MOVWF gbl_porta
05CE  D003      	BRA	label80
05D0            label79
05D0  0EFB      	MOVLW 0xFB
05D2  1489      	ANDWF gbl_lata, W
05D4  6E80      	MOVWF gbl_porta
05D6            label80

		FCP_SET(B, A, 0x8, 0x3, 0);
05D6  6B82      	CLRF FCD_04071__00066_136_ptmp, 1
05D8  9692      	BCF gbl_trisa,3
05DA  5382      	MOVF FCD_04071__00066_136_ptmp, F, 1
05DC  E004      	BZ	label81
05DE  0E08      	MOVLW 0x08
05E0  1089      	IORWF gbl_lata, W
05E2  6E80      	MOVWF gbl_porta
05E4  D003      	BRA	label82
05E6            label81
05E6  0EF7      	MOVLW 0xF7
05E8  1489      	ANDWF gbl_lata, W
05EA  6E80      	MOVWF gbl_porta
05EC            label82

		FCP_SET(B, A, 0x10, 0x4, 0);
05EC  6B82      	CLRF FCD_04071__00066_143_ptmp, 1
05EE  9892      	BCF gbl_trisa,4
05F0  5382      	MOVF FCD_04071__00066_143_ptmp, F, 1
05F2  E004      	BZ	label83
05F4  0E10      	MOVLW 0x10
05F6  1089      	IORWF gbl_lata, W
05F8  6E80      	MOVWF gbl_porta
05FA  D003      	BRA	label84
05FC            label83
05FC  0EEF      	MOVLW 0xEF
05FE  1489      	ANDWF gbl_lata, W
0600  6E80      	MOVWF gbl_porta
0602            label84


		FCL_NIBBLE = (FCL_DATA & 0xf);
0602  0E0F      	MOVLW 0x0F
0604  147F      	ANDWF FCD_04071__00066_arg_FCL_DATA, W
0606  6F82      	MOVWF CompTempVar2713, 1
0608  5182      	MOVF CompTempVar2713, W, 1
060A  6F81      	MOVWF FCD_04071__00066_1_FCL_NIBBLE, 1

		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
060C  0E01      	MOVLW 0x01
060E  1581      	ANDWF FCD_04071__00066_1_FCL_NIBBLE, W, 1
0610  6F82      	MOVWF FCD_04071__00066_152_ptmp, 1
0612  9092      	BCF gbl_trisa,0
0614  5382      	MOVF FCD_04071__00066_152_ptmp, F, 1
0616  E004      	BZ	label85
0618  0E01      	MOVLW 0x01
061A  1089      	IORWF gbl_lata, W
061C  6E80      	MOVWF gbl_porta
061E  D003      	BRA	label86
0620            label85
0620  0EFE      	MOVLW 0xFE
0622  1489      	ANDWF gbl_lata, W
0624  6E80      	MOVWF gbl_porta
0626            label86

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0626  5381      	MOVF FCD_04071__00066_1_FCL_NIBBLE, F, 1
0628  90D8      	BCF STATUS,C
062A  3381      	RRCF FCD_04071__00066_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
062C  0E01      	MOVLW 0x01
062E  1581      	ANDWF FCD_04071__00066_1_FCL_NIBBLE, W, 1
0630  6F82      	MOVWF FCD_04071__00066_161_ptmp, 1
0632  9292      	BCF gbl_trisa,1
0634  5382      	MOVF FCD_04071__00066_161_ptmp, F, 1
0636  E004      	BZ	label87
0638  0E02      	MOVLW 0x02
063A  1089      	IORWF gbl_lata, W
063C  6E80      	MOVWF gbl_porta
063E  D003      	BRA	label88
0640            label87
0640  0EFD      	MOVLW 0xFD
0642  1489      	ANDWF gbl_lata, W
0644  6E80      	MOVWF gbl_porta
0646            label88

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0646  5381      	MOVF FCD_04071__00066_1_FCL_NIBBLE, F, 1
0648  90D8      	BCF STATUS,C
064A  3381      	RRCF FCD_04071__00066_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
064C  0E01      	MOVLW 0x01
064E  1581      	ANDWF FCD_04071__00066_1_FCL_NIBBLE, W, 1
0650  6F82      	MOVWF FCD_04071__00066_170_ptmp, 1
0652  9492      	BCF gbl_trisa,2
0654  5382      	MOVF FCD_04071__00066_170_ptmp, F, 1
0656  E004      	BZ	label89
0658  0E04      	MOVLW 0x04
065A  1089      	IORWF gbl_lata, W
065C  6E80      	MOVWF gbl_porta
065E  D003      	BRA	label90
0660            label89
0660  0EFB      	MOVLW 0xFB
0662  1489      	ANDWF gbl_lata, W
0664  6E80      	MOVWF gbl_porta
0666            label90

		FCL_NIBBLE = FCL_NIBBLE >> 1;
0666  5381      	MOVF FCD_04071__00066_1_FCL_NIBBLE, F, 1
0668  90D8      	BCF STATUS,C
066A  3381      	RRCF FCD_04071__00066_1_FCL_NIBBLE, F, 1

		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));
066C  0E01      	MOVLW 0x01
066E  1581      	ANDWF FCD_04071__00066_1_FCL_NIBBLE, W, 1
0670  6F82      	MOVWF FCD_04071__00066_179_ptmp, 1
0672  9692      	BCF gbl_trisa,3
0674  5382      	MOVF FCD_04071__00066_179_ptmp, F, 1
0676  E004      	BZ	label91
0678  0E08      	MOVLW 0x08
067A  1089      	IORWF gbl_lata, W
067C  6E80      	MOVWF gbl_porta
067E  D003      	BRA	label92
0680            label91
0680  0EF7      	MOVLW 0xF7
0682  1489      	ANDWF gbl_lata, W
0684  6E80      	MOVWF gbl_porta
0686            label92


		if (FCL_TYPE)
0686  A180      	BTFSS FCD_04071__00066_arg_FCL_TYPE,0, 1
0688  D00C      	BRA	label94

		{

			FCP_SET(B, A, 0x10, 0x4, 1);
068A  0E01      	MOVLW 0x01
068C  6F82      	MOVWF FCD_04071__00066_188_ptmp, 1
068E  9892      	BCF gbl_trisa,4
0690  5382      	MOVF FCD_04071__00066_188_ptmp, F, 1
0692  E004      	BZ	label93
0694  0E10      	MOVLW 0x10
0696  1089      	IORWF gbl_lata, W
0698  6E80      	MOVWF gbl_porta
069A  D003      	BRA	label94
069C            label93
069C  0EEF      	MOVLW 0xEF
069E  1489      	ANDWF gbl_lata, W
06A0  6E80      	MOVWF gbl_porta
06A2            label94


		// } else {

		}

		FCI_DELAYBYTE_US(100);
06A2  0E64      	MOVLW 0x64
06A4  6FAD      	MOVWF delay_us_00000_arg_del, 1
06A6  EC06F000  	CALL delay_us_00000


		FCP_SET(B, A, 0x20, 0x5, 1);
06AA  0E01      	MOVLW 0x01
06AC  6F82      	MOVWF FCD_04071__00066_199_ptmp, 1
06AE  9A92      	BCF gbl_trisa,5
06B0  5382      	MOVF FCD_04071__00066_199_ptmp, F, 1
06B2  E004      	BZ	label95
06B4  0E20      	MOVLW 0x20
06B6  1089      	IORWF gbl_lata, W
06B8  6E80      	MOVWF gbl_porta
06BA  D003      	BRA	label96
06BC            label95
06BC  0EDF      	MOVLW 0xDF
06BE  1489      	ANDWF gbl_lata, W
06C0  6E80      	MOVWF gbl_porta
06C2            label96


		FCI_DELAYBYTE_US(100);
06C2  0E64      	MOVLW 0x64
06C4  6FAD      	MOVWF delay_us_00000_arg_del, 1
06C6  EC06F000  	CALL delay_us_00000


		FCP_SET(B, A, 0x20, 0x5, 0);
06CA  6B82      	CLRF FCD_04071__00066_210_ptmp, 1
06CC  9A92      	BCF gbl_trisa,5
06CE  5382      	MOVF FCD_04071__00066_210_ptmp, F, 1
06D0  E004      	BZ	label97
06D2  0E20      	MOVLW 0x20
06D4  1089      	IORWF gbl_lata, W
06D6  6E80      	MOVWF gbl_porta
06D8  D003      	BRA	label98
06DA            label97
06DA  0EDF      	MOVLW 0xDF
06DC  1489      	ANDWF gbl_lata, W
06DE  6E80      	MOVWF gbl_porta
06E0            label98


		FCI_DELAYBYTE_US(100);
06E0  0E64      	MOVLW 0x64
06E2  6FAD      	MOVWF delay_us_00000_arg_del, 1
06E4  EC06F000  	CALL delay_us_00000


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

}
06E8  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()

{



	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
0FAA  6A5B      	CLRF FCD_04071__00053_2_ptmp
0FAC  9092      	BCF gbl_trisa,0
0FAE  525B      	MOVF FCD_04071__00053_2_ptmp, F
0FB0  E004      	BZ	label140
0FB2  0E01      	MOVLW 0x01
0FB4  1089      	IORWF gbl_lata, W
0FB6  6E80      	MOVWF gbl_porta
0FB8  D003      	BRA	label141
0FBA            label140
0FBA  0EFE      	MOVLW 0xFE
0FBC  1489      	ANDWF gbl_lata, W
0FBE  6E80      	MOVWF gbl_porta
0FC0            label141

		FCP_SET(B, A, 0x2, 0x1, 0);
0FC0  6A5B      	CLRF FCD_04071__00053_9_ptmp
0FC2  9292      	BCF gbl_trisa,1
0FC4  525B      	MOVF FCD_04071__00053_9_ptmp, F
0FC6  E004      	BZ	label142
0FC8  0E02      	MOVLW 0x02
0FCA  1089      	IORWF gbl_lata, W
0FCC  6E80      	MOVWF gbl_porta
0FCE  D003      	BRA	label143
0FD0            label142
0FD0  0EFD      	MOVLW 0xFD
0FD2  1489      	ANDWF gbl_lata, W
0FD4  6E80      	MOVWF gbl_porta
0FD6            label143

		FCP_SET(B, A, 0x4, 0x2, 0);
0FD6  6A5B      	CLRF FCD_04071__00053_16_ptmp
0FD8  9492      	BCF gbl_trisa,2
0FDA  525B      	MOVF FCD_04071__00053_16_ptmp, F
0FDC  E004      	BZ	label144
0FDE  0E04      	MOVLW 0x04
0FE0  1089      	IORWF gbl_lata, W
0FE2  6E80      	MOVWF gbl_porta
0FE4  D003      	BRA	label145
0FE6            label144
0FE6  0EFB      	MOVLW 0xFB
0FE8  1489      	ANDWF gbl_lata, W
0FEA  6E80      	MOVWF gbl_porta
0FEC            label145

		FCP_SET(B, A, 0x8, 0x3, 0);
0FEC  6A5B      	CLRF FCD_04071__00053_23_ptmp
0FEE  9692      	BCF gbl_trisa,3
0FF0  525B      	MOVF FCD_04071__00053_23_ptmp, F
0FF2  E004      	BZ	label146
0FF4  0E08      	MOVLW 0x08
0FF6  1089      	IORWF gbl_lata, W
0FF8  6E80      	MOVWF gbl_porta
0FFA  D003      	BRA	label147
0FFC            label146
0FFC  0EF7      	MOVLW 0xF7
0FFE  1489      	ANDWF gbl_lata, W
1000  6E80      	MOVWF gbl_porta
1002            label147

		FCP_SET(B, A, 0x10, 0x4, 0);
1002  6A5B      	CLRF FCD_04071__00053_30_ptmp
1004  9892      	BCF gbl_trisa,4
1006  525B      	MOVF FCD_04071__00053_30_ptmp, F
1008  E004      	BZ	label148
100A  0E10      	MOVLW 0x10
100C  1089      	IORWF gbl_lata, W
100E  6E80      	MOVWF gbl_porta
1010  D003      	BRA	label149
1012            label148
1012  0EEF      	MOVLW 0xEF
1014  1489      	ANDWF gbl_lata, W
1016  6E80      	MOVWF gbl_porta
1018            label149

		FCP_SET(B, A, 0x20, 0x5, 0);
1018  6A5B      	CLRF FCD_04071__00053_37_ptmp
101A  9A92      	BCF gbl_trisa,5
101C  525B      	MOVF FCD_04071__00053_37_ptmp, F
101E  E004      	BZ	label150
1020  0E20      	MOVLW 0x20
1022  1089      	IORWF gbl_lata, W
1024  6E80      	MOVWF gbl_porta
1026  D003      	BRA	label151
1028            label150
1028  0EDF      	MOVLW 0xDF
102A  1489      	ANDWF gbl_lata, W
102C  6E80      	MOVWF gbl_porta
102E            label151


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0)

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);
102E  0E0C      	MOVLW 0x0C
1030  6E70      	MOVWF delay_ms_00000_arg_del
1032  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x33, 0);
1036  0E33      	MOVLW 0x33
1038  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
103A  0100      	MOVLB 0x00
103C  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
103E  EC17F002  	CALL FCD_04071__00066


	FCI_DELAYBYTE_MS(2);
1042  0E02      	MOVLW 0x02
1044  6E70      	MOVWF delay_ms_00000_arg_del
1046  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x33, 0);
104A  0E33      	MOVLW 0x33
104C  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
104E  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
1050  EC17F002  	CALL FCD_04071__00066


	FCI_DELAYBYTE_MS(2);
1054  0E02      	MOVLW 0x02
1056  6E70      	MOVWF delay_ms_00000_arg_del
1058  EC0BF000  	CALL delay_ms_00000


	#if (0) // 0 > 0

	//Le code a été optimisé par le préprocesseur
	#else

		FCD_04071_LCD__RawSend(0x32, 0);
105C  0E32      	MOVLW 0x32
105E  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
1060  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
1062  EC17F002  	CALL FCD_04071__00066


		FCI_DELAYBYTE_MS(2);
1066  0E02      	MOVLW 0x02
1068  6E70      	MOVWF delay_ms_00000_arg_del
106A  EC0BF000  	CALL delay_ms_00000


		FCD_04071_LCD__RawSend(0x2c, 0);
106E  0E2C      	MOVLW 0x2C
1070  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
1072  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
1074  EC17F002  	CALL FCD_04071__00066


	#endif

	FCI_DELAYBYTE_MS(2);
1078  0E02      	MOVLW 0x02
107A  6E70      	MOVWF delay_ms_00000_arg_del
107C  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x06, 0);
1080  0E06      	MOVLW 0x06
1082  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
1084  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
1086  EC17F002  	CALL FCD_04071__00066


	FCI_DELAYBYTE_MS(2);
108A  0E02      	MOVLW 0x02
108C  6E70      	MOVWF delay_ms_00000_arg_del
108E  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x0c, 0);
1092  0E0C      	MOVLW 0x0C
1094  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
1096  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
1098  EC17F002  	CALL FCD_04071__00066


	FCI_DELAYBYTE_MS(2);
109C  0E02      	MOVLW 0x02
109E  6E70      	MOVWF delay_ms_00000_arg_del
10A0  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x01, 0);
10A4  0E01      	MOVLW 0x01
10A6  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
10A8  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
10AA  EC17F002  	CALL FCD_04071__00066


	FCI_DELAYBYTE_MS(2);
10AE  0E02      	MOVLW 0x02
10B0  6E70      	MOVWF delay_ms_00000_arg_del
10B2  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__RawSend(0x02, 0);
10B6  0E02      	MOVLW 0x02
10B8  6E7F      	MOVWF FCD_04071__00066_arg_FCL_DATA
10BA  9180      	BCF FCD_04071__00066_arg_FCL_TYPE,0, 1
10BC  EC17F002  	CALL FCD_04071__00066


	FCI_DELAYBYTE_MS(2);
10C0  0E02      	MOVLW 0x02
10C2  6E70      	MOVWF delay_ms_00000_arg_del
10C4  EC0BF000  	CALL delay_ms_00000


	FCD_04071_LCD__Clear();
10C8  EC3AF005  	CALL FCD_04071__00061


}
10CC  0012      	RETURN



/*========================================================================*\
   Use :lcd_eb005
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :InjectorBase1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :Bluetooth2
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the 4 digit Bluetooth pair key based on a string of numbers.
       :e.g. "1234"
       :Returns 0 to indicate success
       :
       :Param??tres pour la macro SetPairKey :
       :  PairKey[5] : Key to use as the Pair key, e.g. "1234" or "0000"
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY)

{
	//Définitions des variables locales
	#define FCLsz_COMMANDSTR 20
	MX_CHAR FCL_COMMANDSTR[FCLsz_COMMANDSTR];
	MX_UINT8 FCR_RETVAL;


	FCI_SHEAD("AT+BTK=\"",9, FCL_PAIRKEY,FCLsz_PAIRKEY, FCL_COMMANDSTR,20);
09DC  0E22      	MOVLW 0x22
09DE  0100      	MOVLB 0x00
09E0  6F9B      	MOVWF CompTempVar2734+D'7', 1
09E2  0E2B      	MOVLW 0x2B
09E4  6F96      	MOVWF CompTempVar2734+D'2', 1
09E6  0E3D      	MOVLW 0x3D
09E8  6F9A      	MOVWF CompTempVar2734+D'6', 1
09EA  0E41      	MOVLW 0x41
09EC  6F94      	MOVWF CompTempVar2734, 1
09EE  0E42      	MOVLW 0x42
09F0  6F97      	MOVWF CompTempVar2734+D'3', 1
09F2  0E4B      	MOVLW 0x4B
09F4  6F99      	MOVWF CompTempVar2734+D'5', 1
09F6  0E54      	MOVLW 0x54
09F8  6F95      	MOVWF CompTempVar2734+D'1', 1
09FA  6F98      	MOVWF CompTempVar2734+D'4', 1
09FC  6B9C      	CLRF CompTempVar2734+D'8', 1
09FE  0E00      	MOVLW HIGH(CompTempVar2734+D'0')
0A00  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0A02  0E94      	MOVLW LOW(CompTempVar2734+D'0')
0A04  6E7A      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0A06  0E09      	MOVLW 0x09
0A08  6E7C      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0A0A  5070      	MOVF FCD_0c851__00078_arg_FCL_PAIRKEY, W
0A0C  6E7D      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0A0E  5071      	MOVF FCD_0c851__00078_arg_FCL_PAIRKEY+D'1', W
0A10  6E7E      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0A12  5077      	MOVF FCD_0c851__00078_arg_FCLsz_00079, W
0A14  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0A16  0E00      	MOVLW HIGH(FCD_0c851__00078_1_FCL_COM_0007A+D'0')
0A18  6F9E      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0A1A  0E80      	MOVLW LOW(FCD_0c851__00078_1_FCL_COM_0007A+D'0')
0A1C  6F9D      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0A1E  0E14      	MOVLW 0x14
0A20  6F9F      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0A22  ECF0F000  	CALL FCI_SHEAD_00000

	FCI_SHEAD(FCL_COMMANDSTR,FCLsz_COMMANDSTR, "\"",2, FCL_COMMANDSTR,20);
0A26  0E00      	MOVLW HIGH(FCD_0c851__00078_1_FCL_COM_0007A+D'0')
0A28  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0A2A  0E80      	MOVLW LOW(FCD_0c851__00078_1_FCL_COM_0007A+D'0')
0A2C  6E7A      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0A2E  0E14      	MOVLW 0x14
0A30  6E7C      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0A32  0E22      	MOVLW 0x22
0A34  6F94      	MOVWF CompTempVar2737, 1
0A36  6B95      	CLRF CompTempVar2737+D'1', 1
0A38  0E00      	MOVLW HIGH(CompTempVar2737+D'0')
0A3A  6E7E      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0A3C  0E94      	MOVLW LOW(CompTempVar2737+D'0')
0A3E  6E7D      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0A40  0E02      	MOVLW 0x02
0A42  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0A44  0E00      	MOVLW HIGH(FCD_0c851__00078_1_FCL_COM_0007A+D'0')
0A46  6F9E      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0A48  0E80      	MOVLW LOW(FCD_0c851__00078_1_FCL_COM_0007A+D'0')
0A4A  6F9D      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0A4C  0E14      	MOVLW 0x14
0A4E  6F9F      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0A50  ECF0F000  	CALL FCI_SHEAD_00000


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand(FCL_COMMANDSTR, FCLsz_COMMANDSTR, 1);
0A54  0E00      	MOVLW HIGH(FCD_0c851__00078_1_FCL_COM_0007A+D'0')
0A56  6E7B      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND+D'1'
0A58  0E80      	MOVLW LOW(FCD_0c851__00078_1_FCL_COM_0007A+D'0')
0A5A  6E7A      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND
0A5C  0E14      	MOVLW 0x14
0A5E  6E7C      	MOVWF FCD_0c851__00062_arg_FCLsz_00063
0A60  6A7D      	CLRF FCD_0c851__00062_arg_FCLsz_00063+D'1'
0A62  0E01      	MOVLW 0x01
0A64  6E7E      	MOVWF FCD_0c851__00062_arg_FCL_SENDCR
0A66  ECDFF001  	CALL FCD_0c851__00062
0A6A  5196      	MOVF CompTempVarRet2696, W, 1
0A6C  6E79      	MOVWF FCD_0c851__00078_1_FCR_RETVAL


	return (FCR_RETVAL);
0A6E  5079      	MOVF FCD_0c851__00078_1_FCR_RETVAL, W
0A70  6E7A      	MOVWF CompTempVarRet2733


	//Définitions des variables locales
	#undef FCLsz_COMMANDSTR
}
0A72  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Receives a single data byte from the Bluetooth module.
       :0xFF signifies no data available.
       :
       :Param??tres pour la macro ReceiveByte :
       :  Timeout : Amount of time to wait in milliseconds 0=Wait forever
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_COUNT = (0x0);
1184  6A5C      	CLRF FCD_0c851__00065_1_FCL_COUNT

	MX_UINT8 FCR_RETVAL;


	FCV_0c851_Bluetooth2__RX_DONE = 0;
1186  6A59      	CLRF gbl_FCV_0c851_Bluetooth2___00001


FCC_ReceiveByte_A:
1188            label152

;

	if (FCV_0c851_Bluetooth2__RX_IDX < FCV_0c851_Bluetooth2__RX_LENGTH)
1188  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
118A  6058      	CPFSLT gbl_FCV_0c851_Bluetooth2__RX_IDX
118C  D00A      	BRA	label153
11A2            label153

	{

		FCR_RETVAL = FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_IDX];
118E  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00000
1192  50E9      	MOVF FSR0L, W
1194  5058      	MOVF gbl_FCV_0c851_Bluetooth2__RX_IDX, W
1196  26E9      	ADDWF FSR0L, F
1198  50EF      	MOVF INDF0, W
119A  6E5D      	MOVWF FCD_0c851__00065_1_FCR_RETVAL


		FCV_0c851_Bluetooth2__RX_IDX = FCV_0c851_Bluetooth2__RX_IDX + 1;
119C  2858      	INCF gbl_FCV_0c851_Bluetooth2__RX_IDX, W
119E  6E58      	MOVWF gbl_FCV_0c851_Bluetooth2__RX_IDX


	} else {
11A0  D012      	BRA	label156
11C6            label156


		if (FCV_0c851_Bluetooth2__RX_LENGTH < 50)
11A2  0E32      	MOVLW 0x32
11A4  605A      	CPFSLT gbl_FCV_0c851_Bluetooth2___00002
11A6  D00C      	BRA	label155

		{

			if ((FCL_TIMEOUT == 0) || (FCL_COUNT < FCL_TIMEOUT))
11A8  525B      	MOVF FCD_0c851__00065_arg_FCL_TIMEOUT, F
11AA  E003      	BZ	label154
11AC  505B      	MOVF FCD_0c851__00065_arg_FCL_TIMEOUT, W
11AE  605C      	CPFSLT FCD_0c851__00065_1_FCL_COUNT
11B0  D007      	BRA	label155
11B2            label154
11C0            label155

			{

				FCI_DELAYBYTE_MS(1);
11B2  0E01      	MOVLW 0x01
11B4  6E70      	MOVWF delay_ms_00000_arg_del
11B6  EC0BF000  	CALL delay_ms_00000


				FCL_COUNT = FCL_COUNT + 1;
11BA  285C      	INCF FCD_0c851__00065_1_FCL_COUNT, W
11BC  6E5C      	MOVWF FCD_0c851__00065_1_FCL_COUNT


				goto FCC_ReceiveByte_A;
11BE  D7E4      	BRA	label152


			// } else {

			}

		// } else {

		}

		FCV_0c851_Bluetooth2__RX_IDX = 0;
11C0  6A58      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX

		FCV_0c851_Bluetooth2__RX_LENGTH = 0;
11C2  6A5A      	CLRF gbl_FCV_0c851_Bluetooth2___00002


		FCR_RETVAL = 255;
11C4  685D      	SETF FCD_0c851__00065_1_FCR_RETVAL


	}

	return (FCR_RETVAL);
11C6  505D      	MOVF FCD_0c851__00065_1_FCR_RETVAL, W
11C8  6E5E      	MOVWF CompTempVarRet2703


}
11CA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Send an AT command script.
       :Returns 0 for fail, 1 for success and 255 for unrecognised script idx.
       :
       :Param??tres pour la macro SendScript :
       :  idx : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX)

{
	//Définitions des variables locales
	MX_UINT8 FCL_I = (0x0);
0C4A  6A5C      	CLRF FCD_0c851__00054_1_FCL_I

	MX_UINT8 FCL_CH = (0xff);
0C4C  685D      	SETF FCD_0c851__00054_1_FCL_CH

	#define FCLsz_SCRIPT_STR 40
	MX_CHAR FCL_SCRIPT_STR[FCLsz_SCRIPT_STR];
	MX_UINT8 FCL_LEN = (0x0);
0C4E  6A5E      	CLRF FCD_0c851__00054_1_FCL_LEN

	MX_UINT8 FCR_RETVAL;


	if ((FCL_IDX < 1) || (FCL_IDX > 2))
0C50  0E01      	MOVLW 0x01
0C52  605B      	CPFSLT FCD_0c851__00054_arg_FCL_IDX
0C54  D001      	BRA	label118
0C56  D003      	BRA	label119
0C58            label118
0C58  0E02      	MOVLW 0x02
0C5A  645B      	CPFSGT FCD_0c851__00054_arg_FCL_IDX
0C5C  D002      	BRA	label120
0C5E            label119
0C62            label120
0C7C  D08E      	BRA	label126

	{

		FCR_RETVAL = 255;
0C5E  685F      	SETF FCD_0c851__00054_1_FCR_RETVAL


		goto FCC_SendScript_A;
0C60  D0E1      	BRA	label132


	// } else {

	}

	switch (FCL_IDX)
0DBE            label128

	{
		case 1:
0C62  045B      	DECF FCD_0c851__00054_arg_FCL_IDX, W
0C64  E00C      	BZ	label123
0C7E            label123

		{
			FCI_SCOPY("ATS0=1\r\nATR\r\nATS512=7\r\nATS536=1\r\nATS502=",41, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0C7E  0E0A      	MOVLW 0x0A
0C80  0100      	MOVLB 0x00
0C82  6FAF      	MOVWF CompTempVar2655+D'7', 1
0C84  6FB4      	MOVWF CompTempVar2655+D'12', 1
0C86  6FBE      	MOVWF CompTempVar2655+D'22', 1
0C88  6FC8      	MOVWF CompTempVar2655+D'32', 1
0C8A  0E0D      	MOVLW 0x0D
0C8C  6FAE      	MOVWF CompTempVar2655+D'6', 1
0C8E  6FB3      	MOVWF CompTempVar2655+D'11', 1
0C90  6FBD      	MOVWF CompTempVar2655+D'21', 1
0C92  6FC7      	MOVWF CompTempVar2655+D'31', 1
0C94  0E30      	MOVLW 0x30
0C96  6FAB      	MOVWF CompTempVar2655+D'3', 1
0C98  6FCD      	MOVWF CompTempVar2655+D'37', 1
0C9A  0E31      	MOVLW 0x31
0C9C  6FAD      	MOVWF CompTempVar2655+D'5', 1
0C9E  6FB9      	MOVWF CompTempVar2655+D'17', 1
0CA0  6FC6      	MOVWF CompTempVar2655+D'30', 1
0CA2  0E32      	MOVLW 0x32
0CA4  6FBA      	MOVWF CompTempVar2655+D'18', 1
0CA6  6FCE      	MOVWF CompTempVar2655+D'38', 1
0CA8  0E33      	MOVLW 0x33
0CAA  6FC3      	MOVWF CompTempVar2655+D'27', 1
0CAC  0E35      	MOVLW 0x35
0CAE  6FB8      	MOVWF CompTempVar2655+D'16', 1
0CB0  6FC2      	MOVWF CompTempVar2655+D'26', 1
0CB2  6FCC      	MOVWF CompTempVar2655+D'36', 1
0CB4  0E36      	MOVLW 0x36
0CB6  6FC4      	MOVWF CompTempVar2655+D'28', 1
0CB8  0E37      	MOVLW 0x37
0CBA  6FBC      	MOVWF CompTempVar2655+D'20', 1
0CBC  0E3D      	MOVLW 0x3D
0CBE  6FAC      	MOVWF CompTempVar2655+D'4', 1
0CC0  6FBB      	MOVWF CompTempVar2655+D'19', 1
0CC2  6FC5      	MOVWF CompTempVar2655+D'29', 1
0CC4  6FCF      	MOVWF CompTempVar2655+D'39', 1
0CC6  0E41      	MOVLW 0x41
0CC8  6FA8      	MOVWF CompTempVar2655, 1
0CCA  6FB0      	MOVWF CompTempVar2655+D'8', 1
0CCC  6FB5      	MOVWF CompTempVar2655+D'13', 1
0CCE  6FBF      	MOVWF CompTempVar2655+D'23', 1
0CD0  6FC9      	MOVWF CompTempVar2655+D'33', 1
0CD2  0E52      	MOVLW 0x52
0CD4  6FB2      	MOVWF CompTempVar2655+D'10', 1
0CD6  0E53      	MOVLW 0x53
0CD8  6FAA      	MOVWF CompTempVar2655+D'2', 1
0CDA  6FB7      	MOVWF CompTempVar2655+D'15', 1
0CDC  6FC1      	MOVWF CompTempVar2655+D'25', 1
0CDE  6FCB      	MOVWF CompTempVar2655+D'35', 1
0CE0  0E54      	MOVLW 0x54
0CE2  6FA9      	MOVWF CompTempVar2655+D'1', 1
0CE4  6FB1      	MOVWF CompTempVar2655+D'9', 1
0CE6  6FB6      	MOVWF CompTempVar2655+D'14', 1
0CE8  6FC0      	MOVWF CompTempVar2655+D'24', 1
0CEA  6FCA      	MOVWF CompTempVar2655+D'34', 1
0CEC  6BD0      	CLRF CompTempVar2655+D'40', 1
0CEE  0E00      	MOVLW HIGH(CompTempVar2655+D'0')
0CF0  6E61      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
0CF2  0EA8      	MOVLW LOW(CompTempVar2655+D'0')
0CF4  6E60      	MOVWF FCI_SCOPY_00000_arg_sSrc
0CF6  0E29      	MOVLW 0x29
0CF8  6E7C      	MOVWF FCI_SCOPY_00000_arg_iSrc_len
0CFA  0E00      	MOVLW HIGH(FCD_0c851__00054_1_FCL_SCR_00055+D'0')
0CFC  6E7E      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
0CFE  0E80      	MOVLW LOW(FCD_0c851__00054_1_FCL_SCR_00055+D'0')
0D00  6E7D      	MOVWF FCI_SCOPY_00000_arg_sDst
0D02  0E28      	MOVLW 0x28
0D04  6E7F      	MOVWF FCI_SCOPY_00000_arg_iDst_len
0D06  ECF1F003  	CALL FCI_SCOPY_00000


			break;
0D0A  D059      	BRA	label128

		}
		case 2:
0C66  0E02      	MOVLW 0x02
0C68  625B      	CPFSEQ FCD_0c851__00054_arg_FCL_IDX
0C6A  D001      	BRA	label121
0C6C  D04F      	BRA	label124
0C6E            label121
0D0C            label124

		{
			FCI_SCOPY("ATS531=2\r\nATA\r\nAT&W\r\nATZ0",26, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0D0C  0E0A      	MOVLW 0x0A
0D0E  6E6B      	MOVWF CompTempVar2658+D'9'
0D10  6E70      	MOVWF CompTempVar2658+D'14'
0D12  6E76      	MOVWF CompTempVar2658+D'20'
0D14  0E0D      	MOVLW 0x0D
0D16  6E6A      	MOVWF CompTempVar2658+D'8'
0D18  6E6F      	MOVWF CompTempVar2658+D'13'
0D1A  6E75      	MOVWF CompTempVar2658+D'19'
0D1C  0E26      	MOVLW 0x26
0D1E  6E73      	MOVWF CompTempVar2658+D'17'
0D20  0E30      	MOVLW 0x30
0D22  6E7A      	MOVWF CompTempVar2658+D'24'
0D24  0E31      	MOVLW 0x31
0D26  6E67      	MOVWF CompTempVar2658+D'5'
0D28  0E32      	MOVLW 0x32
0D2A  6E69      	MOVWF CompTempVar2658+D'7'
0D2C  0E33      	MOVLW 0x33
0D2E  6E66      	MOVWF CompTempVar2658+D'4'
0D30  0E35      	MOVLW 0x35
0D32  6E65      	MOVWF CompTempVar2658+D'3'
0D34  0E3D      	MOVLW 0x3D
0D36  6E68      	MOVWF CompTempVar2658+D'6'
0D38  0E41      	MOVLW 0x41
0D3A  6E62      	MOVWF CompTempVar2658
0D3C  6E6C      	MOVWF CompTempVar2658+D'10'
0D3E  6E6E      	MOVWF CompTempVar2658+D'12'
0D40  6E71      	MOVWF CompTempVar2658+D'15'
0D42  6E77      	MOVWF CompTempVar2658+D'21'
0D44  0E53      	MOVLW 0x53
0D46  6E64      	MOVWF CompTempVar2658+D'2'
0D48  0E54      	MOVLW 0x54
0D4A  6E63      	MOVWF CompTempVar2658+D'1'
0D4C  6E6D      	MOVWF CompTempVar2658+D'11'
0D4E  6E72      	MOVWF CompTempVar2658+D'16'
0D50  6E78      	MOVWF CompTempVar2658+D'22'
0D52  0E57      	MOVLW 0x57
0D54  6E74      	MOVWF CompTempVar2658+D'18'
0D56  0E5A      	MOVLW 0x5A
0D58  6E79      	MOVWF CompTempVar2658+D'23'
0D5A  6A7B      	CLRF CompTempVar2658+D'25'
0D5C  0E00      	MOVLW HIGH(CompTempVar2658+D'0')
0D5E  6E61      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
0D60  0E62      	MOVLW LOW(CompTempVar2658+D'0')
0D62  6E60      	MOVWF FCI_SCOPY_00000_arg_sSrc
0D64  0E1A      	MOVLW 0x1A
0D66  6E7C      	MOVWF FCI_SCOPY_00000_arg_iSrc_len
0D68  0E00      	MOVLW HIGH(FCD_0c851__00054_1_FCL_SCR_00055+D'0')
0D6A  6E7E      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
0D6C  0E80      	MOVLW LOW(FCD_0c851__00054_1_FCL_SCR_00055+D'0')
0D6E  6E7D      	MOVWF FCI_SCOPY_00000_arg_sDst
0D70  0E28      	MOVLW 0x28
0D72  6E7F      	MOVWF FCI_SCOPY_00000_arg_iDst_len
0D74  ECF1F003  	CALL FCI_SCOPY_00000


			break;
0D78  D022      	BRA	label128

		}
		case 3:
0C6E  0E03      	MOVLW 0x03
0C70  625B      	CPFSEQ FCD_0c851__00054_arg_FCL_IDX
0C72  D001      	BRA	label122
0C74  D082      	BRA	label125
0C76            label122
0D7A            label125

		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0D7A  6A62      	CLRF CompTempVar2661
0D7C  0E00      	MOVLW HIGH(CompTempVar2661+D'0')
0D7E  6E61      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
0D80  0E62      	MOVLW LOW(CompTempVar2661+D'0')
0D82  6E60      	MOVWF FCI_SCOPY_00000_arg_sSrc
0D84  0E01      	MOVLW 0x01
0D86  6E7C      	MOVWF FCI_SCOPY_00000_arg_iSrc_len
0D88  0E00      	MOVLW HIGH(FCD_0c851__00054_1_FCL_SCR_00055+D'0')
0D8A  6E7E      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
0D8C  0E80      	MOVLW LOW(FCD_0c851__00054_1_FCL_SCR_00055+D'0')
0D8E  6E7D      	MOVWF FCI_SCOPY_00000_arg_sDst
0D90  0E28      	MOVLW 0x28
0D92  6E7F      	MOVWF FCI_SCOPY_00000_arg_iDst_len
0D94  ECF1F003  	CALL FCI_SCOPY_00000


			break;
0D98  D012      	BRA	label128

		}
		case 4:
0C76  0E04      	MOVLW 0x04
0C78  625B      	CPFSEQ FCD_0c851__00054_arg_FCL_IDX
0C7A  D09F      	BRA	label127
0D9A            label126

		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);
0D9A  6A62      	CLRF CompTempVar2664
0D9C  0E00      	MOVLW HIGH(CompTempVar2664+D'0')
0D9E  6E61      	MOVWF FCI_SCOPY_00000_arg_sSrc+D'1'
0DA0  0E62      	MOVLW LOW(CompTempVar2664+D'0')
0DA2  6E60      	MOVWF FCI_SCOPY_00000_arg_sSrc
0DA4  0E01      	MOVLW 0x01
0DA6  6E7C      	MOVWF FCI_SCOPY_00000_arg_iSrc_len
0DA8  0E00      	MOVLW HIGH(FCD_0c851__00054_1_FCL_SCR_00055+D'0')
0DAA  6E7E      	MOVWF FCI_SCOPY_00000_arg_sDst+D'1'
0DAC  0E80      	MOVLW LOW(FCD_0c851__00054_1_FCL_SCR_00055+D'0')
0DAE  6E7D      	MOVWF FCI_SCOPY_00000_arg_sDst
0DB0  0E28      	MOVLW 0x28
0DB2  6E7F      	MOVWF FCI_SCOPY_00000_arg_iDst_len
0DB4  ECF1F003  	CALL FCI_SCOPY_00000


			break;
0DB8  D002      	BRA	label128

		}
		default:
0DBA            label127

		{
			FCR_RETVAL = 255;
0DBA  685F      	SETF FCD_0c851__00054_1_FCR_RETVAL


			goto FCC_SendScript_A;
0DBC  D033      	BRA	label132


		}
	}

	while (FCL_CH > 0)
0DBE  0E00      	MOVLW 0x00
0DC0  645D      	CPFSGT FCD_0c851__00054_1_FCL_CH
0DC2  D022      	BRA	label131
0E06  D7DB      	BRA	label128
0E08            label131

	{

		FCL_CH = FCL_SCRIPT_STR[FCL_I];
0DC4  EE00F080  	LFSR 0x00, FCD_0c851__00054_1_FCL_SCR_00055
0DC8  50E9      	MOVF FSR0L, W
0DCA  505C      	MOVF FCD_0c851__00054_1_FCL_I, W
0DCC  26E9      	ADDWF FSR0L, F
0DCE  50EF      	MOVF INDF0, W
0DD0  6E5D      	MOVWF FCD_0c851__00054_1_FCL_CH


		if ((FCL_CH > 0) && (FCL_CH != 0x0A))
0DD2  0E00      	MOVLW 0x00
0DD4  645D      	CPFSGT FCD_0c851__00054_1_FCL_CH
0DD6  D015      	BRA	label130
0DD8  0E0A      	MOVLW 0x0A
0DDA  625D      	CPFSEQ FCD_0c851__00054_1_FCL_CH
0DDC  D001      	BRA	label129
0DDE  D011      	BRA	label130
0DE0            label129

		{

			FC_CAL_UART_Send_1(FCL_CH);
0DE0  505D      	MOVF FCD_0c851__00054_1_FCL_CH, W
0DE2  6FA8      	MOVWF FC_CAL_UAR_00075_arg_nChar, 1
0DE4  6BA9      	CLRF FC_CAL_UAR_00075_arg_nChar+D'1', 1
0DE6  ECB0F000  	CALL FC_CAL_UAR_00075


			FCL_LEN = FCL_LEN + 1;
0DEA  285E      	INCF FCD_0c851__00054_1_FCL_LEN, W
0DEC  6E5E      	MOVWF FCD_0c851__00054_1_FCL_LEN


			if (FCL_CH == FCV_0c851_Bluetooth2__BT_CHAR_CR)
0DEE  0E0D      	MOVLW 0x0D
0DF0  625D      	CPFSEQ FCD_0c851__00054_1_FCL_CH
0DF2  D007      	BRA	label130
0E02            label130

			{

				#if (1) // 1 == 1

					FCD_0c851_Bluetooth2__StringReceive();
0DF4  ECC8F000  	CALL FCD_0c851__0007B


				// #else

				//Le code a été optimisé par le préprocesseur
				#endif

				FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
0DF8  ECC8F000  	CALL FCD_0c851__0007B
0DFC  51AB      	MOVF CompTempVarRet2742, W, 1
0DFE  6E5F      	MOVWF FCD_0c851__00054_1_FCR_RETVAL


				FCL_LEN = 0;
0E00  6A5E      	CLRF FCD_0c851__00054_1_FCL_LEN


			// } else {

			}

		// } else {

		}

		FCL_I = FCL_I + 1;
0E02  285C      	INCF FCD_0c851__00054_1_FCL_I, W
0E04  6E5C      	MOVWF FCD_0c851__00054_1_FCL_I



	}

	if (FCL_LEN > 0)
0E08  0E00      	MOVLW 0x00
0E0A  645E      	CPFSGT FCD_0c851__00054_1_FCL_LEN
0E0C  D00B      	BRA	label132
0E24            label132

	{

		FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);
0E0E  0E0D      	MOVLW 0x0D
0E10  6FA8      	MOVWF FC_CAL_UAR_00075_arg_nChar, 1
0E12  6BA9      	CLRF FC_CAL_UAR_00075_arg_nChar+D'1', 1
0E14  ECB0F000  	CALL FC_CAL_UAR_00075


		#if (1) // 1 == 1

			FCD_0c851_Bluetooth2__StringReceive();
0E18  ECC8F000  	CALL FCD_0c851__0007B


		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
0E1C  ECC8F000  	CALL FCD_0c851__0007B
0E20  51AB      	MOVF CompTempVarRet2742, W, 1
0E22  6E5F      	MOVWF FCD_0c851__00054_1_FCR_RETVAL


	// } else {

	}

FCC_SendScript_A:
;

	return (FCR_RETVAL);
0E24  505F      	MOVF FCD_0c851__00054_1_FCR_RETVAL, W
0E26  6E60      	MOVWF CompTempVarRet2654


	//Définitions des variables locales
	#undef FCLsz_SCRIPT_STR
}
0E28  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sends a command string to the GSM module.
       :0 = Command sent ok, 255 = No Reply
       :
       :Param??tres pour la macro SendCommand :
       :  Command[20] : MX_CHAR (by-ref)
       :  SendCR : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
03BE  6A7F      	CLRF FCD_0c851__00062_1_FCL_IDX

	MX_UINT8 FCL_LEN;
	MX_UINT8 FCR_RETVAL;


	while (1)
03C0            label43

	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
03C0  ECC8F000  	CALL FCD_0c851__0007B
03C4  51AB      	MOVF CompTempVarRet2742, W, 1
03C6  6F95      	MOVWF FCD_0c851__00062_1_FCR_RETVAL, 1



		if ((FCR_RETVAL) == 0) break;
03C8  5395      	MOVF FCD_0c851__00062_1_FCR_RETVAL, F, 1
03CA  E1FA      	BNZ	label43

	}

	FCL_LEN = FCI_GETLENGTH(FCL_COMMAND, FCLsz_COMMAND);
03CC  507A      	MOVF FCD_0c851__00062_arg_FCL_COMMAND, W
03CE  6F96      	MOVWF FCI_GETLEN_0003E_arg_sStr1, 1
03D0  507B      	MOVF FCD_0c851__00062_arg_FCL_COMMAND+D'1', W
03D2  6F97      	MOVWF FCI_GETLEN_0003E_arg_sStr1+D'1', 1
03D4  507C      	MOVF FCD_0c851__00062_arg_FCLsz_00063, W
03D6  6F98      	MOVWF FCI_GETLEN_0003E_arg_iStr1_len, 1
03D8  ECB8F000  	CALL FCI_GETLEN_0003E
03DC  519A      	MOVF CompTempVarRet1850, W, 1
03DE  6F94      	MOVWF FCD_0c851__00062_1_FCL_LEN, 1


	if (FCL_LEN)
03E0  5394      	MOVF FCD_0c851__00062_1_FCL_LEN, F, 1
03E2  E017      	BZ	label46
03E4            label44

	{

		while (FCL_IDX < FCL_LEN)
03E4  5194      	MOVF FCD_0c851__00062_1_FCL_LEN, W, 1
03E6  607F      	CPFSLT FCD_0c851__00062_1_FCL_IDX
03E8  D00D      	BRA	label45
0402  D7F0      	BRA	label44
0404            label45

		{

			FC_CAL_UART_Send_1(FCL_COMMAND[FCL_IDX]);
03EA  507B      	MOVF FCD_0c851__00062_arg_FCL_COMMAND+D'1', W
03EC  6EEA      	MOVWF FSR0H
03EE  507A      	MOVF FCD_0c851__00062_arg_FCL_COMMAND, W
03F0  247F      	ADDWF FCD_0c851__00062_1_FCL_IDX, W
03F2  6EE9      	MOVWF FSR0L
03F4  50EF      	MOVF INDF0, W
03F6  6FA8      	MOVWF FC_CAL_UAR_00075_arg_nChar, 1
03F8  6BA9      	CLRF FC_CAL_UAR_00075_arg_nChar+D'1', 1
03FA  ECB0F000  	CALL FC_CAL_UAR_00075


			FCL_IDX = FCL_IDX + 1;
03FE  287F      	INCF FCD_0c851__00062_1_FCL_IDX, W
0400  6E7F      	MOVWF FCD_0c851__00062_1_FCL_IDX



		}

		if (FCL_SENDCR)
0404  527E      	MOVF FCD_0c851__00062_arg_FCL_SENDCR, F
0406  E005      	BZ	label46
0412            label46

		{

			FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);
0408  0E0D      	MOVLW 0x0D
040A  6FA8      	MOVWF FC_CAL_UAR_00075_arg_nChar, 1
040C  6BA9      	CLRF FC_CAL_UAR_00075_arg_nChar+D'1', 1
040E  ECB0F000  	CALL FC_CAL_UAR_00075


		// } else {

		}

	// } else {

	}

	#if (1) // 1 == 1

		FCD_0c851_Bluetooth2__StringReceive();
0412  ECC8F000  	CALL FCD_0c851__0007B


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
0416  ECC8F000  	CALL FCD_0c851__0007B
041A  51AB      	MOVF CompTempVarRet2742, W, 1
041C  6F95      	MOVWF FCD_0c851__00062_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 0)
041E  5395      	MOVF FCD_0c851__00062_1_FCR_RETVAL, F, 1
0420  E102      	BNZ	label47
0426            label47

	{

		FCR_RETVAL = 255;
0422  6995      	SETF FCD_0c851__00062_1_FCR_RETVAL, 1


	} else {
0424  D001      	BRA	label48
0428            label48


		FCR_RETVAL = 0;
0426  6B95      	CLRF FCD_0c851__00062_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
0428  5195      	MOVF FCD_0c851__00062_1_FCR_RETVAL, W, 1
042A  6F96      	MOVWF CompTempVarRet2696, 1


}
042C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies the incoming data from the data string array to a local string variable.
       :
       :Param??tres pour la macro ReadString :
       :  NumBytes : MX_UINT8
       :
       :Renvoie : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);


	while ((FCL_IDX < FCL_NUMBYTES) && (FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX] > 0))
	{

		FCR_RETVAL[FCL_IDX] = FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX];
		FCL_IDX = FCL_IDX + 1;


	}

	if (FCL_IDX < FCL_NUMBYTES)
	{

		FCR_RETVAL[FCL_IDX] = 0;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Saves the current settings to firmware using the AT&W command followed by the ATZ command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&W", 5, 1);
097E  0E41      	MOVLW 0x41
0980  6E71      	MOVWF CompTempVar2750
0982  0E54      	MOVLW 0x54
0984  6E72      	MOVWF CompTempVar2750+D'1'
0986  0E26      	MOVLW 0x26
0988  6E73      	MOVWF CompTempVar2750+D'2'
098A  0E57      	MOVLW 0x57
098C  6E74      	MOVWF CompTempVar2750+D'3'
098E  6A75      	CLRF CompTempVar2750+D'4'
0990  0E00      	MOVLW HIGH(CompTempVar2750+D'0')
0992  6E7B      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND+D'1'
0994  0E71      	MOVLW LOW(CompTempVar2750+D'0')
0996  6E7A      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND
0998  0E05      	MOVLW 0x05
099A  6E7C      	MOVWF FCD_0c851__00062_arg_FCLsz_00063
099C  6A7D      	CLRF FCD_0c851__00062_arg_FCLsz_00063+D'1'
099E  0E01      	MOVLW 0x01
09A0  6E7E      	MOVWF FCD_0c851__00062_arg_FCL_SENDCR
09A2  ECDFF001  	CALL FCD_0c851__00062
09A6  5196      	MOVF CompTempVarRet2696, W, 1
09A8  6E70      	MOVWF FCD_0c851__0007F_1_FCR_RETVAL


	if (FCR_RETVAL == 0)
09AA  5270      	MOVF FCD_0c851__0007F_1_FCR_RETVAL, F
09AC  E114      	BNZ	label108
09D6            label108

	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATZ", 4, 1);
09AE  0E41      	MOVLW 0x41
09B0  6E71      	MOVWF CompTempVar2752
09B2  0E54      	MOVLW 0x54
09B4  6E72      	MOVWF CompTempVar2752+D'1'
09B6  0E5A      	MOVLW 0x5A
09B8  6E73      	MOVWF CompTempVar2752+D'2'
09BA  6A74      	CLRF CompTempVar2752+D'3'
09BC  0E00      	MOVLW HIGH(CompTempVar2752+D'0')
09BE  6E7B      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND+D'1'
09C0  0E71      	MOVLW LOW(CompTempVar2752+D'0')
09C2  6E7A      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND
09C4  0E04      	MOVLW 0x04
09C6  6E7C      	MOVWF FCD_0c851__00062_arg_FCLsz_00063
09C8  6A7D      	CLRF FCD_0c851__00062_arg_FCLsz_00063+D'1'
09CA  0E01      	MOVLW 0x01
09CC  6E7E      	MOVWF FCD_0c851__00062_arg_FCL_SENDCR
09CE  ECDFF001  	CALL FCD_0c851__00062
09D2  5196      	MOVF CompTempVarRet2696, W, 1
09D4  6E70      	MOVWF FCD_0c851__0007F_1_FCR_RETVAL


	// } else {

	}

	return (FCR_RETVAL);
09D6  5070      	MOVF FCD_0c851__0007F_1_FCR_RETVAL, W
09D8  6E71      	MOVWF CompTempVarRet2749


}
09DA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sends a single data byte out to the Bluetooth module.
       :
       :Param??tres pour la macro SendByte :
       :  Data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA)
{

	FC_CAL_UART_Send_1(FCL_DATA);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the bluetooth mode to be discoverable and or connectable.
       :Returns 0 for success.
       :
       :Param??tres pour la macro SetMode :
       :  Discoverable : 0 = Not Discoverable, 1 = Discoverable
       :  Connectable : 0 = Not Connectable, 1 = Connectable
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE)

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	if (FCL_DISCOVERABLE)
0872  5270      	MOVF FCD_0c851__00081_arg_FCL_D_00082, F
0874  E041      	BZ	label105
08F8            label105

	{

		if (FCL_CONNECTABLE)
0876  5271      	MOVF FCD_0c851__00081_arg_FCL_C_00083, F
0878  E020      	BZ	label104
08BA            label104

		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=4", 9, 1);
087A  0E41      	MOVLW 0x41
087C  0100      	MOVLB 0x00
087E  6F80      	MOVWF CompTempVar2755, 1
0880  0E54      	MOVLW 0x54
0882  6F81      	MOVWF CompTempVar2755+D'1', 1
0884  0E53      	MOVLW 0x53
0886  6F82      	MOVWF CompTempVar2755+D'2', 1
0888  0E35      	MOVLW 0x35
088A  6F83      	MOVWF CompTempVar2755+D'3', 1
088C  0E31      	MOVLW 0x31
088E  6F84      	MOVWF CompTempVar2755+D'4', 1
0890  0E32      	MOVLW 0x32
0892  6F85      	MOVWF CompTempVar2755+D'5', 1
0894  0E3D      	MOVLW 0x3D
0896  6F86      	MOVWF CompTempVar2755+D'6', 1
0898  0E34      	MOVLW 0x34
089A  6F87      	MOVWF CompTempVar2755+D'7', 1
089C  6B88      	CLRF CompTempVar2755+D'8', 1
089E  0E00      	MOVLW HIGH(CompTempVar2755+D'0')
08A0  6E7B      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND+D'1'
08A2  0E80      	MOVLW LOW(CompTempVar2755+D'0')
08A4  6E7A      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND
08A6  0E09      	MOVLW 0x09
08A8  6E7C      	MOVWF FCD_0c851__00062_arg_FCLsz_00063
08AA  6A7D      	CLRF FCD_0c851__00062_arg_FCLsz_00063+D'1'
08AC  0E01      	MOVLW 0x01
08AE  6E7E      	MOVWF FCD_0c851__00062_arg_FCL_SENDCR
08B0  ECDFF001  	CALL FCD_0c851__00062
08B4  5196      	MOVF CompTempVarRet2696, W, 1
08B6  6E72      	MOVWF FCD_0c851__00081_1_FCR_RETVAL


		} else {
08B8  D05F      	BRA	label107


			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 1);
08BA  0E31      	MOVLW 0x31
08BC  0100      	MOVLB 0x00
08BE  6F84      	MOVWF CompTempVar2757+D'4', 1
08C0  0E32      	MOVLW 0x32
08C2  6F85      	MOVWF CompTempVar2757+D'5', 1
08C4  6F87      	MOVWF CompTempVar2757+D'7', 1
08C6  0E35      	MOVLW 0x35
08C8  6F83      	MOVWF CompTempVar2757+D'3', 1
08CA  0E3D      	MOVLW 0x3D
08CC  6F86      	MOVWF CompTempVar2757+D'6', 1
08CE  0E41      	MOVLW 0x41
08D0  6F80      	MOVWF CompTempVar2757, 1
08D2  0E53      	MOVLW 0x53
08D4  6F82      	MOVWF CompTempVar2757+D'2', 1
08D6  0E54      	MOVLW 0x54
08D8  6F81      	MOVWF CompTempVar2757+D'1', 1
08DA  6B88      	CLRF CompTempVar2757+D'8', 1
08DC  0E00      	MOVLW HIGH(CompTempVar2757+D'0')
08DE  6E7B      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND+D'1'
08E0  0E80      	MOVLW LOW(CompTempVar2757+D'0')
08E2  6E7A      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND
08E4  0E09      	MOVLW 0x09
08E6  6E7C      	MOVWF FCD_0c851__00062_arg_FCLsz_00063
08E8  6A7D      	CLRF FCD_0c851__00062_arg_FCLsz_00063+D'1'
08EA  0E01      	MOVLW 0x01
08EC  6E7E      	MOVWF FCD_0c851__00062_arg_FCL_SENDCR
08EE  ECDFF001  	CALL FCD_0c851__00062
08F2  5196      	MOVF CompTempVarRet2696, W, 1
08F4  6E72      	MOVWF FCD_0c851__00081_1_FCR_RETVAL


		}

	} else {
08F6  D040      	BRA	label107


		if (FCL_CONNECTABLE)
08F8  5271      	MOVF FCD_0c851__00081_arg_FCL_C_00083, F
08FA  E01F      	BZ	label106
093A            label106

		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 3);
08FC  0E31      	MOVLW 0x31
08FE  0100      	MOVLB 0x00
0900  6F84      	MOVWF CompTempVar2759+D'4', 1
0902  0E32      	MOVLW 0x32
0904  6F85      	MOVWF CompTempVar2759+D'5', 1
0906  6F87      	MOVWF CompTempVar2759+D'7', 1
0908  0E35      	MOVLW 0x35
090A  6F83      	MOVWF CompTempVar2759+D'3', 1
090C  0E3D      	MOVLW 0x3D
090E  6F86      	MOVWF CompTempVar2759+D'6', 1
0910  0E41      	MOVLW 0x41
0912  6F80      	MOVWF CompTempVar2759, 1
0914  0E53      	MOVLW 0x53
0916  6F82      	MOVWF CompTempVar2759+D'2', 1
0918  0E54      	MOVLW 0x54
091A  6F81      	MOVWF CompTempVar2759+D'1', 1
091C  6B88      	CLRF CompTempVar2759+D'8', 1
091E  0E00      	MOVLW HIGH(CompTempVar2759+D'0')
0920  6E7B      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND+D'1'
0922  0E80      	MOVLW LOW(CompTempVar2759+D'0')
0924  6E7A      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND
0926  0E09      	MOVLW 0x09
0928  6E7C      	MOVWF FCD_0c851__00062_arg_FCLsz_00063
092A  6A7D      	CLRF FCD_0c851__00062_arg_FCLsz_00063+D'1'
092C  0E03      	MOVLW 0x03
092E  6E7E      	MOVWF FCD_0c851__00062_arg_FCL_SENDCR
0930  ECDFF001  	CALL FCD_0c851__00062
0934  5196      	MOVF CompTempVarRet2696, W, 1
0936  6E72      	MOVWF FCD_0c851__00081_1_FCR_RETVAL


		} else {
0938  D01F      	BRA	label107
0978            label107


			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=0", 9, 1);
093A  0E41      	MOVLW 0x41
093C  0100      	MOVLB 0x00
093E  6F80      	MOVWF CompTempVar2761, 1
0940  0E54      	MOVLW 0x54
0942  6F81      	MOVWF CompTempVar2761+D'1', 1
0944  0E53      	MOVLW 0x53
0946  6F82      	MOVWF CompTempVar2761+D'2', 1
0948  0E35      	MOVLW 0x35
094A  6F83      	MOVWF CompTempVar2761+D'3', 1
094C  0E31      	MOVLW 0x31
094E  6F84      	MOVWF CompTempVar2761+D'4', 1
0950  0E32      	MOVLW 0x32
0952  6F85      	MOVWF CompTempVar2761+D'5', 1
0954  0E3D      	MOVLW 0x3D
0956  6F86      	MOVWF CompTempVar2761+D'6', 1
0958  0E30      	MOVLW 0x30
095A  6F87      	MOVWF CompTempVar2761+D'7', 1
095C  6B88      	CLRF CompTempVar2761+D'8', 1
095E  0E00      	MOVLW HIGH(CompTempVar2761+D'0')
0960  6E7B      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND+D'1'
0962  0E80      	MOVLW LOW(CompTempVar2761+D'0')
0964  6E7A      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND
0966  0E09      	MOVLW 0x09
0968  6E7C      	MOVWF FCD_0c851__00062_arg_FCLsz_00063
096A  6A7D      	CLRF FCD_0c851__00062_arg_FCLsz_00063+D'1'
096C  0E01      	MOVLW 0x01
096E  6E7E      	MOVWF FCD_0c851__00062_arg_FCL_SENDCR
0970  ECDFF001  	CALL FCD_0c851__00062
0974  5196      	MOVF CompTempVarRet2696, W, 1
0976  6E72      	MOVWF FCD_0c851__00081_1_FCR_RETVAL


		}

	}

	return (FCR_RETVAL);
0978  5072      	MOVF FCD_0c851__00081_1_FCR_RETVAL, W
097A  6E73      	MOVWF CompTempVarRet2754


}
097C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to receive a string from the GSM modem terminated with a 0x10 CR character. Used to collect the replies from commands.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TOUT = (0x0);
0190  0100      	MOVLB 0x00
0192  6BA8      	CLRF FCD_0c851__0007B_1_FCL_TOUT, 1

	MX_UINT8 FCL_LEN = (0x0);
0194  6BA9      	CLRF FCD_0c851__0007B_1_FCL_LEN, 1

	MX_UINT8 FCR_RETVAL;


	FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
0196  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
0198  6FA9      	MOVWF FCD_0c851__0007B_1_FCL_LEN, 1

	FCV_0c851_Bluetooth2__RX_DONE = 0;
019A  6A59      	CLRF gbl_FCV_0c851_Bluetooth2___00001

	FCV_0c851_Bluetooth2__RX_LENGTH = 0;
019C  6A5A      	CLRF gbl_FCV_0c851_Bluetooth2___00002

	FCV_0c851_Bluetooth2__RX_IDX = 0;
019E  6A58      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX


	while ((FCV_0c851_Bluetooth2__RX_DONE == 0) && (FCL_TOUT < 255))
01A0            label21
01A0  5259      	MOVF gbl_FCV_0c851_Bluetooth2___00001, F
01A2  E113      	BNZ	label23
01A4  0EFF      	MOVLW 0xFF
01A6  61A8      	CPFSLT FCD_0c851__0007B_1_FCL_TOUT, 1
01A8  D010      	BRA	label23
01C8  D7EB      	BRA	label21
01CA            label23

	{

		FCL_TOUT = FCL_TOUT + 1;
01AA  29A8      	INCF FCD_0c851__0007B_1_FCL_TOUT, W, 1
01AC  6FA8      	MOVWF FCD_0c851__0007B_1_FCL_TOUT, 1


		if (FCL_LEN != FCV_0c851_Bluetooth2__RX_LENGTH)
01AE  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
01B0  63A9      	CPFSEQ FCD_0c851__0007B_1_FCL_LEN, 1
01B2  625A      	CPFSEQ gbl_FCV_0c851_Bluetooth2___00002
01B4  D003      	BRA	label22
01BC            label22

		{

			FCL_TOUT = 0;
01B6  6BA8      	CLRF FCD_0c851__0007B_1_FCL_TOUT, 1

			FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
01B8  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
01BA  6FA9      	MOVWF FCD_0c851__0007B_1_FCL_LEN, 1


		// } else {

		}

		FCI_DELAYINT_US(500);
01BC  0EF4      	MOVLW 0xF4
01BE  6FAB      	MOVWF FCI_DELAYI_00038_arg_Delay, 1
01C0  0E01      	MOVLW 0x01
01C2  6FAC      	MOVWF FCI_DELAYI_00038_arg_Delay+D'1', 1
01C4  EC95F000  	CALL FCI_DELAYI_00038



	}

	if (FCL_TOUT == 255)
01CA  29A8      	INCF FCD_0c851__0007B_1_FCL_TOUT, W, 1
01CC  E104      	BNZ	label24
01D6            label24

	{

		FCV_0c851_Bluetooth2__RX_DONE = 0;
01CE  6A59      	CLRF gbl_FCV_0c851_Bluetooth2___00001

		FCV_0c851_Bluetooth2__RX_LENGTH = 0;
01D0  6A5A      	CLRF gbl_FCV_0c851_Bluetooth2___00002

		FCR_RETVAL = 0;
01D2  6BAA      	CLRF FCD_0c851__0007B_1_FCR_RETVAL, 1


	} else {
01D4  D002      	BRA	label25
01DA            label25


		FCR_RETVAL = 1;
01D6  0E01      	MOVLW 0x01
01D8  6FAA      	MOVWF FCD_0c851__0007B_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
01DA  51AA      	MOVF FCD_0c851__0007B_1_FCR_RETVAL, W, 1
01DC  6FAB      	MOVWF CompTempVarRet2742, 1


}
01DE  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Restores the factory settings to firmware using the AT&F* command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&F*", 6, 1);
083C  0E41      	MOVLW 0x41
083E  6E71      	MOVWF CompTempVar2764
0840  0E54      	MOVLW 0x54
0842  6E72      	MOVWF CompTempVar2764+D'1'
0844  0E26      	MOVLW 0x26
0846  6E73      	MOVWF CompTempVar2764+D'2'
0848  0E46      	MOVLW 0x46
084A  6E74      	MOVWF CompTempVar2764+D'3'
084C  0E2A      	MOVLW 0x2A
084E  6E75      	MOVWF CompTempVar2764+D'4'
0850  6A76      	CLRF CompTempVar2764+D'5'
0852  0E00      	MOVLW HIGH(CompTempVar2764+D'0')
0854  6E7B      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND+D'1'
0856  0E71      	MOVLW LOW(CompTempVar2764+D'0')
0858  6E7A      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND
085A  0E06      	MOVLW 0x06
085C  6E7C      	MOVWF FCD_0c851__00062_arg_FCLsz_00063
085E  6A7D      	CLRF FCD_0c851__00062_arg_FCLsz_00063+D'1'
0860  0E01      	MOVLW 0x01
0862  6E7E      	MOVWF FCD_0c851__00062_arg_FCL_SENDCR
0864  ECDFF001  	CALL FCD_0c851__00062
0868  5196      	MOVF CompTempVarRet2696, W, 1
086A  6E70      	MOVWF FCD_0c851__00084_1_FCR_RETVAL


	return (FCR_RETVAL);
086C  5070      	MOVF FCD_0c851__00084_1_FCR_RETVAL, W
086E  6E71      	MOVWF CompTempVarRet2763


}
0870  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets up the GSM module.
       :Returns 0 for OK, 255 for no reply and 254 for command fail.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__Initialise()

{
	//Définitions des variables locales
	#define FCLsz_CMDSTR 20
	MX_CHAR FCL_CMDSTR[FCLsz_CMDSTR];
	MX_UINT8 FCR_RETVAL;


	FCP_SET(B, B, 0x2, 0x1, 0);
0E2A  6A70      	CLRF FCD_0c851__00052_2_ptmp
0E2C  9293      	BCF gbl_trisb,1
0E2E  5270      	MOVF FCD_0c851__00052_2_ptmp, F
0E30  E004      	BZ	label133
0E32  0E02      	MOVLW 0x02
0E34  108A      	IORWF gbl_latb, W
0E36  6E81      	MOVWF gbl_portb
0E38  D003      	BRA	label134
0E3A            label133
0E3A  0EFD      	MOVLW 0xFD
0E3C  148A      	ANDWF gbl_latb, W
0E3E  6E81      	MOVWF gbl_portb
0E40            label134


	FCI_DELAYBYTE_MS(100);
0E40  0E64      	MOVLW 0x64
0E42  6E70      	MOVWF delay_ms_00000_arg_del
0E44  EC0BF000  	CALL delay_ms_00000


	FCP_SET(B, B, 0x2, 0x1, 1);
0E48  0E01      	MOVLW 0x01
0E4A  6E70      	MOVWF FCD_0c851__00052_13_ptmp
0E4C  9293      	BCF gbl_trisb,1
0E4E  5270      	MOVF FCD_0c851__00052_13_ptmp, F
0E50  E004      	BZ	label135
0E52  0E02      	MOVLW 0x02
0E54  108A      	IORWF gbl_latb, W
0E56  6E81      	MOVWF gbl_portb
0E58  D003      	BRA	label136
0E5A            label135
0E5A  0EFD      	MOVLW 0xFD
0E5C  148A      	ANDWF gbl_latb, W
0E5E  6E81      	MOVWF gbl_portb
0E60            label136


	FCR_RETVAL = 0;
0E60  6A6F      	CLRF FCD_0c851__00052_1_FCR_RETVAL


	FC_CAL_UART_Init_1();
0E62  ECE6F003  	CALL FC_CAL_UAR_00076


	FCI_DELAYBYTE_MS(10);
0E66  0E0A      	MOVLW 0x0A
0E68  6E70      	MOVWF delay_ms_00000_arg_del
0E6A  EC0BF000  	CALL delay_ms_00000


	FCD_0c851_Bluetooth2__StringReceive();
0E6E  ECC8F000  	CALL FCD_0c851__0007B


	#if (1)

		FCD_0c851_Bluetooth2__RestoreFactorySettings();
0E72  EC1EF004  	CALL FCD_0c851__00084


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCI_SHEAD("AT+BTN=\"",9, "lool",5, FCL_CMDSTR,20);
0E76  0E22      	MOVLW 0x22
0E78  6F87      	MOVWF CompTempVar2642+D'7', 1
0E7A  0E2B      	MOVLW 0x2B
0E7C  6F82      	MOVWF CompTempVar2642+D'2', 1
0E7E  0E3D      	MOVLW 0x3D
0E80  6F86      	MOVWF CompTempVar2642+D'6', 1
0E82  0E41      	MOVLW 0x41
0E84  6F80      	MOVWF CompTempVar2642, 1
0E86  0E42      	MOVLW 0x42
0E88  6F83      	MOVWF CompTempVar2642+D'3', 1
0E8A  0E4E      	MOVLW 0x4E
0E8C  6F85      	MOVWF CompTempVar2642+D'5', 1
0E8E  0E54      	MOVLW 0x54
0E90  6F81      	MOVWF CompTempVar2642+D'1', 1
0E92  6F84      	MOVWF CompTempVar2642+D'4', 1
0E94  6B88      	CLRF CompTempVar2642+D'8', 1
0E96  0E00      	MOVLW HIGH(CompTempVar2642+D'0')
0E98  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0E9A  0E80      	MOVLW LOW(CompTempVar2642+D'0')
0E9C  6E7A      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0E9E  0E09      	MOVLW 0x09
0EA0  6E7C      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0EA2  0E6C      	MOVLW 0x6C
0EA4  6F89      	MOVWF CompTempVar2643, 1
0EA6  6F8C      	MOVWF CompTempVar2643+D'3', 1
0EA8  0E6F      	MOVLW 0x6F
0EAA  6F8A      	MOVWF CompTempVar2643+D'1', 1
0EAC  6F8B      	MOVWF CompTempVar2643+D'2', 1
0EAE  6B8D      	CLRF CompTempVar2643+D'4', 1
0EB0  0E00      	MOVLW HIGH(CompTempVar2643+D'0')
0EB2  6E7E      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0EB4  0E89      	MOVLW LOW(CompTempVar2643+D'0')
0EB6  6E7D      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0EB8  0E05      	MOVLW 0x05
0EBA  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0EBC  0E00      	MOVLW HIGH(FCD_0c851__00052_1_FCL_CMDSTR+D'0')
0EBE  6F9E      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0EC0  0E5B      	MOVLW LOW(FCD_0c851__00052_1_FCL_CMDSTR+D'0')
0EC2  6F9D      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0EC4  0E14      	MOVLW 0x14
0EC6  6F9F      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0EC8  ECF0F000  	CALL FCI_SHEAD_00000

	FCI_SHEAD(FCL_CMDSTR,FCLsz_CMDSTR, "\"",2, FCL_CMDSTR,20);
0ECC  0E00      	MOVLW HIGH(FCD_0c851__00052_1_FCL_CMDSTR+D'0')
0ECE  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0ED0  0E5B      	MOVLW LOW(FCD_0c851__00052_1_FCL_CMDSTR+D'0')
0ED2  6E7A      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0ED4  0E14      	MOVLW 0x14
0ED6  6E7C      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0ED8  0E22      	MOVLW 0x22
0EDA  6E71      	MOVWF CompTempVar2647
0EDC  6A72      	CLRF CompTempVar2647+D'1'
0EDE  0E00      	MOVLW HIGH(CompTempVar2647+D'0')
0EE0  6E7E      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0EE2  0E71      	MOVLW LOW(CompTempVar2647+D'0')
0EE4  6E7D      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0EE6  0E02      	MOVLW 0x02
0EE8  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0EEA  0E00      	MOVLW HIGH(FCD_0c851__00052_1_FCL_CMDSTR+D'0')
0EEC  6F9E      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0EEE  0E5B      	MOVLW LOW(FCD_0c851__00052_1_FCL_CMDSTR+D'0')
0EF0  6F9D      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0EF2  0E14      	MOVLW 0x14
0EF4  6F9F      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0EF6  ECF0F000  	CALL FCI_SHEAD_00000


	FCD_0c851_Bluetooth2__SendCommand(FCL_CMDSTR, FCLsz_CMDSTR, 1);
0EFA  0E00      	MOVLW HIGH(FCD_0c851__00052_1_FCL_CMDSTR+D'0')
0EFC  6E7B      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND+D'1'
0EFE  0E5B      	MOVLW LOW(FCD_0c851__00052_1_FCL_CMDSTR+D'0')
0F00  6E7A      	MOVWF FCD_0c851__00062_arg_FCL_COMMAND
0F02  0E14      	MOVLW 0x14
0F04  6E7C      	MOVWF FCD_0c851__00062_arg_FCLsz_00063
0F06  6A7D      	CLRF FCD_0c851__00062_arg_FCLsz_00063+D'1'
0F08  0E01      	MOVLW 0x01
0F0A  6E7E      	MOVWF FCD_0c851__00062_arg_FCL_SENDCR
0F0C  ECDFF001  	CALL FCD_0c851__00062


	FCD_0c851_Bluetooth2__SetPairKey("1379", 5);
0F10  0E31      	MOVLW 0x31
0F12  6E72      	MOVWF CompTempVar2652
0F14  0E33      	MOVLW 0x33
0F16  6E73      	MOVWF CompTempVar2652+D'1'
0F18  0E37      	MOVLW 0x37
0F1A  6E74      	MOVWF CompTempVar2652+D'2'
0F1C  0E39      	MOVLW 0x39
0F1E  6E75      	MOVWF CompTempVar2652+D'3'
0F20  6A76      	CLRF CompTempVar2652+D'4'
0F22  0E00      	MOVLW HIGH(CompTempVar2652+D'0')
0F24  6E71      	MOVWF FCD_0c851__00078_arg_FCL_PAIRKEY+D'1'
0F26  0E72      	MOVLW LOW(CompTempVar2652+D'0')
0F28  6E70      	MOVWF FCD_0c851__00078_arg_FCL_PAIRKEY
0F2A  0E05      	MOVLW 0x05
0F2C  6E77      	MOVWF FCD_0c851__00078_arg_FCLsz_00079
0F2E  6A78      	CLRF FCD_0c851__00078_arg_FCLsz_00079+D'1'
0F30  ECEEF004  	CALL FCD_0c851__00078


	FCD_0c851_Bluetooth2__SetMode(1, 1);
0F34  0E01      	MOVLW 0x01
0F36  6E70      	MOVWF FCD_0c851__00081_arg_FCL_D_00082
0F38  6E71      	MOVWF FCD_0c851__00081_arg_FCL_C_00083
0F3A  EC39F004  	CALL FCD_0c851__00081


	FCR_RETVAL = FCD_0c851_Bluetooth2__SaveSettings();
0F3E  ECBFF004  	CALL FCD_0c851__0007F
0F42  5071      	MOVF CompTempVarRet2749, W
0F44  6E6F      	MOVWF FCD_0c851__00052_1_FCR_RETVAL


	return (FCR_RETVAL);
0F46  506F      	MOVF FCD_0c851__00052_1_FCR_RETVAL, W
0F48  6E70      	MOVWF CompTempVarRet2641


	//Définitions des variables locales
	#undef FCLsz_CMDSTR
}
0F4A  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Convertir un tableau de donn??e en cha??ne de caract??res
       :
       :Param??tres pour la macro CONVERT_TABLE_STRING :
       :  var_table[255] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCM_CONVERT_TABLE_STRING(MX_CHAR *PFCL_VAR_TABLE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_VAR_ASCII_RETURN;
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_VAR_TABLE 255
	MX_CHAR FCL_VAR_TABLE[FCLsz_VAR_TABLE];
	FCI_CONCATENATE(PFCL_VAR_TABLE,FCLsz_VAR_TABLE,"",0,FCL_VAR_TABLE,FCLsz_VAR_TABLE);
	// Calcul
	// Calcul:

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_VAR_TABLE
}

/*=----------------------------------------------------------------------=*\
   Use :Initialisation de tout les modules tel que le Bluetooth ou encore de LCD etc...
\*=----------------------------------------------------------------------=*/
void FCM_INITIALISATION()

{

	//Commentaire:
	//BT4

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::Initialise()
	FCD_0c851_Bluetooth2__Initialise();
10CE  EC15F007  	CALL FCD_0c851__00052


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Start()
	FCD_0ad31_lcd_eb005__Start();
10D2  ECD5F007  	CALL FCD_04071__00053


	// Pause
	// Pause: 1 s
	FCI_DELAYBYTE_S(1);
10D6  0E01      	MOVLW 0x01
10D8  6E5B      	MOVWF delay_s_00000_arg_del
10DA  EC33F000  	CALL delay_s_00000


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendScript(1)
	FCD_0c851_Bluetooth2__SendScript(1);
10DE  0E01      	MOVLW 0x01
10E0  6E5B      	MOVWF FCD_0c851__00054_arg_FCL_IDX
10E2  EC25F006  	CALL FCD_0c851__00054


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::SendScript(2)
	FCD_0c851_Bluetooth2__SendScript(2);
10E6  0E02      	MOVLW 0x02
10E8  6E5B      	MOVWF FCD_0c851__00054_arg_FCL_IDX
10EA  EC25F006  	CALL FCD_0c851__00054


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Initialisation...")
	FCD_0ad31_lcd_eb005__PrintString("Initialisation...", 18);
10EE  0E2E      	MOVLW 0x2E
10F0  6E77      	MOVWF CompTempVar2637+D'14'
10F2  6E78      	MOVWF CompTempVar2637+D'15'
10F4  6E79      	MOVWF CompTempVar2637+D'16'
10F6  0E49      	MOVLW 0x49
10F8  6E69      	MOVWF CompTempVar2637
10FA  0E61      	MOVLW 0x61
10FC  6E6E      	MOVWF CompTempVar2637+D'5'
10FE  6E72      	MOVWF CompTempVar2637+D'9'
1100  0E69      	MOVLW 0x69
1102  6E6B      	MOVWF CompTempVar2637+D'2'
1104  6E6D      	MOVWF CompTempVar2637+D'4'
1106  6E70      	MOVWF CompTempVar2637+D'7'
1108  6E74      	MOVWF CompTempVar2637+D'11'
110A  0E6C      	MOVLW 0x6C
110C  6E6F      	MOVWF CompTempVar2637+D'6'
110E  0E6E      	MOVLW 0x6E
1110  6E6A      	MOVWF CompTempVar2637+D'1'
1112  6E76      	MOVWF CompTempVar2637+D'13'
1114  0E6F      	MOVLW 0x6F
1116  6E75      	MOVWF CompTempVar2637+D'12'
1118  0E73      	MOVLW 0x73
111A  6E71      	MOVWF CompTempVar2637+D'8'
111C  0E74      	MOVLW 0x74
111E  6E6C      	MOVWF CompTempVar2637+D'3'
1120  6E73      	MOVWF CompTempVar2637+D'10'
1122  6A7A      	CLRF CompTempVar2637+D'17'
1124  0E00      	MOVLW HIGH(CompTempVar2637+D'0')
1126  6E68      	MOVWF FCD_04071__00056_arg_FCL_TEXT+D'1'
1128  0E69      	MOVLW LOW(CompTempVar2637+D'0')
112A  6E67      	MOVWF FCD_04071__00056_arg_FCL_TEXT
112C  0E12      	MOVLW 0x12
112E  6E7B      	MOVWF FCD_04071__00056_arg_FCLsz_TEXT
1130  6A7C      	CLRF FCD_04071__00056_arg_FCLsz_TEXT+D'1'
1132  ECB9F007  	CALL FCD_04071__00056


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Cursor(0, 1)
	FCD_0ad31_lcd_eb005__Cursor(0, 1);
1136  6A5B      	CLRF FCD_04071__00057_arg_FCL_X
1138  0E01      	MOVLW 0x01
113A  6E5C      	MOVWF FCD_04071__00057_arg_FCL_Y
113C  ECA6F007  	CALL FCD_04071__00057


	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Player (1)")
	FCD_0ad31_lcd_eb005__PrintString("Player (1)", 11);
1140  0E50      	MOVLW 0x50
1142  6E69      	MOVWF CompTempVar2639
1144  0E6C      	MOVLW 0x6C
1146  6E6A      	MOVWF CompTempVar2639+D'1'
1148  0E61      	MOVLW 0x61
114A  6E6B      	MOVWF CompTempVar2639+D'2'
114C  0E79      	MOVLW 0x79
114E  6E6C      	MOVWF CompTempVar2639+D'3'
1150  0E65      	MOVLW 0x65
1152  6E6D      	MOVWF CompTempVar2639+D'4'
1154  0E72      	MOVLW 0x72
1156  6E6E      	MOVWF CompTempVar2639+D'5'
1158  0E20      	MOVLW 0x20
115A  6E6F      	MOVWF CompTempVar2639+D'6'
115C  0E28      	MOVLW 0x28
115E  6E70      	MOVWF CompTempVar2639+D'7'
1160  0E31      	MOVLW 0x31
1162  6E71      	MOVWF CompTempVar2639+D'8'
1164  0E29      	MOVLW 0x29
1166  6E72      	MOVWF CompTempVar2639+D'9'
1168  6A73      	CLRF CompTempVar2639+D'10'
116A  0E00      	MOVLW HIGH(CompTempVar2639+D'0')
116C  6E68      	MOVWF FCD_04071__00056_arg_FCL_TEXT+D'1'
116E  0E69      	MOVLW LOW(CompTempVar2639+D'0')
1170  6E67      	MOVWF FCD_04071__00056_arg_FCL_TEXT
1172  0E0B      	MOVLW 0x0B
1174  6E7B      	MOVWF FCD_04071__00056_arg_FCLsz_TEXT
1176  6A7C      	CLRF FCD_04071__00056_arg_FCLsz_TEXT+D'1'
1178  ECB9F007  	CALL FCD_04071__00056


	// Appel d'une Macro
	// Appel d'une Macro: SET_ASCII_CHARATERS()
	FCM_SET_ASCII_CHARATERS();
117C  EC4EF005  	CALL FCM_SET_AS_00058


	#if 0 // Disabled code
	// Boucle
	// Boucle: While 1
	while (1)
	{

		// Calcul
		// Calcul:
		//  octet = 0
		FCV_OCTET = 0;

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();

		// Appel de la Routine Composant
		// Appel de la Routine Composant: octet=Bluetooth2::ReceiveByte(20)
		FCV_OCTET = FCD_0c851_Bluetooth2__ReceiveByte(20);

		// Appel de la Routine Composant
		// Appel de la Routine Composant: return=Bluetooth2::ReadString(octet)
		FCD_0c851_Bluetooth2__ReadString(FCV_RETURN,20, FCV_OCTET);

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString(return)
		FCD_0ad31_lcd_eb005__PrintString(FCV_RETURN, FCVsz_RETURN);

		#if 0 // Disabled code
		// Pause
		// Pause: 1 s
		FCI_DELAYBYTE_S(1);

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Calcul
		// Calcul:
		//  loop = loop + 1
		FCV_LOOP = FCV_LOOP + 1;

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Décision
		// Décision: loop >= 15?
		if (FCV_LOOP >= 15)
		{

			#if 0 // Disabled code
			// Calcul
			// Calcul:
			//  loop = 0
			FCV_LOOP = 0;

			#endif // #if 0: Disabled code
			#if 0 // Disabled code
			// Appel de la Routine Composant
			// Appel de la Routine Composant: Bluetooth2::SendCommand("salut", 0)
			FCD_0c851_Bluetooth2__SendCommand("salut", 6, 0);

			#endif // #if 0: Disabled code
		// } else {

		}

		#endif // #if 0: Disabled code

	}

	#endif // #if 0: Disabled code
}
1180  EF07F009  	GOTO	label158


/*=----------------------------------------------------------------------=*\
   Use :V??rification de la connexion entre les deux modules bluetooth
\*=----------------------------------------------------------------------=*/
void FCM_BT_CHECK_CONNECTON()
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_BT_DATA_RECEIVER()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Convertir une valeur binaire en caract??re ascii
       :
       :Param??tres pour la macro CONVERT_BINARY_ASCII :
       :  var_binary[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCM_CONVERT_BINARY_ASCII(MX_CHAR *PFCL_VAR_BINARY)
{
	//Définitions des variables locales
	MX_UINT8 FCL_VAR_ASCII_RETURN;
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_VAR_BINARY 20
	MX_CHAR FCL_VAR_BINARY[FCLsz_VAR_BINARY];
	FCI_CONCATENATE(PFCL_VAR_BINARY,FCLsz_VAR_BINARY,"",0,FCL_VAR_BINARY,FCLsz_VAR_BINARY);
	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_VAR_BINARY
}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_SET_ASCII_CHARATERS()

{

	// Calcul
	// Calcul:
	//  ascii[48] = 0
	//  ascii[49] = 1
	//  ascii[50] = 2
	//  ascii[51] = 3
	//  ascii[52] = 4
	//  ascii[53] = 5
	//  ascii[54] = 6
	//  ascii[55] = 7
	//  ascii[56] = 8
	//  ascii[57] = 9
	//  ascii[58] = 10
	FCV_ASCII[48] = 0;
0A9C  0101      	MOVLB 0x01
0A9E  6B30      	CLRF gbl_FCV_ASCII+D'48', 1

	FCV_ASCII[49] = 1;
0AA0  0E01      	MOVLW 0x01
0AA2  6F31      	MOVWF gbl_FCV_ASCII+D'49', 1

	FCV_ASCII[50] = 2;
0AA4  0E02      	MOVLW 0x02
0AA6  6F32      	MOVWF gbl_FCV_ASCII+D'50', 1

	FCV_ASCII[51] = 3;
0AA8  0E03      	MOVLW 0x03
0AAA  6F33      	MOVWF gbl_FCV_ASCII+D'51', 1

	FCV_ASCII[52] = 4;
0AAC  0E04      	MOVLW 0x04
0AAE  6F34      	MOVWF gbl_FCV_ASCII+D'52', 1

	FCV_ASCII[53] = 5;
0AB0  0E05      	MOVLW 0x05
0AB2  6F35      	MOVWF gbl_FCV_ASCII+D'53', 1

	FCV_ASCII[54] = 6;
0AB4  0E06      	MOVLW 0x06
0AB6  6F36      	MOVWF gbl_FCV_ASCII+D'54', 1

	FCV_ASCII[55] = 7;
0AB8  0E07      	MOVLW 0x07
0ABA  6F37      	MOVWF gbl_FCV_ASCII+D'55', 1

	FCV_ASCII[56] = 8;
0ABC  0E08      	MOVLW 0x08
0ABE  6F38      	MOVWF gbl_FCV_ASCII+D'56', 1

	FCV_ASCII[57] = 9;
0AC0  0E09      	MOVLW 0x09
0AC2  6F39      	MOVWF gbl_FCV_ASCII+D'57', 1

	FCV_ASCII[58] = 10;
0AC4  0E0A      	MOVLW 0x0A
0AC6  6F3A      	MOVWF gbl_FCV_ASCII+D'58', 1


}
0AC8  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_CHECK_BT_GETTING()
{

}

/*=----------------------------------------------------------------------=*\
   Use :Connection des deux modules entre eux
\*=----------------------------------------------------------------------=*/
void FCM_BT_CONNECTION()
{

	// Boucle
	// Boucle: While bt_state != 0
	while (FCV_BT_STATE != 0)
	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString("Connection...")
		FCD_0ad31_lcd_eb005__PrintString("Connection...", 14);

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Cursor(0, 1)
		FCD_0ad31_lcd_eb005__Cursor(0, 1);

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintString("Please wait...")
		FCD_0ad31_lcd_eb005__PrintString("Please wait...", 15);

		//Commentaire:
		//On se connete automatiquement au module bluetooth du joueur 2

		#if 0 // Disabled code
		// Appel de la Routine Composant
		// Appel de la Routine Composant: command_return=Bluetooth2::SendCommand("ATD0080980B9388", 1)
		FCV_COMMAND_RETURN = FCD_0c851_Bluetooth2__SendCommand("ATD0080980B9388", 16, 1);

		#endif // #if 0: Disabled code
		// Appel de la Routine Composant
		// Appel de la Routine Composant: Bluetooth2::SendCommand("ATA", 1)
		FCD_0c851_Bluetooth2__SendCommand("ATA", 4, 1);

		// Pause
		// Pause: 1 s
		FCI_DELAYBYTE_S(1);

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();

		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintNumber(command_return)
		FCD_0ad31_lcd_eb005__PrintNumber(FCV_COMMAND_RETURN);

		// Calcul
		// Calcul:
		//  bt_state = command_return
		FCV_BT_STATE = FCV_COMMAND_RETURN;


	}

	// Pause
	// Pause: 5 s
	FCI_DELAYBYTE_S(5);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Clear()
	FCD_0ad31_lcd_eb005__Clear();

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("Connected to")
	FCD_0ad31_lcd_eb005__PrintString("Connected to", 13);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Cursor(0, 1)
	FCD_0ad31_lcd_eb005__Cursor(0, 1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString("player (2)")
	FCD_0ad31_lcd_eb005__PrintString("player (2)", 11);

	// Pause
	// Pause: 1 s
	FCI_DELAYBYTE_S(1);

	//Commentaire:
	//DEBUG

	// Boucle
	// Boucle: While 1
	while (1)
	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: command_return=Bluetooth2::ReceiveByte(0)
		FCV_COMMAND_RETURN = FCD_0c851_Bluetooth2__ReceiveByte(0);

		// Calcul
		// Calcul:


	}

}



/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
1204  0E0F      	MOVLW 0x0F
1206  6EC1      	MOVWF gbl_adcon1





	// Appel d'une Macro
	// Appel d'une Macro: INITIALISATION()
	FCM_INITIALISATION();
1208  0E99      	MOVLW 0x99
120A  EF67F008  	GOTO	FCM_INITIA_00051
120E            label158


	//Commentaire:
	//S DEBUG

	// Boucle
	// Boucle: While 1
	while (1)
122E  D7EF      	BRA	label158

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: octet=Bluetooth2::ReceiveByte(0)
		FCV_OCTET = FCD_0c851_Bluetooth2__ReceiveByte(0);
120E  6A5B      	CLRF FCD_0c851__00065_arg_FCL_TIMEOUT
1210  ECC2F008  	CALL FCD_0c851__00065
1214  505E      	MOVF CompTempVarRet2703, W
1216  6E56      	MOVWF gbl_FCV_OCTET


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::PrintNumber(octet)
		FCD_0ad31_lcd_eb005__PrintNumber(FCV_OCTET);
1218  5056      	MOVF gbl_FCV_OCTET, W
121A  6E5B      	MOVWF FCD_04071__00064_arg_FCL_NUMBER
121C  6A5C      	CLRF FCD_04071__00064_arg_FCL_NUMBER+D'1'
121E  ECE6F008  	CALL FCD_04071__00064


		// Pause
		// Pause: 250 ms
		FCI_DELAYBYTE_MS(250);
1222  0EFA      	MOVLW 0xFA
1224  6E70      	MOVWF delay_ms_00000_arg_del
1226  EC0BF000  	CALL delay_ms_00000


		// Appel de la Routine Composant
		// Appel de la Routine Composant: lcd_eb005::Clear()
		FCD_0ad31_lcd_eb005__Clear();
122A  EC3AF005  	CALL FCD_04071__00061



	}

	//Commentaire:
	//F DEBUG

	#if 0 // Disabled code
	// Appel d'une Macro
	// Appel d'une Macro: BT_CONNECTION()
	FCM_BT_CONNECTION();

	#endif // #if 0: Disabled code
	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

	MX_UART_INT_CH1_FUNC

	MX_UINT8 FCL_BT_IN;
1284  CFEAF001  	MOVFF FSR0H,  Int1Context
1288  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
128C  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
1290  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'


	FCL_BT_IN = MX_UART_INT_CH1_DET;
1294  0E20      	MOVLW 0x20
1296  149E      	ANDWF gbl_pir1, W
1298  0100      	MOVLB 0x00
129A  6FD6      	MOVWF CompTempVar2767, 1
129C  0E20      	MOVLW 0x20
129E  149D      	ANDWF gbl_pie1, W
12A0  6FD5      	MOVWF CompTempVar2766, 1
12A2  6BD4      	CLRF interrupt_1_FCL_BT_IN, 1
12A4  53D5      	MOVF CompTempVar2766, F, 1
12A6  A4D8      	BTFSS STATUS,Z
12A8  53D6      	MOVF CompTempVar2767, F, 1
12AA  A4D8      	BTFSS STATUS,Z
12AC  2BD4      	INCF interrupt_1_FCL_BT_IN, F, 1


	if (FCL_BT_IN)
12AE  53D4      	MOVF interrupt_1_FCL_BT_IN, F, 1
12B0  E022      	BZ	label162
12F6            label162

	{

	FCL_BT_IN = FC_CAL_UART_Receive_1(1);
12B2  0E01      	MOVLW 0x01
12B4  6FD5      	MOVWF FC_CAL_UAR_00074_arg_nTimeout, 1
12B6  EC46F000  	CALL FC_CAL_UAR_00074
12BA  51DE      	MOVF CompTempVarRet2728, W, 1
12BC  6FD4      	MOVWF interrupt_1_FCL_BT_IN, 1


	if (FCV_0c851_Bluetooth2__RX_DONE == 0)
12BE  5259      	MOVF gbl_FCV_0c851_Bluetooth2___00001, F
12C0  E119      	BNZ	label161

	{

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 50)
12C2  0E32      	MOVLW 0x32
12C4  605A      	CPFSLT gbl_FCV_0c851_Bluetooth2___00002
12C6  D016      	BRA	label161

		{

			if (FCL_BT_IN == 0x0A)
12C8  0E0A      	MOVLW 0x0A
12CA  63D4      	CPFSEQ interrupt_1_FCL_BT_IN, 1
12CC  D00A      	BRA	label160
12E2            label160

			{

				FCV_0c851_Bluetooth2__RX_DONE = 1;
12CE  0E01      	MOVLW 0x01
12D0  6E59      	MOVWF gbl_FCV_0c851_Bluetooth2___00001

				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = 0;
12D2  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00000
12D6  50E9      	MOVF FSR0L, W
12D8  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
12DA  26E9      	ADDWF FSR0L, F
12DC  0E00      	MOVLW 0x00
12DE  6EEF      	MOVWF INDF0


			} else {
12E0  D009      	BRA	label161
12F4            label161


				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = FCL_BT_IN;
12E2  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00000
12E6  50E9      	MOVF FSR0L, W
12E8  505A      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
12EA  26E9      	ADDWF FSR0L, F
12EC  51D4      	MOVF interrupt_1_FCL_BT_IN, W, 1
12EE  6EEF      	MOVWF INDF0

				FCV_0c851_Bluetooth2__RX_LENGTH = FCV_0c851_Bluetooth2__RX_LENGTH + 1;
12F0  285A      	INCF gbl_FCV_0c851_Bluetooth2___00002, W
12F2  6E5A      	MOVWF gbl_FCV_0c851_Bluetooth2___00002


			}

		// } else {

		}

	// } else {

	}

	MX_UART_INT_CH1_CLR;
12F4  9A9E      	BCF gbl_pir1,5


	}

	MX_UART_INT_FUNC_END
}
12F6  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
12FA  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
12FE  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
1302  C001FFEA  	MOVFF Int1Context,  FSR0H
1306  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
07CC  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
07CE  0E7F      	MOVLW 0x7F
07D0  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
07D2  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
07D4  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
07D6  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
07D8  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
07DA  8A9D      	BSF gbl_pie1,5

				st_bit(intcon, PEIE);
07DC  8CF2      	BSF gbl_intcon,6

				st_bit(intcon, GIE);
07DE  8EF2      	BSF gbl_intcon,7

			#else
				cr_bit (pie1, RCIE);
			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
07E0  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
0160            label18
0160  0E10      	MOVLW 0x10
0162  149E      	ANDWF gbl_pir1, W
0164  6FAA      	MOVWF CompTempVar2732, 1
0166  53AA      	MOVF CompTempVar2732, F, 1
0168  E0FB      	BZ	label18


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
016A  51A8      	MOVF FC_CAL_UAR_00075_arg_nChar, W, 1
016C  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
016E  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
008C  69D6      	SETF FC_CAL_UAR_00074_1_retVal, 1

  #endif

	MX_UINT8 delay1 = 0;
008E  6BD7      	CLRF FC_CAL_UAR_00074_1_delay1, 1

	MX_UINT8 regcheck = 0;
0090  6BD8      	CLRF FC_CAL_UAR_00074_1_regcheck, 1

	MX_UINT8 bWaitForever = 0;
0092  6BD9      	CLRF FC_CAL_UAR_00074_1_bWaitForever, 1

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
0094  6BDA      	CLRF FC_CAL_UAR_00074_1_rxStatus, 1

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0096  6BDD      	CLRF FC_CAL_UAR_00074_1_dummy, 1

  #endif

	if (nTimeout == 255)
0098  29D5      	INCF FC_CAL_UAR_00074_arg_nTimeout, W, 1
009A  E102      	BNZ	label5
00A0            label5

		bWaitForever = 1;
009C  0E01      	MOVLW 0x01
009E  6FD9      	MOVWF FC_CAL_UAR_00074_1_bWaitForever, 1


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00A0  53DA      	MOVF FC_CAL_UAR_00074_1_rxStatus, F, 1
00A2  E124      	BNZ	label10
00EA  D7DA      	BRA	label5
00EC            label10

	{
		if (bWaitForever == 0)
00A4  53D9      	MOVF FC_CAL_UAR_00074_1_bWaitForever, F, 1
00A6  E118      	BNZ	label9

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00A8  53D5      	MOVF FC_CAL_UAR_00074_arg_nTimeout, F, 1
00AA  E103      	BNZ	label6
00B2            label6

			{
				rxStatus = UART_STATUS_TIMEOUT;
00AC  0E01      	MOVLW 0x01
00AE  6FDA      	MOVWF FC_CAL_UAR_00074_1_rxStatus, 1

			}
			else
00B0  D013      	BRA	label9

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00B2  6BDB      	CLRF FC_CAL_UAR_00074_1_delaycnt, 1
00B4  6BDC      	CLRF FC_CAL_UAR_00074_1_delaycnt+D'1', 1
00B6            label7
00B6  0E31      	MOVLW 0x31
00B8  5DDB      	SUBWF FC_CAL_UAR_00074_1_delaycnt, W, 1
00BA  E205      	BC	label8
00BC  67DC      	TSTFSZ FC_CAL_UAR_00074_1_delaycnt+D'1', 1
00BE  D003      	BRA	label8
00C0  4BDB      	INFSNZ FC_CAL_UAR_00074_1_delaycnt, F, 1
00C2  2BDC      	INCF FC_CAL_UAR_00074_1_delaycnt+D'1', F, 1
00C4  D7F8      	BRA	label7
00C6            label8

				delay1 = delay1 + 1;
00C6  29D7      	INCF FC_CAL_UAR_00074_1_delay1, W, 1
00C8  6FD7      	MOVWF FC_CAL_UAR_00074_1_delay1, 1

				if(delay1 == 100)
00CA  0E64      	MOVLW 0x64
00CC  63D7      	CPFSEQ FC_CAL_UAR_00074_1_delay1, 1
00CE  D004      	BRA	label9
00D8            label9

				{
					nTimeout = nTimeout - 1;
00D0  05D5      	DECF FC_CAL_UAR_00074_arg_nTimeout, W, 1
00D2  6FD5      	MOVWF FC_CAL_UAR_00074_arg_nTimeout, 1

					MX_CLEAR_WATCHDOG;
00D4  0004      	CLRWDT

					delay1 = 0;
00D6  6BD7      	CLRF FC_CAL_UAR_00074_1_delay1, 1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00D8  0E20      	MOVLW 0x20
00DA  149E      	ANDWF gbl_pir1, W
00DC  6FDE      	MOVWF CompTempVar2729, 1
00DE  51DE      	MOVF CompTempVar2729, W, 1
00E0  6FD8      	MOVWF FC_CAL_UAR_00074_1_regcheck, 1

			if (regcheck != 0)
00E2  53D8      	MOVF FC_CAL_UAR_00074_1_regcheck, F, 1
00E4  E0DD      	BZ	label5

				rxStatus = UART_STATUS_RXBYTE;
00E6  0E02      	MOVLW 0x02
00E8  6FDA      	MOVWF FC_CAL_UAR_00074_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00EC  0E02      	MOVLW 0x02
00EE  63DA      	CPFSEQ FC_CAL_UAR_00074_1_rxStatus, 1
00F0  D018      	BRA	label13

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
00F2  0E04      	MOVLW 0x04
00F4  14AB      	ANDWF gbl_rcsta, W
00F6  6FDE      	MOVWF CompTempVar2730, 1
00F8  51DE      	MOVF CompTempVar2730, W, 1
00FA  6FD8      	MOVWF FC_CAL_UAR_00074_1_regcheck, 1

			if (regcheck != 0)
00FC  53D8      	MOVF FC_CAL_UAR_00074_1_regcheck, F, 1
00FE  E003      	BZ	label11
0106            label11

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0100  50AE      	MOVF gbl_rcreg, W
0102  6FDD      	MOVWF FC_CAL_UAR_00074_1_dummy, 1

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0104  D00E      	BRA	label13

			{
				regcheck = ts_bit(rcsta, OERR);
0106  0E02      	MOVLW 0x02
0108  14AB      	ANDWF gbl_rcsta, W
010A  6FDE      	MOVWF CompTempVar2731, 1
010C  51DE      	MOVF CompTempVar2731, W, 1
010E  6FD8      	MOVWF FC_CAL_UAR_00074_1_regcheck, 1

				if (regcheck != 0)
0110  53D8      	MOVF FC_CAL_UAR_00074_1_regcheck, F, 1
0112  E003      	BZ	label12
011A            label12

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0114  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0116  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0118  D004      	BRA	label13
0122            label13

				{
					retVal = 0;
011A  6BD6      	CLRF FC_CAL_UAR_00074_1_retVal, 1


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
011C  50AE      	MOVF gbl_rcreg, W
011E  11D6      	IORWF FC_CAL_UAR_00074_1_retVal, W, 1
0120  6FD6      	MOVWF FC_CAL_UAR_00074_1_retVal, 1

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0122  51D6      	MOVF FC_CAL_UAR_00074_1_retVal, W, 1
0124  6FDE      	MOVWF CompTempVarRet2728, 1
0126  6BDF      	CLRF CompTempVarRet2728+D'1', 1

}
0128  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF18F009  	GOTO	_startup

0008  EF42F009  	GOTO	interrupt
000C            delay_us_00000
000C            ; { delay_us ; function begin
000C            label1
000C  0000      	NOP
000E  0000      	NOP
0010  2FAD      	DECFSZ delay_us_00000_arg_del, F, 1
0012  D7FC      	BRA	label1
0014  0012      	RETURN
0016            ; } delay_us function end

0016            delay_ms_00000
0016            ; { delay_ms ; function begin
0016  5270      	MOVF delay_ms_00000_arg_del, F
0018  0000      	NOP
001A  E101      	BNZ	label2
001C  0012      	RETURN
001E            label2
001E  0EF5      	MOVLW 0xF5
0020            label3
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0000      	NOP
0040  0FFF      	ADDLW 0xFF
0042  A4D8      	BTFSS STATUS,Z
0044  D7ED      	BRA	label3
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  0000      	NOP
0058  0000      	NOP
005A  0000      	NOP
005C  0000      	NOP
005E  0000      	NOP
0060  2E70      	DECFSZ delay_ms_00000_arg_del, F
0062  D7DD      	BRA	label2
0064  0012      	RETURN
0066            ; } delay_ms function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6E70      	MOVWF delay_ms_00000_arg_del
006A  EC0BF000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6E70      	MOVWF delay_ms_00000_arg_del
0072  EC0BF000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6E70      	MOVWF delay_ms_00000_arg_del
007A  EC0BF000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6E70      	MOVWF delay_ms_00000_arg_del
0082  EC0BF000  	CALL delay_ms_00000
0086  2E5B      	DECFSZ delay_s_00000_arg_del, F
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end

















































06EA            __mul_32_3_00009
06EA            ; { __mul_32_32 ; function begin
06EA  6B86      	CLRF CompTempVarRet414, 1
06EC  6B87      	CLRF CompTempVarRet414+D'1', 1
06EE  6B88      	CLRF CompTempVarRet414+D'2', 1
06F0  6B89      	CLRF CompTempVarRet414+D'3', 1
06F2  6B88      	CLRF CompTempVarRet414+D'2', 1
06F4  6B89      	CLRF CompTempVarRet414+D'3', 1
06F6  507A      	MOVF __mul_32_3_00009_arg_a, W
06F8  0380      	MULWF __mul_32_3_00009_arg_b, 1
06FA  50F3      	MOVF gbl_prodl, W
06FC  6F86      	MOVWF CompTempVarRet414, 1
06FE  50F4      	MOVF gbl_prodh, W
0700  6F87      	MOVWF CompTempVarRet414+D'1', 1
0702  507B      	MOVF __mul_32_3_00009_arg_a+D'1', W
0704  0380      	MULWF __mul_32_3_00009_arg_b, 1
0706  50F3      	MOVF gbl_prodl, W
0708  2787      	ADDWF CompTempVarRet414+D'1', F, 1
070A  50F4      	MOVF gbl_prodh, W
070C  2388      	ADDWFC CompTempVarRet414+D'2', F, 1
070E  B0D8      	BTFSC gbl_status,0
0710  2B89      	INCF CompTempVarRet414+D'3', F, 1
0712  507C      	MOVF __mul_32_3_00009_arg_a+D'2', W
0714  0380      	MULWF __mul_32_3_00009_arg_b, 1
0716  50F3      	MOVF gbl_prodl, W
0718  2788      	ADDWF CompTempVarRet414+D'2', F, 1
071A  50F4      	MOVF gbl_prodh, W
071C  2389      	ADDWFC CompTempVarRet414+D'3', F, 1
071E  507D      	MOVF __mul_32_3_00009_arg_a+D'3', W
0720  0380      	MULWF __mul_32_3_00009_arg_b, 1
0722  50F3      	MOVF gbl_prodl, W
0724  2789      	ADDWF CompTempVarRet414+D'3', F, 1
0726  507A      	MOVF __mul_32_3_00009_arg_a, W
0728  0381      	MULWF __mul_32_3_00009_arg_b+D'1', 1
072A  50F3      	MOVF gbl_prodl, W
072C  2787      	ADDWF CompTempVarRet414+D'1', F, 1
072E  50F4      	MOVF gbl_prodh, W
0730  2388      	ADDWFC CompTempVarRet414+D'2', F, 1
0732  B0D8      	BTFSC gbl_status,0
0734  2B89      	INCF CompTempVarRet414+D'3', F, 1
0736  507B      	MOVF __mul_32_3_00009_arg_a+D'1', W
0738  0381      	MULWF __mul_32_3_00009_arg_b+D'1', 1
073A  50F3      	MOVF gbl_prodl, W
073C  2788      	ADDWF CompTempVarRet414+D'2', F, 1
073E  50F4      	MOVF gbl_prodh, W
0740  2389      	ADDWFC CompTempVarRet414+D'3', F, 1
0742  507C      	MOVF __mul_32_3_00009_arg_a+D'2', W
0744  0381      	MULWF __mul_32_3_00009_arg_b+D'1', 1
0746  50F3      	MOVF gbl_prodl, W
0748  2789      	ADDWF CompTempVarRet414+D'3', F, 1
074A  507A      	MOVF __mul_32_3_00009_arg_a, W
074C  0382      	MULWF __mul_32_3_00009_arg_b+D'2', 1
074E  50F3      	MOVF gbl_prodl, W
0750  2788      	ADDWF CompTempVarRet414+D'2', F, 1
0752  50F4      	MOVF gbl_prodh, W
0754  2389      	ADDWFC CompTempVarRet414+D'3', F, 1
0756  507B      	MOVF __mul_32_3_00009_arg_a+D'1', W
0758  0382      	MULWF __mul_32_3_00009_arg_b+D'2', 1
075A  50F3      	MOVF gbl_prodl, W
075C  2789      	ADDWF CompTempVarRet414+D'3', F, 1
075E  507A      	MOVF __mul_32_3_00009_arg_a, W
0760  0383      	MULWF __mul_32_3_00009_arg_b+D'3', 1
0762  50F3      	MOVF gbl_prodl, W
0764  2789      	ADDWF CompTempVarRet414+D'3', F, 1
0766  0012      	RETURN
0768            ; } __mul_32_32 function end

0768            __div_32_3_00004
0768            ; { __div_32_32 ; function begin
0768  6B84      	CLRF __div_32_3_00004_1_r, 1
076A  6B85      	CLRF __div_32_3_00004_1_r+D'1', 1
076C  6B86      	CLRF __div_32_3_00004_1_r+D'2', 1
076E  6B87      	CLRF __div_32_3_00004_1_r+D'3', 1
0770  6B88      	CLRF CompTempVarRet172, 1
0772  6B89      	CLRF CompTempVarRet172+D'1', 1
0774  6B8A      	CLRF CompTempVarRet172+D'2', 1
0776  6B8B      	CLRF CompTempVarRet172+D'3', 1
0778  6A7E      	CLRF __div_32_3_00004_1_i
077A            label99
077A  0E20      	MOVLW 0x20
077C  147E      	ANDWF __div_32_3_00004_1_i, W
077E  6E7F      	MOVWF CompTempVar174
0780  667F      	TSTFSZ CompTempVar174
0782  0012      	RETURN
0784  90D8      	BCF STATUS,C
0786  3788      	RLCF CompTempVarRet172, F, 1
0788  3789      	RLCF CompTempVarRet172+D'1', F, 1
078A  378A      	RLCF CompTempVarRet172+D'2', F, 1
078C  378B      	RLCF CompTempVarRet172+D'3', F, 1
078E  367A      	RLCF __div_32_3_00004_arg_a, F
0790  367B      	RLCF __div_32_3_00004_arg_a+D'1', F
0792  367C      	RLCF __div_32_3_00004_arg_a+D'2', F
0794  367D      	RLCF __div_32_3_00004_arg_a+D'3', F
0796  3784      	RLCF __div_32_3_00004_1_r, F, 1
0798  3785      	RLCF __div_32_3_00004_1_r+D'1', F, 1
079A  3786      	RLCF __div_32_3_00004_1_r+D'2', F, 1
079C  3787      	RLCF __div_32_3_00004_1_r+D'3', F, 1
079E  5183      	MOVF __div_32_3_00004_arg_b+D'3', W, 1
07A0  5D87      	SUBWF __div_32_3_00004_1_r+D'3', W, 1
07A2  E108      	BNZ	label100
07A4  5182      	MOVF __div_32_3_00004_arg_b+D'2', W, 1
07A6  5D86      	SUBWF __div_32_3_00004_1_r+D'2', W, 1
07A8  E105      	BNZ	label100
07AA  5181      	MOVF __div_32_3_00004_arg_b+D'1', W, 1
07AC  5D85      	SUBWF __div_32_3_00004_1_r+D'1', W, 1
07AE  E102      	BNZ	label100
07B0  5180      	MOVF __div_32_3_00004_arg_b, W, 1
07B2  5D84      	SUBWF __div_32_3_00004_1_r, W, 1
07B4            label100
07B4  E309      	BNC	label101
07B6  5180      	MOVF __div_32_3_00004_arg_b, W, 1
07B8  5F84      	SUBWF __div_32_3_00004_1_r, F, 1
07BA  5181      	MOVF __div_32_3_00004_arg_b+D'1', W, 1
07BC  5B85      	SUBWFB __div_32_3_00004_1_r+D'1', F, 1
07BE  5182      	MOVF __div_32_3_00004_arg_b+D'2', W, 1
07C0  5B86      	SUBWFB __div_32_3_00004_1_r+D'2', F, 1
07C2  5183      	MOVF __div_32_3_00004_arg_b+D'3', W, 1
07C4  5B87      	SUBWFB __div_32_3_00004_1_r+D'3', F, 1
07C6  8188      	BSF CompTempVarRet172,0, 1
07C8            label101
07C8  2A7E      	INCF __div_32_3_00004_1_i, F
07CA  D7D7      	BRA	label99
07CC            ; } __div_32_32 function end



















































1230            _startup
1230  0ED5      	MOVLW 0xD5
1232  6E37      	MOVWF gbl_14_LSR
1234  0EC4      	MOVLW 0xC4
1236  6E38      	MOVWF gbl_14_LSR+D'1'
1238  0EBB      	MOVLW 0xBB
123A  6E39      	MOVWF gbl_14_LSR+D'2'
123C  0EDC      	MOVLW 0xDC
123E  6E3A      	MOVWF gbl_14_LSR+D'3'
1240  6A3B      	CLRF gbl_15_gbl_aSig
1242  6A3C      	CLRF gbl_15_gbl_aSig+D'1'
1244  6A3D      	CLRF gbl_15_gbl_aSig+D'2'
1246  6A3E      	CLRF gbl_15_gbl_aSig+D'3'
1248  6A3F      	CLRF gbl_15_gbl_bSig
124A  6A40      	CLRF gbl_15_gbl_bSig+D'1'
124C  6A41      	CLRF gbl_15_gbl_bSig+D'2'
124E  6A42      	CLRF gbl_15_gbl_bSig+D'3'
1250  6A43      	CLRF gbl_15_gbl_zSig
1252  6A44      	CLRF gbl_15_gbl_zSig+D'1'
1254  6A45      	CLRF gbl_15_gbl_zSig+D'2'
1256  6A46      	CLRF gbl_15_gbl_zSig+D'3'
1258  6A50      	CLRF gbl_15_gbl_aExp
125A  6A51      	CLRF gbl_15_gbl_bExp
125C  6A4B      	CLRF gbl_15_gbl_zExp
125E  6A4C      	CLRF gbl_15_gbl_zExp+D'1'
1260  6A52      	CLRF gbl_15_gbl_aSign
1262  6A53      	CLRF gbl_15_gbl_bSign
1264  6A54      	CLRF gbl_15_gbl_zSign
1266  6A55      	CLRF gbl_15_gbl_zSigZero
1268  6A47      	CLRF gbl_15_gbl_ret
126A  6A48      	CLRF gbl_15_gbl_ret+D'1'
126C  6A49      	CLRF gbl_15_gbl_ret+D'2'
126E  6A4A      	CLRF gbl_15_gbl_ret+D'3'
1270  6A4E      	CLRF gbl_float_rounding_mode
1272  6A4F      	CLRF gbl_float_exception_flags
1274  6A4D      	CLRF gbl_float_detect_tininess




1280  EF02F009  	GOTO	main




300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  78FF      	DW 0x78FF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
