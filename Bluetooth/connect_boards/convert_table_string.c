//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BOYER\PROJET\Bluetooth\connect_boards\convert_table_string.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Monday, March 27, 2017 17:10:18
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0xFB
#endif
#ifdef HI_TECH_C
__CONFIG(0xFB);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_CHAR 20
#define FCVsz_OCTET 20
#define FCVsz_RESULT_STRING 255
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_CHAR_ENTRIES;
MX_GLOBAL MX_UINT8 FCV_LOOP_COUNT_2 = (0x1);
MX_GLOBAL MX_CHAR FCV_CHAR[FCVsz_CHAR];
MX_GLOBAL MX_UINT8 FCV_OCTET[FCVsz_OCTET];
MX_GLOBAL MX_UINT8 FCV_LOOP_COUNT = (0x2);
MX_GLOBAL MX_CHAR FCV_RESULT_STRING[FCVsz_RESULT_STRING];
MX_GLOBAL MX_SINT16 FCV_RESULT_OCTET = (0);


/*========================================================================*\
   Use :ctrl_lcd
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_eb005
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCD_0ad31_lcd_eb005__Clear FCD_04071_LCD__Clear
#define FCD_0ad31_lcd_eb005__PrintString FCD_04071_LCD__PrintString
#define FCD_0ad31_lcd_eb005__PrintAscii FCD_04071_LCD__PrintAscii
#define FCD_0ad31_lcd_eb005__PrintNumber FCD_04071_LCD__PrintNumber
#define FCD_0ad31_lcd_eb005__RAMWrite FCD_04071_LCD__RAMWrite
#define FCD_0ad31_lcd_eb005__ClearLine FCD_04071_LCD__ClearLine
#define FCD_0ad31_lcd_eb005__Cursor FCD_04071_LCD__Cursor
#define FCD_0ad31_lcd_eb005__Command FCD_04071_LCD__Command
#define FCD_0ad31_lcd_eb005__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
#define FCD_0ad31_lcd_eb005__ScrollDisplay FCD_04071_LCD__ScrollDisplay
#define FCD_0ad31_lcd_eb005__RawSend FCD_04071_LCD__RawSend
#define FCD_0ad31_lcd_eb005__Start FCD_04071_LCD__Start

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :ctrl_lcd
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()
{




	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Param??tres pour la macro PrintString :
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_COUNT;



	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

	while (FCL_IDX < FCL_COUNT)
	{

		FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);

		FCL_IDX = FCL_IDX + 1;


	}


}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Param??tres pour la macro PrintAscii :
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)
{
	//Définitions des variables locales
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Param??tres pour la macro RAMWrite :
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Param??tres pour la macro ClearLine :
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_X;


	if (FCL_LINE < 2)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 16)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Param??tres pour la macro Cursor :
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{



	#if (0) // 2 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (1) // 2 == 2

		if (FCL_Y == 0)
		{

			FCL_Y = 0x80;

		} else {

			FCL_Y = 0xC0;

		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 2 == 4

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Param??tres pour la macro Command :
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.
       :Signed = -2147483648 to 2147483647
       :Unsigned = 0 to 4294967295
       :
       :Param??tres pour la macro PrintFormattedNumber :
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Définitions des variables locales
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Définitions des variables locales
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Param??tres pour la macro ScrollDisplay :
       :  Position : Holds the number of positions to shift the display
       :  direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Définitions des variables locales
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	switch (FCL_DIRECTION)
	{
		case 0:
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'l':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'L':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 1:
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'r':
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'R':
		{
			FCL_CMD = 0x1C;


			break;
		}
		// default:

	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Param??tres pour la macro RawSend :
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{
	//Définitions des variables locales
	MX_UINT8 FCL_NIBBLE;


	//Commentaire:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
		FCP_SET(B, A, 0x2, 0x1, 0);
		FCP_SET(B, A, 0x4, 0x2, 0);
		FCP_SET(B, A, 0x8, 0x3, 0);
		FCP_SET(B, A, 0x10, 0x4, 0);
		FCP_SET(B, A, 0x20, 0x5, 0);

		#if (0)

		//Le code a été optimisé par le préprocesseur
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	//Commentaire:
	//Output byte to pins

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	//Commentaire:
	//Output byte to port

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	if (FCL_TYPE)
	{

		FCP_SET(B, A, 0x10, 0x4, 1);

	// } else {

	}

	FCI_DELAYBYTE_US(100);

	//Commentaire:
	//Set Enable high, pause then set low
	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, A, 0x20, 0x5, 1);

	FCI_DELAYBYTE_US(100);

	FCP_SET(B, A, 0x20, 0x5, 0);

	FCI_DELAYBYTE_US(100);

	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
		FCP_SET(B, A, 0x2, 0x1, 0);
		FCP_SET(B, A, 0x4, 0x2, 0);
		FCP_SET(B, A, 0x8, 0x3, 0);
		FCP_SET(B, A, 0x10, 0x4, 0);

		FCL_NIBBLE = (FCL_DATA & 0xf);
		FCP_SET(B, A, 0x1, 0x0, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x2, 0x1, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x4, 0x2, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, A, 0x8, 0x3, (FCL_NIBBLE & 0x01));

		if (FCL_TYPE)
		{

			FCP_SET(B, A, 0x10, 0x4, 1);

		// } else {

		}

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, A, 0x20, 0x5, 1);

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, A, 0x20, 0x5, 0);

		FCI_DELAYBYTE_US(100);

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()
{



	#if (1) // 0 == 0

		FCP_SET(B, A, 0x1, 0x0, 0);
		FCP_SET(B, A, 0x2, 0x1, 0);
		FCP_SET(B, A, 0x4, 0x2, 0);
		FCP_SET(B, A, 0x8, 0x3, 0);
		FCP_SET(B, A, 0x10, 0x4, 0);
		FCP_SET(B, A, 0x20, 0x5, 0);

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0) // 0 == 2

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	#if (0)

	//Le code a été optimisé par le préprocesseur
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	#if (0) // 0 > 0

	//Le code a été optimisé par le préprocesseur
	#else

		FCD_04071_LCD__RawSend(0x32, 0);

		FCI_DELAYBYTE_MS(2);

		FCD_04071_LCD__RawSend(0x2c, 0);

	#endif

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x06, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x0c, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__Clear();

}


/*========================================================================*\
   Use :lcd_eb005
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/


/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()
{
adcon1 = 0x0F;




	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::Start()
	FCD_0ad31_lcd_eb005__Start();

	// Calcul
	// Calcul:
	//  char[0] = 0b01010111
	//  char[1] = 0b11101010
	//  char[2] = 0b00010101
	//  char[3] = 0b11111101
	//  char_entries = Length$ (char)
	//  result_string[0] = '['
	FCV_CHAR[0] = 87;
	FCV_CHAR[1] = 234;
	FCV_CHAR[2] = 21;
	FCV_CHAR[3] = 253;
	FCV_CHAR_ENTRIES = FCI_GETLENGTH(FCV_CHAR, FCVsz_CHAR);
	FCV_RESULT_STRING[0] = '[';

	// Boucle
	// Boucle: While result_octet < char_entries
	while (FCV_RESULT_OCTET < FCV_CHAR_ENTRIES)
	{

		// Calcul
		// Calcul:
		//  octet = NumberToHex$ (char[result_octet])
		FCV_OCTET = FCI_NUMBER_TO_HEX(FCV_CHAR[FCV_RESULT_OCTET], %[opn0%tmp%],%[len0%tsz%]);

		// Code C
		// Code C:
		// Convertir l'hexa en décimal j'en ai marre
		hexa = FCV_OCTET;
		FCV_OCTET = Convert.ToInt32(hexa, 16);

		// Calcul
		// Calcul:
		//  result_string[loop_count_2] = StringToInt$ (octet)
		//  result_string[loop_count] = ','
		//  // Incrémentations
		//  result_octet = result_octet + 1
		//  loop_count = loop_count + 2
		//  loop_count_2 = loop_count_2 + 2
		FCV_RESULT_STRING[FCV_LOOP_COUNT_2] = FCI_STRING_TO_INT(FCV_OCTET, FCVsz_OCTET);
		FCV_RESULT_STRING[FCV_LOOP_COUNT] = ',';
		FCV_RESULT_OCTET = FCV_RESULT_OCTET + 1;
		FCV_LOOP_COUNT = FCV_LOOP_COUNT + 2;
		FCV_LOOP_COUNT_2 = FCV_LOOP_COUNT_2 + 2;


	}

	// Calcul
	// Calcul:
	//  result_string[loop_count - 2] = ']'
	FCV_RESULT_STRING[FCV_LOOP_COUNT - 2] = ']';

	// Appel de la Routine Composant
	// Appel de la Routine Composant: lcd_eb005::PrintString(result_string)
	FCD_0ad31_lcd_eb005__PrintString(FCV_RESULT_STRING, FCVsz_RESULT_STRING);

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

}




