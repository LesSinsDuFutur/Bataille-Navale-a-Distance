;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BOYER\PROJET\Bluetooth\trame.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Tuesday, April 04, 2017 12:20:38
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0xFB
#endif
#ifdef HI_TECH_C
__CONFIG(0xFB);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
//ICD functionality
#define USE_FLOWCODE_ICD2
#define ICD_CLK_PORT 1
#define ICD_DATA_PORT 1
#define ICD_CLK_PIN 6
#define ICD_DATA_PIN 7
#define ICD_NUM_BPS 8
signed int brk_pnt[ICD_NUM_BPS] = {-1, -1, -1, -1, -1, -1, -1, -1};
0ED0  682D      	SETF gbl_brk_pnt
0ED2  6A2E      	CLRF gbl_brk_pnt+D'1'
0ED4  062E      	DECF gbl_brk_pnt+D'1', F
0ED6  682F      	SETF gbl_brk_pnt+D'2'
0ED8  6A30      	CLRF gbl_brk_pnt+D'3'
0EDA  0630      	DECF gbl_brk_pnt+D'3', F
0EDC  6831      	SETF gbl_brk_pnt+D'4'
0EDE  6A32      	CLRF gbl_brk_pnt+D'5'
0EE0  0632      	DECF gbl_brk_pnt+D'5', F
0EE2  6833      	SETF gbl_brk_pnt+D'6'
0EE4  6A34      	CLRF gbl_brk_pnt+D'7'
0EE6  0634      	DECF gbl_brk_pnt+D'7', F
0EE8  6835      	SETF gbl_brk_pnt+D'8'
0EEA  6A36      	CLRF gbl_brk_pnt+D'9'
0EEC  0636      	DECF gbl_brk_pnt+D'9', F
0EEE  6837      	SETF gbl_brk_pnt+D'10'
0EF0  6A38      	CLRF gbl_brk_pnt+D'11'
0EF2  0638      	DECF gbl_brk_pnt+D'11', F
0EF4  6839      	SETF gbl_brk_pnt+D'12'
0EF6  6A3A      	CLRF gbl_brk_pnt+D'13'
0EF8  063A      	DECF gbl_brk_pnt+D'13', F
0EFA  683B      	SETF gbl_brk_pnt+D'14'
0EFC  6A3C      	CLRF gbl_brk_pnt+D'15'
0EFE  063C      	DECF gbl_brk_pnt+D'15', F

#define ICD_STACK_SIZE 8
unsigned char icd_stack[ICD_STACK_SIZE] = {0, 0, 0, 0, 0, 0, 0, 0};
0F00  6A3D      	CLRF gbl_icd_stack
0F02  6A3E      	CLRF gbl_icd_stack+D'1'
0F04  6A3F      	CLRF gbl_icd_stack+D'2'
0F06  6A40      	CLRF gbl_icd_stack+D'3'
0F08  6A41      	CLRF gbl_icd_stack+D'4'
0F0A  6A42      	CLRF gbl_icd_stack+D'5'
0F0C  6A43      	CLRF gbl_icd_stack+D'6'
0F0E  6A44      	CLRF gbl_icd_stack+D'7'

#define ICD_ID0 0x19
#define ICD_ID1 0xbc
#define ICD_ID2 0xf2
#define ICD_ID3 0xb7
#define ICD_ID4 0x51
#define ICD_ID5 0x14
#define ICD_ID6 0x22
#define ICD_ID7 0xe5



/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_DATA = (0x36);
0F1E  0E36      	MOVLW 0x36
0F20  6E69      	MOVWF gbl_FCV_DATA



/*========================================================================*\
   Use :InjectorBase1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 portb
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 portb
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisb
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisb
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (4)
#define MX_UART_INT_1 (1)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :Bluetooth2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_0c851_Bluetooth2__STRING_ARRAY 40
#define FCV_0c851_Bluetooth2__BT_CHAR_CR (13)
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__STRING_ARRAY[FCVsz_0c851_Bluetooth2__STRING_ARRAY];
MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_IDX = (0x0);
0F22  6A6A      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX

MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_DONE = (0x0);
0F24  6A6B      	CLRF gbl_FCV_0c851_Bluetooth2___00001

MX_GLOBAL MX_UINT8 FCV_0c851_Bluetooth2__RX_LENGTH = (0x0);
0F26  6A6C      	CLRF gbl_FCV_0c851_Bluetooth2___00002


MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY);
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT);
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX);
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR);
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES);
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings();
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA);
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE);
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive();
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings();
MX_UINT8 FCD_0c851_Bluetooth2__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :InjectorBase1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :Bluetooth2
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the 4 digit Bluetooth pair key based on a string of numbers.
       :e.g. "1234"
       :Returns 0 to indicate success
       :
       :Param??tres pour la macro SetPairKey :
       :  PairKey[5] : Key to use as the Pair key, e.g. "1234" or "0000"
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetPairKey(MX_CHAR *FCL_PAIRKEY, MX_UINT16 FCLsz_PAIRKEY)

{
	//Définitions des variables locales
	#define FCLsz_COMMANDSTR 20
	MX_CHAR FCL_COMMANDSTR[FCLsz_COMMANDSTR];
	MX_UINT8 FCR_RETVAL;


	FCI_SHEAD("AT+BTK=\"",9, FCL_PAIRKEY,FCLsz_PAIRKEY, FCL_COMMANDSTR,20);
07D2  0E22      	MOVLW 0x22
07D4  0100      	MOVLB 0x00
07D6  6FAF      	MOVWF CompTempVar2717+D'7', 1
07D8  0E2B      	MOVLW 0x2B
07DA  6FAA      	MOVWF CompTempVar2717+D'2', 1
07DC  0E3D      	MOVLW 0x3D
07DE  6FAE      	MOVWF CompTempVar2717+D'6', 1
07E0  0E41      	MOVLW 0x41
07E2  6FA8      	MOVWF CompTempVar2717, 1
07E4  0E42      	MOVLW 0x42
07E6  6FAB      	MOVWF CompTempVar2717+D'3', 1
07E8  0E4B      	MOVLW 0x4B
07EA  6FAD      	MOVWF CompTempVar2717+D'5', 1
07EC  0E54      	MOVLW 0x54
07EE  6FA9      	MOVWF CompTempVar2717+D'1', 1
07F0  6FAC      	MOVWF CompTempVar2717+D'4', 1
07F2  6BB0      	CLRF CompTempVar2717+D'8', 1
07F4  0E00      	MOVLW HIGH(CompTempVar2717+D'0')
07F6  6E79      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
07F8  0EA8      	MOVLW LOW(CompTempVar2717+D'0')
07FA  6E78      	MOVWF FCI_SHEAD_00000_arg_sSrc1
07FC  0E09      	MOVLW 0x09
07FE  6E7A      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0800  506E      	MOVF FCD_0c851__00059_arg_FCL_PAIRKEY, W
0802  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0804  506F      	MOVF FCD_0c851__00059_arg_FCL_PAIRKEY+D'1', W
0806  6E7C      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0808  5075      	MOVF FCD_0c851__00059_arg_FCLsz_0005A, W
080A  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
080C  0E00      	MOVLW HIGH(FCD_0c851__00059_1_FCL_COM_0005B+D'0')
080E  6FB2      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0810  0E94      	MOVLW LOW(FCD_0c851__00059_1_FCL_COM_0005B+D'0')
0812  6FB1      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0814  0E14      	MOVLW 0x14
0816  6FB3      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0818  EC2BF001  	CALL FCI_SHEAD_00000

	FCI_SHEAD(FCL_COMMANDSTR,FCLsz_COMMANDSTR, "\"",2, FCL_COMMANDSTR,20);
081C  0E00      	MOVLW HIGH(FCD_0c851__00059_1_FCL_COM_0005B+D'0')
081E  6E79      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0820  0E94      	MOVLW LOW(FCD_0c851__00059_1_FCL_COM_0005B+D'0')
0822  6E78      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0824  0E14      	MOVLW 0x14
0826  6E7A      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0828  0E22      	MOVLW 0x22
082A  6E7D      	MOVWF CompTempVar2720
082C  6A7E      	CLRF CompTempVar2720+D'1'
082E  0E00      	MOVLW HIGH(CompTempVar2720+D'0')
0830  6E7C      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0832  0E7D      	MOVLW LOW(CompTempVar2720+D'0')
0834  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0836  0E02      	MOVLW 0x02
0838  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
083A  0E00      	MOVLW HIGH(FCD_0c851__00059_1_FCL_COM_0005B+D'0')
083C  6FB2      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
083E  0E94      	MOVLW LOW(FCD_0c851__00059_1_FCL_COM_0005B+D'0')
0840  6FB1      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0842  0E14      	MOVLW 0x14
0844  6FB3      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0846  EC2BF001  	CALL FCI_SHEAD_00000


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand(FCL_COMMANDSTR, FCLsz_COMMANDSTR, 1);
084A  0E00      	MOVLW HIGH(FCD_0c851__00059_1_FCL_COM_0005B+D'0')
084C  6E79      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND+D'1'
084E  0E94      	MOVLW LOW(FCD_0c851__00059_1_FCL_COM_0005B+D'0')
0850  6E78      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND
0852  0E14      	MOVLW 0x14
0854  6E7A      	MOVWF FCD_0c851__0005C_arg_FCLsz_0005D
0856  6A7B      	CLRF FCD_0c851__0005C_arg_FCLsz_0005D+D'1'
0858  0E01      	MOVLW 0x01
085A  6E7C      	MOVWF FCD_0c851__0005C_arg_FCL_SENDCR
085C  EC1AF002  	CALL FCD_0c851__0005C
0860  51A8      	MOVF CompTempVarRet2725, W, 1
0862  6E77      	MOVWF FCD_0c851__00059_1_FCR_RETVAL


	return (FCR_RETVAL);
0864  5077      	MOVF FCD_0c851__00059_1_FCR_RETVAL, W
0866  6E78      	MOVWF CompTempVarRet2716


	//Définitions des variables locales
	#undef FCLsz_COMMANDSTR
}
0868  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Receives a single data byte from the Bluetooth module.
       :0xFF signifies no data available.
       :
       :Param??tres pour la macro ReceiveByte :
       :  Timeout : Amount of time to wait in milliseconds 0=Wait forever
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__ReceiveByte(MX_UINT8 FCL_TIMEOUT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	FCV_0c851_Bluetooth2__RX_DONE = 0;

FCC_ReceiveByte_A:
;

	if (FCV_0c851_Bluetooth2__RX_IDX < FCV_0c851_Bluetooth2__RX_LENGTH)
	{

		FCR_RETVAL = FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_IDX];

		FCV_0c851_Bluetooth2__RX_IDX = FCV_0c851_Bluetooth2__RX_IDX + 1;

	} else {

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 40)
		{

			if ((FCL_TIMEOUT == 0) || (FCL_COUNT < FCL_TIMEOUT))
			{

				FCI_DELAYBYTE_MS(1);

				FCL_COUNT = FCL_COUNT + 1;

				goto FCC_ReceiveByte_A;

			// } else {

			}

		// } else {

		}

		FCV_0c851_Bluetooth2__RX_IDX = 0;
		FCV_0c851_Bluetooth2__RX_LENGTH = 0;

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Send an AT command script.
       :Returns 0 for fail, 1 for success and 255 for unrecognised script idx.
       :
       :Param??tres pour la macro SendScript :
       :  idx : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendScript(MX_UINT8 FCL_IDX)
{
	//Définitions des variables locales
	MX_UINT8 FCL_I = (0x0);
	MX_UINT8 FCL_CH = (0xff);
	#define FCLsz_SCRIPT_STR 40
	MX_CHAR FCL_SCRIPT_STR[FCLsz_SCRIPT_STR];
	MX_UINT8 FCL_LEN = (0x0);
	MX_UINT8 FCR_RETVAL;


	if ((FCL_IDX < 1) || (FCL_IDX > 1))
	{

		FCR_RETVAL = 255;

		goto FCC_SendScript_A;

	// } else {

	}

	switch (FCL_IDX)
	{
		case 1:
		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		case 2:
		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		case 3:
		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		case 4:
		{
			FCI_SCOPY("",1, FCL_SCRIPT_STR,FCLsz_SCRIPT_STR);

			break;
		}
		default:
		{
			FCR_RETVAL = 255;

			goto FCC_SendScript_A;

		}
	}

	while (1)
	{

		if ((FCL_CH > 0) == 0) break;
		FCL_CH = FCL_SCRIPT_STR[FCL_I];

		if ((FCL_CH > 0) && (FCL_CH != 0x0A))
		{

			FC_CAL_UART_Send_1(FCL_CH);

			FCL_LEN = FCL_LEN + 1;

			if (FCL_CH == FCV_0c851_Bluetooth2__BT_CHAR_CR)
			{

				#if (1) // 1 == 1

					FCD_0c851_Bluetooth2__StringReceive();

				// #else

				//Le code a été optimisé par le préprocesseur
				#endif

				FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();

				FCL_LEN = 0;

			// } else {

			}

		// } else {

		}

		FCL_I = FCL_I + 1;


	}

	if (FCL_LEN > 0)
	{

		FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);

		#if (1) // 1 == 1

			FCD_0c851_Bluetooth2__StringReceive();

		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();

	// } else {

	}

FCC_SendScript_A:
;

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_SCRIPT_STR
}

/*=----------------------------------------------------------------------=*\
   Use :Sends a command string to the GSM module.
       :0 = Command sent ok, 255 = No Reply
       :
       :Param??tres pour la macro SendCommand :
       :  Command[20] : MX_CHAR (by-ref)
       :  SendCR : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SendCommand(MX_CHAR *FCL_COMMAND, MX_UINT16 FCLsz_COMMAND, MX_UINT8 FCL_SENDCR)

{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
0434  6A7D      	CLRF FCD_0c851__0005C_1_FCL_IDX

	MX_UINT8 FCL_LEN;
	MX_UINT8 FCR_RETVAL;


	while (1)
0436            label51

	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
0436  ECB5F000  	CALL FCD_0c851__00061
043A  51AB      	MOVF CompTempVarRet2747, W, 1
043C  6E7F      	MOVWF FCD_0c851__0005C_1_FCR_RETVAL



		if ((FCR_RETVAL) == 0) break;
043E  527F      	MOVF FCD_0c851__0005C_1_FCR_RETVAL, F
0440  E1FA      	BNZ	label51

	}

	FCL_LEN = FCI_GETLENGTH(FCL_COMMAND, FCLsz_COMMAND);
0442  5078      	MOVF FCD_0c851__0005C_arg_FCL_COMMAND, W
0444  6FA8      	MOVWF FCI_GETLEN_0003E_arg_sStr1, 1
0446  5079      	MOVF FCD_0c851__0005C_arg_FCL_COMMAND+D'1', W
0448  6FA9      	MOVWF FCI_GETLEN_0003E_arg_sStr1+D'1', 1
044A  507A      	MOVF FCD_0c851__0005C_arg_FCLsz_0005D, W
044C  6FAA      	MOVWF FCI_GETLEN_0003E_arg_iStr1_len, 1
044E  ECA5F000  	CALL FCI_GETLEN_0003E
0452  51AC      	MOVF CompTempVarRet1850, W, 1
0454  6E7E      	MOVWF FCD_0c851__0005C_1_FCL_LEN


	if (FCL_LEN)
0456  527E      	MOVF FCD_0c851__0005C_1_FCL_LEN, F
0458  E01B      	BZ	label55
045A            label52

	{

		while (1)
0480  D7EC      	BRA	label52
0482            label54

		{

			if ((FCL_IDX < FCL_LEN) == 0) break;
045A  6BA8      	CLRF CompTempVar2726, 1
045C  507E      	MOVF FCD_0c851__0005C_1_FCL_LEN, W
045E  607D      	CPFSLT FCD_0c851__0005C_1_FCL_IDX
0460  D001      	BRA	label53
0462  71A8      	BTG CompTempVar2726,0, 1
0464            label53
0464  53A8      	MOVF CompTempVar2726, F, 1
0466  E00D      	BZ	label54

			FC_CAL_UART_Send_1(FCL_COMMAND[FCL_IDX]);
0468  5079      	MOVF FCD_0c851__0005C_arg_FCL_COMMAND+D'1', W
046A  6EEA      	MOVWF FSR0H
046C  5078      	MOVF FCD_0c851__0005C_arg_FCL_COMMAND, W
046E  247D      	ADDWF FCD_0c851__0005C_1_FCL_IDX, W
0470  6EE9      	MOVWF FSR0L
0472  50EF      	MOVF INDF0, W
0474  6FA9      	MOVWF FC_CAL_UAR_00056_arg_nChar, 1
0476  6BAA      	CLRF FC_CAL_UAR_00056_arg_nChar+D'1', 1
0478  EC9DF000  	CALL FC_CAL_UAR_00056


			FCL_IDX = FCL_IDX + 1;
047C  287D      	INCF FCD_0c851__0005C_1_FCL_IDX, W
047E  6E7D      	MOVWF FCD_0c851__0005C_1_FCL_IDX



		}

		if (FCL_SENDCR)
0482  527C      	MOVF FCD_0c851__0005C_arg_FCL_SENDCR, F
0484  E005      	BZ	label55
0490            label55

		{

			FC_CAL_UART_Send_1(FCV_0c851_Bluetooth2__BT_CHAR_CR);
0486  0E0D      	MOVLW 0x0D
0488  6FA9      	MOVWF FC_CAL_UAR_00056_arg_nChar, 1
048A  6BAA      	CLRF FC_CAL_UAR_00056_arg_nChar+D'1', 1
048C  EC9DF000  	CALL FC_CAL_UAR_00056


		// } else {

		}

	// } else {

	}

	#if (1) // 1 == 1

		FCD_0c851_Bluetooth2__StringReceive();
0490  ECB5F000  	CALL FCD_0c851__00061


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCR_RETVAL = FCD_0c851_Bluetooth2__StringReceive();
0494  ECB5F000  	CALL FCD_0c851__00061
0498  51AB      	MOVF CompTempVarRet2747, W, 1
049A  6E7F      	MOVWF FCD_0c851__0005C_1_FCR_RETVAL


	if (FCR_RETVAL == 0)
049C  527F      	MOVF FCD_0c851__0005C_1_FCR_RETVAL, F
049E  E102      	BNZ	label56
04A4            label56

	{

		FCR_RETVAL = 255;
04A0  687F      	SETF FCD_0c851__0005C_1_FCR_RETVAL


	} else {
04A2  D001      	BRA	label57
04A6            label57


		FCR_RETVAL = 0;
04A4  6A7F      	CLRF FCD_0c851__0005C_1_FCR_RETVAL


	}

	return (FCR_RETVAL);
04A6  507F      	MOVF FCD_0c851__0005C_1_FCR_RETVAL, W
04A8  6FA8      	MOVWF CompTempVarRet2725, 1


}
04AA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies the incoming data from the data string array to a local string variable.
       :
       :Param??tres pour la macro ReadString :
       :  NumBytes : MX_UINT8
       :
       :Renvoie : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_NUMBYTES)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);


	while (1)
	{

		if (((FCL_IDX < FCL_NUMBYTES) && (FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX] > 0)) == 0) break;
		FCR_RETVAL[FCL_IDX] = FCV_0c851_Bluetooth2__STRING_ARRAY[FCL_IDX];
		FCL_IDX = FCL_IDX + 1;


	}

	if (FCL_IDX < FCL_NUMBYTES)
	{

		FCR_RETVAL[FCL_IDX] = 0;

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Saves the current settings to firmware using the AT&W command followed by the ATZ command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SaveSettings()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&W", 5, 1);
0774  0E41      	MOVLW 0x41
0776  6E6F      	MOVWF CompTempVar2761
0778  0E54      	MOVLW 0x54
077A  6E70      	MOVWF CompTempVar2761+D'1'
077C  0E26      	MOVLW 0x26
077E  6E71      	MOVWF CompTempVar2761+D'2'
0780  0E57      	MOVLW 0x57
0782  6E72      	MOVWF CompTempVar2761+D'3'
0784  6A73      	CLRF CompTempVar2761+D'4'
0786  0E00      	MOVLW HIGH(CompTempVar2761+D'0')
0788  6E79      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND+D'1'
078A  0E6F      	MOVLW LOW(CompTempVar2761+D'0')
078C  6E78      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND
078E  0E05      	MOVLW 0x05
0790  6E7A      	MOVWF FCD_0c851__0005C_arg_FCLsz_0005D
0792  6A7B      	CLRF FCD_0c851__0005C_arg_FCLsz_0005D+D'1'
0794  0E01      	MOVLW 0x01
0796  6E7C      	MOVWF FCD_0c851__0005C_arg_FCL_SENDCR
0798  EC1AF002  	CALL FCD_0c851__0005C
079C  51A8      	MOVF CompTempVarRet2725, W, 1
079E  6E6E      	MOVWF FCD_0c851__00065_1_FCR_RETVAL


	if (FCR_RETVAL == 0)
07A0  526E      	MOVF FCD_0c851__00065_1_FCR_RETVAL, F
07A2  E114      	BNZ	label79
07CC            label79

	{

		FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATZ", 4, 1);
07A4  0E41      	MOVLW 0x41
07A6  6E6F      	MOVWF CompTempVar2763
07A8  0E54      	MOVLW 0x54
07AA  6E70      	MOVWF CompTempVar2763+D'1'
07AC  0E5A      	MOVLW 0x5A
07AE  6E71      	MOVWF CompTempVar2763+D'2'
07B0  6A72      	CLRF CompTempVar2763+D'3'
07B2  0E00      	MOVLW HIGH(CompTempVar2763+D'0')
07B4  6E79      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND+D'1'
07B6  0E6F      	MOVLW LOW(CompTempVar2763+D'0')
07B8  6E78      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND
07BA  0E04      	MOVLW 0x04
07BC  6E7A      	MOVWF FCD_0c851__0005C_arg_FCLsz_0005D
07BE  6A7B      	CLRF FCD_0c851__0005C_arg_FCLsz_0005D+D'1'
07C0  0E01      	MOVLW 0x01
07C2  6E7C      	MOVWF FCD_0c851__0005C_arg_FCL_SENDCR
07C4  EC1AF002  	CALL FCD_0c851__0005C
07C8  51A8      	MOVF CompTempVarRet2725, W, 1
07CA  6E6E      	MOVWF FCD_0c851__00065_1_FCR_RETVAL


	// } else {

	}

	return (FCR_RETVAL);
07CC  506E      	MOVF FCD_0c851__00065_1_FCR_RETVAL, W
07CE  6E6F      	MOVWF CompTempVarRet2760


}
07D0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sends a single data byte out to the Bluetooth module.
       :
       :Param??tres pour la macro SendByte :
       :  Data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c851_Bluetooth2__SendByte(MX_UINT8 FCL_DATA)

{

	FC_CAL_UART_Send_1(FCL_DATA);
0E16  506D      	MOVF FCD_0c851__00066_arg_FCL_DATA, W
0E18  0100      	MOVLB 0x00
0E1A  6FA9      	MOVWF FC_CAL_UAR_00056_arg_nChar, 1
0E1C  6BAA      	CLRF FC_CAL_UAR_00056_arg_nChar+D'1', 1
0E1E  EC9DF000  	CALL FC_CAL_UAR_00056


}
0E22  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets the bluetooth mode to be discoverable and or connectable.
       :Returns 0 for success.
       :
       :Param??tres pour la macro SetMode :
       :  Discoverable : 0 = Not Discoverable, 1 = Discoverable
       :  Connectable : 0 = Not Connectable, 1 = Connectable
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__SetMode(MX_UINT8 FCL_DISCOVERABLE, MX_UINT8 FCL_CONNECTABLE)

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	if (FCL_DISCOVERABLE)
0668  526E      	MOVF FCD_0c851__00067_arg_FCL_D_00068, F
066A  E041      	BZ	label76
06EE            label76

	{

		if (FCL_CONNECTABLE)
066C  526F      	MOVF FCD_0c851__00067_arg_FCL_C_00069, F
066E  E020      	BZ	label75
06B0            label75

		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=4", 9, 1);
0670  0E41      	MOVLW 0x41
0672  0100      	MOVLB 0x00
0674  6F94      	MOVWF CompTempVar2766, 1
0676  0E54      	MOVLW 0x54
0678  6F95      	MOVWF CompTempVar2766+D'1', 1
067A  0E53      	MOVLW 0x53
067C  6F96      	MOVWF CompTempVar2766+D'2', 1
067E  0E35      	MOVLW 0x35
0680  6F97      	MOVWF CompTempVar2766+D'3', 1
0682  0E31      	MOVLW 0x31
0684  6F98      	MOVWF CompTempVar2766+D'4', 1
0686  0E32      	MOVLW 0x32
0688  6F99      	MOVWF CompTempVar2766+D'5', 1
068A  0E3D      	MOVLW 0x3D
068C  6F9A      	MOVWF CompTempVar2766+D'6', 1
068E  0E34      	MOVLW 0x34
0690  6F9B      	MOVWF CompTempVar2766+D'7', 1
0692  6B9C      	CLRF CompTempVar2766+D'8', 1
0694  0E00      	MOVLW HIGH(CompTempVar2766+D'0')
0696  6E79      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND+D'1'
0698  0E94      	MOVLW LOW(CompTempVar2766+D'0')
069A  6E78      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND
069C  0E09      	MOVLW 0x09
069E  6E7A      	MOVWF FCD_0c851__0005C_arg_FCLsz_0005D
06A0  6A7B      	CLRF FCD_0c851__0005C_arg_FCLsz_0005D+D'1'
06A2  0E01      	MOVLW 0x01
06A4  6E7C      	MOVWF FCD_0c851__0005C_arg_FCL_SENDCR
06A6  EC1AF002  	CALL FCD_0c851__0005C
06AA  51A8      	MOVF CompTempVarRet2725, W, 1
06AC  6E70      	MOVWF FCD_0c851__00067_1_FCR_RETVAL


		} else {
06AE  D05F      	BRA	label78


			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 1);
06B0  0E31      	MOVLW 0x31
06B2  0100      	MOVLB 0x00
06B4  6F98      	MOVWF CompTempVar2768+D'4', 1
06B6  0E32      	MOVLW 0x32
06B8  6F99      	MOVWF CompTempVar2768+D'5', 1
06BA  6F9B      	MOVWF CompTempVar2768+D'7', 1
06BC  0E35      	MOVLW 0x35
06BE  6F97      	MOVWF CompTempVar2768+D'3', 1
06C0  0E3D      	MOVLW 0x3D
06C2  6F9A      	MOVWF CompTempVar2768+D'6', 1
06C4  0E41      	MOVLW 0x41
06C6  6F94      	MOVWF CompTempVar2768, 1
06C8  0E53      	MOVLW 0x53
06CA  6F96      	MOVWF CompTempVar2768+D'2', 1
06CC  0E54      	MOVLW 0x54
06CE  6F95      	MOVWF CompTempVar2768+D'1', 1
06D0  6B9C      	CLRF CompTempVar2768+D'8', 1
06D2  0E00      	MOVLW HIGH(CompTempVar2768+D'0')
06D4  6E79      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND+D'1'
06D6  0E94      	MOVLW LOW(CompTempVar2768+D'0')
06D8  6E78      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND
06DA  0E09      	MOVLW 0x09
06DC  6E7A      	MOVWF FCD_0c851__0005C_arg_FCLsz_0005D
06DE  6A7B      	CLRF FCD_0c851__0005C_arg_FCLsz_0005D+D'1'
06E0  0E01      	MOVLW 0x01
06E2  6E7C      	MOVWF FCD_0c851__0005C_arg_FCL_SENDCR
06E4  EC1AF002  	CALL FCD_0c851__0005C
06E8  51A8      	MOVF CompTempVarRet2725, W, 1
06EA  6E70      	MOVWF FCD_0c851__00067_1_FCR_RETVAL


		}

	} else {
06EC  D040      	BRA	label78


		if (FCL_CONNECTABLE)
06EE  526F      	MOVF FCD_0c851__00067_arg_FCL_C_00069, F
06F0  E01F      	BZ	label77
0730            label77

		{

			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=2", 9, 3);
06F2  0E31      	MOVLW 0x31
06F4  0100      	MOVLB 0x00
06F6  6F98      	MOVWF CompTempVar2770+D'4', 1
06F8  0E32      	MOVLW 0x32
06FA  6F99      	MOVWF CompTempVar2770+D'5', 1
06FC  6F9B      	MOVWF CompTempVar2770+D'7', 1
06FE  0E35      	MOVLW 0x35
0700  6F97      	MOVWF CompTempVar2770+D'3', 1
0702  0E3D      	MOVLW 0x3D
0704  6F9A      	MOVWF CompTempVar2770+D'6', 1
0706  0E41      	MOVLW 0x41
0708  6F94      	MOVWF CompTempVar2770, 1
070A  0E53      	MOVLW 0x53
070C  6F96      	MOVWF CompTempVar2770+D'2', 1
070E  0E54      	MOVLW 0x54
0710  6F95      	MOVWF CompTempVar2770+D'1', 1
0712  6B9C      	CLRF CompTempVar2770+D'8', 1
0714  0E00      	MOVLW HIGH(CompTempVar2770+D'0')
0716  6E79      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND+D'1'
0718  0E94      	MOVLW LOW(CompTempVar2770+D'0')
071A  6E78      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND
071C  0E09      	MOVLW 0x09
071E  6E7A      	MOVWF FCD_0c851__0005C_arg_FCLsz_0005D
0720  6A7B      	CLRF FCD_0c851__0005C_arg_FCLsz_0005D+D'1'
0722  0E03      	MOVLW 0x03
0724  6E7C      	MOVWF FCD_0c851__0005C_arg_FCL_SENDCR
0726  EC1AF002  	CALL FCD_0c851__0005C
072A  51A8      	MOVF CompTempVarRet2725, W, 1
072C  6E70      	MOVWF FCD_0c851__00067_1_FCR_RETVAL


		} else {
072E  D01F      	BRA	label78
076E            label78


			FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("ATS512=0", 9, 1);
0730  0E41      	MOVLW 0x41
0732  0100      	MOVLB 0x00
0734  6F94      	MOVWF CompTempVar2772, 1
0736  0E54      	MOVLW 0x54
0738  6F95      	MOVWF CompTempVar2772+D'1', 1
073A  0E53      	MOVLW 0x53
073C  6F96      	MOVWF CompTempVar2772+D'2', 1
073E  0E35      	MOVLW 0x35
0740  6F97      	MOVWF CompTempVar2772+D'3', 1
0742  0E31      	MOVLW 0x31
0744  6F98      	MOVWF CompTempVar2772+D'4', 1
0746  0E32      	MOVLW 0x32
0748  6F99      	MOVWF CompTempVar2772+D'5', 1
074A  0E3D      	MOVLW 0x3D
074C  6F9A      	MOVWF CompTempVar2772+D'6', 1
074E  0E30      	MOVLW 0x30
0750  6F9B      	MOVWF CompTempVar2772+D'7', 1
0752  6B9C      	CLRF CompTempVar2772+D'8', 1
0754  0E00      	MOVLW HIGH(CompTempVar2772+D'0')
0756  6E79      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND+D'1'
0758  0E94      	MOVLW LOW(CompTempVar2772+D'0')
075A  6E78      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND
075C  0E09      	MOVLW 0x09
075E  6E7A      	MOVWF FCD_0c851__0005C_arg_FCLsz_0005D
0760  6A7B      	CLRF FCD_0c851__0005C_arg_FCLsz_0005D+D'1'
0762  0E01      	MOVLW 0x01
0764  6E7C      	MOVWF FCD_0c851__0005C_arg_FCL_SENDCR
0766  EC1AF002  	CALL FCD_0c851__0005C
076A  51A8      	MOVF CompTempVarRet2725, W, 1
076C  6E70      	MOVWF FCD_0c851__00067_1_FCR_RETVAL


		}

	}

	return (FCR_RETVAL);
076E  5070      	MOVF FCD_0c851__00067_1_FCR_RETVAL, W
0770  6E71      	MOVWF CompTempVarRet2765


}
0772  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to receive a string from the GSM modem terminated with a 0x10 CR character. Used to collect the replies from commands.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__StringReceive()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TOUT = (0x0);
016A  0100      	MOVLB 0x00
016C  6BA8      	CLRF FCD_0c851__00061_1_FCL_TOUT, 1

	MX_UINT8 FCL_LEN = (0x0);
016E  6BA9      	CLRF FCD_0c851__00061_1_FCL_LEN, 1

	MX_UINT8 FCR_RETVAL;


	FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
0170  506C      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
0172  6FA9      	MOVWF FCD_0c851__00061_1_FCL_LEN, 1

	FCV_0c851_Bluetooth2__RX_DONE = 0;
0174  6A6B      	CLRF gbl_FCV_0c851_Bluetooth2___00001

	FCV_0c851_Bluetooth2__RX_LENGTH = 0;
0176  6A6C      	CLRF gbl_FCV_0c851_Bluetooth2___00002

	FCV_0c851_Bluetooth2__RX_IDX = 0;
0178  6A6A      	CLRF gbl_FCV_0c851_Bluetooth2__RX_IDX


	while (1)
017A            label20
01BA  D7DF      	BRA	label20
01BC            label23

	{

		if (((FCV_0c851_Bluetooth2__RX_DONE == 0) && (FCL_TOUT < 255)) == 0) break;
017A  6BAD      	CLRF CompTempVar2750, 1
017C  2BAD      	INCF CompTempVar2750, F, 1
017E  666B      	TSTFSZ gbl_FCV_0c851_Bluetooth2___00001
0180  91AD      	BCF CompTempVar2750,0, 1
0182  6BAC      	CLRF CompTempVar2749, 1
0184  0EFF      	MOVLW 0xFF
0186  61A8      	CPFSLT FCD_0c851__00061_1_FCL_TOUT, 1
0188  D001      	BRA	label21
018A  71AC      	BTG CompTempVar2749,0, 1
018C            label21
018C  6BAB      	CLRF CompTempVar2748, 1
018E  53AC      	MOVF CompTempVar2749, F, 1
0190  A4D8      	BTFSS STATUS,Z
0192  53AD      	MOVF CompTempVar2750, F, 1
0194  A4D8      	BTFSS STATUS,Z
0196  2BAB      	INCF CompTempVar2748, F, 1
0198  53AB      	MOVF CompTempVar2748, F, 1
019A  E010      	BZ	label23

		FCL_TOUT = FCL_TOUT + 1;
019C  29A8      	INCF FCD_0c851__00061_1_FCL_TOUT, W, 1
019E  6FA8      	MOVWF FCD_0c851__00061_1_FCL_TOUT, 1


		if (FCL_LEN != FCV_0c851_Bluetooth2__RX_LENGTH)
01A0  506C      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
01A2  63A9      	CPFSEQ FCD_0c851__00061_1_FCL_LEN, 1
01A4  626C      	CPFSEQ gbl_FCV_0c851_Bluetooth2___00002
01A6  D003      	BRA	label22
01AE            label22

		{

			FCL_TOUT = 0;
01A8  6BA8      	CLRF FCD_0c851__00061_1_FCL_TOUT, 1

			FCL_LEN = FCV_0c851_Bluetooth2__RX_LENGTH;
01AA  506C      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
01AC  6FA9      	MOVWF FCD_0c851__00061_1_FCL_LEN, 1


		// } else {

		}

		FCI_DELAYINT_US(500);
01AE  0EF4      	MOVLW 0xF4
01B0  6FAC      	MOVWF FCI_DELAYI_00038_arg_Delay, 1
01B2  0E01      	MOVLW 0x01
01B4  6FAD      	MOVWF FCI_DELAYI_00038_arg_Delay+D'1', 1
01B6  EC82F000  	CALL FCI_DELAYI_00038



	}

	if (FCL_TOUT == 255)
01BC  29A8      	INCF FCD_0c851__00061_1_FCL_TOUT, W, 1
01BE  E104      	BNZ	label24
01C8            label24

	{

		FCV_0c851_Bluetooth2__RX_DONE = 0;
01C0  6A6B      	CLRF gbl_FCV_0c851_Bluetooth2___00001

		FCV_0c851_Bluetooth2__RX_LENGTH = 0;
01C2  6A6C      	CLRF gbl_FCV_0c851_Bluetooth2___00002

		FCR_RETVAL = 0;
01C4  6BAA      	CLRF FCD_0c851__00061_1_FCR_RETVAL, 1


	} else {
01C6  D002      	BRA	label25
01CC            label25


		FCR_RETVAL = 1;
01C8  0E01      	MOVLW 0x01
01CA  6FAA      	MOVWF FCD_0c851__00061_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
01CC  51AA      	MOVF FCD_0c851__00061_1_FCR_RETVAL, W, 1
01CE  6FAB      	MOVWF CompTempVarRet2747, 1


}
01D0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Restores the factory settings to firmware using the AT&F* command.
       :Returns 0 to indicate success
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__RestoreFactorySettings()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FCD_0c851_Bluetooth2__SendCommand("AT&F*", 6, 1);
0632  0E41      	MOVLW 0x41
0634  6E6F      	MOVWF CompTempVar2775
0636  0E54      	MOVLW 0x54
0638  6E70      	MOVWF CompTempVar2775+D'1'
063A  0E26      	MOVLW 0x26
063C  6E71      	MOVWF CompTempVar2775+D'2'
063E  0E46      	MOVLW 0x46
0640  6E72      	MOVWF CompTempVar2775+D'3'
0642  0E2A      	MOVLW 0x2A
0644  6E73      	MOVWF CompTempVar2775+D'4'
0646  6A74      	CLRF CompTempVar2775+D'5'
0648  0E00      	MOVLW HIGH(CompTempVar2775+D'0')
064A  6E79      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND+D'1'
064C  0E6F      	MOVLW LOW(CompTempVar2775+D'0')
064E  6E78      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND
0650  0E06      	MOVLW 0x06
0652  6E7A      	MOVWF FCD_0c851__0005C_arg_FCLsz_0005D
0654  6A7B      	CLRF FCD_0c851__0005C_arg_FCLsz_0005D+D'1'
0656  0E01      	MOVLW 0x01
0658  6E7C      	MOVWF FCD_0c851__0005C_arg_FCL_SENDCR
065A  EC1AF002  	CALL FCD_0c851__0005C
065E  51A8      	MOVF CompTempVarRet2725, W, 1
0660  6E6E      	MOVWF FCD_0c851__0006A_1_FCR_RETVAL


	return (FCR_RETVAL);
0662  506E      	MOVF FCD_0c851__0006A_1_FCR_RETVAL, W
0664  6E6F      	MOVWF CompTempVarRet2774


}
0666  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets up the GSM module.
       :Returns 0 for OK, 255 for no reply and 254 for command fail.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0c851_Bluetooth2__Initialise()

{
	//Définitions des variables locales
	#define FCLsz_CMDSTR 20
	MX_CHAR FCL_CMDSTR[FCLsz_CMDSTR];
	MX_UINT8 FCR_RETVAL;


	FCP_SET(B, C, 0x2, 0x1, 0);
0CE2  6A6E      	CLRF FCD_0c851__0006B_2_ptmp
0CE4  9294      	BCF gbl_trisc,1
0CE6  526E      	MOVF FCD_0c851__0006B_2_ptmp, F
0CE8  E004      	BZ	label127
0CEA  0E02      	MOVLW 0x02
0CEC  108B      	IORWF gbl_latc, W
0CEE  6E82      	MOVWF gbl_portc
0CF0  D003      	BRA	label128
0CF2            label127
0CF2  0EFD      	MOVLW 0xFD
0CF4  148B      	ANDWF gbl_latc, W
0CF6  6E82      	MOVWF gbl_portc
0CF8            label128


	FCI_DELAYBYTE_MS(100);
0CF8  0E64      	MOVLW 0x64
0CFA  6E6E      	MOVWF delay_ms_00000_arg_del
0CFC  EC0BF000  	CALL delay_ms_00000


	FCP_SET(B, C, 0x2, 0x1, 1);
0D00  0E01      	MOVLW 0x01
0D02  6E6E      	MOVWF FCD_0c851__0006B_13_ptmp
0D04  9294      	BCF gbl_trisc,1
0D06  526E      	MOVF FCD_0c851__0006B_13_ptmp, F
0D08  E004      	BZ	label129
0D0A  0E02      	MOVLW 0x02
0D0C  108B      	IORWF gbl_latc, W
0D0E  6E82      	MOVWF gbl_portc
0D10  D003      	BRA	label130
0D12            label129
0D12  0EFD      	MOVLW 0xFD
0D14  148B      	ANDWF gbl_latc, W
0D16  6E82      	MOVWF gbl_portc
0D18            label130


	FCR_RETVAL = 0;
0D18  6A6D      	CLRF FCD_0c851__0006B_1_FCR_RETVAL


	FC_CAL_UART_Init_1();
0D1A  EC0EF003  	CALL FC_CAL_UAR_00057


	FCI_DELAYBYTE_MS(10);
0D1E  0E0A      	MOVLW 0x0A
0D20  6E6E      	MOVWF delay_ms_00000_arg_del
0D22  EC0BF000  	CALL delay_ms_00000


	FCD_0c851_Bluetooth2__StringReceive();
0D26  ECB5F000  	CALL FCD_0c851__00061


	#if (1)

		FCD_0c851_Bluetooth2__RestoreFactorySettings();
0D2A  EC19F003  	CALL FCD_0c851__0006A


	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FCI_SHEAD("AT+BTN=\"",9, "FlowBlue",9, FCL_CMDSTR,20);
0D2E  0E22      	MOVLW 0x22
0D30  6F9B      	MOVWF CompTempVar2778+D'7', 1
0D32  0E2B      	MOVLW 0x2B
0D34  6F96      	MOVWF CompTempVar2778+D'2', 1
0D36  0E3D      	MOVLW 0x3D
0D38  6F9A      	MOVWF CompTempVar2778+D'6', 1
0D3A  0E41      	MOVLW 0x41
0D3C  6F94      	MOVWF CompTempVar2778, 1
0D3E  0E42      	MOVLW 0x42
0D40  6F97      	MOVWF CompTempVar2778+D'3', 1
0D42  0E4E      	MOVLW 0x4E
0D44  6F99      	MOVWF CompTempVar2778+D'5', 1
0D46  0E54      	MOVLW 0x54
0D48  6F95      	MOVWF CompTempVar2778+D'1', 1
0D4A  6F98      	MOVWF CompTempVar2778+D'4', 1
0D4C  6B9C      	CLRF CompTempVar2778+D'8', 1
0D4E  0E00      	MOVLW HIGH(CompTempVar2778+D'0')
0D50  6E79      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0D52  0E94      	MOVLW LOW(CompTempVar2778+D'0')
0D54  6E78      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0D56  0E09      	MOVLW 0x09
0D58  6E7A      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0D5A  0E42      	MOVLW 0x42
0D5C  6FA1      	MOVWF CompTempVar2779+D'4', 1
0D5E  0E46      	MOVLW 0x46
0D60  6F9D      	MOVWF CompTempVar2779, 1
0D62  0E65      	MOVLW 0x65
0D64  6FA4      	MOVWF CompTempVar2779+D'7', 1
0D66  0E6C      	MOVLW 0x6C
0D68  6F9E      	MOVWF CompTempVar2779+D'1', 1
0D6A  6FA2      	MOVWF CompTempVar2779+D'5', 1
0D6C  0E6F      	MOVLW 0x6F
0D6E  6F9F      	MOVWF CompTempVar2779+D'2', 1
0D70  0E75      	MOVLW 0x75
0D72  6FA3      	MOVWF CompTempVar2779+D'6', 1
0D74  0E77      	MOVLW 0x77
0D76  6FA0      	MOVWF CompTempVar2779+D'3', 1
0D78  6BA5      	CLRF CompTempVar2779+D'8', 1
0D7A  0E00      	MOVLW HIGH(CompTempVar2779+D'0')
0D7C  6E7C      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0D7E  0E9D      	MOVLW LOW(CompTempVar2779+D'0')
0D80  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0D82  0E09      	MOVLW 0x09
0D84  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0D86  0E00      	MOVLW HIGH(FCD_0c851__0006B_1_FCL_CMDSTR+D'0')
0D88  6FB2      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0D8A  0E80      	MOVLW LOW(FCD_0c851__0006B_1_FCL_CMDSTR+D'0')
0D8C  6FB1      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0D8E  0E14      	MOVLW 0x14
0D90  6FB3      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0D92  EC2BF001  	CALL FCI_SHEAD_00000

	FCI_SHEAD(FCL_CMDSTR,FCLsz_CMDSTR, "\"",2, FCL_CMDSTR,20);
0D96  0E00      	MOVLW HIGH(FCD_0c851__0006B_1_FCL_CMDSTR+D'0')
0D98  6E79      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'
0D9A  0E80      	MOVLW LOW(FCD_0c851__0006B_1_FCL_CMDSTR+D'0')
0D9C  6E78      	MOVWF FCI_SHEAD_00000_arg_sSrc1
0D9E  0E14      	MOVLW 0x14
0DA0  6E7A      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len
0DA2  0E22      	MOVLW 0x22
0DA4  6E6F      	MOVWF CompTempVar2783
0DA6  6A70      	CLRF CompTempVar2783+D'1'
0DA8  0E00      	MOVLW HIGH(CompTempVar2783+D'0')
0DAA  6E7C      	MOVWF FCI_SHEAD_00000_arg_sSrc2+D'1'
0DAC  0E6F      	MOVLW LOW(CompTempVar2783+D'0')
0DAE  6E7B      	MOVWF FCI_SHEAD_00000_arg_sSrc2
0DB0  0E02      	MOVLW 0x02
0DB2  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len
0DB4  0E00      	MOVLW HIGH(FCD_0c851__0006B_1_FCL_CMDSTR+D'0')
0DB6  6FB2      	MOVWF FCI_SHEAD_00000_arg_sDst+D'1', 1
0DB8  0E80      	MOVLW LOW(FCD_0c851__0006B_1_FCL_CMDSTR+D'0')
0DBA  6FB1      	MOVWF FCI_SHEAD_00000_arg_sDst, 1
0DBC  0E14      	MOVLW 0x14
0DBE  6FB3      	MOVWF FCI_SHEAD_00000_arg_iDst_len, 1
0DC0  EC2BF001  	CALL FCI_SHEAD_00000


	FCD_0c851_Bluetooth2__SendCommand(FCL_CMDSTR, FCLsz_CMDSTR, 1);
0DC4  0E00      	MOVLW HIGH(FCD_0c851__0006B_1_FCL_CMDSTR+D'0')
0DC6  6E79      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND+D'1'
0DC8  0E80      	MOVLW LOW(FCD_0c851__0006B_1_FCL_CMDSTR+D'0')
0DCA  6E78      	MOVWF FCD_0c851__0005C_arg_FCL_COMMAND
0DCC  0E14      	MOVLW 0x14
0DCE  6E7A      	MOVWF FCD_0c851__0005C_arg_FCLsz_0005D
0DD0  6A7B      	CLRF FCD_0c851__0005C_arg_FCLsz_0005D+D'1'
0DD2  0E01      	MOVLW 0x01
0DD4  6E7C      	MOVWF FCD_0c851__0005C_arg_FCL_SENDCR
0DD6  EC1AF002  	CALL FCD_0c851__0005C


	FCD_0c851_Bluetooth2__SetPairKey("1234", 5);
0DDA  0E31      	MOVLW 0x31
0DDC  6E70      	MOVWF CompTempVar2788
0DDE  0E32      	MOVLW 0x32
0DE0  6E71      	MOVWF CompTempVar2788+D'1'
0DE2  0E33      	MOVLW 0x33
0DE4  6E72      	MOVWF CompTempVar2788+D'2'
0DE6  0E34      	MOVLW 0x34
0DE8  6E73      	MOVWF CompTempVar2788+D'3'
0DEA  6A74      	CLRF CompTempVar2788+D'4'
0DEC  0E00      	MOVLW HIGH(CompTempVar2788+D'0')
0DEE  6E6F      	MOVWF FCD_0c851__00059_arg_FCL_PAIRKEY+D'1'
0DF0  0E70      	MOVLW LOW(CompTempVar2788+D'0')
0DF2  6E6E      	MOVWF FCD_0c851__00059_arg_FCL_PAIRKEY
0DF4  0E05      	MOVLW 0x05
0DF6  6E75      	MOVWF FCD_0c851__00059_arg_FCLsz_0005A
0DF8  6A76      	CLRF FCD_0c851__00059_arg_FCLsz_0005A+D'1'
0DFA  ECE9F003  	CALL FCD_0c851__00059


	FCD_0c851_Bluetooth2__SetMode(1, 1);
0DFE  0E01      	MOVLW 0x01
0E00  6E6E      	MOVWF FCD_0c851__00067_arg_FCL_D_00068
0E02  6E6F      	MOVWF FCD_0c851__00067_arg_FCL_C_00069
0E04  EC34F003  	CALL FCD_0c851__00067


	FCR_RETVAL = FCD_0c851_Bluetooth2__SaveSettings();
0E08  ECBAF003  	CALL FCD_0c851__00065
0E0C  506F      	MOVF CompTempVarRet2760, W
0E0E  6E6D      	MOVWF FCD_0c851__0006B_1_FCR_RETVAL


	return (FCR_RETVAL);
0E10  506D      	MOVF FCD_0c851__0006B_1_FCR_RETVAL, W
0E12  6E6E      	MOVWF CompTempVarRet2777


	//Définitions des variables locales
	#undef FCLsz_CMDSTR
}
0E14  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/


/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
0E24  0E0F      	MOVLW 0x0F
0E26  6EC1      	MOVWF gbl_adcon1





	//Enable initial stop condition
	dbg_mode = 0x08;
0E28  0E08      	MOVLW 0x08
0E2A  6E67      	MOVWF gbl_dbg_mode


	ICD_PUSH(0);
0E2C  6A6D      	CLRF ICD_PUSH_00000_arg_macro_id
0E2E  EC35F004  	CALL ICD_PUSH_00000



	FC_MARKER(1);
0E32  0E01      	MOVLW 0x01
0E34  6E6D      	MOVWF FC_MARKER_00000_arg_block_id
0E36  6A6E      	CLRF FC_MARKER_00000_arg_block_id+D'1'
0E38  EC4CF004  	CALL FC_MARKER_00000


	FC_MARKER(2);
0E3C  0E02      	MOVLW 0x02
0E3E  6E6D      	MOVWF FC_MARKER_00000_arg_block_id
0E40  6A6E      	CLRF FC_MARKER_00000_arg_block_id+D'1'
0E42  EC4CF004  	CALL FC_MARKER_00000


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Bluetooth2::Initialise()
	FCD_0c851_Bluetooth2__Initialise();
0E46  EC71F006  	CALL FCD_0c851__0006B


	FC_MARKER(6);
0E4A  0E06      	MOVLW 0x06
0E4C  6E6D      	MOVWF FC_MARKER_00000_arg_block_id
0E4E  6A6E      	CLRF FC_MARKER_00000_arg_block_id+D'1'
0E50  EC4CF004  	CALL FC_MARKER_00000


	// Boucle
	// Boucle: While 1
	while (1)
0E54            label131
0E88  D7E5      	BRA	label131

	{

		FC_MARKER(6);
0E54  0E06      	MOVLW 0x06
0E56  6E6D      	MOVWF FC_MARKER_00000_arg_block_id
0E58  6A6E      	CLRF FC_MARKER_00000_arg_block_id+D'1'
0E5A  EC4CF004  	CALL FC_MARKER_00000


		if ((1) == 0) break;
		FC_MARKER(4);
0E5E  0E04      	MOVLW 0x04
0E60  6E6D      	MOVWF FC_MARKER_00000_arg_block_id
0E62  6A6E      	CLRF FC_MARKER_00000_arg_block_id+D'1'
0E64  EC4CF004  	CALL FC_MARKER_00000


		// Appel de la Routine Composant
		// Appel de la Routine Composant: Bluetooth2::SendByte(42)
		FCD_0c851_Bluetooth2__SendByte(42);
0E68  0E2A      	MOVLW 0x2A
0E6A  6E6D      	MOVWF FCD_0c851__00066_arg_FCL_DATA
0E6C  EC0BF007  	CALL FCD_0c851__00066


		FC_MARKER(5);
0E70  0E05      	MOVLW 0x05
0E72  6E6D      	MOVWF FC_MARKER_00000_arg_block_id
0E74  6A6E      	CLRF FC_MARKER_00000_arg_block_id+D'1'
0E76  EC4CF004  	CALL FC_MARKER_00000


		// Calcul
		// Calcul:
		//  data = data + 1
		FCV_DATA = FCV_DATA + 1;
0E7A  2869      	INCF gbl_FCV_DATA, W
0E7C  6E69      	MOVWF gbl_FCV_DATA


		FC_MARKER(3);
0E7E  0E03      	MOVLW 0x03
0E80  6E6D      	MOVWF FC_MARKER_00000_arg_block_id
0E82  6A6E      	CLRF FC_MARKER_00000_arg_block_id+D'1'
0E84  EC4CF004  	CALL FC_MARKER_00000



	}

	FC_MARKER(7);


	ICD_POP();


	//Code to signal end of program to ICD
	dbg_mode = 0x08;


	FC_MARKER(-1);



	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

	MX_UART_INT_CH1_FUNC

	MX_UINT8 FCL_BT_IN;
0F2C  CFEAF001  	MOVFF FSR0H,  Int1Context
0F30  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
0F34  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
0F38  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'


	FCL_BT_IN = MX_UART_INT_CH1_DET;
0F3C  0E20      	MOVLW 0x20
0F3E  149E      	ANDWF gbl_pir1, W
0F40  0100      	MOVLB 0x00
0F42  6FBB      	MOVWF CompTempVar2791, 1
0F44  0E20      	MOVLW 0x20
0F46  149D      	ANDWF gbl_pie1, W
0F48  6FBA      	MOVWF CompTempVar2790, 1
0F4A  6BB9      	CLRF interrupt_1_FCL_BT_IN, 1
0F4C  53BA      	MOVF CompTempVar2790, F, 1
0F4E  A4D8      	BTFSS STATUS,Z
0F50  53BB      	MOVF CompTempVar2791, F, 1
0F52  A4D8      	BTFSS STATUS,Z
0F54  2BB9      	INCF interrupt_1_FCL_BT_IN, F, 1


	if (FCL_BT_IN)
0F56  53B9      	MOVF interrupt_1_FCL_BT_IN, F, 1
0F58  E022      	BZ	label135
0F9E            label135

	{

	FCL_BT_IN = FC_CAL_UART_Receive_1(1);
0F5A  0E01      	MOVLW 0x01
0F5C  6FBA      	MOVWF FC_CAL_UAR_00055_arg_nTimeout, 1
0F5E  EC33F000  	CALL FC_CAL_UAR_00055
0F62  51C3      	MOVF CompTempVarRet2711, W, 1
0F64  6FB9      	MOVWF interrupt_1_FCL_BT_IN, 1


	if (FCV_0c851_Bluetooth2__RX_DONE == 0)
0F66  526B      	MOVF gbl_FCV_0c851_Bluetooth2___00001, F
0F68  E119      	BNZ	label134

	{

		if (FCV_0c851_Bluetooth2__RX_LENGTH < 40)
0F6A  0E28      	MOVLW 0x28
0F6C  606C      	CPFSLT gbl_FCV_0c851_Bluetooth2___00002
0F6E  D016      	BRA	label134

		{

			if (FCL_BT_IN == 0x0A)
0F70  0E0A      	MOVLW 0x0A
0F72  63B9      	CPFSEQ interrupt_1_FCL_BT_IN, 1
0F74  D00A      	BRA	label133
0F8A            label133

			{

				FCV_0c851_Bluetooth2__RX_DONE = 1;
0F76  0E01      	MOVLW 0x01
0F78  6E6B      	MOVWF gbl_FCV_0c851_Bluetooth2___00001

				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = 0;
0F7A  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00000
0F7E  50E9      	MOVF FSR0L, W
0F80  506C      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
0F82  26E9      	ADDWF FSR0L, F
0F84  0E00      	MOVLW 0x00
0F86  6EEF      	MOVWF INDF0


			} else {
0F88  D009      	BRA	label134
0F9C            label134


				FCV_0c851_Bluetooth2__STRING_ARRAY[FCV_0c851_Bluetooth2__RX_LENGTH] = FCL_BT_IN;
0F8A  EE00F005  	LFSR 0x00, gbl_FCV_0c851_Bluetooth2___00000
0F8E  50E9      	MOVF FSR0L, W
0F90  506C      	MOVF gbl_FCV_0c851_Bluetooth2___00002, W
0F92  26E9      	ADDWF FSR0L, F
0F94  51B9      	MOVF interrupt_1_FCL_BT_IN, W, 1
0F96  6EEF      	MOVWF INDF0

				FCV_0c851_Bluetooth2__RX_LENGTH = FCV_0c851_Bluetooth2__RX_LENGTH + 1;
0F98  286C      	INCF gbl_FCV_0c851_Bluetooth2___00002, W
0F9A  6E6C      	MOVWF gbl_FCV_0c851_Bluetooth2___00002


			}

		// } else {

		}

	// } else {

	}

	MX_UART_INT_CH1_CLR;
0F9C  9A9E      	BCF gbl_pir1,5


	}

	MX_UART_INT_FUNC_END
}
0F9E  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
0FA2  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
0FA6  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
0FAA  C001FFEA  	MOVFF Int1Context,  FSR0H
0FAE  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

// Delay by bytes
#define FCI_DELAYBYTE_S(count)     delay_s((count))
#define FCI_DELAYBYTE_MS(count)    delay_ms((count))
#define FCI_DELAYBYTE_US(count)    delay_us((count))
// With watchdog timer
#define FCI_DELAYBYTEWDT_S(count)  Wdt_Delay_S((count))
#define FCI_DELAYBYTEWDT_MS(count) Wdt_Delay_Ms((count))
#define FCI_DELAYBYTEWDT_US(count) delay_us((count))

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)
{
    char i;
    for (i=0; i<delay; i++)
    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
        delay_ms(1);
    }
}


void FCI_DELAYINT_US(MX_UINT16 Delay)

{
  	while (Delay > 255)
0104            label13
0104  0EFF      	MOVLW 0xFF
0106  65AC      	CPFSGT FCI_DELAYI_00038_arg_Delay, 1
0108  67AD      	TSTFSZ FCI_DELAYI_00038_arg_Delay+D'1', 1
010A  D001      	BRA	label14
010C  D00C      	BRA	label15
010E            label14
0124  D7EF      	BRA	label13
0126            label15

  	{
	  	delay_us(255);
010E  69AE      	SETF delay_us_00000_arg_del, 1
0110  EC06F000  	CALL delay_us_00000

	  	Delay = Delay - 255;
0114  0EFF      	MOVLW 0xFF
0116  5DAC      	SUBWF FCI_DELAYI_00038_arg_Delay, W, 1
0118  6FAE      	MOVWF CompTempVar1836, 1
011A  59AC      	SUBWFB FCI_DELAYI_00038_arg_Delay, W, 1
011C  08FF      	SUBLW 0xFF
011E  5FAD      	SUBWF FCI_DELAYI_00038_arg_Delay+D'1', F, 1
0120  51AE      	MOVF CompTempVar1836, W, 1
0122  6FAC      	MOVWF FCI_DELAYI_00038_arg_Delay, 1

  	}
  	if (Delay > 0)
0126  0E00      	MOVLW 0x00
0128  65AC      	CPFSGT FCI_DELAYI_00038_arg_Delay, 1
012A  67AD      	TSTFSZ FCI_DELAYI_00038_arg_Delay+D'1', 1
012C  D001      	BRA	label16
0130            label16

  		delay_us(Delay & 0xFF);
0130  51AC      	MOVF FCI_DELAYI_00038_arg_Delay, W, 1
0132  6FAE      	MOVWF delay_us_00000_arg_del, 1
0134  EC06F000  	CALL delay_us_00000

}
012E  0012      	RETURN
0138  0012      	RETURN


void FCI_DELAYINT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_ms(Delay & 0xFF);
}

void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
014A  6BAB      	CLRF FCI_GETLEN_0003E_1_tmp, 1
014C            label18
014C  51AA      	MOVF FCI_GETLEN_0003E_arg_iStr1_len, W, 1
014E  61AB      	CPFSLT FCI_GETLEN_0003E_1_tmp, 1
0150  D009      	BRA	label19
0152  51A9      	MOVF FCI_GETLEN_0003E_arg_sStr1+D'1', W, 1
0154  6EEA      	MOVWF FSR0H
0156  51A8      	MOVF FCI_GETLEN_0003E_arg_sStr1, W, 1
0158  25AB      	ADDWF FCI_GETLEN_0003E_1_tmp, W, 1
015A  6EE9      	MOVWF FSR0L
015C  52EF      	MOVF INDF0, F
015E  E002      	BZ	label19
0160  2BAB      	INCF FCI_GETLEN_0003E_1_tmp, F, 1
0162  D7F4      	BRA	label18
0164            label19

	return (tmp);
0164  51AB      	MOVF FCI_GETLEN_0003E_1_tmp, W, 1
0166  6FAC      	MOVWF CompTempVarRet1850, 1

}
0168  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	if (iDst_len == 0) return sDst;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (sDst);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)

{
  MX_UINT8 len, strt;

  len = 0;
0256  6BB4      	CLRF FCI_SHEAD_00000_1_len, 1

  if (sSrc2 == sDst)
0258  51B1      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
025A  627B      	CPFSEQ FCI_SHEAD_00000_arg_sSrc2
025C  D08C      	BRA	label45
025E  51B2      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0260  627C      	CPFSEQ FCI_SHEAD_00000_arg_sSrc2+D'1'
0262  D089      	BRA	label45
0376            label45

  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
0264  6BB5      	CLRF FCI_SHEAD_00000_1_strt, 1
0266            label34
0266  507A      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
0268  61B5      	CPFSLT FCI_SHEAD_00000_1_strt, 1
026A  D009      	BRA	label35
026C  5079      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
026E  6EEA      	MOVWF FSR0H
0270  5078      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0272  25B5      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0274  6EE9      	MOVWF FSR0L
0276  52EF      	MOVF INDF0, F
0278  E002      	BZ	label35
027A  2BB5      	INCF FCI_SHEAD_00000_1_strt, F, 1
027C  D7F4      	BRA	label34
027E            label35
0374  D7E0      	BRA	label44

    if (strt < iDst_len)
027E  51B3      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
0280  61B5      	CPFSLT FCI_SHEAD_00000_1_strt, 1
0282  D058      	BRA	label43
0334            label43

    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
0284  6BB4      	CLRF FCI_SHEAD_00000_1_len, 1
0286            label36
0286  507F      	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W
0288  61B4      	CPFSLT FCI_SHEAD_00000_1_len, 1
028A  D009      	BRA	label37
028C  507C      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
028E  6EEA      	MOVWF FSR0H
0290  507B      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
0292  25B4      	ADDWF FCI_SHEAD_00000_1_len, W, 1
0294  6EE9      	MOVWF FSR0L
0296  52EF      	MOVF INDF0, F
0298  E002      	BZ	label37
029A  2BB4      	INCF FCI_SHEAD_00000_1_len, F, 1
029C  D7F4      	BRA	label36
029E            label37

      if (len > (iDst_len - strt))
029E  51B5      	MOVF FCI_SHEAD_00000_1_strt, W, 1
02A0  5DB3      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
02A2  6FB6      	MOVWF CompTempVar2023, 1
02A4  51B4      	MOVF FCI_SHEAD_00000_1_len, W, 1
02A6  61B6      	CPFSLT CompTempVar2023, 1
02A8  D005      	BRA	label38
02B4            label38

      {
        len = (iDst_len - strt); // Length of string to copy to
02AA  51B5      	MOVF FCI_SHEAD_00000_1_strt, W, 1
02AC  5DB3      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
02AE  6FB7      	MOVWF CompTempVar2029, 1
02B0  51B7      	MOVF CompTempVar2029, W, 1
02B2  6FB4      	MOVWF FCI_SHEAD_00000_1_len, 1

      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
02B4  51B4      	MOVF FCI_SHEAD_00000_1_len, W, 1
02B6  25B5      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
02B8  6E7F      	MOVWF FCI_SHEAD_00000_arg_iSrc2_len

      strt = len;
02BA  51B4      	MOVF FCI_SHEAD_00000_1_len, W, 1
02BC  6FB5      	MOVWF FCI_SHEAD_00000_1_strt, 1

      while (strt > 0)
02BE            label39
02BE  0E00      	MOVLW 0x00
02C0  65B5      	CPFSGT FCI_SHEAD_00000_1_strt, 1
02C2  D014      	BRA	label40
02EA  D7E9      	BRA	label39
02EC            label40

      {
        strt--;
02C4  07B5      	DECF FCI_SHEAD_00000_1_strt, F, 1

        iSrc2_len--;
02C6  067F      	DECF FCI_SHEAD_00000_arg_iSrc2_len, F

        sDst[iSrc2_len] = sSrc2[strt];
02C8  507C      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
02CA  6EEA      	MOVWF FSR0H
02CC  507B      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
02CE  6EE9      	MOVWF FSR0L
02D0  51B5      	MOVF FCI_SHEAD_00000_1_strt, W, 1
02D2  6FB7      	MOVWF CompTempVar2032, 1
02D4  51B7      	MOVF CompTempVar2032, W, 1
02D6  26E9      	ADDWF FSR0L, F
02D8  50EF      	MOVF INDF0, W
02DA  6FB8      	MOVWF CompTempVar2033, 1
02DC  51B2      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
02DE  6EEA      	MOVWF FSR0H
02E0  51B1      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
02E2  247F      	ADDWF FCI_SHEAD_00000_arg_iSrc2_len, W
02E4  6EE9      	MOVWF FSR0L
02E6  51B8      	MOVF CompTempVar2033, W, 1
02E8  6EEF      	MOVWF INDF0

      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
02EC  6BB5      	CLRF FCI_SHEAD_00000_1_strt, 1
02EE            label41
02EE  507A      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
02F0  61B5      	CPFSLT FCI_SHEAD_00000_1_strt, 1
02F2  D01D      	BRA	label42
02F4  51B3      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
02F6  61B5      	CPFSLT FCI_SHEAD_00000_1_strt, 1
02F8  D01A      	BRA	label42
02FA  5079      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
02FC  6EEA      	MOVWF FSR0H
02FE  5078      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0300  25B5      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0302  6EE9      	MOVWF FSR0L
0304  52EF      	MOVF INDF0, F
0306  E013      	BZ	label42
0308  5079      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
030A  6EEA      	MOVWF FSR0H
030C  5078      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
030E  6EE9      	MOVWF FSR0L
0310  51B5      	MOVF FCI_SHEAD_00000_1_strt, W, 1
0312  6FB7      	MOVWF CompTempVar2036, 1
0314  51B7      	MOVF CompTempVar2036, W, 1
0316  26E9      	ADDWF FSR0L, F
0318  50EF      	MOVF INDF0, W
031A  6FB8      	MOVWF CompTempVar2037, 1
031C  51B2      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
031E  6EEA      	MOVWF FSR0H
0320  51B1      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
0322  25B5      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0324  6EE9      	MOVWF FSR0L
0326  51B8      	MOVF CompTempVar2037, W, 1
0328  6EEF      	MOVWF INDF0
032A  2BB5      	INCF FCI_SHEAD_00000_1_strt, F, 1
032C  D7E0      	BRA	label41
032E            label42

      len += strt;
032E  51B5      	MOVF FCI_SHEAD_00000_1_strt, W, 1
0330  27B4      	ADDWF FCI_SHEAD_00000_1_len, F, 1

    }
    else
0332  D075      	BRA	label50

    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
0334  6BB4      	CLRF FCI_SHEAD_00000_1_len, 1
0336            label44
0336  507A      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
0338  61B4      	CPFSLT FCI_SHEAD_00000_1_len, 1
033A  D071      	BRA	label50
033C  51B3      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
033E  61B4      	CPFSLT FCI_SHEAD_00000_1_len, 1
0340  D06E      	BRA	label50
0342  5079      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0344  6EEA      	MOVWF FSR0H
0346  5078      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0348  25B4      	ADDWF FCI_SHEAD_00000_1_len, W, 1
034A  6EE9      	MOVWF FSR0L
034C  52EF      	MOVF INDF0, F
034E  E067      	BZ	label50
0350  5079      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0352  6EEA      	MOVWF FSR0H
0354  5078      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0356  6EE9      	MOVWF FSR0L
0358  51B4      	MOVF FCI_SHEAD_00000_1_len, W, 1
035A  6FB6      	MOVWF CompTempVar2044, 1
035C  51B6      	MOVF CompTempVar2044, W, 1
035E  26E9      	ADDWF FSR0L, F
0360  50EF      	MOVF INDF0, W
0362  6FB7      	MOVWF CompTempVar2045, 1
0364  51B2      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0366  6EEA      	MOVWF FSR0H
0368  51B1      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
036A  25B4      	ADDWF FCI_SHEAD_00000_1_len, W, 1
036C  6EE9      	MOVWF FSR0L
036E  51B7      	MOVF CompTempVar2045, W, 1
0370  6EEF      	MOVWF INDF0
0372  2BB4      	INCF FCI_SHEAD_00000_1_len, F, 1

    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
0376  6BB4      	CLRF FCI_SHEAD_00000_1_len, 1
0378            label46
0378  507A      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
037A  61B4      	CPFSLT FCI_SHEAD_00000_1_len, 1
037C  D01D      	BRA	label47
037E  51B3      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
0380  61B4      	CPFSLT FCI_SHEAD_00000_1_len, 1
0382  D01A      	BRA	label47
0384  5079      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0386  6EEA      	MOVWF FSR0H
0388  5078      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
038A  25B4      	ADDWF FCI_SHEAD_00000_1_len, W, 1
038C  6EE9      	MOVWF FSR0L
038E  52EF      	MOVF INDF0, F
0390  E013      	BZ	label47
0392  5079      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
0394  6EEA      	MOVWF FSR0H
0396  5078      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
0398  6EE9      	MOVWF FSR0L
039A  51B4      	MOVF FCI_SHEAD_00000_1_len, W, 1
039C  6FB6      	MOVWF CompTempVar2052, 1
039E  51B6      	MOVF CompTempVar2052, W, 1
03A0  26E9      	ADDWF FSR0L, F
03A2  50EF      	MOVF INDF0, W
03A4  6FB7      	MOVWF CompTempVar2053, 1
03A6  51B2      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
03A8  6EEA      	MOVWF FSR0H
03AA  51B1      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
03AC  25B4      	ADDWF FCI_SHEAD_00000_1_len, W, 1
03AE  6EE9      	MOVWF FSR0L
03B0  51B7      	MOVF CompTempVar2053, W, 1
03B2  6EEF      	MOVWF INDF0
03B4  2BB4      	INCF FCI_SHEAD_00000_1_len, F, 1
03B6  D7E0      	BRA	label46
03B8            label47

    // Copy second
    if (len < iDst_len)
03B8  51B3      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
03BA  61B4      	CPFSLT FCI_SHEAD_00000_1_len, 1
03BC  D030      	BRA	label50
041E            label50

    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
03BE  6BB7      	CLRF CompTempVar2059, 1
03C0  51B4      	MOVF FCI_SHEAD_00000_1_len, W, 1
03C2  25B1      	ADDWF FCI_SHEAD_00000_arg_sDst, W, 1
03C4  6FB6      	MOVWF CompTempVar2058, 1
03C6  51B2      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
03C8  23B7      	ADDWFC CompTempVar2059, F, 1
03CA  51B6      	MOVF CompTempVar2058, W, 1
03CC  6E78      	MOVWF FCI_SHEAD_00000_arg_sSrc1
03CE  51B7      	MOVF CompTempVar2059, W, 1
03D0  6E79      	MOVWF FCI_SHEAD_00000_arg_sSrc1+D'1'

      iSrc1_len = iDst_len - len;
03D2  51B4      	MOVF FCI_SHEAD_00000_1_len, W, 1
03D4  5DB3      	SUBWF FCI_SHEAD_00000_arg_iDst_len, W, 1
03D6  6E7A      	MOVWF FCI_SHEAD_00000_arg_iSrc1_len

      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
03D8  6BB5      	CLRF FCI_SHEAD_00000_1_strt, 1
03DA            label48
03DA  507F      	MOVF FCI_SHEAD_00000_arg_iSrc2_len, W
03DC  61B5      	CPFSLT FCI_SHEAD_00000_1_strt, 1
03DE  D01D      	BRA	label49
03E0  507A      	MOVF FCI_SHEAD_00000_arg_iSrc1_len, W
03E2  61B5      	CPFSLT FCI_SHEAD_00000_1_strt, 1
03E4  D01A      	BRA	label49
03E6  507C      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
03E8  6EEA      	MOVWF FSR0H
03EA  507B      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
03EC  25B5      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
03EE  6EE9      	MOVWF FSR0L
03F0  52EF      	MOVF INDF0, F
03F2  E013      	BZ	label49
03F4  507C      	MOVF FCI_SHEAD_00000_arg_sSrc2+D'1', W
03F6  6EEA      	MOVWF FSR0H
03F8  507B      	MOVF FCI_SHEAD_00000_arg_sSrc2, W
03FA  6EE9      	MOVWF FSR0L
03FC  51B5      	MOVF FCI_SHEAD_00000_1_strt, W, 1
03FE  6FB6      	MOVWF CompTempVar2062, 1
0400  51B6      	MOVF CompTempVar2062, W, 1
0402  26E9      	ADDWF FSR0L, F
0404  50EF      	MOVF INDF0, W
0406  6FB7      	MOVWF CompTempVar2063, 1
0408  5079      	MOVF FCI_SHEAD_00000_arg_sSrc1+D'1', W
040A  6EEA      	MOVWF FSR0H
040C  5078      	MOVF FCI_SHEAD_00000_arg_sSrc1, W
040E  25B5      	ADDWF FCI_SHEAD_00000_1_strt, W, 1
0410  6EE9      	MOVWF FSR0L
0412  51B7      	MOVF CompTempVar2063, W, 1
0414  6EEF      	MOVWF INDF0
0416  2BB5      	INCF FCI_SHEAD_00000_1_strt, F, 1
0418  D7E0      	BRA	label48
041A            label49

      len += strt;
041A  51B5      	MOVF FCI_SHEAD_00000_1_strt, W, 1
041C  27B4      	ADDWF FCI_SHEAD_00000_1_len, F, 1

    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
041E  51B3      	MOVF FCI_SHEAD_00000_arg_iDst_len, W, 1
0420  61B4      	CPFSLT FCI_SHEAD_00000_1_len, 1

  {
    sDst[len] = '\0';
0424  51B2      	MOVF FCI_SHEAD_00000_arg_sDst+D'1', W, 1
0426  6EEA      	MOVWF FSR0H
0428  51B1      	MOVF FCI_SHEAD_00000_arg_sDst, W, 1
042A  25B4      	ADDWF FCI_SHEAD_00000_1_len, W, 1
042C  6EE9      	MOVWF FSR0L
042E  0E00      	MOVLW 0x00
0430  6EEF      	MOVWF INDF0

  }
}
0422  0012      	RETURN
0432  0012      	RETURN



/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




/*********************************************************************
 *                  Flowcode CAL ICD File
 *
 * File: PIC_CAL_ICD.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in vioportion
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */


char ICD_Interrupt_Enable = 0;
0F10  6A66      	CLRF gbl_ICD_Interrupt_Enable


	//ICD Clock Port Defines
	#if (ICD_CLK_PORT == 0)
		#ifdef PORTA
			#define ICD_CLK_PIN_TRIS trisa
			#define ICD_CLK_PIN_PORT porta
		#endif
		#ifdef GPIO
			#define ICD_CLK_PIN_PORT gpio
			#ifdef TRISGPIO
				#define ICD_CLK_PIN_TRIS trisgpio
			#endif
			#ifdef TRISIO
				#define ICD_CLK_PIN_TRIS trisio
			#endif
			#ifdef TRIS
				#define ICD_CLK_PIN_TRIS tris
			#endif
		#endif
	#endif
	#if (ICD_CLK_PORT == 1)
	  #define ICD_CLK_PIN_TRIS trisb
	  #define ICD_CLK_PIN_PORT portb
	#endif
	#if (ICD_CLK_PORT == 2)
	  #define ICD_CLK_PIN_TRIS trisc
	  #define ICD_CLK_PIN_PORT portc
	#endif
	#if (ICD_CLK_PORT == 3)
	  #define ICD_CLK_PIN_TRIS trisd
	  #define ICD_CLK_PIN_PORT portd
	#endif
	#if (ICD_CLK_PORT == 4)
	  #define ICD_CLK_PIN_TRIS trise
	  #define ICD_CLK_PIN_PORT porte
	#endif
	#if (ICD_CLK_PORT == 5)
	  #define ICD_CLK_PIN_TRIS trisf
	  #define ICD_CLK_PIN_PORT portf
	#endif
	#if (ICD_CLK_PORT == 6)
	  #define ICD_CLK_PIN_TRIS trisg
	  #define ICD_CLK_PIN_PORT portg
	#endif

	//ICD Data Port Defines
	#if (ICD_DATA_PORT == 0)
		#ifdef PORTA
			#define ICD_DATA_PIN_TRIS trisa
			#define ICD_DATA_PIN_PORT porta
		#endif
		#ifdef GPIO
			#define ICD_DATA_PIN_PORT gpio
			#ifdef TRISGPIO
				#define ICD_DATA_PIN_TRIS trisgpio
			#endif
			#ifdef TRISIO
				#define ICD_DATA_PIN_TRIS trisio
			#endif
			#ifdef TRIS
				#define ICD_DATA_PIN_TRIS tris
			#endif
		#endif
	#endif
	#if (ICD_DATA_PORT == 1)
	  #define ICD_DATA_PIN_TRIS trisb
	  #define ICD_DATA_PIN_PORT portb
	#endif
	#if (ICD_DATA_PORT == 2)
	  #define ICD_DATA_PIN_TRIS trisc
	  #define ICD_DATA_PIN_PORT portc
	#endif
	#if (ICD_DATA_PORT == 3)
	  #define ICD_DATA_PIN_TRIS trisd
	  #define ICD_DATA_PIN_PORT portd
	#endif
	#if (ICD_DATA_PORT == 4)
	  #define ICD_DATA_PIN_TRIS trise
	  #define ICD_DATA_PIN_PORT porte
	#endif
	#if (ICD_DATA_PORT == 5)
	  #define ICD_DATA_PIN_TRIS trisf
	  #define ICD_DATA_PIN_PORT portf
	#endif
	#if (ICD_DATA_PORT == 6)
	  #define ICD_DATA_PIN_TRIS trisg
	  #define ICD_DATA_PIN_PORT portg
	#endif

	#ifndef ICD_CLK_PIN_TRIS
	  #warning "Error: no definition for the ICD clock pin"
	#endif

	#ifndef ICD_DATA_PIN_TRIS
	  #warning "Error: no definition for the ICD data pin"
	#endif

	//ICD Global Defines
	#define ICD_START	  0x80
	#define ICD_SETBP	  0x81
	#define ICD_CLRBP	  0x82
	#define ICD_EN_IBP	  0x83
	#define ICD_DIS_IBP	  0x84
	#define ICD_EN_SBP	  0x85
	#define ICD_DIS_SBP	  0x86
	#define ICD_RD_RAM	  0x87
	#define ICD_WR_RAM	  0x88
	#define ICD_GET_ID    0x8C
	#define ICD_GET_STACK 0x8D
	#define ICD_DIS_BPS	  0x8B
	#define ICD_RESET	  0x8E

	#ifdef MX_EE					//If EEPROM
		#define ICD_RD_EE	  0x89
		#define ICD_WR_EE	  0x8A
	#endif

	//ICD Global Variables
	unsigned char dbg_mode = 0x00;
0F12  6A67      	CLRF gbl_dbg_mode

	unsigned char icd_stack_ptr = 0x00;
0F14  6A68      	CLRF gbl_icd_stack_ptr

	unsigned int ICD_TIMEOUT = 1000;
0F16  0EE8      	MOVLW 0xE8
0F18  6E5B      	MOVWF gbl_ICD_TIMEOUT
0F1A  0E03      	MOVLW 0x03
0F1C  6E5C      	MOVWF gbl_ICD_TIMEOUT+D'1'


	//ICD Functions
	void FC_MARKER(signed int block_id);
	void ICD_PUSH(char macro_id);
	void ICD_POP();
	unsigned char icd_byte_tx(char data);
	unsigned char icd_byte_rx(void);
	unsigned char wait_clock(char state, char timeout_inc);
	unsigned char wait_data(char state);
	char read_register(unsigned int address);
	void write_register(unsigned int address, char data);
	void rst_dev(void);


	//ICD Marker Functions - Called at the start of every Flowcode block when ICD is enabled.
	void FC_MARKER(signed int block_id)

	{
		if (ICD_Interrupt_Enable == 0)
0898  5266      	MOVF gbl_ICD_Interrupt_Enable, F
089A  A4D8      	BTFSS STATUS,Z

		{
			unsigned char dbg_hold = 0;
089E  6A6F      	CLRF FC_MARKER_00000_2_dbg_hold

			unsigned char icd_cmd;
			unsigned int address;
			unsigned char int_store = 0;
08A0  6A73      	CLRF FC_MARKER_00000_2_int_store

			unsigned char idx;
			char tempdata = 0;
08A2  6A75      	CLRF FC_MARKER_00000_2_tempdata


			set_bit(ICD_CLK_PIN_TRIS, ICD_CLK_PIN);					//Clock is an input
08A4  8C93      	BSF gbl_trisb,6

			clear_bit(ICD_DATA_PIN_TRIS, ICD_DATA_PIN);				//Data is an output
08A6  9E93      	BCF gbl_trisb,7

			clear_bit(ICD_DATA_PIN_PORT, ICD_DATA_PIN);				//Data is default low
08A8  9E81      	BCF gbl_portb,7


			if(test_bit(ICD_CLK_PIN_PORT, ICD_CLK_PIN))				//Test to see if clock input is 1
08AA  AC81      	BTFSS gbl_portb,6
08AC  D004      	BRA	label81
08B6            label81

			{
				dbg_mode = dbg_mode | 0x04;							//Enable ICD Pause
08AE  0E04      	MOVLW 0x04
08B0  1067      	IORWF gbl_dbg_mode, W
08B2  6E67      	MOVWF gbl_dbg_mode

			}
			else
08B4  D003      	BRA	label82
08BC            label82
0A2C  D152      	BRA	label125
0C50  D7E1      	BRA	label121
0CD0  D7EA      	BRA	label124

			{
				dbg_mode = dbg_mode & 0xFB;							//Disable ICD Pause
08B6  0EFB      	MOVLW 0xFB
08B8  1467      	ANDWF gbl_dbg_mode, W
08BA  6E67      	MOVWF gbl_dbg_mode

			}

			if(dbg_mode)											//Is ICD Active?
08BC  5267      	MOVF gbl_dbg_mode, F
08BE  B4D8      	BTFSC STATUS,Z

			{
				int_store = intcon;									//Store interrupt register
08C2  50F2      	MOVF gbl_intcon, W
08C4  6E73      	MOVWF FC_MARKER_00000_2_int_store

				intcon = 0;											//Disable all interrupts
08C6  6AF2      	CLRF gbl_intcon


				if(dbg_mode & 0x01)
08C8  A067      	BTFSS gbl_dbg_mode,0
08CA  D002      	BRA	label83
08D0            label83

				{
					dbg_hold = 0x01;								//Test for Single Step operation
08CC  0E01      	MOVLW 0x01
08CE  6E6F      	MOVWF FC_MARKER_00000_2_dbg_hold

				}
				if(dbg_mode & 0x02)									//Test for Breakpoint operation and match
08D0  A267      	BTFSS gbl_dbg_mode,1
08D2  D020      	BRA	label86

				{
					for(idx=0; idx<ICD_NUM_BPS; idx++)
08D4  6A74      	CLRF FC_MARKER_00000_2_idx
08D6            label84
08D6  0E08      	MOVLW 0x08
08D8  6074      	CPFSLT FC_MARKER_00000_2_idx
08DA  D01C      	BRA	label86
0910  2A74      	INCF FC_MARKER_00000_2_idx, F
0912  D7E1      	BRA	label84
0914            label86

					{
						if(block_id == *(brk_pnt + idx))
08DC  5074      	MOVF FC_MARKER_00000_2_idx, W
08DE  6E76      	MOVWF CompTempVar2633
08E0  90D8      	BCF STATUS,C
08E2  3676      	RLCF CompTempVar2633, F
08E4  0E00      	MOVLW HIGH(gbl_brk_pnt+D'0')
08E6  6E79      	MOVWF CompTempVar2636
08E8  0E2D      	MOVLW LOW(gbl_brk_pnt+D'0')
08EA  6E78      	MOVWF CompTempVar2635
08EC  6A77      	CLRF CompTempVar2634
08EE  5078      	MOVF CompTempVar2635, W
08F0  2676      	ADDWF CompTempVar2633, F
08F2  5079      	MOVF CompTempVar2636, W
08F4  2277      	ADDWFC CompTempVar2634, F
08F6  5077      	MOVF CompTempVar2634, W
08F8  6EEA      	MOVWF FSR0H
08FA  5076      	MOVF CompTempVar2633, W
08FC  6EE9      	MOVWF FSR0L
08FE  50EE      	MOVF POSTINC0, W
0900  626D      	CPFSEQ FC_MARKER_00000_arg_block_id
0902  D006      	BRA	label85
0904  50EF      	MOVF INDF0, W
0906  626E      	CPFSEQ FC_MARKER_00000_arg_block_id+D'1'
0908  D003      	BRA	label85
0910            label85

						{
							dbg_hold = dbg_hold | 0x02;				//if(block_id == brk_pnt[idx]) dbg_hold = dbg_hold | 0x02;
090A  0E02      	MOVLW 0x02
090C  106F      	IORWF FC_MARKER_00000_2_dbg_hold, W
090E  6E6F      	MOVWF FC_MARKER_00000_2_dbg_hold

						}
					}
				}

				if(dbg_mode & 0x04) 								//Test for Flowcode triggered operation
0914  A467      	BTFSS gbl_dbg_mode,2
0916  D003      	BRA	label87
091E            label87

				{
					dbg_hold = dbg_hold | 0x04;
0918  0E04      	MOVLW 0x04
091A  106F      	IORWF FC_MARKER_00000_2_dbg_hold, W
091C  6E6F      	MOVWF FC_MARKER_00000_2_dbg_hold

				}

				if(dbg_mode & 0x08) 								//Test for initial stop condition
091E  A667      	BTFSS gbl_dbg_mode,3
0920  D006      	BRA	label88
092E            label88

				{
					dbg_hold = dbg_hold | 0x08;						//Place target into infinite wait mode
0922  0E08      	MOVLW 0x08
0924  106F      	IORWF FC_MARKER_00000_2_dbg_hold, W
0926  6E6F      	MOVWF FC_MARKER_00000_2_dbg_hold

					dbg_mode = dbg_mode & 0xF7;						//Disable infinite wait mode for next iteration.
0928  0EF7      	MOVLW 0xF7
092A  1467      	ANDWF gbl_dbg_mode, W
092C  6E67      	MOVWF gbl_dbg_mode

				}

				if(dbg_hold)										//Enter Debug mode
092E  526F      	MOVF FC_MARKER_00000_2_dbg_hold, F
0930  B4D8      	BTFSC STATUS,Z
0932  D1D2      	BRA	label126

				{
					set_bit(ICD_DATA_PIN_TRIS, ICD_DATA_PIN);		//Data is an input target stopped
0934  8E93      	BSF gbl_trisb,7


					if (dbg_hold & 0x08)
0936  A66F      	BTFSS FC_MARKER_00000_2_dbg_hold,3
0938  D020      	BRA	label89
097A            label89

					{
						//delay_us(250);							//Wait for pins to settle after reset
						delay_us(250);								//Wait for pins to settle after reset
093A  0EFA      	MOVLW 0xFA
093C  0100      	MOVLB 0x00
093E  6FAE      	MOVWF delay_us_00000_arg_del, 1
0940  EC06F000  	CALL delay_us_00000

						wait_clock(1<<ICD_CLK_PIN, 0);				//Wait indefinitely for the next clock
0944  0E40      	MOVLW 0x40
0946  6F80      	MOVWF wait_clock_00000_arg_state, 1
0948  6B81      	CLRF wait_clock_00000_arg_timeout_inc, 1
094A  EC09F001  	CALL wait_clock_00000

						wait_clock(0, 0);							//Wait indefinitely for the next clock
094E  6B80      	CLRF wait_clock_00000_arg_state, 1
0950  6B81      	CLRF wait_clock_00000_arg_timeout_inc, 1
0952  EC09F001  	CALL wait_clock_00000

						wait_clock(1<<ICD_CLK_PIN, 0);				//Wait indefinitely for the next clock
0956  0E40      	MOVLW 0x40
0958  6F80      	MOVWF wait_clock_00000_arg_state, 1
095A  6B81      	CLRF wait_clock_00000_arg_timeout_inc, 1
095C  EC09F001  	CALL wait_clock_00000

						icd_byte_tx(dbg_mode);						//Send current ICD mode
0960  5067      	MOVF gbl_dbg_mode, W
0962  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0964  EC7CF002  	CALL icd_byte_t_0004E

						icd_byte_tx(block_id);						//Send block ID
0968  506D      	MOVF FC_MARKER_00000_arg_block_id, W
096A  6E7A      	MOVWF icd_byte_t_0004E_arg_data
096C  EC7CF002  	CALL icd_byte_t_0004E

						icd_byte_tx(block_id>>8);
0970  506E      	MOVF FC_MARKER_00000_arg_block_id+D'1', W
0972  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0974  EC7CF002  	CALL icd_byte_t_0004E

					}
					else
0978  D01F      	BRA	label90
09B8            label90

					{
						//delay_us(250);							//Wait for pins to settle after reset
						delay_us(250);								//Wait for pins to settle after reset
097A  0EFA      	MOVLW 0xFA
097C  0100      	MOVLB 0x00
097E  6FAE      	MOVWF delay_us_00000_arg_del, 1
0980  EC06F000  	CALL delay_us_00000

						wait_clock(1<<ICD_CLK_PIN, 0);				//Wait indefinitely for the next clock
0984  0E40      	MOVLW 0x40
0986  6F80      	MOVWF wait_clock_00000_arg_state, 1
0988  6B81      	CLRF wait_clock_00000_arg_timeout_inc, 1
098A  EC09F001  	CALL wait_clock_00000

						wait_clock(0, 0);							//Wait indefinitely for the next clock
098E  6B80      	CLRF wait_clock_00000_arg_state, 1
0990  6B81      	CLRF wait_clock_00000_arg_timeout_inc, 1
0992  EC09F001  	CALL wait_clock_00000

						wait_clock(1<<ICD_CLK_PIN, 0);				//Wait indefinitely for the next clock
0996  0E40      	MOVLW 0x40
0998  6F80      	MOVWF wait_clock_00000_arg_state, 1
099A  6B81      	CLRF wait_clock_00000_arg_timeout_inc, 1
099C  EC09F001  	CALL wait_clock_00000

						icd_byte_tx(dbg_mode);						//Send current ICD mode
09A0  5067      	MOVF gbl_dbg_mode, W
09A2  6E7A      	MOVWF icd_byte_t_0004E_arg_data
09A4  EC7CF002  	CALL icd_byte_t_0004E

						icd_byte_tx(block_id);						//Send block ID
09A8  506D      	MOVF FC_MARKER_00000_arg_block_id, W
09AA  6E7A      	MOVWF icd_byte_t_0004E_arg_data
09AC  EC7CF002  	CALL icd_byte_t_0004E

						icd_byte_tx(block_id>>8);
09B0  506E      	MOVF FC_MARKER_00000_arg_block_id+D'1', W
09B2  6E7A      	MOVWF icd_byte_t_0004E_arg_data
09B4  EC7CF002  	CALL icd_byte_t_0004E

					}

					while(dbg_hold)
09B8  526F      	MOVF FC_MARKER_00000_2_dbg_hold, F
09BA  B4D8      	BTFSC STATUS,Z
09BC  D18D      	BRA	label126
0CD6  D670      	BRA	label90
0CD8            label126

					{
						icd_cmd = icd_byte_rx();					//Receive command byte
09BE  ECC4F002  	CALL icd_byte_r_0004F
09C2  507F      	MOVF CompTempVarRet2700, W
09C4  6E70      	MOVWF FC_MARKER_00000_2_icd_cmd

						switch(icd_cmd)
						{
							case ICD_START:									//Start Command
09C6  0E80      	MOVLW 0x80
09C8  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
09CA  D001      	BRA	label91
09CC  D030      	BRA	label103
09CE            label91
0A2E            label103


								dbg_hold = 0;								//Start the target running
0A2E  6A6F      	CLRF FC_MARKER_00000_2_dbg_hold

								clear_bit(ICD_DATA_PIN_TRIS, ICD_DATA_PIN);				//Data is an output
0A30  9E93      	BCF gbl_trisb,7

								set_bit(ICD_DATA_PIN_PORT, ICD_DATA_PIN);				//Data is high
0A32  8E81      	BSF gbl_portb,7

								wait_clock(0, 1);
0A34  6B80      	CLRF wait_clock_00000_arg_state, 1
0A36  0E01      	MOVLW 0x01
0A38  6F81      	MOVWF wait_clock_00000_arg_timeout_inc, 1
0A3A  EC09F001  	CALL wait_clock_00000

								break;
0A3E  D7BC      	BRA	label90


							case ICD_SETBP:						//Set Breakpoint Command
09CE  0E81      	MOVLW 0x81
09D0  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
09D2  D001      	BRA	label92
09D4  D035      	BRA	label104
09D6            label92
0A40            label104


								address = icd_byte_rx();					//Receive BP ID
0A40  ECC4F002  	CALL icd_byte_r_0004F
0A44  507F      	MOVF CompTempVarRet2700, W
0A46  6E71      	MOVWF FC_MARKER_00000_2_address
0A48  6A72      	CLRF FC_MARKER_00000_2_address+D'1'

								address = address | (icd_byte_rx() << 8);
0A4A  ECC4F002  	CALL icd_byte_r_0004F
0A4E  6A7A      	CLRF CompTempVar2646
0A50  507F      	MOVF CompTempVarRet2700, W
0A52  6E7B      	MOVWF CompTempVar2647
0A54  507A      	MOVF CompTempVar2646, W
0A56  1271      	IORWF FC_MARKER_00000_2_address, F
0A58  507B      	MOVF CompTempVar2647, W
0A5A  1272      	IORWF FC_MARKER_00000_2_address+D'1', F

								idx=0;										//Initialise BP counter
0A5C  6A74      	CLRF FC_MARKER_00000_2_idx

								while(idx < ICD_NUM_BPS && *(brk_pnt + idx) != -1)	//Scan for empty BP slot           //while(idx < ICD_NUM_BPS && brk_pnt[idx] != -1)	//Scan for empty BP slot
0A5E            label105
0A5E  0E08      	MOVLW 0x08
0A60  6074      	CPFSLT FC_MARKER_00000_2_idx
0A62  D01C      	BRA	label107
0A64  5074      	MOVF FC_MARKER_00000_2_idx, W
0A66  6E76      	MOVWF CompTempVar2640
0A68  90D8      	BCF STATUS,C
0A6A  3676      	RLCF CompTempVar2640, F
0A6C  0E00      	MOVLW HIGH(gbl_brk_pnt+D'0')
0A6E  6E7B      	MOVWF CompTempVar2651
0A70  0E2D      	MOVLW LOW(gbl_brk_pnt+D'0')
0A72  6E7A      	MOVWF CompTempVar2650
0A74  6A77      	CLRF CompTempVar2641
0A76  507A      	MOVF CompTempVar2650, W
0A78  2676      	ADDWF CompTempVar2640, F
0A7A  507B      	MOVF CompTempVar2651, W
0A7C  2277      	ADDWFC CompTempVar2641, F
0A7E  5077      	MOVF CompTempVar2641, W
0A80  6EEA      	MOVWF FSR0H
0A82  5076      	MOVF CompTempVar2640, W
0A84  6EE9      	MOVWF FSR0L
0A86  50EE      	MOVF POSTINC0, W
0A88  6E7A      	MOVWF CompTempVar2653
0A8A  0EFF      	MOVLW 0xFF
0A8C  62EF      	CPFSEQ INDF0
0A8E  D003      	BRA	label106
0A90  507A      	MOVF CompTempVar2653, W
0A92  0AFF      	XORLW 0xFF
0A94  E003      	BZ	label107
0A96            label106
0A9A  D7E1      	BRA	label105
0A9C            label107

									idx = idx + 1;
0A96  2874      	INCF FC_MARKER_00000_2_idx, W
0A98  6E74      	MOVWF FC_MARKER_00000_2_idx


								if (idx == ICD_NUM_BPS)						//If breakpoint command list full
0A9C  0E08      	MOVLW 0x08
0A9E  6274      	CPFSEQ FC_MARKER_00000_2_idx
0AA0  D004      	BRA	label108
0AAA            label108

									icd_byte_tx(255);						//Let the ICD know
0AA2  687A      	SETF icd_byte_t_0004E_arg_data
0AA4  EC7CF002  	CALL icd_byte_t_0004E

								else
0AA8  D787      	BRA	label90

								{
									*(brk_pnt + idx) = address;					//Else assign the BP ID to the BP list				//brk_pnt[idx] = address;
0AAA  5074      	MOVF FC_MARKER_00000_2_idx, W
0AAC  6E7A      	MOVWF CompTempVar2654
0AAE  90D8      	BCF STATUS,C
0AB0  367A      	RLCF CompTempVar2654, F
0AB2  0E00      	MOVLW HIGH(gbl_brk_pnt+D'0')
0AB4  6E7D      	MOVWF CompTempVar2657
0AB6  0E2D      	MOVLW LOW(gbl_brk_pnt+D'0')
0AB8  6E7C      	MOVWF CompTempVar2656
0ABA  6A7B      	CLRF CompTempVar2655
0ABC  507C      	MOVF CompTempVar2656, W
0ABE  267A      	ADDWF CompTempVar2654, F
0AC0  507D      	MOVF CompTempVar2657, W
0AC2  227B      	ADDWFC CompTempVar2655, F
0AC4  507B      	MOVF CompTempVar2655, W
0AC6  6EEA      	MOVWF FSR0H
0AC8  507A      	MOVF CompTempVar2654, W
0ACA  6EE9      	MOVWF FSR0L
0ACC  2AE9      	INCF FSR0L, F
0ACE  5071      	MOVF FC_MARKER_00000_2_address, W
0AD0  6E7C      	MOVWF CompTempVar2659
0AD2  5072      	MOVF FC_MARKER_00000_2_address+D'1', W
0AD4  6EEF      	MOVWF INDF0
0AD6  06E9      	DECF FSR0L, F
0AD8  507C      	MOVF CompTempVar2659, W
0ADA  6EEF      	MOVWF INDF0

									icd_byte_tx(0);							//Transmit an acknowledge
0ADC  6A7A      	CLRF icd_byte_t_0004E_arg_data
0ADE  EC7CF002  	CALL icd_byte_t_0004E

								}
								break;
0AE2  D76A      	BRA	label90


							case ICD_CLRBP:						//Clear Breakpoint Command
09D6  0E82      	MOVLW 0x82
09D8  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
09DA  D001      	BRA	label93
09DC  D083      	BRA	label109
09DE            label93
0AE4            label109


								address = icd_byte_rx();
0AE4  ECC4F002  	CALL icd_byte_r_0004F
0AE8  507F      	MOVF CompTempVarRet2700, W
0AEA  6E71      	MOVWF FC_MARKER_00000_2_address
0AEC  6A72      	CLRF FC_MARKER_00000_2_address+D'1'

								address = address | (icd_byte_rx() << 8);
0AEE  ECC4F002  	CALL icd_byte_r_0004F
0AF2  6A7A      	CLRF CompTempVar2660
0AF4  507F      	MOVF CompTempVarRet2700, W
0AF6  6E7B      	MOVWF CompTempVar2661
0AF8  507A      	MOVF CompTempVar2660, W
0AFA  1271      	IORWF FC_MARKER_00000_2_address, F
0AFC  507B      	MOVF CompTempVar2661, W
0AFE  1272      	IORWF FC_MARKER_00000_2_address+D'1', F

								idx=0;										//Initialise BP counter
0B00  6A74      	CLRF FC_MARKER_00000_2_idx

								while(idx < ICD_NUM_BPS && *(brk_pnt + idx) != address)	//Scan for slot containing BP				//while(idx < ICD_NUM_BPS && brk_pnt[idx] != address)
0B02            label110
0B02  0E08      	MOVLW 0x08
0B04  6074      	CPFSLT FC_MARKER_00000_2_idx
0B06  D01F      	BRA	label112
0B08  5074      	MOVF FC_MARKER_00000_2_idx, W
0B0A  6E78      	MOVWF CompTempVar2644
0B0C  90D8      	BCF STATUS,C
0B0E  3678      	RLCF CompTempVar2644, F
0B10  0E00      	MOVLW HIGH(gbl_brk_pnt+D'0')
0B12  6E7B      	MOVWF CompTempVar2665
0B14  0E2D      	MOVLW LOW(gbl_brk_pnt+D'0')
0B16  6E7A      	MOVWF CompTempVar2664
0B18  6A79      	CLRF CompTempVar2645
0B1A  507A      	MOVF CompTempVar2664, W
0B1C  2678      	ADDWF CompTempVar2644, F
0B1E  507B      	MOVF CompTempVar2665, W
0B20  2279      	ADDWFC CompTempVar2645, F
0B22  5079      	MOVF CompTempVar2645, W
0B24  6EEA      	MOVWF FSR0H
0B26  5078      	MOVF CompTempVar2644, W
0B28  6EE9      	MOVWF FSR0L
0B2A  50EE      	MOVF POSTINC0, W
0B2C  6E7A      	MOVWF CompTempVar2667
0B2E  5071      	MOVF FC_MARKER_00000_2_address, W
0B30  187A      	XORWF CompTempVar2667, W
0B32  BE72      	BTFSC FC_MARKER_00000_2_address+D'1',7
0B34  D005      	BRA	label111
0B36  E104      	BNZ	label111
0B38  5072      	MOVF FC_MARKER_00000_2_address+D'1', W
0B3A  62EF      	CPFSEQ INDF0
0B3C  6272      	CPFSEQ FC_MARKER_00000_2_address+D'1'
0B3E  D003      	BRA	label112
0B40            label111
0B44  D7DE      	BRA	label110
0B46            label112

									idx = idx + 1;
0B40  2874      	INCF FC_MARKER_00000_2_idx, W
0B42  6E74      	MOVWF FC_MARKER_00000_2_idx


								if (idx == ICD_NUM_BPS)						//If breakpoint not in the list
0B46  0E08      	MOVLW 0x08
0B48  6274      	CPFSEQ FC_MARKER_00000_2_idx
0B4A  D004      	BRA	label113
0B54            label113

									icd_byte_tx(255);						//Let the ICD know
0B4C  687A      	SETF icd_byte_t_0004E_arg_data
0B4E  EC7CF002  	CALL icd_byte_t_0004E

								else
0B52  D732      	BRA	label90

								{
									*(brk_pnt + idx) = -1;						//Else clear the BP ID from the BP list					//brk_pnt[idx] = -1;
0B54  5074      	MOVF FC_MARKER_00000_2_idx, W
0B56  6E7A      	MOVWF CompTempVar2668
0B58  90D8      	BCF STATUS,C
0B5A  367A      	RLCF CompTempVar2668, F
0B5C  0E00      	MOVLW HIGH(gbl_brk_pnt+D'0')
0B5E  6E7D      	MOVWF CompTempVar2671
0B60  0E2D      	MOVLW LOW(gbl_brk_pnt+D'0')
0B62  6E7C      	MOVWF CompTempVar2670
0B64  6A7B      	CLRF CompTempVar2669
0B66  507C      	MOVF CompTempVar2670, W
0B68  267A      	ADDWF CompTempVar2668, F
0B6A  507D      	MOVF CompTempVar2671, W
0B6C  227B      	ADDWFC CompTempVar2669, F
0B6E  507B      	MOVF CompTempVar2669, W
0B70  6EEA      	MOVWF FSR0H
0B72  507A      	MOVF CompTempVar2668, W
0B74  6EE9      	MOVWF FSR0L
0B76  2AE9      	INCF FSR0L, F
0B78  0EFF      	MOVLW 0xFF
0B7A  6E7C      	MOVWF CompTempVar2673
0B7C  6AEF      	CLRF INDF0
0B7E  06EF      	DECF INDF0, F
0B80  06E9      	DECF FSR0L, F
0B82  507C      	MOVF CompTempVar2673, W
0B84  6EEF      	MOVWF INDF0

									icd_byte_tx(0);							//Transmit an acknowledge
0B86  6A7A      	CLRF icd_byte_t_0004E_arg_data
0B88  EC7CF002  	CALL icd_byte_t_0004E

								}
								break;
0B8C  D715      	BRA	label90


							case ICD_EN_IBP:					//Enable indexed breakpoints Command
09DE  0E83      	MOVLW 0x83
09E0  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
09E2  D001      	BRA	label94
09E4  D0D4      	BRA	label114
09E6            label94
0B8E            label114


								dbg_mode = dbg_mode | 0x02;					//Enable indexed breakpoints
0B8E  0E02      	MOVLW 0x02
0B90  1067      	IORWF gbl_dbg_mode, W
0B92  6E67      	MOVWF gbl_dbg_mode

								break;
0B94  D711      	BRA	label90


							case ICD_DIS_IBP:					//Disable indexed breakpoints Command
09E6  0E84      	MOVLW 0x84
09E8  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
09EA  D001      	BRA	label95
09EC  D0D4      	BRA	label115
09EE            label95
0B96            label115


								dbg_mode = dbg_mode & 0xFD;					//Disable indexed breakpoints
0B96  0EFD      	MOVLW 0xFD
0B98  1467      	ANDWF gbl_dbg_mode, W
0B9A  6E67      	MOVWF gbl_dbg_mode

								break;
0B9C  D70D      	BRA	label90


							case ICD_EN_SBP:					//Enable step breakpoint Command
09EE  0E85      	MOVLW 0x85
09F0  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
09F2  D001      	BRA	label96
09F4  D0D4      	BRA	label116
09F6            label96
0B9E            label116


								dbg_mode = dbg_mode | 0x01;					//Enable step breakpoint
0B9E  0E01      	MOVLW 0x01
0BA0  1067      	IORWF gbl_dbg_mode, W
0BA2  6E67      	MOVWF gbl_dbg_mode

								break;
0BA4  D709      	BRA	label90


							case ICD_DIS_SBP:					//Disable step breakpoint Command
09F6  0E86      	MOVLW 0x86
09F8  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
09FA  D001      	BRA	label97
09FC  D0D4      	BRA	label117
09FE            label97
0BA6            label117


								dbg_mode = dbg_mode & 0xFE;					//Disable step breakpoint
0BA6  0EFE      	MOVLW 0xFE
0BA8  1467      	ANDWF gbl_dbg_mode, W
0BAA  6E67      	MOVWF gbl_dbg_mode

								break;
0BAC  D705      	BRA	label90


							case ICD_RD_RAM:					//Read Byte Of RAM Command
09FE  0E87      	MOVLW 0x87
0A00  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
0A02  D001      	BRA	label98
0A04  D0D4      	BRA	label118
0A06            label98
0BAE            label118


								address = icd_byte_rx();
0BAE  ECC4F002  	CALL icd_byte_r_0004F
0BB2  507F      	MOVF CompTempVarRet2700, W
0BB4  6E71      	MOVWF FC_MARKER_00000_2_address
0BB6  6A72      	CLRF FC_MARKER_00000_2_address+D'1'

								address = address | (icd_byte_rx() << 8);
0BB8  ECC4F002  	CALL icd_byte_r_0004F
0BBC  6A7A      	CLRF CompTempVar2674
0BBE  507F      	MOVF CompTempVarRet2700, W
0BC0  6E7B      	MOVWF CompTempVar2675
0BC2  507A      	MOVF CompTempVar2674, W
0BC4  1271      	IORWF FC_MARKER_00000_2_address, F
0BC6  507B      	MOVF CompTempVar2675, W
0BC8  1272      	IORWF FC_MARKER_00000_2_address+D'1', F

								icd_byte_tx(read_register(address));		//&address//Transmit the register value
0BCA  5071      	MOVF FC_MARKER_00000_2_address, W
0BCC  6E7B      	MOVWF read_regis_00050_arg_address
0BCE  5072      	MOVF FC_MARKER_00000_2_address+D'1', W
0BD0  6E7C      	MOVWF read_regis_00050_arg_address+D'1'
0BD2  EC6EF002  	CALL read_regis_00050
0BD6  5180      	MOVF CompTempVarRet2702, W, 1
0BD8  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0BDA  EC7CF002  	CALL icd_byte_t_0004E

								break;
0BDE  D6EC      	BRA	label90


							case ICD_WR_RAM:					//Write Byte Of RAM Command
0A06  0E88      	MOVLW 0x88
0A08  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
0A0A  D001      	BRA	label99
0A0C  D0E9      	BRA	label119
0A0E            label99
0BE0            label119


								address = icd_byte_rx();
0BE0  ECC4F002  	CALL icd_byte_r_0004F
0BE4  507F      	MOVF CompTempVarRet2700, W
0BE6  6E71      	MOVWF FC_MARKER_00000_2_address
0BE8  6A72      	CLRF FC_MARKER_00000_2_address+D'1'

								address = address | (icd_byte_rx() << 8);
0BEA  ECC4F002  	CALL icd_byte_r_0004F
0BEE  6A7A      	CLRF CompTempVar2678
0BF0  507F      	MOVF CompTempVarRet2700, W
0BF2  6E7B      	MOVWF CompTempVar2679
0BF4  507A      	MOVF CompTempVar2678, W
0BF6  1271      	IORWF FC_MARKER_00000_2_address, F
0BF8  507B      	MOVF CompTempVar2679, W
0BFA  1272      	IORWF FC_MARKER_00000_2_address+D'1', F

								write_register(address, icd_byte_rx());
0BFC  5071      	MOVF FC_MARKER_00000_2_address, W
0BFE  6E7A      	MOVWF write_regi_00051_arg_address
0C00  5072      	MOVF FC_MARKER_00000_2_address+D'1', W
0C02  6E7B      	MOVWF write_regi_00051_arg_address+D'1'
0C04  ECC4F002  	CALL icd_byte_r_0004F
0C08  507F      	MOVF CompTempVarRet2700, W
0C0A  6E7C      	MOVWF write_regi_00051_arg_data
0C0C  EC56F002  	CALL write_regi_00051

								break;
0C10  D6D3      	BRA	label90


							case ICD_DIS_BPS:					//Clear all breakpoints
0A0E  0E8B      	MOVLW 0x8B
0A10  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
0A12  D001      	BRA	label100
0A14  D0FE      	BRA	label120
0A16            label100
0C12            label120


								idx=0;	//init BP counter
0C12  6A74      	CLRF FC_MARKER_00000_2_idx

								while (idx < ICD_NUM_BPS)
0C14            label121
0C14  0E08      	MOVLW 0x08
0C16  6074      	CPFSLT FC_MARKER_00000_2_idx
0C18  D6CF      	BRA	label90

								{
									*(brk_pnt + idx) = -1;											//brk_pnt[idx] = -1;
0C1A  5074      	MOVF FC_MARKER_00000_2_idx, W
0C1C  6E7A      	MOVWF CompTempVar2682
0C1E  90D8      	BCF STATUS,C
0C20  367A      	RLCF CompTempVar2682, F
0C22  0E00      	MOVLW HIGH(gbl_brk_pnt+D'0')
0C24  6E7D      	MOVWF CompTempVar2685
0C26  0E2D      	MOVLW LOW(gbl_brk_pnt+D'0')
0C28  6E7C      	MOVWF CompTempVar2684
0C2A  6A7B      	CLRF CompTempVar2683
0C2C  507C      	MOVF CompTempVar2684, W
0C2E  267A      	ADDWF CompTempVar2682, F
0C30  507D      	MOVF CompTempVar2685, W
0C32  227B      	ADDWFC CompTempVar2683, F
0C34  507B      	MOVF CompTempVar2683, W
0C36  6EEA      	MOVWF FSR0H
0C38  507A      	MOVF CompTempVar2682, W
0C3A  6EE9      	MOVWF FSR0L
0C3C  2AE9      	INCF FSR0L, F
0C3E  0EFF      	MOVLW 0xFF
0C40  6E7C      	MOVWF CompTempVar2687
0C42  6AEF      	CLRF INDF0
0C44  06EF      	DECF INDF0, F
0C46  06E9      	DECF FSR0L, F
0C48  507C      	MOVF CompTempVar2687, W
0C4A  6EEF      	MOVWF INDF0

									idx = idx + 1;
0C4C  2874      	INCF FC_MARKER_00000_2_idx, W
0C4E  6E74      	MOVWF FC_MARKER_00000_2_idx

								}
								break;

							#ifdef MX_EE						//Is EEPROM Available?
								#ifdef _BOOSTC
									#ifndef MX_ICD_EEADR
										#ifdef EEADR
											#define MX_ICD_EEADR eeadr
										#endif
									#endif
									#ifndef MX_ICD_EEADR
										#ifdef EEADRL
											#define MX_ICD_EEADR eeadrl
										#endif
									#endif
									#ifndef MX_ICD_EEDATA
										#ifdef EEDATA
											#define MX_ICD_EEDATA eedata
										#endif
									#endif
									#ifndef MX_ICD_EEDATA
										#ifdef EEDATAL
											#define MX_ICD_EEDATA eedatal
										#endif
									#endif
								#endif

								case ICD_RD_EE:					//Read Contents Of EEPROM Command

									address = icd_byte_rx();
									address = address | (icd_byte_rx() << 8);

									#ifdef _BOOSTC
										MX_ICD_EEADR = address & 0xff;
										#if (MX_EE_SIZE > 256)
											eeadrh = (address & 0xff00) >> 8;
										#endif
										#ifdef MX_EE_TYPE2
											cr_bit(eecon1, EEPGD);
										#endif
										#ifdef MX_EE_TYPE3
											cr_bit(eecon1, EEPGD);
											cr_bit(eecon1, CFGS);
										#endif
											st_bit(eecon1, RD);

										icd_byte_tx(MX_ICD_EEDATA);
									#endif
									#ifdef HI_TECH_C
										icd_byte_tx(eeprom_read(address));
									#endif
									break;

								case ICD_WR_EE:					//Write Byte to EEPROM Command

									address = icd_byte_rx();
									address = address | (icd_byte_rx() << 8);
									tempdata = icd_byte_rx();

									#ifdef _BOOSTC
										while (ts_bit(eecon1, WR));				//wait for previous EE writes to complete...

										#if (MX_EE_SIZE > 256)
											eeadrh = (address & 0xff00) >> 8;
										#endif

										MX_ICD_EEADR = address & 0xff;
										MX_ICD_EEDATA = tempdata;

										#ifdef MX_EE_TYPE2
											cr_bit(eecon1, EEPGD);
										#endif
										#ifdef MX_EE_TYPE3
											cr_bit(eecon1, EEPGD);
											cr_bit(eecon1, CFGS);
										#endif

										st_bit(eecon1, WREN);
										eecon2 = 0x55;
										eecon2 = 0xAA;
										st_bit(eecon1, WR);
										while (ts_bit(eecon1, WR));				//wait for EE write to complete...
									#endif
									#ifdef HI_TECH_C
										eeprom_write(address, tempdata);
									#endif

									break;

							#endif								//End of EEPROM code

							case ICD_GET_ID:
0A16  0E8C      	MOVLW 0x8C
0A18  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
0A1A  D001      	BRA	label101
0A1C  D11A      	BRA	label122
0A1E            label101
0C52            label122

								icd_byte_tx(ICD_ID0);
0C52  0E19      	MOVLW 0x19
0C54  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0C56  EC7CF002  	CALL icd_byte_t_0004E

								icd_byte_tx(ICD_ID1);
0C5A  0EBC      	MOVLW 0xBC
0C5C  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0C5E  EC7CF002  	CALL icd_byte_t_0004E

								icd_byte_tx(ICD_ID2);
0C62  0EF2      	MOVLW 0xF2
0C64  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0C66  EC7CF002  	CALL icd_byte_t_0004E

								icd_byte_tx(ICD_ID3);
0C6A  0EB7      	MOVLW 0xB7
0C6C  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0C6E  EC7CF002  	CALL icd_byte_t_0004E

								icd_byte_tx(ICD_ID4);
0C72  0E51      	MOVLW 0x51
0C74  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0C76  EC7CF002  	CALL icd_byte_t_0004E

								icd_byte_tx(ICD_ID5);
0C7A  0E14      	MOVLW 0x14
0C7C  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0C7E  EC7CF002  	CALL icd_byte_t_0004E

								icd_byte_tx(ICD_ID6);
0C82  0E22      	MOVLW 0x22
0C84  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0C86  EC7CF002  	CALL icd_byte_t_0004E

								icd_byte_tx(ICD_ID7);
0C8A  0EE5      	MOVLW 0xE5
0C8C  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0C8E  EC7CF002  	CALL icd_byte_t_0004E

								break;
0C92  D692      	BRA	label90


							case ICD_GET_STACK:
0A1E  0E8D      	MOVLW 0x8D
0A20  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
0A22  D001      	BRA	label102
0A24  D137      	BRA	label123
0A26            label102
0C94            label123

								icd_byte_tx(ICD_STACK_SIZE+1);		//+1 because the PPP firmware does not expect the stack pointer return as well
0C94  0E09      	MOVLW 0x09
0C96  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0C98  EC7CF002  	CALL icd_byte_t_0004E

								icd_byte_tx(icd_stack_ptr);
0C9C  5068      	MOVF gbl_icd_stack_ptr, W
0C9E  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0CA0  EC7CF002  	CALL icd_byte_t_0004E

								for (idx=0; idx<ICD_STACK_SIZE; idx++)
0CA4  6A74      	CLRF FC_MARKER_00000_2_idx
0CA6            label124
0CA6  0E08      	MOVLW 0x08
0CA8  6074      	CPFSLT FC_MARKER_00000_2_idx
0CAA  D686      	BRA	label90
0CCE  2A74      	INCF FC_MARKER_00000_2_idx, F

								{
									icd_byte_tx(*(icd_stack + idx));											//icd_byte_tx(icd_stack[idx]);
0CAC  0E00      	MOVLW HIGH(gbl_icd_stack+D'0')
0CAE  6E7D      	MOVWF CompTempVar2693
0CB0  0E3D      	MOVLW LOW(gbl_icd_stack+D'0')
0CB2  6E7B      	MOVWF CompTempVar2690
0CB4  6A7C      	CLRF CompTempVar2691
0CB6  5074      	MOVF FC_MARKER_00000_2_idx, W
0CB8  267B      	ADDWF CompTempVar2690, F
0CBA  507D      	MOVF CompTempVar2693, W
0CBC  227C      	ADDWFC CompTempVar2691, F
0CBE  507C      	MOVF CompTempVar2691, W
0CC0  6EEA      	MOVWF FSR0H
0CC2  507B      	MOVF CompTempVar2690, W
0CC4  6EE9      	MOVWF FSR0L
0CC6  50EF      	MOVF INDF0, W
0CC8  6E7A      	MOVWF icd_byte_t_0004E_arg_data
0CCA  EC7CF002  	CALL icd_byte_t_0004E

								}
								break;

							case ICD_RESET:
0A26  0E8E      	MOVLW 0x8E
0A28  6270      	CPFSEQ FC_MARKER_00000_2_icd_cmd
0A2A  D7C6      	BRA	label90
0CD2            label125

								rst_dev();
0CD2  EC61F002  	CALL rst_dev_00000

								break;

							default:

								break;
						}
					}
				}
				clear_bit(ICD_DATA_PIN_TRIS,ICD_DATA_PIN);				//Data line as output
0CD8  9E93      	BCF gbl_trisb,7

				clear_bit(ICD_DATA_PIN_PORT,ICD_DATA_PIN);				//Data output low
0CDA  9E81      	BCF gbl_portb,7

				intcon = int_store;										//Restore all interrupts
0CDC  5073      	MOVF FC_MARKER_00000_2_int_store, W
0CDE  6EF2      	MOVWF gbl_intcon

			}
		}
	}
089C  0012      	RETURN
08C0  0012      	RETURN
0CE0  0012      	RETURN



	void ICD_PUSH(char macro_id)

	{
		if (ICD_Interrupt_Enable == 0)
086A  5266      	MOVF gbl_ICD_Interrupt_Enable, F
086C  A4D8      	BTFSS STATUS,Z

		{
			//note: there is no specific stack overflow test here (there will be at the PC end though)
			if (icd_stack_ptr < ICD_STACK_SIZE)
0870  0E08      	MOVLW 0x08
0872  6068      	CPFSLT gbl_icd_stack_ptr
0874  D00F      	BRA	label80
0894            label80

			{
				*(icd_stack + icd_stack_ptr) = macro_id;			//Assign macro ID				//icd_stack[icd_stack_ptr] = macro_id;
0876  0E00      	MOVLW HIGH(gbl_icd_stack+D'0')
0878  6E70      	MOVWF CompTempVar2706
087A  0E3D      	MOVLW LOW(gbl_icd_stack+D'0')
087C  6E6E      	MOVWF CompTempVar2703
087E  6A6F      	CLRF CompTempVar2704
0880  5068      	MOVF gbl_icd_stack_ptr, W
0882  266E      	ADDWF CompTempVar2703, F
0884  5070      	MOVF CompTempVar2706, W
0886  226F      	ADDWFC CompTempVar2704, F
0888  506F      	MOVF CompTempVar2704, W
088A  6EEA      	MOVWF FSR0H
088C  506E      	MOVF CompTempVar2703, W
088E  6EE9      	MOVWF FSR0L
0890  506D      	MOVF ICD_PUSH_00000_arg_macro_id, W
0892  6EEF      	MOVWF INDF0

			}
			icd_stack_ptr++;									//Move to next layer of stack
0894  2A68      	INCF gbl_icd_stack_ptr, F

		}
	}
086E  0012      	RETURN
0896  0012      	RETURN



	void ICD_POP()
	{
		if (ICD_Interrupt_Enable == 0)
		{
			//note: there is no specific stack underflow test here (there will be at the PC end though)
			icd_stack_ptr--;
		}
	}


	//ICD transmit byte Function - Bit bangs out a data byte.
	char icd_byte_tx(char data)

	{
		char count, mask;

		set_bit(ICD_CLK_PIN_TRIS,ICD_CLK_PIN);				//Clock line as input
04F8  8C93      	BSF gbl_trisb,6


		clear_bit(ICD_DATA_PIN_TRIS,ICD_DATA_PIN);			//Data line as output
04FA  9E93      	BCF gbl_trisb,7

		clear_bit(ICD_DATA_PIN_PORT,ICD_DATA_PIN);			//Data is 0 RTS
04FC  9E81      	BCF gbl_portb,7


		if (wait_clock(0, 0))								//Wait here for receive to start from host
04FE  0100      	MOVLB 0x00
0500  6B80      	CLRF wait_clock_00000_arg_state, 1
0502  6B81      	CLRF wait_clock_00000_arg_timeout_inc, 1
0504  EC09F001  	CALL wait_clock_00000
0508  5384      	MOVF CompTempVarRet2694, F, 1
050A  E002      	BZ	label58
0510            label58

			return 255;
050C  687D      	SETF CompTempVarRet2698


		for(count=0; count<8; count++)
0510  6A7B      	CLRF icd_byte_t_0004E_1_count
0512            label59
0512  0E08      	MOVLW 0x08
0514  607B      	CPFSLT icd_byte_t_0004E_1_count
0516  D022      	BRA	label64
0558  2A7B      	INCF icd_byte_t_0004E_1_count, F
055A  D7DB      	BRA	label59
055C            label64

		{
			mask = data & 0x01;								//Prepare data
0518  0E01      	MOVLW 0x01
051A  147A      	ANDWF icd_byte_t_0004E_arg_data, W
051C  6E7C      	MOVWF icd_byte_t_0004E_1_mask

			if(mask)										//Write data onto data line
051E  527C      	MOVF icd_byte_t_0004E_1_mask, F
0520  E002      	BZ	label60
0526            label60

				set_bit(ICD_DATA_PIN_PORT,ICD_DATA_PIN);
0522  8E81      	BSF gbl_portb,7

			else
0524  D001      	BRA	label61
0528            label61

				clear_bit(ICD_DATA_PIN_PORT,ICD_DATA_PIN);
0526  9E81      	BCF gbl_portb,7

			data = data >> 1;
0528  527A      	MOVF icd_byte_t_0004E_arg_data, F
052A  90D8      	BCF STATUS,C
052C  327A      	RRCF icd_byte_t_0004E_arg_data, F

			if (wait_clock(1<<ICD_CLK_PIN, 1))				//Wait for clock to go high
052E  0E40      	MOVLW 0x40
0530  6F80      	MOVWF wait_clock_00000_arg_state, 1
0532  0E01      	MOVLW 0x01
0534  6F81      	MOVWF wait_clock_00000_arg_timeout_inc, 1
0536  EC09F001  	CALL wait_clock_00000
053A  5384      	MOVF CompTempVarRet2694, F, 1
053C  E003      	BZ	label62
0544            label62

				return 254;
053E  0EFE      	MOVLW 0xFE
0540  6E7D      	MOVWF CompTempVarRet2698

			if (wait_clock(0, 1))							//Wait for clock to go low
0544  6B80      	CLRF wait_clock_00000_arg_state, 1
0546  0E01      	MOVLW 0x01
0548  6F81      	MOVWF wait_clock_00000_arg_timeout_inc, 1
054A  EC09F001  	CALL wait_clock_00000
054E  5384      	MOVF CompTempVarRet2694, F, 1
0550  E003      	BZ	label63
0558            label63

				return 253;
0552  0EFD      	MOVLW 0xFD
0554  6E7D      	MOVWF CompTempVarRet2698

		}

		set_bit(ICD_DATA_PIN_TRIS,ICD_DATA_PIN);			//Data line as input end of byte
055C  8E93      	BSF gbl_trisb,7

		if (wait_data(0))									//Wait for byte acknowledge
055E  6B80      	CLRF wait_data_00000_arg_state, 1
0560  ECE9F000  	CALL wait_data_00000
0564  5383      	MOVF CompTempVarRet2707, F, 1
0566  E003      	BZ	label65
056E            label65

				return 252;
0568  0EFC      	MOVLW 0xFC
056A  6E7D      	MOVWF CompTempVarRet2698

		if (wait_clock(1<<ICD_CLK_PIN, 1))					//Wait for byte acknowledge end
056E  0E40      	MOVLW 0x40
0570  6F80      	MOVWF wait_clock_00000_arg_state, 1
0572  0E01      	MOVLW 0x01
0574  6F81      	MOVWF wait_clock_00000_arg_timeout_inc, 1
0576  EC09F001  	CALL wait_clock_00000
057A  5384      	MOVF CompTempVarRet2694, F, 1
057C  E003      	BZ	label66
0584            label66

				return 251;
057E  0EFB      	MOVLW 0xFB
0580  6E7D      	MOVWF CompTempVarRet2698


		return 0;											//Success!
0584  6A7D      	CLRF CompTempVarRet2698

	}
050E  0012      	RETURN
0542  0012      	RETURN
0556  0012      	RETURN
056C  0012      	RETURN
0582  0012      	RETURN
0586  0012      	RETURN




	//ICD receive byte Function - Collects a bit banged serial data byte.
	char icd_byte_rx(void)

	{
		unsigned char data = 0;
0588  6A7D      	CLRF icd_byte_r_0004F_1_data

		unsigned char count;

		set_bit(ICD_DATA_PIN_TRIS,ICD_DATA_PIN);			//Data line as input
058A  8E93      	BSF gbl_trisb,7

		set_bit(ICD_CLK_PIN_TRIS,ICD_CLK_PIN);				//Clock line as input
058C  8C93      	BSF gbl_trisb,6


		wait_clock(0, 0);									//Wait here for transmit to start from host
058E  0100      	MOVLB 0x00
0590  6B80      	CLRF wait_clock_00000_arg_state, 1
0592  6B81      	CLRF wait_clock_00000_arg_timeout_inc, 1
0594  EC09F001  	CALL wait_clock_00000


		for(count=0; count<8; count++)						//Receive Byte
0598  6A7E      	CLRF icd_byte_r_0004F_1_count
059A            label67
059A  0E08      	MOVLW 0x08
059C  607E      	CPFSLT icd_byte_r_0004F_1_count
059E  D01D      	BRA	label71
05D6  2A7E      	INCF icd_byte_r_0004F_1_count, F
05D8  D7E0      	BRA	label67
05DA            label71

		{
			data = data >> 1;
05A0  527D      	MOVF icd_byte_r_0004F_1_data, F
05A2  90D8      	BCF STATUS,C
05A4  327D      	RRCF icd_byte_r_0004F_1_data, F

			if (wait_clock(0, 1))							//Wait for clock to go low
05A6  6B80      	CLRF wait_clock_00000_arg_state, 1
05A8  0E01      	MOVLW 0x01
05AA  6F81      	MOVWF wait_clock_00000_arg_timeout_inc, 1
05AC  EC09F001  	CALL wait_clock_00000
05B0  5384      	MOVF CompTempVarRet2694, F, 1
05B2  E002      	BZ	label68
05B8            label68

			{
				return 0;
05B4  6A7F      	CLRF CompTempVarRet2700

			}
			if (test_bit(ICD_DATA_PIN_PORT,ICD_DATA_PIN)) 	//Read incoming data on data pin
05B8  AE81      	BTFSS gbl_portb,7
05BA  D003      	BRA	label69
05C2            label69

				data = data | 0x80;
05BC  0E80      	MOVLW 0x80
05BE  107D      	IORWF icd_byte_r_0004F_1_data, W
05C0  6E7D      	MOVWF icd_byte_r_0004F_1_data


			if (wait_clock(1<<ICD_CLK_PIN, 1))				//Wait for clock to go high
05C2  0E40      	MOVLW 0x40
05C4  6F80      	MOVWF wait_clock_00000_arg_state, 1
05C6  0E01      	MOVLW 0x01
05C8  6F81      	MOVWF wait_clock_00000_arg_timeout_inc, 1
05CA  EC09F001  	CALL wait_clock_00000
05CE  5384      	MOVF CompTempVarRet2694, F, 1
05D0  E002      	BZ	label70
05D6            label70

			{
				return 0;
05D2  6A7F      	CLRF CompTempVarRet2700

			}
		}

		if (wait_data(1<<ICD_DATA_PIN))						//Wait for data to go high
05DA  0E80      	MOVLW 0x80
05DC  6F80      	MOVWF wait_data_00000_arg_state, 1
05DE  ECE9F000  	CALL wait_data_00000
05E2  5383      	MOVF CompTempVarRet2707, F, 1
05E4  E002      	BZ	label72
05EA            label72

		{
			return 0;
05E6  6A7F      	CLRF CompTempVarRet2700

		}

		if (wait_clock(0, 1))								//Wait for clock to go low
05EA  6B80      	CLRF wait_clock_00000_arg_state, 1
05EC  0E01      	MOVLW 0x01
05EE  6F81      	MOVWF wait_clock_00000_arg_timeout_inc, 1
05F0  EC09F001  	CALL wait_clock_00000
05F4  5384      	MOVF CompTempVarRet2694, F, 1
05F6  E002      	BZ	label73
05FC            label73

		{
			return 0;
05F8  6A7F      	CLRF CompTempVarRet2700

		}

		clear_bit(ICD_DATA_PIN_TRIS, ICD_DATA_PIN);			//ICD data is an output
05FC  9E93      	BCF gbl_trisb,7

		clear_bit(ICD_DATA_PIN_PORT, ICD_DATA_PIN);			//ICD data 0 send Ack
05FE  9E81      	BCF gbl_portb,7


		if (wait_clock(1<<ICD_CLK_PIN, 1))					//Wait for clock to go high
0600  0E40      	MOVLW 0x40
0602  6F80      	MOVWF wait_clock_00000_arg_state, 1
0604  0E01      	MOVLW 0x01
0606  6F81      	MOVWF wait_clock_00000_arg_timeout_inc, 1
0608  EC09F001  	CALL wait_clock_00000
060C  5384      	MOVF CompTempVarRet2694, F, 1
060E  E002      	BZ	label74
0614            label74

		{
			return 0;
0610  6A7F      	CLRF CompTempVarRet2700

		}

		set_bit(ICD_DATA_PIN_TRIS, ICD_DATA_PIN);			//ICD data clear ack
0614  8E93      	BSF gbl_trisb,7


		return(data);
0616  507D      	MOVF icd_byte_r_0004F_1_data, W
0618  6E7F      	MOVWF CompTempVarRet2700

	}
05B6  0012      	RETURN
05D4  0012      	RETURN
05E8  0012      	RETURN
05FA  0012      	RETURN
0612  0012      	RETURN
061A  0012      	RETURN



	char wait_clock(char state, char timeout_inc)

	{
		unsigned int timeout = 0;
0212  6B82      	CLRF wait_clock_00000_1_timeout, 1
0214  6B83      	CLRF wait_clock_00000_1_timeout+D'1', 1


		while ((test_bit(ICD_CLK_PIN_PORT,ICD_CLK_PIN) != state) && (timeout < ICD_TIMEOUT))	//Wait for clk
0216            label30
0216  0E40      	MOVLW 0x40
0218  1481      	ANDWF gbl_portb, W
021A  6F84      	MOVWF CompTempVar2695, 1
021C  5180      	MOVF wait_clock_00000_arg_state, W, 1
021E  6384      	CPFSEQ CompTempVar2695, 1
0220  6380      	CPFSEQ wait_clock_00000_arg_state, 1
0222  D00E      	BRA	label32
0224  505C      	MOVF gbl_ICD_TIMEOUT+D'1', W
0226  5D83      	SUBWF wait_clock_00000_1_timeout+D'1', W, 1
0228  E102      	BNZ	label31
022A  505B      	MOVF gbl_ICD_TIMEOUT, W
022C  5D82      	SUBWF wait_clock_00000_1_timeout, W, 1
022E            label31
022E  E208      	BC	label32
023E  D7EB      	BRA	label30
0240            label32

			timeout = timeout +  timeout_inc;		//Increment time out
0230  6B84      	CLRF CompTempVar2697, 1
0232  5181      	MOVF wait_clock_00000_arg_timeout_inc, W, 1
0234  2782      	ADDWF wait_clock_00000_1_timeout, F, 1
0236  5183      	MOVF wait_clock_00000_1_timeout+D'1', W, 1
0238  2384      	ADDWFC CompTempVar2697, F, 1
023A  5184      	MOVF CompTempVar2697, W, 1
023C  6F83      	MOVWF wait_clock_00000_1_timeout+D'1', 1


		if (timeout == ICD_TIMEOUT)					//Has the routine timed out
0240  505B      	MOVF gbl_ICD_TIMEOUT, W
0242  6382      	CPFSEQ wait_clock_00000_1_timeout, 1
0244  D006      	BRA	label33
0246  505C      	MOVF gbl_ICD_TIMEOUT+D'1', W
0248  6383      	CPFSEQ wait_clock_00000_1_timeout+D'1', 1
024A  D003      	BRA	label33
0252            label33

			return 1;
024C  0E01      	MOVLW 0x01
024E  6F84      	MOVWF CompTempVarRet2694, 1

		return 0;
0252  6B84      	CLRF CompTempVarRet2694, 1

	}
0250  0012      	RETURN
0254  0012      	RETURN



	char wait_data(char state)

	{
		unsigned int timeout = 0;
01D2  6B81      	CLRF wait_data_00000_1_timeout, 1
01D4  6B82      	CLRF wait_data_00000_1_timeout+D'1', 1

		while ((test_bit(ICD_DATA_PIN_PORT, ICD_DATA_PIN) != state) && (timeout < ICD_TIMEOUT))	//Wait for data
01D6            label26
01D6  0E80      	MOVLW 0x80
01D8  1481      	ANDWF gbl_portb, W
01DA  6F83      	MOVWF CompTempVar2708, 1
01DC  5180      	MOVF wait_data_00000_arg_state, W, 1
01DE  6383      	CPFSEQ CompTempVar2708, 1
01E0  6380      	CPFSEQ wait_data_00000_arg_state, 1
01E2  D00C      	BRA	label28
01E4  505C      	MOVF gbl_ICD_TIMEOUT+D'1', W
01E6  5D82      	SUBWF wait_data_00000_1_timeout+D'1', W, 1
01E8  E102      	BNZ	label27
01EA  505B      	MOVF gbl_ICD_TIMEOUT, W
01EC  5D81      	SUBWF wait_data_00000_1_timeout, W, 1
01EE            label27
01EE  E206      	BC	label28
01FA  D7ED      	BRA	label26
01FC            label28

			timeout = timeout +  1;					//Increment time out
01F0  5381      	MOVF wait_data_00000_1_timeout, F, 1
01F2  5382      	MOVF wait_data_00000_1_timeout+D'1', F, 1
01F4  2B81      	INCF wait_data_00000_1_timeout, F, 1
01F6  B4D8      	BTFSC STATUS,Z
01F8  2B82      	INCF wait_data_00000_1_timeout+D'1', F, 1


		if (timeout == ICD_TIMEOUT)					//Has the routine timed out
01FC  505B      	MOVF gbl_ICD_TIMEOUT, W
01FE  6381      	CPFSEQ wait_data_00000_1_timeout, 1
0200  D006      	BRA	label29
0202  505C      	MOVF gbl_ICD_TIMEOUT+D'1', W
0204  6382      	CPFSEQ wait_data_00000_1_timeout+D'1', 1
0206  D003      	BRA	label29
020E            label29

			return 1;
0208  0E01      	MOVLW 0x01
020A  6F83      	MOVWF CompTempVarRet2707, 1

		return 0;
020E  6B83      	CLRF CompTempVarRet2707, 1

	}
020C  0012      	RETURN
0210  0012      	RETURN



	char read_register(unsigned int address)

	{
		char RetVal;

		volatile char* register_ptr = (char*)address;
04DC  507B      	MOVF read_regis_00050_arg_address, W
04DE  6E7E      	MOVWF read_regis_00050_1_register_ptr
04E0  507C      	MOVF read_regis_00050_arg_address+D'1', W
04E2  6E7F      	MOVWF read_regis_00050_1_register_ptr+D'1'


		RetVal = *register_ptr;
04E4  507F      	MOVF read_regis_00050_1_register_ptr+D'1', W
04E6  6EEA      	MOVWF FSR0H
04E8  507E      	MOVF read_regis_00050_1_register_ptr, W
04EA  6EE9      	MOVWF FSR0L
04EC  50EF      	MOVF INDF0, W
04EE  6E7D      	MOVWF read_regis_00050_1_RetVal


		return RetVal;
04F0  507D      	MOVF read_regis_00050_1_RetVal, W
04F2  0100      	MOVLB 0x00
04F4  6F80      	MOVWF CompTempVarRet2702, 1

	}
04F6  0012      	RETURN



	void write_register(unsigned int address, char data)

	{
		volatile char* register_ptr = (char*)address;
04AC  507A      	MOVF write_regi_00051_arg_address, W
04AE  6E7D      	MOVWF write_regi_00051_1_register_ptr
04B0  507B      	MOVF write_regi_00051_arg_address+D'1', W
04B2  6E7E      	MOVWF write_regi_00051_1_register_ptr+D'1'


		*register_ptr = data;
04B4  507E      	MOVF write_regi_00051_1_register_ptr+D'1', W
04B6  6EEA      	MOVWF FSR0H
04B8  507D      	MOVF write_regi_00051_1_register_ptr, W
04BA  6EE9      	MOVWF FSR0L
04BC  507C      	MOVF write_regi_00051_arg_data, W
04BE  6EEF      	MOVWF INDF0

	}
04C0  0012      	RETURN



	void rst_dev()

	{
		//Disable all interrupts
		intcon = 0;
04C2  6AF2      	CLRF gbl_intcon

		#ifdef PIE1 | pie1
			pie1 = 0x00;
04C4  6A9D      	CLRF gbl_pie1

		#endif
		#ifdef PIE2 | pie2
			pie2 = 0x00;
04C6  6AA0      	CLRF gbl_pie2

		#endif

		//Reset all port pins back to inputs
		#ifdef PORTA | porta
			trisa = 0xff;
04C8  6892      	SETF gbl_trisa

			porta = 0x00;
04CA  6A80      	CLRF gbl_porta

		#endif
		#ifdef GPIO | gpio
			gpio = 0x00;
			#ifdef TRISGPIO | trisgpio
				trisgpio = 0xff;
			#endif
			#ifdef TRISIO | trisio
				trisio = 0xff;
			#endif
			#ifdef TRIS | tris
				tris = 0xff;
			#endif
		#endif
		#ifdef PORTB | portb
			trisb = 0xff;
04CC  6893      	SETF gbl_trisb

			portb = 0x00;
04CE  6A81      	CLRF gbl_portb

		#endif
		#ifdef portc | portc
			trisc = 0xff;
			portc = 0x00;
		#endif
		#ifdef PORTD | portd
			trisd = 0xff;
04D0  6895      	SETF gbl_trisd

			portd = 0x00;
04D2  6A83      	CLRF gbl_portd

		#endif
		#ifdef PORTE | porte
			trise = 0xff;
04D4  6896      	SETF gbl_trise

			porte = 0x00;
04D6  6A84      	CLRF gbl_porte

		#endif
		#ifdef PORTF | portf
			trisf = 0xff;
			portf = 0x00;
		#endif

		//Software Reset
		#ifdef _BOOSTC
			reset();			//Supported in BoostC
04D8  00FF      	RESET

		#endif
		#ifdef HI_TECH_C
			intcon=0;			//Disable Interrupts
			option_reg=8;		//Enable watchdog timer with 1:1 prescale
			while(1) ;   		//Wait forever for watchdog reset
		#endif
	}
04DA  0012      	RETURN


//End of ICD functionality

/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * Company) for its Flowcode graphical programming language is
 * intended and supplied to you, the Companys customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
061C  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
061E  0E7F      	MOVLW 0x7F
0620  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
0622  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
0624  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
0626  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
0628  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
062A  8A9D      	BSF gbl_pie1,5

				st_bit(intcon, PEIE);
062C  8CF2      	BSF gbl_intcon,6

				st_bit(intcon, GIE);
062E  8EF2      	BSF gbl_intcon,7

			#else
				cr_bit (pie1, RCIE);
			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
0630  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))
{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
			txsta = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}



CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
013A            label17
013A  0E10      	MOVLW 0x10
013C  149E      	ANDWF gbl_pir1, W
013E  6FAB      	MOVWF CompTempVar2715, 1
0140  53AB      	MOVF CompTempVar2715, F, 1
0142  E0FB      	BZ	label17


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0144  51A9      	MOVF FC_CAL_UAR_00056_arg_nChar, W, 1
0146  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
0148  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
0066  69BB      	SETF FC_CAL_UAR_00055_1_retVal, 1

  #endif

	MX_UINT8 delay1 = 0;
0068  6BBC      	CLRF FC_CAL_UAR_00055_1_delay1, 1

	MX_UINT8 regcheck = 0;
006A  6BBD      	CLRF FC_CAL_UAR_00055_1_regcheck, 1

	MX_UINT8 bWaitForever = 0;
006C  6BBE      	CLRF FC_CAL_UAR_00055_1_bWaitForever, 1

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
006E  6BBF      	CLRF FC_CAL_UAR_00055_1_rxStatus, 1

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
0070  6BC2      	CLRF FC_CAL_UAR_00055_1_dummy, 1

  #endif

	if (nTimeout == 255)
0072  29BA      	INCF FC_CAL_UAR_00055_arg_nTimeout, W, 1
0074  E102      	BNZ	label4
007A            label4

		bWaitForever = 1;
0076  0E01      	MOVLW 0x01
0078  6FBE      	MOVWF FC_CAL_UAR_00055_1_bWaitForever, 1


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
007A  53BF      	MOVF FC_CAL_UAR_00055_1_rxStatus, F, 1
007C  E124      	BNZ	label9
00C4  D7DA      	BRA	label4
00C6            label9

	{
		if (bWaitForever == 0)
007E  53BE      	MOVF FC_CAL_UAR_00055_1_bWaitForever, F, 1
0080  E118      	BNZ	label8

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
0082  53BA      	MOVF FC_CAL_UAR_00055_arg_nTimeout, F, 1
0084  E103      	BNZ	label5
008C            label5

			{
				rxStatus = UART_STATUS_TIMEOUT;
0086  0E01      	MOVLW 0x01
0088  6FBF      	MOVWF FC_CAL_UAR_00055_1_rxStatus, 1

			}
			else
008A  D013      	BRA	label8

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
008C  6BC0      	CLRF FC_CAL_UAR_00055_1_delaycnt, 1
008E  6BC1      	CLRF FC_CAL_UAR_00055_1_delaycnt+D'1', 1
0090            label6
0090  0E31      	MOVLW 0x31
0092  5DC0      	SUBWF FC_CAL_UAR_00055_1_delaycnt, W, 1
0094  E205      	BC	label7
0096  67C1      	TSTFSZ FC_CAL_UAR_00055_1_delaycnt+D'1', 1
0098  D003      	BRA	label7
009A  4BC0      	INFSNZ FC_CAL_UAR_00055_1_delaycnt, F, 1
009C  2BC1      	INCF FC_CAL_UAR_00055_1_delaycnt+D'1', F, 1
009E  D7F8      	BRA	label6
00A0            label7

				delay1 = delay1 + 1;
00A0  29BC      	INCF FC_CAL_UAR_00055_1_delay1, W, 1
00A2  6FBC      	MOVWF FC_CAL_UAR_00055_1_delay1, 1

				if(delay1 == 100)
00A4  0E64      	MOVLW 0x64
00A6  63BC      	CPFSEQ FC_CAL_UAR_00055_1_delay1, 1
00A8  D004      	BRA	label8
00B2            label8

				{
					nTimeout = nTimeout - 1;
00AA  05BA      	DECF FC_CAL_UAR_00055_arg_nTimeout, W, 1
00AC  6FBA      	MOVWF FC_CAL_UAR_00055_arg_nTimeout, 1

					MX_CLEAR_WATCHDOG;
00AE  0004      	CLRWDT

					delay1 = 0;
00B0  6BBC      	CLRF FC_CAL_UAR_00055_1_delay1, 1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00B2  0E20      	MOVLW 0x20
00B4  149E      	ANDWF gbl_pir1, W
00B6  6FC3      	MOVWF CompTempVar2712, 1
00B8  51C3      	MOVF CompTempVar2712, W, 1
00BA  6FBD      	MOVWF FC_CAL_UAR_00055_1_regcheck, 1

			if (regcheck != 0)
00BC  53BD      	MOVF FC_CAL_UAR_00055_1_regcheck, F, 1
00BE  E0DD      	BZ	label4

				rxStatus = UART_STATUS_RXBYTE;
00C0  0E02      	MOVLW 0x02
00C2  6FBF      	MOVWF FC_CAL_UAR_00055_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00C6  0E02      	MOVLW 0x02
00C8  63BF      	CPFSEQ FC_CAL_UAR_00055_1_rxStatus, 1
00CA  D018      	BRA	label12

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
00CC  0E04      	MOVLW 0x04
00CE  14AB      	ANDWF gbl_rcsta, W
00D0  6FC3      	MOVWF CompTempVar2713, 1
00D2  51C3      	MOVF CompTempVar2713, W, 1
00D4  6FBD      	MOVWF FC_CAL_UAR_00055_1_regcheck, 1

			if (regcheck != 0)
00D6  53BD      	MOVF FC_CAL_UAR_00055_1_regcheck, F, 1
00D8  E003      	BZ	label10
00E0            label10

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
00DA  50AE      	MOVF gbl_rcreg, W
00DC  6FC2      	MOVWF FC_CAL_UAR_00055_1_dummy, 1

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
00DE  D00E      	BRA	label12

			{
				regcheck = ts_bit(rcsta, OERR);
00E0  0E02      	MOVLW 0x02
00E2  14AB      	ANDWF gbl_rcsta, W
00E4  6FC3      	MOVWF CompTempVar2714, 1
00E6  51C3      	MOVF CompTempVar2714, W, 1
00E8  6FBD      	MOVWF FC_CAL_UAR_00055_1_regcheck, 1

				if (regcheck != 0)
00EA  53BD      	MOVF FC_CAL_UAR_00055_1_regcheck, F, 1
00EC  E003      	BZ	label11
00F4            label11

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
00EE  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
00F0  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
00F2  D004      	BRA	label12
00FC            label12

				{
					retVal = 0;
00F4  6BBB      	CLRF FC_CAL_UAR_00055_1_retVal, 1


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
00F6  50AE      	MOVF gbl_rcreg, W
00F8  11BB      	IORWF FC_CAL_UAR_00055_1_retVal, W, 1
00FA  6FBB      	MOVWF FC_CAL_UAR_00055_1_retVal, 1

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
00FC  51BB      	MOVF FC_CAL_UAR_00055_1_retVal, W, 1
00FE  6FC3      	MOVWF CompTempVarRet2711, 1
0100  6BC4      	CLRF CompTempVarRet2711+D'1', 1

}
0102  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))
{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
		return;

	if (new_baud == 0)
	{
		baudrate = MX_HARD_BAUD_1200;
		baudmode = MX_HARD_SLOW_1200;
	}
	else if (new_baud == 1)
	{
		baudrate = MX_HARD_BAUD_2400;
		baudmode = MX_HARD_SLOW_2400;
	}
	else if (new_baud == 2)
	{
		baudrate = MX_HARD_BAUD_4800;
		baudmode = MX_HARD_SLOW_4800;
	}
	else if (new_baud == 3)
	{
		baudrate = MX_HARD_BAUD_9600;
		baudmode = MX_HARD_SLOW_9600;
	}
	else if (new_baud == 4)
	{
		baudrate = MX_HARD_BAUD_19200;
		baudmode = MX_HARD_SLOW_19200;
	}
	else if (new_baud == 5)
	{
		baudrate = MX_HARD_BAUD_38400;
		baudmode = MX_HARD_SLOW_38400;
	}
	else if (new_baud == 6)
	{
		baudrate = MX_HARD_BAUD_57600;
		baudmode = MX_HARD_SLOW_57600;
	}
	else if (new_baud == 7)
	{
		baudrate = MX_HARD_BAUD_115200;
		baudmode = MX_HARD_SLOW_115200;
	}

	UART_Uninit();

	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
			cr_bit(txsta, BRGH);					//Low Speed
	    else
			st_bit(txsta, BRGH);					//High Speed

		spbrg = baudrate;   						// set the baud rate
		rcsta = 0;                    				// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
		st_bit(txsta, TXEN);
		st_bit(rcsta, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}

////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF45F007  	GOTO	_startup

0008  EF96F007  	GOTO	interrupt
000C            delay_us_00000
000C            ; { delay_us ; function begin
000C            label1
000C  0000      	NOP
000E  0000      	NOP
0010  2FAE      	DECFSZ delay_us_00000_arg_del, F, 1
0012  D7FC      	BRA	label1
0014  0012      	RETURN
0016            ; } delay_us function end

0016            delay_ms_00000
0016            ; { delay_ms ; function begin
0016  526E      	MOVF delay_ms_00000_arg_del, F
0018  0000      	NOP
001A  E101      	BNZ	label2
001C  0012      	RETURN
001E            label2
001E  0EF5      	MOVLW 0xF5
0020            label3
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0000      	NOP
0040  0FFF      	ADDLW 0xFF
0042  A4D8      	BTFSS STATUS,Z
0044  D7ED      	BRA	label3
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  0000      	NOP
0058  0000      	NOP
005A  0000      	NOP
005C  0000      	NOP
005E  0000      	NOP
0060  2E6E      	DECFSZ delay_ms_00000_arg_del, F
0062  D7DD      	BRA	label2
0064  0012      	RETURN
0066            ; } delay_ms function end




































































0E8A            _startup
0E8A  0ED5      	MOVLW 0xD5
0E8C  6E45      	MOVWF gbl_14_LSR
0E8E  0EC4      	MOVLW 0xC4
0E90  6E46      	MOVWF gbl_14_LSR+D'1'
0E92  0EBB      	MOVLW 0xBB
0E94  6E47      	MOVWF gbl_14_LSR+D'2'
0E96  0EDC      	MOVLW 0xDC
0E98  6E48      	MOVWF gbl_14_LSR+D'3'
0E9A  6A49      	CLRF gbl_15_gbl_aSig
0E9C  6A4A      	CLRF gbl_15_gbl_aSig+D'1'
0E9E  6A4B      	CLRF gbl_15_gbl_aSig+D'2'
0EA0  6A4C      	CLRF gbl_15_gbl_aSig+D'3'
0EA2  6A4D      	CLRF gbl_15_gbl_bSig
0EA4  6A4E      	CLRF gbl_15_gbl_bSig+D'1'
0EA6  6A4F      	CLRF gbl_15_gbl_bSig+D'2'
0EA8  6A50      	CLRF gbl_15_gbl_bSig+D'3'
0EAA  6A51      	CLRF gbl_15_gbl_zSig
0EAC  6A52      	CLRF gbl_15_gbl_zSig+D'1'
0EAE  6A53      	CLRF gbl_15_gbl_zSig+D'2'
0EB0  6A54      	CLRF gbl_15_gbl_zSig+D'3'
0EB2  6A60      	CLRF gbl_15_gbl_aExp
0EB4  6A61      	CLRF gbl_15_gbl_bExp
0EB6  6A59      	CLRF gbl_15_gbl_zExp
0EB8  6A5A      	CLRF gbl_15_gbl_zExp+D'1'
0EBA  6A62      	CLRF gbl_15_gbl_aSign
0EBC  6A63      	CLRF gbl_15_gbl_bSign
0EBE  6A64      	CLRF gbl_15_gbl_zSign
0EC0  6A65      	CLRF gbl_15_gbl_zSigZero
0EC2  6A55      	CLRF gbl_15_gbl_ret
0EC4  6A56      	CLRF gbl_15_gbl_ret+D'1'
0EC6  6A57      	CLRF gbl_15_gbl_ret+D'2'
0EC8  6A58      	CLRF gbl_15_gbl_ret+D'3'
0ECA  6A5E      	CLRF gbl_float_rounding_mode
0ECC  6A5F      	CLRF gbl_float_exception_flags
0ECE  6A5D      	CLRF gbl_float_detect_tininess





0F28  EF12F007  	GOTO	main




300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  FBFF      	DW 0xFBFF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
