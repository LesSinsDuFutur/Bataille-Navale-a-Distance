;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
0384  5052      	MOVF FC_CAL_Por_00042_arg_Tris+D'1', W
0386  6EEA      	MOVWF FSR0H
0388  5051      	MOVF FC_CAL_Por_00042_arg_Tris, W
038A  6EE9      	MOVWF FSR0L
038C  5053      	MOVF FC_CAL_Por_00042_arg_InMask, W
038E  10EF      	IORWF INDF0, W
0390  6E55      	MOVWF CompTempVar1825
0392  5055      	MOVF CompTempVar1825, W
0394  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
0396  5050      	MOVF FC_CAL_Por_00042_arg_Port+D'1', W
0398  6EEA      	MOVWF FSR0H
039A  504F      	MOVF FC_CAL_Por_00042_arg_Port, W
039C  6EE9      	MOVWF FSR0L
039E  5053      	MOVF FC_CAL_Por_00042_arg_InMask, W
03A0  14EF      	ANDWF INDF0, W
03A2  6E55      	MOVWF CompTempVarRet1822
03A4  5054      	MOVF FC_CAL_Por_00042_arg_Shift, W
03A6  6E56      	MOVWF CompTempVar1827
03A8            label29
03A8  B4D8      	BTFSC STATUS,Z
03AC  90D8      	BCF STATUS,C
03AE  3255      	RRCF CompTempVarRet1822, F
03B0  0656      	DECF CompTempVar1827, F
03B2  D7FA      	BRA	label29

		}
03AA  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BatailleNavale\affichage_bateau_v1.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Monday, January 30, 2017 14:58:36
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0xFB
#endif
#ifdef HI_TECH_C
__CONFIG(0xFB);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_TABLEAU 101
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT16 FCV_Y_LIGNE = (0x18);
099E  0E18      	MOVLW 0x18
09A0  6E1F      	MOVWF gbl_FCV_Y_LIGNE
09A2  6A20      	CLRF gbl_FCV_Y_LIGNE+D'1'

MX_GLOBAL MX_UINT8 FCV_NUM_CASE = (0x0);
09A4  6A3E      	CLRF gbl_FCV_NUM_CASE

MX_GLOBAL MX_UINT16 FCV_X_SORTIE = (0x0);
09A6  6A21      	CLRF gbl_FCV_X_SORTIE
09A8  6A22      	CLRF gbl_FCV_X_SORTIE+D'1'

MX_GLOBAL MX_UINT16 FCV_Y_TOUCH = (0x0);
09AA  6A23      	CLRF gbl_FCV_Y_TOUCH
09AC  6A24      	CLRF gbl_FCV_Y_TOUCH+D'1'

MX_GLOBAL MX_UINT8 FCV_HITBOX = (0x1);
09AE  0E01      	MOVLW 0x01
09B0  6E3F      	MOVWF gbl_FCV_HITBOX

MX_GLOBAL MX_UINT16 FCV_X_LIGNE = (0x18);
09B2  0E18      	MOVLW 0x18
09B4  6E25      	MOVWF gbl_FCV_X_LIGNE
09B6  6A26      	CLRF gbl_FCV_X_LIGNE+D'1'

MX_GLOBAL MX_UINT16 FCV_Y = (0x18);
09B8  0E18      	MOVLW 0x18
09BA  6E27      	MOVWF gbl_FCV_Y
09BC  6A28      	CLRF gbl_FCV_Y+D'1'

MX_GLOBAL MX_UINT16 FCV_X = (0x18);
09BE  0E18      	MOVLW 0x18
09C0  6E29      	MOVWF gbl_FCV_X
09C2  6A2A      	CLRF gbl_FCV_X+D'1'

MX_GLOBAL MX_UINT16 FCV_X_TOUCH = (0x0);
09C4  6A2B      	CLRF gbl_FCV_X_TOUCH
09C6  6A2C      	CLRF gbl_FCV_X_TOUCH+D'1'

MX_GLOBAL MX_UINT8 FCV_APPUI_ECRAN = (0x0);
09C8  6A40      	CLRF gbl_FCV_APPUI_ECRAN

MX_GLOBAL MX_UINT8 FCV_HITBOX_2 = (0x0);
09CA  6A41      	CLRF gbl_FCV_HITBOX_2

MX_GLOBAL MX_CHAR FCV_TABLEAU[FCVsz_TABLEAU];

void FCM_X_144();
void FCM_Hitbox_v2();
void FCM_Lecture_Coordonnes();
void FCM_X_72();
void FCM_X_168();
void FCM_Initialisation();
void FCM_Reinitialisation_tactile();
void FCM_X_96();
void FCM_Hitbox();
void FCM_X_24();
void FCM_X_240();
void FCM_affichage_bateau();
void FCM_X_48();
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2);
void FCM_Appui_tactile();
void FCM_Recuperation_coordonees();
void FCM_X_192();
void FCM_X_120();
void FCM_X_216();
void FCM_lignes();

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 porta
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 porta
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisa
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisa
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (2)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
09CC  0E00      	MOVLW 0x00
09CE  6E42      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
09D0  0E01      	MOVLW 0x01
09D2  6E43      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
09D4  0E02      	MOVLW 0x02
09D6  6E44      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
09D8  0E03      	MOVLW 0x03
09DA  6E45      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
09DC  0E04      	MOVLW 0x04
09DE  6E46      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
09E0  0E05      	MOVLW 0x05
09E2  6E47      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
09E4  0E06      	MOVLW 0x06
09E6  6E48      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
09E8  0E07      	MOVLW 0x07
09EA  6E49      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
09EC  6A19      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009
09EE  6A1A      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1'
09F0  6A1B      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2'
09F2  6A1C      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3'

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
09F4  6A4A      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x63);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)

{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;
0822  6A4C      	CLRF FCD_0f051__0005E_1_FCR_RETVAL
0824  6A4D      	CLRF FCD_0f051__0005E_1_FCR_RETVAL+D'1'


	if (FCL_AXIS == 0)
0826  524B      	MOVF FCD_0f051__0005E_arg_FCL_AXIS, F
0828  E007      	BZ	label42

	{

	} else {

		if (FCL_AXIS == 'x')
082A  0E78      	MOVLW 0x78
082C  624B      	CPFSEQ FCD_0f051__0005E_arg_FCL_AXIS
082E  D001      	BRA	label41
0832            label41

		{

		} else {
0830  D003      	BRA	label42


			if (FCL_AXIS == 'X')
0832  0E58      	MOVLW 0x58
0834  624B      	CPFSEQ FCD_0f051__0005E_arg_FCL_AXIS
0836  D004      	BRA	label43
0838            label42

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;
0838  5033      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W
083A  6E4C      	MOVWF FCD_0f051__0005E_1_FCR_RETVAL
083C  5034      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', W
083E  6E4D      	MOVWF FCD_0f051__0005E_1_FCR_RETVAL+D'1'


FCC_G4D_ReadTouchCoordinatesPicaso_A:
0840            label43

;

	if (FCL_AXIS == 1)
0840  044B      	DECF FCD_0f051__0005E_arg_FCL_AXIS, W
0842  E007      	BZ	label45

	{

	} else {

		if (FCL_AXIS == 'y')
0844  0E79      	MOVLW 0x79
0846  624B      	CPFSEQ FCD_0f051__0005E_arg_FCL_AXIS
0848  D001      	BRA	label44
084C            label44

		{

		} else {
084A  D003      	BRA	label45


			if (FCL_AXIS == 'Y')
084C  0E59      	MOVLW 0x59
084E  624B      	CPFSEQ FCD_0f051__0005E_arg_FCL_AXIS
0850  D004      	BRA	label46
0852            label45

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;
0852  5031      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W
0854  6E4C      	MOVWF FCD_0f051__0005E_1_FCR_RETVAL
0856  5032      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', W
0858  6E4D      	MOVWF FCD_0f051__0005E_1_FCR_RETVAL+D'1'


FCC_G4D_ReadTouchCoordinatesPicaso_B:
085A            label46

;

	return (FCR_RETVAL);
085A  504C      	MOVF FCD_0f051__0005E_1_FCR_RETVAL, W
085C  6E4E      	MOVWF CompTempVarRet2644
085E  504D      	MOVF FCD_0f051__0005E_1_FCR_RETVAL+D'1', W
0860  6E4F      	MOVWF CompTempVarRet2644+D'1'


}
0862  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x6F);
0576  0E6F      	MOVLW 0x6F
0578  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
057A  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
057C  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(4);
0580  0E04      	MOVLW 0x04
0582  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0584  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0586  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
058A  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
058C  EC4EF000  	CALL FC_CAL_UAR_00072


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0590  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0592  EC4EF000  	CALL FC_CAL_UAR_00072
0596  5066      	MOVF CompTempVarRet2734, W
0598  6E4C      	MOVWF FCD_0f051__0006D_1_FCR_RETVAL


	FC_CAL_UART_Receive_1(255);
059A  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
059C  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(255);
05A0  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
05A2  EC4EF000  	CALL FC_CAL_UAR_00072


	if (FCR_RETVAL)
05A6  524C      	MOVF FCD_0f051__0006D_1_FCR_RETVAL, F
05A8  E032      	BZ	label34
060E            label34

	{

		FC_CAL_UART_Send_1(0x6F);
05AA  0E6F      	MOVLW 0x6F
05AC  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
05AE  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
05B0  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(5);
05B4  0E05      	MOVLW 0x05
05B6  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
05B8  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
05BA  EC46F000  	CALL FC_CAL_UAR_00073


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_1(255);
05BE  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
05C0  EC4EF000  	CALL FC_CAL_UAR_00072
05C4  5066      	MOVF CompTempVarRet2734, W
05C6  6E33      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F
05C8  5067      	MOVF CompTempVarRet2734+D'1', W
05CA  6E34      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1'


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
05CC  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
05CE  EC4EF000  	CALL FC_CAL_UAR_00072
05D2  5066      	MOVF CompTempVarRet2734, W
05D4  6E4B      	MOVWF FCD_0f051__0006D_1_FCL_TEMP


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
05D6  6A4D      	CLRF CompTempVar2716
05D8  5033      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W
05DA  6E34      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1'
05DC  504D      	MOVF CompTempVar2716, W
05DE  6E33      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;
05E0  504B      	MOVF FCD_0f051__0006D_1_FCL_TEMP, W
05E2  1233      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000F, F
05E4  5234      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', F


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_1(255);
05E6  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
05E8  EC4EF000  	CALL FC_CAL_UAR_00072
05EC  5066      	MOVF CompTempVarRet2734, W
05EE  6E31      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E
05F0  5067      	MOVF CompTempVarRet2734+D'1', W
05F2  6E32      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1'


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
05F4  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
05F6  EC4EF000  	CALL FC_CAL_UAR_00072
05FA  5066      	MOVF CompTempVarRet2734, W
05FC  6E4B      	MOVWF FCD_0f051__0006D_1_FCL_TEMP


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
05FE  6A4D      	CLRF CompTempVar2720
0600  5031      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W
0602  6E32      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1'
0604  504D      	MOVF CompTempVar2720, W
0606  6E31      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;
0608  504B      	MOVF FCD_0f051__0006D_1_FCL_TEMP, W
060A  1231      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000E, F
060C  5232      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', F


	// } else {

	}

	return (FCR_RETVAL);
060E  504C      	MOVF FCD_0f051__0006D_1_FCR_RETVAL, W
0610  6E4D      	MOVWF CompTempVarRet2715


}
0612  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_1(FCL_RADIUS);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
03EC  6A54      	CLRF FCD_0f051__0006E_1_FCL_D1
03EE  6A55      	CLRF FCD_0f051__0006E_1_FCL_D1+D'1'

	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
03F0  0E01      	MOVLW 0x01
03F2  6E56      	MOVWF FCD_0f051__0006E_1_FCL_YINC
03F4  6A57      	CLRF FCD_0f051__0006E_1_FCL_YINC+D'1'

	MX_SINT16 FCL_XINC = (1);
03F6  0E01      	MOVLW 0x01
03F8  6E58      	MOVWF FCD_0f051__0006E_1_FCL_XINC
03FA  6A59      	CLRF FCD_0f051__0006E_1_FCL_XINC+D'1'



	FC_CAL_UART_Send_1(0x4C);
03FC  0E4C      	MOVLW 0x4C
03FE  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0400  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0402  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0406  504D      	MOVF FCD_0f051__0006E_arg_FCL_X1+D'1', W
0408  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
040A  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
040C  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1);
0410  504C      	MOVF FCD_0f051__0006E_arg_FCL_X1, W
0412  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0414  504D      	MOVF FCD_0f051__0006E_arg_FCL_X1+D'1', W
0416  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0418  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
041C  504F      	MOVF FCD_0f051__0006E_arg_FCL_Y1+D'1', W
041E  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0420  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0422  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1);
0426  504E      	MOVF FCD_0f051__0006E_arg_FCL_Y1, W
0428  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
042A  504F      	MOVF FCD_0f051__0006E_arg_FCL_Y1+D'1', W
042C  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
042E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
0432  5051      	MOVF FCD_0f051__0006E_arg_FCL_X2+D'1', W
0434  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0436  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0438  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2);
043C  5050      	MOVF FCD_0f051__0006E_arg_FCL_X2, W
043E  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0440  5051      	MOVF FCD_0f051__0006E_arg_FCL_X2+D'1', W
0442  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0444  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
0448  5053      	MOVF FCD_0f051__0006E_arg_FCL_Y2+D'1', W
044A  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
044C  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
044E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2);
0452  5052      	MOVF FCD_0f051__0006E_arg_FCL_Y2, W
0454  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0456  5053      	MOVF FCD_0f051__0006E_arg_FCL_Y2+D'1', W
0458  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
045A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
045E  5030      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
0460  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0462  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0464  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0468  502F      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W
046A  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
046C  5030      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
046E  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0470  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
0474  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0476  EC4EF000  	CALL FC_CAL_UAR_00072


}
047A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_POSH >> 8);

	FC_CAL_UART_Send_1(FCL_POSH);

	FC_CAL_UART_Send_1(FCL_POSL >> 8);

	FC_CAL_UART_Send_1(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
0674  0E59      	MOVLW 0x59
0676  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0678  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
067A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x05);
067E  0E05      	MOVLW 0x05
0680  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0682  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0684  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x01);
0688  0E01      	MOVLW 0x01
068A  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
068C  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
068E  EC46F000  	CALL FC_CAL_UAR_00073


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0692  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0694  EC4EF000  	CALL FC_CAL_UAR_00072
0698  5066      	MOVF CompTempVarRet2734, W
069A  6E4B      	MOVWF FCD_0f051__00063_1_FCR_RETVAL


	if (FCR_RETVAL == 6)
069C  0E06      	MOVLW 0x06
069E  624B      	CPFSEQ FCD_0f051__00063_1_FCR_RETVAL
06A0  D002      	BRA	label37
06A6            label37

	{

		FCR_RETVAL = 0;
06A2  6A4B      	CLRF FCD_0f051__00063_1_FCR_RETVAL


	} else {
06A4  D001      	BRA	label38
06A8            label38


		FCR_RETVAL = 255;
06A6  684B      	SETF FCD_0f051__00063_1_FCR_RETVAL


	}

	return (FCR_RETVAL);
06A8  504B      	MOVF FCD_0f051__00063_1_FCR_RETVAL, W
06AA  6E4C      	MOVWF CompTempVarRet2679


}
06AC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x00);

	FC_CAL_UART_Send_1(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x01);

	FC_CAL_UART_Send_1(FCL_DISPLAY);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x02);

	FC_CAL_UART_Send_1(FCL_CONTRAST);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
0614  0E59      	MOVLW 0x59
0616  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0618  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
061A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x05);
061E  0E05      	MOVLW 0x05
0620  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0622  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0624  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x00);
0628  6A5D      	CLRF FC_CAL_UAR_00073_arg_nChar
062A  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
062C  EC46F000  	CALL FC_CAL_UAR_00073


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0630  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0632  EC4EF000  	CALL FC_CAL_UAR_00072
0636  5066      	MOVF CompTempVarRet2734, W
0638  6E4B      	MOVWF FCD_0f051__00064_1_FCR_RETVAL


	FC_CAL_UART_Send_1(0x59);
063A  0E59      	MOVLW 0x59
063C  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
063E  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0640  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x05);
0644  0E05      	MOVLW 0x05
0646  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0648  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
064A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x02);
064E  0E02      	MOVLW 0x02
0650  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0652  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0654  EC46F000  	CALL FC_CAL_UAR_00073


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0658  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
065A  EC4EF000  	CALL FC_CAL_UAR_00072
065E  5066      	MOVF CompTempVarRet2734, W
0660  6E4B      	MOVWF FCD_0f051__00064_1_FCR_RETVAL


	if (FCR_RETVAL == 6)
0662  0E06      	MOVLW 0x06
0664  624B      	CPFSEQ FCD_0f051__00064_1_FCR_RETVAL
0666  D002      	BRA	label35
066C            label35

	{

		FCR_RETVAL = 0;
0668  6A4B      	CLRF FCD_0f051__00064_1_FCR_RETVAL


	} else {
066A  D001      	BRA	label36
066E            label36


		FCR_RETVAL = 255;
066C  684B      	SETF FCD_0f051__00064_1_FCR_RETVAL


	}

	return (FCR_RETVAL);
066E  504B      	MOVF FCD_0f051__00064_1_FCR_RETVAL, W
0670  6E4C      	MOVWF CompTempVarRet2680


}
0672  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x56);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_1(0x10);

	} else {

		FC_CAL_UART_Send_1(0x08);

	}

	FC_CAL_UART_Send_1(FCL_DELAY);

	FC_CAL_UART_Send_1(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_1(FCL_FRAMES);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x76);

	FC_CAL_UART_Send_1(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_1(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_1(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_1(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_1(0x03);

		}
	}

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x65);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RX >> 8);

	FC_CAL_UART_Send_1(FCL_RX);

	FC_CAL_UART_Send_1(FCL_RY >> 8);

	FC_CAL_UART_Send_1(FCL_RY);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);


	FC_CAL_UART_Send_1(0x4F);

	if (FCL_TRANSPARENT)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x53);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_FONT);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Send_1(1);

	FC_CAL_UART_Send_1(1);

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		if (FCL_STR[FCL_IDX] == 0)
		{

			goto FCC_Print_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_STR[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_Print_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x0c);

	FC_CAL_UART_Send_1(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
047C  6A4F      	CLRF FCD_0f051__00061_1_FCL_Y
047E  6A50      	CLRF FCD_0f051__00061_1_FCL_Y+D'1'

	MX_UINT16 FCL_X = (0x0);
0480  6A51      	CLRF FCD_0f051__00061_1_FCL_X
0482  6A52      	CLRF FCD_0f051__00061_1_FCL_X+D'1'



	FC_CAL_UART_Send_1(0x42);
0484  0E42      	MOVLW 0x42
0486  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0488  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
048A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
048E  502E      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
0490  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0492  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0494  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
0498  502D      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W
049A  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
049C  502E      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
049E  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
04A0  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
04A4  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
04A6  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Send_1(0x45);
04AA  0E45      	MOVLW 0x45
04AC  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
04AE  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
04B0  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
04B4  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
04B6  EC4EF000  	CALL FC_CAL_UAR_00072


}
04BA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x49);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)

{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
0286  3253      	RRCF FCD_0f051__00066_arg_FCL_RED, F
0288  3253      	RRCF FCD_0f051__00066_arg_FCL_RED, F
028A  3253      	RRCF FCD_0f051__00066_arg_FCL_RED, F
028C  0E1F      	MOVLW 0x1F
028E  1653      	ANDWF FCD_0f051__00066_arg_FCL_RED, F

	FCL_GREEN = FCL_GREEN >> (8 - 6);
0290  3254      	RRCF FCD_0f051__00066_arg_FCL_GREEN, F
0292  3254      	RRCF FCD_0f051__00066_arg_FCL_GREEN, F
0294  0E3F      	MOVLW 0x3F
0296  1654      	ANDWF FCD_0f051__00066_arg_FCL_GREEN, F

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0298  3255      	RRCF FCD_0f051__00066_arg_FCL_BLUE, F
029A  3255      	RRCF FCD_0f051__00066_arg_FCL_BLUE, F
029C  3255      	RRCF FCD_0f051__00066_arg_FCL_BLUE, F
029E  0E1F      	MOVLW 0x1F
02A0  1655      	ANDWF FCD_0f051__00066_arg_FCL_BLUE, F


	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
02A2  5054      	MOVF FCD_0f051__00066_arg_FCL_GREEN, W
02A4  6E56      	MOVWF CompTempVar2684
02A6  6A30      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1'
02A8  3656      	RLCF CompTempVar2684, F
02AA  3630      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
02AC  3656      	RLCF CompTempVar2684, F
02AE  3630      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
02B0  3656      	RLCF CompTempVar2684, F
02B2  3630      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
02B4  3656      	RLCF CompTempVar2684, F
02B6  3630      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
02B8  3656      	RLCF CompTempVar2684, F
02BA  3630      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
02BC  0EE0      	MOVLW 0xE0
02BE  1656      	ANDWF CompTempVar2684, F
02C0  5056      	MOVF CompTempVar2684, W
02C2  1055      	IORWF FCD_0f051__00066_arg_FCL_BLUE, W
02C4  6E2F      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
02C6  6A56      	CLRF CompTempVar2688
02C8  5053      	MOVF FCD_0f051__00066_arg_FCL_RED, W
02CA  6E57      	MOVWF CompTempVar2689
02CC  90D8      	BCF STATUS,C
02CE  3657      	RLCF CompTempVar2689, F
02D0  90D8      	BCF STATUS,C
02D2  3657      	RLCF CompTempVar2689, F
02D4  90D8      	BCF STATUS,C
02D6  3657      	RLCF CompTempVar2689, F
02D8  5056      	MOVF CompTempVar2688, W
02DA  122F      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F
02DC  5057      	MOVF CompTempVar2689, W
02DE  1230      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F


}
02E0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x75);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6C);

	FC_CAL_UART_Send_1(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)

{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
0140  525B      	MOVF FCD_0f051__00067_arg_FCL_T_00068, F
0142  E14D      	BNZ	label15
0144  525C      	MOVF FCD_0f051__00067_arg_FCL_SOLID, F
0146  E14B      	BNZ	label15
01DE            label15

	{

		FC_CAL_UART_Send_1(0x70);
0148  0E70      	MOVLW 0x70
014A  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
014C  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
014E  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(0x00);
0152  6A5D      	CLRF FC_CAL_UAR_00073_arg_nChar
0154  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0156  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Receive_1(255);
015A  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
015C  EC4EF000  	CALL FC_CAL_UAR_00072


		FC_CAL_UART_Send_1(0x72);
0160  0E72      	MOVLW 0x72
0162  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0164  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0166  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X1 >> 8);
016A  5054      	MOVF FCD_0f051__00067_arg_FCL_X1+D'1', W
016C  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
016E  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0170  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X1);
0174  5053      	MOVF FCD_0f051__00067_arg_FCL_X1, W
0176  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0178  5054      	MOVF FCD_0f051__00067_arg_FCL_X1+D'1', W
017A  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
017C  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0180  5056      	MOVF FCD_0f051__00067_arg_FCL_Y1+D'1', W
0182  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0184  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0186  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y1);
018A  5055      	MOVF FCD_0f051__00067_arg_FCL_Y1, W
018C  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
018E  5056      	MOVF FCD_0f051__00067_arg_FCL_Y1+D'1', W
0190  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0192  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X2 >> 8);
0196  5058      	MOVF FCD_0f051__00067_arg_FCL_X2+D'1', W
0198  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
019A  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
019C  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X2);
01A0  5057      	MOVF FCD_0f051__00067_arg_FCL_X2, W
01A2  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
01A4  5058      	MOVF FCD_0f051__00067_arg_FCL_X2+D'1', W
01A6  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
01A8  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y2 >> 8);
01AC  505A      	MOVF FCD_0f051__00067_arg_FCL_Y2+D'1', W
01AE  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
01B0  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
01B2  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y2);
01B6  5059      	MOVF FCD_0f051__00067_arg_FCL_Y2, W
01B8  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
01BA  505A      	MOVF FCD_0f051__00067_arg_FCL_Y2+D'1', W
01BC  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
01BE  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
01C2  502E      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
01C4  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
01C6  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
01C8  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
01CC  502D      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W
01CE  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
01D0  502E      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W
01D2  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
01D4  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Receive_1(255);
01D8  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
01DA  EC4EF000  	CALL FC_CAL_UAR_00072


	// } else {

	}

	FC_CAL_UART_Send_1(0x70);
01DE  0E70      	MOVLW 0x70
01E0  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
01E2  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
01E4  EC46F000  	CALL FC_CAL_UAR_00073


	if (FCL_SOLID)
01E8  525C      	MOVF FCD_0f051__00067_arg_FCL_SOLID, F
01EA  E005      	BZ	label16
01F6            label16

	{

		FC_CAL_UART_Send_1(0x00);
01EC  6A5D      	CLRF FC_CAL_UAR_00073_arg_nChar
01EE  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
01F0  EC46F000  	CALL FC_CAL_UAR_00073


	} else {
01F4  D005      	BRA	label17
0200            label17


		FC_CAL_UART_Send_1(0x01);
01F6  0E01      	MOVLW 0x01
01F8  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
01FA  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
01FC  EC46F000  	CALL FC_CAL_UAR_00073


	}

	FC_CAL_UART_Receive_1(255);
0200  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0202  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Send_1(0x72);
0206  0E72      	MOVLW 0x72
0208  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
020A  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
020C  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0210  5054      	MOVF FCD_0f051__00067_arg_FCL_X1+D'1', W
0212  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0214  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0216  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1);
021A  5053      	MOVF FCD_0f051__00067_arg_FCL_X1, W
021C  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
021E  5054      	MOVF FCD_0f051__00067_arg_FCL_X1+D'1', W
0220  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0222  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0226  5056      	MOVF FCD_0f051__00067_arg_FCL_Y1+D'1', W
0228  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
022A  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
022C  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1);
0230  5055      	MOVF FCD_0f051__00067_arg_FCL_Y1, W
0232  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0234  5056      	MOVF FCD_0f051__00067_arg_FCL_Y1+D'1', W
0236  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0238  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
023C  5058      	MOVF FCD_0f051__00067_arg_FCL_X2+D'1', W
023E  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0240  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0242  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2);
0246  5057      	MOVF FCD_0f051__00067_arg_FCL_X2, W
0248  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
024A  5058      	MOVF FCD_0f051__00067_arg_FCL_X2+D'1', W
024C  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
024E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
0252  505A      	MOVF FCD_0f051__00067_arg_FCL_Y2+D'1', W
0254  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0256  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0258  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2);
025C  5059      	MOVF FCD_0f051__00067_arg_FCL_Y2, W
025E  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0260  505A      	MOVF FCD_0f051__00067_arg_FCL_Y2+D'1', W
0262  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
0264  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
0268  5030      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
026A  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
026C  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
026E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0272  502F      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W
0274  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0276  5030      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W
0278  6E5E      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1'
027A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
027E  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0280  EC4EF000  	CALL FC_CAL_UAR_00072


}
0284  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, C, 0x20, 0x5, 0);
06AE  6A4F      	CLRF FCD_0f051__00060_2_ptmp
06B0  9A94      	BCF gbl_trisc,5
06B2  524F      	MOVF FCD_0f051__00060_2_ptmp, F
06B4  E004      	BZ	label39
06B6  0E20      	MOVLW 0x20
06B8  108B      	IORWF gbl_latc, W
06BA  6E82      	MOVWF gbl_portc
06BC  D003      	BRA	label40
06BE            label39
06BE  0EDF      	MOVLW 0xDF
06C0  148B      	ANDWF gbl_latc, W
06C2  6E82      	MOVWF gbl_portc
06C4            label40


	FC_CAL_UART_Init_1();
06C4  EC71F001  	CALL FC_CAL_UAR_00074


	FCI_DELAYBYTE_US(100);
06C8  0E64      	MOVLW 0x64
06CA  6E4F      	MOVWF delay_us_00000_arg_del
06CC  EC2EF000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, C, 0x20, 0x5);
06D0  0E0F      	MOVLW HIGH(gbl_portc+D'0')
06D2  6E50      	MOVWF FC_CAL_Por_00042_arg_Port+D'1'
06D4  0E82      	MOVLW LOW(gbl_portc+D'0')
06D6  6E4F      	MOVWF FC_CAL_Por_00042_arg_Port
06D8  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
06DA  6E52      	MOVWF FC_CAL_Por_00042_arg_Tris+D'1'
06DC  0E94      	MOVLW LOW(gbl_trisc+D'0')
06DE  6E51      	MOVWF FC_CAL_Por_00042_arg_Tris
06E0  0E20      	MOVLW 0x20
06E2  6E53      	MOVWF FC_CAL_Por_00042_arg_InMask
06E4  0E05      	MOVLW 0x05
06E6  6E54      	MOVWF FC_CAL_Por_00042_arg_Shift
06E8  ECC2F001  	CALL FC_CAL_Por_00042
06EC  5055      	MOVF CompTempVarRet1822, W
06EE  6E4E      	MOVWF FCD_0f051__00060_1_FCL_DUMMY


	FCI_DELAYBYTE_S(3);
06F0  0E03      	MOVLW 0x03
06F2  6E4F      	MOVWF delay_s_00000_arg_del
06F4  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_1(0);
06F8  6A5D      	CLRF FC_CAL_UAR_00072_arg_nTimeout
06FA  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(0);
06FE  6A5D      	CLRF FC_CAL_UAR_00072_arg_nTimeout
0700  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(0);
0704  6A5D      	CLRF FC_CAL_UAR_00072_arg_nTimeout
0706  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Send_1(0x55);
070A  0E55      	MOVLW 0x55
070C  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
070E  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0710  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
0714  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0716  EC4EF000  	CALL FC_CAL_UAR_00072


	#if (1) // 1 == 1

		#if (1) // 1 != 0

			FC_CAL_UART_Send_1(0x51);
071A  0E51      	MOVLW 0x51
071C  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
071E  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
0720  EC46F000  	CALL FC_CAL_UAR_00073


			FC_CAL_UART_Send_1(0x0C);
0724  0E0C      	MOVLW 0x0C
0726  6E5D      	MOVWF FC_CAL_UAR_00073_arg_nChar
0728  6A5E      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1'
072A  EC46F000  	CALL FC_CAL_UAR_00073


			FC_CAL_UART_Receive_1(255);
072E  685D      	SETF FC_CAL_UAR_00072_arg_nTimeout
0730  EC4EF000  	CALL FC_CAL_UAR_00072


			FC_CAL_UART_UpdateBaud_1(6);
0734  0E06      	MOVLW 0x06
0736  6E4F      	MOVWF FC_CAL_UAR_00070_arg_new_baud
0738  EC7AF001  	CALL FC_CAL_UAR_00070



		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_1(10);
073C  0E0A      	MOVLW 0x0A
073E  6E5D      	MOVWF FC_CAL_UAR_00072_arg_nTimeout
0740  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(10);
0744  0E0A      	MOVLW 0x0A
0746  6E5D      	MOVWF FC_CAL_UAR_00072_arg_nTimeout
0748  EC4EF000  	CALL FC_CAL_UAR_00072


	FCL_RED = 0 & 0xFF;
074C  6A4B      	CLRF FCD_0f051__00060_1_FCL_RED

	FCL_RED = FCL_RED >> (8 - 5);
074E  324B      	RRCF FCD_0f051__00060_1_FCL_RED, F
0750  324B      	RRCF FCD_0f051__00060_1_FCL_RED, F
0752  324B      	RRCF FCD_0f051__00060_1_FCL_RED, F
0754  0E1F      	MOVLW 0x1F
0756  164B      	ANDWF FCD_0f051__00060_1_FCL_RED, F

	FCL_GREEN = (0 >> 8) & 0xFF;
0758  6A4C      	CLRF FCD_0f051__00060_1_FCL_GREEN

	FCL_GREEN = FCL_GREEN >> (8 - 6);
075A  324C      	RRCF FCD_0f051__00060_1_FCL_GREEN, F
075C  324C      	RRCF FCD_0f051__00060_1_FCL_GREEN, F
075E  0E3F      	MOVLW 0x3F
0760  164C      	ANDWF FCD_0f051__00060_1_FCL_GREEN, F

	FCL_BLUE = (0 >> 16) & 0xFF;
0762  6A4D      	CLRF FCD_0f051__00060_1_FCL_BLUE

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0764  324D      	RRCF FCD_0f051__00060_1_FCL_BLUE, F
0766  324D      	RRCF FCD_0f051__00060_1_FCL_BLUE, F
0768  324D      	RRCF FCD_0f051__00060_1_FCL_BLUE, F
076A  0E1F      	MOVLW 0x1F
076C  164D      	ANDWF FCD_0f051__00060_1_FCL_BLUE, F

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
076E  504C      	MOVF FCD_0f051__00060_1_FCL_GREEN, W
0770  6E4F      	MOVWF CompTempVar2652
0772  6A30      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1'
0774  364F      	RLCF CompTempVar2652, F
0776  3630      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0778  364F      	RLCF CompTempVar2652, F
077A  3630      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
077C  364F      	RLCF CompTempVar2652, F
077E  3630      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0780  364F      	RLCF CompTempVar2652, F
0782  3630      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0784  364F      	RLCF CompTempVar2652, F
0786  3630      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F
0788  0EE0      	MOVLW 0xE0
078A  164F      	ANDWF CompTempVar2652, F
078C  504F      	MOVF CompTempVar2652, W
078E  104D      	IORWF FCD_0f051__00060_1_FCL_BLUE, W
0790  6E2F      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
0792  6A4F      	CLRF CompTempVar2656
0794  504B      	MOVF FCD_0f051__00060_1_FCL_RED, W
0796  6E50      	MOVWF CompTempVar2657
0798  90D8      	BCF STATUS,C
079A  3650      	RLCF CompTempVar2657, F
079C  90D8      	BCF STATUS,C
079E  3650      	RLCF CompTempVar2657, F
07A0  90D8      	BCF STATUS,C
07A2  3650      	RLCF CompTempVar2657, F
07A4  504F      	MOVF CompTempVar2656, W
07A6  122F      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F
07A8  5050      	MOVF CompTempVar2657, W
07AA  1230      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F

	FCL_RED = 16777215 & 0xFF;
07AC  684B      	SETF FCD_0f051__00060_1_FCL_RED

	FCL_RED = FCL_RED >> (8 - 5);
07AE  324B      	RRCF FCD_0f051__00060_1_FCL_RED, F
07B0  324B      	RRCF FCD_0f051__00060_1_FCL_RED, F
07B2  324B      	RRCF FCD_0f051__00060_1_FCL_RED, F
07B4  0E1F      	MOVLW 0x1F
07B6  164B      	ANDWF FCD_0f051__00060_1_FCL_RED, F

	FCL_GREEN = (16777215 >> 8) & 0xFF;
07B8  684C      	SETF FCD_0f051__00060_1_FCL_GREEN

	FCL_GREEN = FCL_GREEN >> (8 - 6);
07BA  324C      	RRCF FCD_0f051__00060_1_FCL_GREEN, F
07BC  324C      	RRCF FCD_0f051__00060_1_FCL_GREEN, F
07BE  0E3F      	MOVLW 0x3F
07C0  164C      	ANDWF FCD_0f051__00060_1_FCL_GREEN, F

	FCL_BLUE = (16777215 >> 16) & 0xFF;
07C2  684D      	SETF FCD_0f051__00060_1_FCL_BLUE

	FCL_BLUE = FCL_BLUE >> (8 - 5);
07C4  324D      	RRCF FCD_0f051__00060_1_FCL_BLUE, F
07C6  324D      	RRCF FCD_0f051__00060_1_FCL_BLUE, F
07C8  324D      	RRCF FCD_0f051__00060_1_FCL_BLUE, F
07CA  0E1F      	MOVLW 0x1F
07CC  164D      	ANDWF FCD_0f051__00060_1_FCL_BLUE, F

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
07CE  504C      	MOVF FCD_0f051__00060_1_FCL_GREEN, W
07D0  6E4F      	MOVWF CompTempVar2663
07D2  6A2E      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1'
07D4  364F      	RLCF CompTempVar2663, F
07D6  362E      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
07D8  364F      	RLCF CompTempVar2663, F
07DA  362E      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
07DC  364F      	RLCF CompTempVar2663, F
07DE  362E      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
07E0  364F      	RLCF CompTempVar2663, F
07E2  362E      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
07E4  364F      	RLCF CompTempVar2663, F
07E6  362E      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F
07E8  0EE0      	MOVLW 0xE0
07EA  164F      	ANDWF CompTempVar2663, F
07EC  504F      	MOVF CompTempVar2663, W
07EE  104D      	IORWF FCD_0f051__00060_1_FCL_BLUE, W
07F0  6E2D      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
07F2  6A4F      	CLRF CompTempVar2667
07F4  504B      	MOVF FCD_0f051__00060_1_FCL_RED, W
07F6  6E50      	MOVWF CompTempVar2668
07F8  90D8      	BCF STATUS,C
07FA  3650      	RLCF CompTempVar2668, F
07FC  90D8      	BCF STATUS,C
07FE  3650      	RLCF CompTempVar2668, F
0800  90D8      	BCF STATUS,C
0802  3650      	RLCF CompTempVar2668, F
0804  504F      	MOVF CompTempVar2667, W
0806  122D      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F
0808  5050      	MOVF CompTempVar2668, W
080A  122E      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
080C  EC3EF002  	CALL FCD_0f051__00061


	FC_CAL_UART_Receive_1(10);
0810  0E0A      	MOVLW 0x0A
0812  6E5D      	MOVWF FC_CAL_UAR_00072_arg_nTimeout
0814  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(10);
0818  0E0A      	MOVLW 0x0A
081A  6E5D      	MOVWF FC_CAL_UAR_00072_arg_nTimeout
081C  EC4EF000  	CALL FC_CAL_UAR_00072


}
0820  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_144()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 6
		FCV_HITBOX = 6;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 16
			FCV_HITBOX = 16;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 26
				FCV_HITBOX = 26;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 36
					FCV_HITBOX = 36;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 46
						FCV_HITBOX = 46;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 56
							FCV_HITBOX = 56;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 66
								FCV_HITBOX = 66;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 76
									FCV_HITBOX = 76;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 86
										FCV_HITBOX = 86;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 96
											FCV_HITBOX = 96;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Hitbox_v2()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
08A6  0E01      	MOVLW 0x01
08A8  6E3F      	MOVWF gbl_FCV_HITBOX

	FCV_Y = 24;
08AA  0E18      	MOVLW 0x18
08AC  6E27      	MOVWF gbl_FCV_Y
08AE  6A28      	CLRF gbl_FCV_Y+D'1'

	FCV_X = 24;
08B0  0E18      	MOVLW 0x18
08B2  6E29      	MOVWF gbl_FCV_X
08B4  6A2A      	CLRF gbl_FCV_X+D'1'


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
08B6            label47
08B6  0E01      	MOVLW 0x01
08B8  5C21      	SUBWF gbl_FCV_X_SORTIE, W
08BA  E23A      	BC	label55
08BC  6622      	TSTFSZ gbl_FCV_X_SORTIE+D'1'
08BE  D038      	BRA	label55
092E  D7C3      	BRA	label47
0930            label55

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
08C0  5028      	MOVF gbl_FCV_Y+D'1', W
08C2  5C24      	SUBWF gbl_FCV_Y_TOUCH+D'1', W
08C4  E102      	BNZ	label48
08C6  5027      	MOVF gbl_FCV_Y, W
08C8  5C23      	SUBWF gbl_FCV_Y_TOUCH, W
08CA            label48
08CA  E227      	BC	label54
08CC            label49
091A            label54

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
08CC  502A      	MOVF gbl_FCV_X+D'1', W
08CE  5C2C      	SUBWF gbl_FCV_X_TOUCH+D'1', W
08D0  E102      	BNZ	label50
08D2  5029      	MOVF gbl_FCV_X, W
08D4  5C2B      	SUBWF gbl_FCV_X_TOUCH, W
08D6            label50
08D6  E309      	BNC	label51

				{

				} else {
08EA            label51


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
08D8  283F      	INCF gbl_FCV_HITBOX, W
08DA  6E3F      	MOVWF gbl_FCV_HITBOX

					FCV_X = FCV_X + 24;
08DC  6A4C      	CLRF CompTempVar2635
08DE  0E18      	MOVLW 0x18
08E0  2629      	ADDWF gbl_FCV_X, F
08E2  502A      	MOVF gbl_FCV_X+D'1', W
08E4  224C      	ADDWFC CompTempVar2635, F
08E6  504C      	MOVF CompTempVar2635, W
08E8  6E2A      	MOVWF gbl_FCV_X+D'1'


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
08EA  5221      	MOVF gbl_FCV_X_SORTIE, F
08EC  5222      	MOVF gbl_FCV_X_SORTIE+D'1', F
08EE  2A21      	INCF gbl_FCV_X_SORTIE, F
08F0  B4D8      	BTFSC STATUS,Z
08F2  2A22      	INCF gbl_FCV_X_SORTIE+D'1', F



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
08F4  6A4B      	CLRF CompTempVar2633
08F6  502A      	MOVF gbl_FCV_X+D'1', W
08F8  5C2C      	SUBWF gbl_FCV_X_TOUCH+D'1', W
08FA  E104      	BNZ	label52
08FC  5029      	MOVF gbl_FCV_X, W
08FE  602B      	CPFSLT gbl_FCV_X_TOUCH
0900  D001      	BRA	label52
0902  D001      	BRA	label53
0904            label52
0904  A0D8      	BTFSS STATUS,C
0906  704B      	BTG CompTempVar2633,0
0908  524B      	MOVF CompTempVar2633, F
090A  E0E0      	BZ	label49

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
090C  ECA2F002  	CALL FCM_affich_0005C


			// Calcul
			// Calcul:
			//  X = 0
			//  Y = 0
			FCV_X = 0;
0910  6A29      	CLRF gbl_FCV_X
0912  6A2A      	CLRF gbl_FCV_X+D'1'

			FCV_Y = 0;
0914  6A27      	CLRF gbl_FCV_Y
0916  6A28      	CLRF gbl_FCV_Y+D'1'


		} else {
0918  D7CE      	BRA	label47


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
091A  0E0A      	MOVLW 0x0A
091C  243F      	ADDWF gbl_FCV_HITBOX, W
091E  6E3F      	MOVWF gbl_FCV_HITBOX

			FCV_Y = FCV_Y + 24;
0920  6A4B      	CLRF CompTempVar2639
0922  0E18      	MOVLW 0x18
0924  2627      	ADDWF gbl_FCV_Y, F
0926  5028      	MOVF gbl_FCV_Y+D'1', W
0928  224B      	ADDWFC CompTempVar2639, F
092A  504B      	MOVF CompTempVar2639, W
092C  6E28      	MOVWF gbl_FCV_Y+D'1'


		}


	}

	// Calcul
	// Calcul:
	//  X_SORTIE = 0
	FCV_X_SORTIE = 0;
0930  6A21      	CLRF gbl_FCV_X_SORTIE
0932  6A22      	CLRF gbl_FCV_X_SORTIE+D'1'


}
0934  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Lecture_Coordonnes()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: X_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);
0878  6A4B      	CLRF FCD_0f051__0005E_arg_FCL_AXIS
087A  EC11F004  	CALL FCD_0f051__0005E
087E  504E      	MOVF CompTempVarRet2644, W
0880  6E2B      	MOVWF gbl_FCV_X_TOUCH
0882  504F      	MOVF CompTempVarRet2644+D'1', W
0884  6E2C      	MOVWF gbl_FCV_X_TOUCH+D'1'


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);
0886  0E01      	MOVLW 0x01
0888  6E4B      	MOVWF FCD_0f051__0005E_arg_FCL_AXIS
088A  EC11F004  	CALL FCD_0f051__0005E
088E  504E      	MOVF CompTempVarRet2644, W
0890  6E23      	MOVWF gbl_FCV_Y_TOUCH
0892  504F      	MOVF CompTempVarRet2644+D'1', W
0894  6E24      	MOVWF gbl_FCV_Y_TOUCH+D'1'


}
0896  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_72()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 3
		FCV_HITBOX = 3;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 13
			FCV_HITBOX = 13;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 23
				FCV_HITBOX = 23;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 33
					FCV_HITBOX = 33;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// Calcul
						// Calcul:
						//  hitbox = 43
						FCV_HITBOX = 43;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 53
							FCV_HITBOX = 53;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 63
								FCV_HITBOX = 63;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 73
									FCV_HITBOX = 73;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 83
										FCV_HITBOX = 83;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 93
											FCV_HITBOX = 93;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_168()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 7
		FCV_HITBOX = 7;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 17
			FCV_HITBOX = 17;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 27
				FCV_HITBOX = 27;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 37
					FCV_HITBOX = 37;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 47
						FCV_HITBOX = 47;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 57
							FCV_HITBOX = 57;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 67
								FCV_HITBOX = 67;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 77
									FCV_HITBOX = 77;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 87
										FCV_HITBOX = 87;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 97
											FCV_HITBOX = 97;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Initialisation()

{

	// Calcul
	// Calcul:

	#if 0 // Disabled code
	// Boucle
	// Boucle: While num_case = 100
	while (1)
	{

		// Calcul
		// Calcul:
		//  tableau[num_case] = tableau[num_case] || 0b000000
		//  num_case = num_case + 1
		FCV_TABLEAU[FCV_NUM_CASE] = FCV_TABLEAU[FCV_NUM_CASE] || 0;
		FCV_NUM_CASE = FCV_NUM_CASE + 1;


		if ((FCV_NUM_CASE == 100) != 0) break;
	}

	#endif // #if 0: Disabled code
	#if 0 // Disabled code
	// Calcul
	// Calcul:
	//  tableau[23] = 0b00000001
	//  tableau[24] = 0b00000001
	//  tableau[25] = 0b00000001
	FCV_TABLEAU[23] = 1;
	FCV_TABLEAU[24] = 1;
	FCV_TABLEAU[25] = 1;

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
0898  EC57F003  	CALL FCD_0f051__00060


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
089C  EC3EF002  	CALL FCD_0f051__00061


	// Appel d'une Macro
	// Appel d'une Macro: lignes()
	FCM_lignes();
08A0  EC5EF002  	CALL FCM_lignes_00000


}
08A4  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_tactile()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_DisableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
0864  EC3AF003  	CALL FCD_0f051__00063


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_EnableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
0868  EC0AF003  	CALL FCD_0f051__00064


}
086C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_96()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 4
		FCV_HITBOX = 4;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 14
			FCV_HITBOX = 14;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 24
				FCV_HITBOX = 24;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 34
					FCV_HITBOX = 34;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 44
						FCV_HITBOX = 44;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 54
							FCV_HITBOX = 54;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 64
								FCV_HITBOX = 64;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 74
									FCV_HITBOX = 74;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 84
										FCV_HITBOX = 84;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 94
											FCV_HITBOX = 94;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Hitbox()
{

	// Décision
	// Décision: X < 24?
	if (FCV_X < 24)
	{

		// Appel d'une Macro
		// Appel d'une Macro: X_24()
		FCM_X_24();

	} else {

		// Décision
		// Décision: X < 48?
		if (FCV_X < 48)
		{

			// Appel d'une Macro
			// Appel d'une Macro: X_48()
			FCM_X_48();

		} else {

			// Décision
			// Décision: X < 72?
			if (FCV_X < 72)
			{

				// Appel d'une Macro
				// Appel d'une Macro: X_72()
				FCM_X_72();

			} else {

				// Décision
				// Décision: X < 96?
				if (FCV_X < 96)
				{

					// Appel d'une Macro
					// Appel d'une Macro: X_96()
					FCM_X_96();

				} else {

					// Décision
					// Décision: X < 120?
					if (FCV_X < 120)
					{

						// Appel d'une Macro
						// Appel d'une Macro: X_120()
						FCM_X_120();

					} else {

						// Décision
						// Décision: X < 144?
						if (FCV_X < 144)
						{

							// Appel d'une Macro
							// Appel d'une Macro: X_144()
							FCM_X_144();

						} else {

							// Décision
							// Décision: X < 168?
							if (FCV_X < 168)
							{

								// Appel d'une Macro
								// Appel d'une Macro: X_168()
								FCM_X_168();

							} else {

								// Décision
								// Décision: X < 192?
								if (FCV_X < 192)
								{

									// Appel d'une Macro
									// Appel d'une Macro: X_192()
									FCM_X_192();

								} else {

									// Décision
									// Décision: X < 216?
									if (FCV_X < 216)
									{

										// Appel d'une Macro
										// Appel d'une Macro: X_216()
										FCM_X_216();

									} else {

										// Décision
										// Décision: X < 240?
										if (FCV_X < 240)
										{

											// Appel d'une Macro
											// Appel d'une Macro: X_240()
											FCM_X_240();

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_24()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 1
		FCV_HITBOX = 1;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 11
			FCV_HITBOX = 11;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 21
				FCV_HITBOX = 21;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 31
					FCV_HITBOX = 31;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 41
						FCV_HITBOX = 41;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 51
							FCV_HITBOX = 51;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 61
								FCV_HITBOX = 61;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 71
									FCV_HITBOX = 71;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 81
										FCV_HITBOX = 81;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 91
											FCV_HITBOX = 91;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_240()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 10
		FCV_HITBOX = 10;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 20
			FCV_HITBOX = 20;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 30
				FCV_HITBOX = 30;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 40
					FCV_HITBOX = 40;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 50
						FCV_HITBOX = 50;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 60
							FCV_HITBOX = 60;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 70
								FCV_HITBOX = 70;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 80
									FCV_HITBOX = 80;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 90
										FCV_HITBOX = 90;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 100
											FCV_HITBOX = 100;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_affichage_bateau()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24);
0544  5029      	MOVF gbl_FCV_X, W
0546  6E4B      	MOVWF FCM_parame_00065_arg_FCL_POS_X1
0548  502A      	MOVF gbl_FCV_X+D'1', W
054A  6E4C      	MOVWF FCM_parame_00065_arg_FCL_POS_X1+D'1'
054C  0E18      	MOVLW 0x18
054E  5C29      	SUBWF gbl_FCV_X, W
0550  6E4D      	MOVWF FCM_parame_00065_arg_FCL_POS_X2
0552  5829      	SUBWFB gbl_FCV_X, W
0554  0818      	SUBLW 0x18
0556  5C2A      	SUBWF gbl_FCV_X+D'1', W
0558  6E4E      	MOVWF FCM_parame_00065_arg_FCL_POS_X2+D'1'
055A  5027      	MOVF gbl_FCV_Y, W
055C  6E4F      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1
055E  5028      	MOVF gbl_FCV_Y+D'1', W
0560  6E50      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1+D'1'
0562  0E18      	MOVLW 0x18
0564  5C27      	SUBWF gbl_FCV_Y, W
0566  6E51      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2
0568  5827      	SUBWFB gbl_FCV_Y, W
056A  0818      	SUBLW 0x18
056C  5C28      	SUBWF gbl_FCV_Y+D'1', W
056E  6E52      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2+D'1'
0570  ECDAF001  	CALL FCM_parame_00065


}
0574  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_48()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 2
		FCV_HITBOX = 2;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 12
			FCV_HITBOX = 12;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 22
				FCV_HITBOX = 22;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 32
					FCV_HITBOX = 32;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// Calcul
						// Calcul:
						//  hitbox = 42
						FCV_HITBOX = 42;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 52
							FCV_HITBOX = 52;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 62
								FCV_HITBOX = 62;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 72
									FCV_HITBOX = 72;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 82
										FCV_HITBOX = 82;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 92
											FCV_HITBOX = 92;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro parametres_bateau :
       :  pos_x1 : MX_UINT16
       :  pos_x2 : MX_UINT16
       :  pos_y1 : MX_UINT16
       :  pos_y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2)

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(50, 50, 50)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(50, 50, 50);
03B4  0E32      	MOVLW 0x32
03B6  6E53      	MOVWF FCD_0f051__00066_arg_FCL_RED
03B8  6E54      	MOVWF FCD_0f051__00066_arg_FCL_GREEN
03BA  6E55      	MOVWF FCD_0f051__00066_arg_FCL_BLUE
03BC  EC43F001  	CALL FCD_0f051__00066


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(.pos_x1, .pos_y1, .pos_x2, .pos_y2, 0, 1)
	FCD_0f051_gLCD_EB076_4D1__DrawRectangle(FCL_POS_X1, FCL_POS_Y1, FCL_POS_X2, FCL_POS_Y2, 0, 1);
03C0  504B      	MOVF FCM_parame_00065_arg_FCL_POS_X1, W
03C2  6E53      	MOVWF FCD_0f051__00067_arg_FCL_X1
03C4  504C      	MOVF FCM_parame_00065_arg_FCL_POS_X1+D'1', W
03C6  6E54      	MOVWF FCD_0f051__00067_arg_FCL_X1+D'1'
03C8  504F      	MOVF FCM_parame_00065_arg_FCL_POS_Y1, W
03CA  6E55      	MOVWF FCD_0f051__00067_arg_FCL_Y1
03CC  5050      	MOVF FCM_parame_00065_arg_FCL_POS_Y1+D'1', W
03CE  6E56      	MOVWF FCD_0f051__00067_arg_FCL_Y1+D'1'
03D0  504D      	MOVF FCM_parame_00065_arg_FCL_POS_X2, W
03D2  6E57      	MOVWF FCD_0f051__00067_arg_FCL_X2
03D4  504E      	MOVF FCM_parame_00065_arg_FCL_POS_X2+D'1', W
03D6  6E58      	MOVWF FCD_0f051__00067_arg_FCL_X2+D'1'
03D8  5051      	MOVF FCM_parame_00065_arg_FCL_POS_Y2, W
03DA  6E59      	MOVWF FCD_0f051__00067_arg_FCL_Y2
03DC  5052      	MOVF FCM_parame_00065_arg_FCL_POS_Y2+D'1', W
03DE  6E5A      	MOVWF FCD_0f051__00067_arg_FCL_Y2+D'1'
03E0  6A5B      	CLRF FCD_0f051__00067_arg_FCL_T_00068
03E2  0E01      	MOVLW 0x01
03E4  6E5C      	MOVWF FCD_0f051__00067_arg_FCL_SOLID
03E6  ECA0F000  	CALL FCD_0f051__00067


}
03EA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Appui_tactile()
{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	#if 0 // Disabled code
	//Commentaire:
	//Coordonnée pour X

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: X=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);

	#if 0 // Disabled code
	//Commentaire:
	//Coordonée pour Y

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(X, 80, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_X, 80, 150, 2, 1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(Y, 120, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_Y, 120, 150, 2, 1);

	// Pause
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	// Calcul
	// Calcul:
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	FCV_APPUI_ECRAN = 0;
	FCV_X = 0;
	FCV_Y = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Recuperation_coordonees()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Appui_Ecran=gLCD_EB076_4D1::G4D_GetTouchCoordinatesPicaso()
	FCV_APPUI_ECRAN = FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
086E  ECBBF002  	CALL FCD_0f051__0006D
0872  504D      	MOVF CompTempVarRet2715, W
0874  6E40      	MOVWF gbl_FCV_APPUI_ECRAN


}
0876  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_192()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 8
		FCV_HITBOX = 8;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 18
			FCV_HITBOX = 18;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 28
				FCV_HITBOX = 28;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 38
					FCV_HITBOX = 38;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 48
						FCV_HITBOX = 48;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 58
							FCV_HITBOX = 58;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 68
								FCV_HITBOX = 68;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 78
									FCV_HITBOX = 78;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 88
										FCV_HITBOX = 88;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 98
											FCV_HITBOX = 98;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_120()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 5
		FCV_HITBOX = 5;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 15
			FCV_HITBOX = 15;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 25
				FCV_HITBOX = 25;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 35
					FCV_HITBOX = 35;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 45
						FCV_HITBOX = 45;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 55
							FCV_HITBOX = 55;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 65
								FCV_HITBOX = 65;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 75
									FCV_HITBOX = 75;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 85
										FCV_HITBOX = 85;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 95
											FCV_HITBOX = 95;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_216()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 9
		FCV_HITBOX = 9;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 19
			FCV_HITBOX = 19;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 29
				FCV_HITBOX = 29;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 39
					FCV_HITBOX = 39;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 49
						FCV_HITBOX = 49;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 59
							FCV_HITBOX = 59;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 69
								FCV_HITBOX = 69;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 79
									FCV_HITBOX = 79;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 89
										FCV_HITBOX = 89;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 99
											FCV_HITBOX = 99;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_lignes()

{

	// Calcul
	// Calcul:
	//  X_ligne = 24
	//  Y_ligne = 24
	FCV_X_LIGNE = 24;
04BC  0E18      	MOVLW 0x18
04BE  6E25      	MOVWF gbl_FCV_X_LIGNE
04C0  6A26      	CLRF gbl_FCV_X_LIGNE+D'1'

	FCV_Y_LIGNE = 24;
04C2  0E18      	MOVLW 0x18
04C4  6E1F      	MOVWF gbl_FCV_Y_LIGNE
04C6  6A20      	CLRF gbl_FCV_Y_LIGNE+D'1'


	// tracé des verticales
	// Boucle: While X_ligne = 240
	while (1)
04C8            label30

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(X_ligne, 0, X_ligne, 240)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(FCV_X_LIGNE, 0, FCV_X_LIGNE, 240);
04C8  5025      	MOVF gbl_FCV_X_LIGNE, W
04CA  6E4C      	MOVWF FCD_0f051__0006E_arg_FCL_X1
04CC  5026      	MOVF gbl_FCV_X_LIGNE+D'1', W
04CE  6E4D      	MOVWF FCD_0f051__0006E_arg_FCL_X1+D'1'
04D0  6A4E      	CLRF FCD_0f051__0006E_arg_FCL_Y1
04D2  6A4F      	CLRF FCD_0f051__0006E_arg_FCL_Y1+D'1'
04D4  5025      	MOVF gbl_FCV_X_LIGNE, W
04D6  6E50      	MOVWF FCD_0f051__0006E_arg_FCL_X2
04D8  5026      	MOVF gbl_FCV_X_LIGNE+D'1', W
04DA  6E51      	MOVWF FCD_0f051__0006E_arg_FCL_X2+D'1'
04DC  0EF0      	MOVLW 0xF0
04DE  6E52      	MOVWF FCD_0f051__0006E_arg_FCL_Y2
04E0  6A53      	CLRF FCD_0f051__0006E_arg_FCL_Y2+D'1'
04E2  ECF6F001  	CALL FCD_0f051__0006E


		// Calcul
		// Calcul:
		//  X_ligne = X_ligne + 24
		FCV_X_LIGNE = FCV_X_LIGNE + 24;
04E6  6A4C      	CLRF CompTempVar2675
04E8  0E18      	MOVLW 0x18
04EA  2625      	ADDWF gbl_FCV_X_LIGNE, F
04EC  5026      	MOVF gbl_FCV_X_LIGNE+D'1', W
04EE  224C      	ADDWFC CompTempVar2675, F
04F0  504C      	MOVF CompTempVar2675, W
04F2  6E26      	MOVWF gbl_FCV_X_LIGNE+D'1'



		if ((FCV_X_LIGNE == 240) != 0) break;
04F4  6A4B      	CLRF CompTempVar2673
04F6  0EF0      	MOVLW 0xF0
04F8  6225      	CPFSEQ gbl_FCV_X_LIGNE
04FA  D003      	BRA	label31
04FC  5026      	MOVF gbl_FCV_X_LIGNE+D'1', W
04FE  B4D8      	BTFSC STATUS,Z
0500  2A4B      	INCF CompTempVar2673, F
0502            label31
0502  524B      	MOVF CompTempVar2673, F
0504  E0E1      	BZ	label30

	}

	// tracé des horizontales
	// Boucle: While Y_ligne <= 240
	while (1)
	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, Y_ligne, 240, Y_ligne)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(0, FCV_Y_LIGNE, 240, FCV_Y_LIGNE);
0506  6A4C      	CLRF FCD_0f051__0006E_arg_FCL_X1
0508  6A4D      	CLRF FCD_0f051__0006E_arg_FCL_X1+D'1'
050A  501F      	MOVF gbl_FCV_Y_LIGNE, W
050C  6E4E      	MOVWF FCD_0f051__0006E_arg_FCL_Y1
050E  5020      	MOVF gbl_FCV_Y_LIGNE+D'1', W
0510  6E4F      	MOVWF FCD_0f051__0006E_arg_FCL_Y1+D'1'
0512  0EF0      	MOVLW 0xF0
0514  6E50      	MOVWF FCD_0f051__0006E_arg_FCL_X2
0516  6A51      	CLRF FCD_0f051__0006E_arg_FCL_X2+D'1'
0518  501F      	MOVF gbl_FCV_Y_LIGNE, W
051A  6E52      	MOVWF FCD_0f051__0006E_arg_FCL_Y2
051C  5020      	MOVF gbl_FCV_Y_LIGNE+D'1', W
051E  6E53      	MOVWF FCD_0f051__0006E_arg_FCL_Y2+D'1'
0520  ECF6F001  	CALL FCD_0f051__0006E


		// Calcul
		// Calcul:
		//  Y_ligne = Y_ligne + 24
		FCV_Y_LIGNE = FCV_Y_LIGNE + 24;
0524  6A4C      	CLRF CompTempVar2678
0526  0E18      	MOVLW 0x18
0528  261F      	ADDWF gbl_FCV_Y_LIGNE, F
052A  5020      	MOVF gbl_FCV_Y_LIGNE+D'1', W
052C  224C      	ADDWFC CompTempVar2678, F
052E  504C      	MOVF CompTempVar2678, W
0530  6E20      	MOVWF gbl_FCV_Y_LIGNE+D'1'



		if ((FCV_Y_LIGNE <= 240) == 0) break;
0532  6A4B      	CLRF CompTempVar2676
0534  0EF0      	MOVLW 0xF0
0536  641F      	CPFSGT gbl_FCV_Y_LIGNE
0538  6620      	TSTFSZ gbl_FCV_Y_LIGNE+D'1'
053A  D001      	BRA	label33
053C  2A4B      	INCF CompTempVar2676, F
053E            label33
053E  524B      	MOVF CompTempVar2676, F
0540  E1E2      	BNZ	label32

	}

}
0542  0012      	RETURN




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
0936  0E0F      	MOVLW 0x0F
0938  6EC1      	MOVWF gbl_adcon1





	// Appel d'une Macro
	// Appel d'une Macro: Initialisation()
	FCM_Initialisation();
093A  EC4CF004  	CALL FCM_Initia_0005F


	// Boucle
	// Boucle: While 1
	while (1)
093E            label56
0956  D7F3      	BRA	label56

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_tactile()
		FCM_Reinitialisation_tactile();
093E  EC32F004  	CALL FCM_Reinit_00062


		// Boucle
		// Boucle: While Appui_Ecran = 0
		while (FCV_APPUI_ECRAN == 0)
0942            label57
0942  5240      	MOVF gbl_FCV_APPUI_ECRAN, F
0944  E103      	BNZ	label58
094A  D7FB      	BRA	label57
094C            label58

		{

			// Appel d'une Macro
			// Appel d'une Macro: Recuperation_coordonees()
			FCM_Recuperation_coordonees();
0946  EC37F004  	CALL FCM_Recupe_0006C



		}

		// Appel d'une Macro
		// Appel d'une Macro: Lecture_Coordonnes()
		FCM_Lecture_Coordonnes();
094C  EC3CF004  	CALL FCM_Lectur_0005D


		// Appel d'une Macro
		// Appel d'une Macro: Hitbox_v2()
		FCM_Hitbox_v2();
0950  EC53F004  	CALL FCM_Hitbox_0005B


		#if 0 // Disabled code
		// Appel d'une Macro
		// Appel d'une Macro: affichage_bateau()
		FCM_affichage_bateau();

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Pause
		// Pause: 2 s
		FCI_DELAYBYTE_S(2);

		#endif // #if 0: Disabled code
		// Calcul
		// Calcul:
		//  Appui_Ecran = 0
		FCV_APPUI_ECRAN = 0;
0954  6A40      	CLRF gbl_FCV_APPUI_ECRAN



	}

	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

}
09FA  CFEAF001  	MOVFF FSR0H,  Int1Context
09FE  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
0A02  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
0A06  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
0A0A  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
0A0E  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
0A12  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
0A16  C001FFEA  	MOVFF Int1Context,  FSR0H
0A1A  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
02E2  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
02E4  0E7F      	MOVLW 0x7F
02E6  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
02E8  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
02EA  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
02EC  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
02EE  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
02F0  9A9D      	BCF gbl_pie1,5

			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
02F2  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
013A  6AAB      	CLRF gbl_rcsta

			txsta = 0;
013C  6AAC      	CLRF gbl_txsta

		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}
013E  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
008C            label5
008C  0E10      	MOVLW 0x10
008E  149E      	ANDWF gbl_pir1, W
0090  6E5F      	MOVWF CompTempVar2738
0092  525F      	MOVF CompTempVar2738, F
0094  E0FB      	BZ	label5


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0096  505D      	MOVF FC_CAL_UAR_00073_arg_nChar, W
0098  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
009A  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
009C  685E      	SETF FC_CAL_UAR_00072_1_retVal

  #endif

	MX_UINT8 delay1 = 0;
009E  6A5F      	CLRF FC_CAL_UAR_00072_1_delay1

	MX_UINT8 regcheck = 0;
00A0  6A60      	CLRF FC_CAL_UAR_00072_1_regcheck

	MX_UINT8 bWaitForever = 0;
00A2  6A61      	CLRF FC_CAL_UAR_00072_1_bWaitForever

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
00A4  6A62      	CLRF FC_CAL_UAR_00072_1_rxStatus

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
00A6  6A65      	CLRF FC_CAL_UAR_00072_1_dummy

  #endif

	if (nTimeout == 255)
00A8  285D      	INCF FC_CAL_UAR_00072_arg_nTimeout, W
00AA  E102      	BNZ	label6
00B0            label6

		bWaitForever = 1;
00AC  0E01      	MOVLW 0x01
00AE  6E61      	MOVWF FC_CAL_UAR_00072_1_bWaitForever


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00B0  5262      	MOVF FC_CAL_UAR_00072_1_rxStatus, F
00B2  E124      	BNZ	label11
00FA  D7DA      	BRA	label6
00FC            label11

	{
		if (bWaitForever == 0)
00B4  5261      	MOVF FC_CAL_UAR_00072_1_bWaitForever, F
00B6  E118      	BNZ	label10

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00B8  525D      	MOVF FC_CAL_UAR_00072_arg_nTimeout, F
00BA  E103      	BNZ	label7
00C2            label7

			{
				rxStatus = UART_STATUS_TIMEOUT;
00BC  0E01      	MOVLW 0x01
00BE  6E62      	MOVWF FC_CAL_UAR_00072_1_rxStatus

			}
			else
00C0  D013      	BRA	label10

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00C2  6A63      	CLRF FC_CAL_UAR_00072_1_delaycnt
00C4  6A64      	CLRF FC_CAL_UAR_00072_1_delaycnt+D'1'
00C6            label8
00C6  0E31      	MOVLW 0x31
00C8  5C63      	SUBWF FC_CAL_UAR_00072_1_delaycnt, W
00CA  E205      	BC	label9
00CC  6664      	TSTFSZ FC_CAL_UAR_00072_1_delaycnt+D'1'
00CE  D003      	BRA	label9
00D0  4A63      	INFSNZ FC_CAL_UAR_00072_1_delaycnt, F
00D2  2A64      	INCF FC_CAL_UAR_00072_1_delaycnt+D'1', F
00D4  D7F8      	BRA	label8
00D6            label9

				delay1 = delay1 + 1;
00D6  285F      	INCF FC_CAL_UAR_00072_1_delay1, W
00D8  6E5F      	MOVWF FC_CAL_UAR_00072_1_delay1

				if(delay1 == 100)
00DA  0E64      	MOVLW 0x64
00DC  625F      	CPFSEQ FC_CAL_UAR_00072_1_delay1
00DE  D004      	BRA	label10
00E8            label10

				{
					nTimeout = nTimeout - 1;
00E0  045D      	DECF FC_CAL_UAR_00072_arg_nTimeout, W
00E2  6E5D      	MOVWF FC_CAL_UAR_00072_arg_nTimeout

					MX_CLEAR_WATCHDOG;
00E4  0004      	CLRWDT

					delay1 = 0;
00E6  6A5F      	CLRF FC_CAL_UAR_00072_1_delay1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00E8  0E20      	MOVLW 0x20
00EA  149E      	ANDWF gbl_pir1, W
00EC  6E66      	MOVWF CompTempVar2735
00EE  5066      	MOVF CompTempVar2735, W
00F0  6E60      	MOVWF FC_CAL_UAR_00072_1_regcheck

			if (regcheck != 0)
00F2  5260      	MOVF FC_CAL_UAR_00072_1_regcheck, F
00F4  E0DD      	BZ	label6

				rxStatus = UART_STATUS_RXBYTE;
00F6  0E02      	MOVLW 0x02
00F8  6E62      	MOVWF FC_CAL_UAR_00072_1_rxStatus

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00FC  0E02      	MOVLW 0x02
00FE  6262      	CPFSEQ FC_CAL_UAR_00072_1_rxStatus
0100  D018      	BRA	label14

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0102  0E04      	MOVLW 0x04
0104  14AB      	ANDWF gbl_rcsta, W
0106  6E66      	MOVWF CompTempVar2736
0108  5066      	MOVF CompTempVar2736, W
010A  6E60      	MOVWF FC_CAL_UAR_00072_1_regcheck

			if (regcheck != 0)
010C  5260      	MOVF FC_CAL_UAR_00072_1_regcheck, F
010E  E003      	BZ	label12
0116            label12

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0110  50AE      	MOVF gbl_rcreg, W
0112  6E65      	MOVWF FC_CAL_UAR_00072_1_dummy

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0114  D00E      	BRA	label14

			{
				regcheck = ts_bit(rcsta, OERR);
0116  0E02      	MOVLW 0x02
0118  14AB      	ANDWF gbl_rcsta, W
011A  6E66      	MOVWF CompTempVar2737
011C  5066      	MOVF CompTempVar2737, W
011E  6E60      	MOVWF FC_CAL_UAR_00072_1_regcheck

				if (regcheck != 0)
0120  5260      	MOVF FC_CAL_UAR_00072_1_regcheck, F
0122  E003      	BZ	label13
012A            label13

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0124  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0126  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0128  D004      	BRA	label14
0132            label14

				{
					retVal = 0;
012A  6A5E      	CLRF FC_CAL_UAR_00072_1_retVal


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
012C  50AE      	MOVF gbl_rcreg, W
012E  105E      	IORWF FC_CAL_UAR_00072_1_retVal, W
0130  6E5E      	MOVWF FC_CAL_UAR_00072_1_retVal

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0132  505E      	MOVF FC_CAL_UAR_00072_1_retVal, W
0134  6E66      	MOVWF CompTempVarRet2734
0136  6A67      	CLRF CompTempVarRet2734+D'1'

}
0138  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))

{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
02F4  0E07      	MOVLW 0x07
02F6  644F      	CPFSGT FC_CAL_UAR_00070_arg_new_baud
02F8  D001      	BRA	label18
02FC            label18

		return;

	if (new_baud == 0)
02FC  524F      	MOVF FC_CAL_UAR_00070_arg_new_baud, F
02FE  E104      	BNZ	label19
0308            label19

	{
		baudrate = MX_HARD_BAUD_1200;
0300  6850      	SETF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_1200;
0302  0E01      	MOVLW 0x01
0304  6E51      	MOVWF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 1)
0306  D02F      	BRA	label26
0308  044F      	DECF FC_CAL_UAR_00070_arg_new_baud, W
030A  E105      	BNZ	label20
0316            label20

	{
		baudrate = MX_HARD_BAUD_2400;
030C  0E7F      	MOVLW 0x7F
030E  6E50      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_2400;
0310  0E01      	MOVLW 0x01
0312  6E51      	MOVWF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 2)
0314  D028      	BRA	label26
0316  0E02      	MOVLW 0x02
0318  624F      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
031A  D003      	BRA	label21
0322            label21

	{
		baudrate = MX_HARD_BAUD_4800;
031C  6850      	SETF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_4800;
031E  6A51      	CLRF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 3)
0320  D022      	BRA	label26
0322  0E03      	MOVLW 0x03
0324  624F      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
0326  D004      	BRA	label22
0330            label22

	{
		baudrate = MX_HARD_BAUD_9600;
0328  0E7F      	MOVLW 0x7F
032A  6E50      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_9600;
032C  6A51      	CLRF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 4)
032E  D01B      	BRA	label26
0330  0E04      	MOVLW 0x04
0332  624F      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
0334  D004      	BRA	label23
033E            label23

	{
		baudrate = MX_HARD_BAUD_19200;
0336  0E3F      	MOVLW 0x3F
0338  6E50      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_19200;
033A  6A51      	CLRF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 5)
033C  D014      	BRA	label26
033E  0E05      	MOVLW 0x05
0340  624F      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
0342  D004      	BRA	label24
034C            label24

	{
		baudrate = MX_HARD_BAUD_38400;
0344  0E1F      	MOVLW 0x1F
0346  6E50      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_38400;
0348  6A51      	CLRF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 6)
034A  D00D      	BRA	label26
034C  0E06      	MOVLW 0x06
034E  624F      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
0350  D004      	BRA	label25
035A            label25

	{
		baudrate = MX_HARD_BAUD_57600;
0352  0E14      	MOVLW 0x14
0354  6E50      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_57600;
0356  6A51      	CLRF FC_CAL_UAR_00070_1_baudmode

	}
	else if (new_baud == 7)
0358  D006      	BRA	label26
035A  0E07      	MOVLW 0x07
035C  624F      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud
035E  D003      	BRA	label26
0366            label26

	{
		baudrate = MX_HARD_BAUD_115200;
0360  0E0A      	MOVLW 0x0A
0362  6E50      	MOVWF FC_CAL_UAR_00070_1_baudrate

		baudmode = MX_HARD_SLOW_115200;
0364  6A51      	CLRF FC_CAL_UAR_00070_1_baudmode

	}

	UART_Uninit();
0366  EC9DF000  	CALL FC_CAL_UAR_00071


	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
036A  0451      	DECF FC_CAL_UAR_00070_1_baudmode, W
036C  E102      	BNZ	label27
0372            label27

			cr_bit(txsta, BRGH);					//Low Speed
036E  94AC      	BCF gbl_txsta,2

	    else
0370  D001      	BRA	label28
0374            label28

			st_bit(txsta, BRGH);					//High Speed
0372  84AC      	BSF gbl_txsta,2


		spbrg = baudrate;   						// set the baud rate
0374  5050      	MOVF FC_CAL_UAR_00070_1_baudrate, W
0376  6EAF      	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
0378  6AAB      	CLRF gbl_rcsta


		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
037A  8EAB      	BSF gbl_rcsta,7

		st_bit(txsta, TXEN);
037C  8AAC      	BSF gbl_txsta,5

		st_bit(rcsta, CREN);
037E  88AB      	BSF gbl_rcsta,4


		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
0380  9A9D      	BCF gbl_pie1,5

		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
02FA  0012      	RETURN
0382  0012      	RETURN


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EFACF004  	GOTO	_startup

0008  EFFDF004  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  5250      	MOVF delay_ms_00000_arg_del, F
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF5      	MOVLW 0xF5
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0FFF      	ADDLW 0xFF
0038  A4D8      	BTFSS STATUS,Z
003A  D7ED      	BRA	label2
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  2E50      	DECFSZ delay_ms_00000_arg_del, F
0058  D7DD      	BRA	label1
005A  0012      	RETURN
005C            ; } delay_ms function end

005C            delay_us_00000
005C            ; { delay_us ; function begin
005C            label3
005C  0000      	NOP
005E  0000      	NOP
0060  2E4F      	DECFSZ delay_us_00000_arg_del, F
0062  D7FC      	BRA	label3
0064  0012      	RETURN
0066            ; } delay_us function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6E50      	MOVWF delay_ms_00000_arg_del
006A  EC06F000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6E50      	MOVWF delay_ms_00000_arg_del
0072  EC06F000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6E50      	MOVWF delay_ms_00000_arg_del
007A  EC06F000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6E50      	MOVWF delay_ms_00000_arg_del
0082  EC06F000  	CALL delay_ms_00000
0086  2E4F      	DECFSZ delay_s_00000_arg_del, F
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end























































0958            _startup
0958  0ED5      	MOVLW 0xD5
095A  6E05      	MOVWF gbl_14_LSR
095C  0EC4      	MOVLW 0xC4
095E  6E06      	MOVWF gbl_14_LSR+D'1'
0960  0EBB      	MOVLW 0xBB
0962  6E07      	MOVWF gbl_14_LSR+D'2'
0964  0EDC      	MOVLW 0xDC
0966  6E08      	MOVWF gbl_14_LSR+D'3'
0968  6A09      	CLRF gbl_15_gbl_aSig
096A  6A0A      	CLRF gbl_15_gbl_aSig+D'1'
096C  6A0B      	CLRF gbl_15_gbl_aSig+D'2'
096E  6A0C      	CLRF gbl_15_gbl_aSig+D'3'
0970  6A0D      	CLRF gbl_15_gbl_bSig
0972  6A0E      	CLRF gbl_15_gbl_bSig+D'1'
0974  6A0F      	CLRF gbl_15_gbl_bSig+D'2'
0976  6A10      	CLRF gbl_15_gbl_bSig+D'3'
0978  6A11      	CLRF gbl_15_gbl_zSig
097A  6A12      	CLRF gbl_15_gbl_zSig+D'1'
097C  6A13      	CLRF gbl_15_gbl_zSig+D'2'
097E  6A14      	CLRF gbl_15_gbl_zSig+D'3'
0980  6A38      	CLRF gbl_15_gbl_aExp
0982  6A39      	CLRF gbl_15_gbl_bExp
0984  6A1D      	CLRF gbl_15_gbl_zExp
0986  6A1E      	CLRF gbl_15_gbl_zExp+D'1'
0988  6A3A      	CLRF gbl_15_gbl_aSign
098A  6A3B      	CLRF gbl_15_gbl_bSign
098C  6A3C      	CLRF gbl_15_gbl_zSign
098E  6A3D      	CLRF gbl_15_gbl_zSigZero
0990  6A15      	CLRF gbl_15_gbl_ret
0992  6A16      	CLRF gbl_15_gbl_ret+D'1'
0994  6A17      	CLRF gbl_15_gbl_ret+D'2'
0996  6A18      	CLRF gbl_15_gbl_ret+D'3'
0998  6A36      	CLRF gbl_float_rounding_mode
099A  6A37      	CLRF gbl_float_exception_flags
099C  6A35      	CLRF gbl_float_detect_tininess













09F6  EF9BF004  	GOTO	main

300000  32FF      	DW 0x32FF
300002  FEFF      	DW 0xFEFF
300004  FBFF      	DW 0xFBFF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
