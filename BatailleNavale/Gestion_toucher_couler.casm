;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
084C  51BE      	MOVF FC_CAL_Por_00042_arg_Tris+D'1', W, 1
084E  6EEA      	MOVWF FSR0H
0850  51BD      	MOVF FC_CAL_Por_00042_arg_Tris, W, 1
0852  6EE9      	MOVWF FSR0L
0854  51BF      	MOVF FC_CAL_Por_00042_arg_InMask, W, 1
0856  10EF      	IORWF INDF0, W
0858  6FC1      	MOVWF CompTempVar1825, 1
085A  51C1      	MOVF CompTempVar1825, W, 1
085C  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
085E  51BC      	MOVF FC_CAL_Por_00042_arg_Port+D'1', W, 1
0860  6EEA      	MOVWF FSR0H
0862  51BB      	MOVF FC_CAL_Por_00042_arg_Port, W, 1
0864  6EE9      	MOVWF FSR0L
0866  51BF      	MOVF FC_CAL_Por_00042_arg_InMask, W, 1
0868  14EF      	ANDWF INDF0, W
086A  6FC1      	MOVWF CompTempVarRet1822, 1
086C  51C0      	MOVF FC_CAL_Por_00042_arg_Shift, W, 1
086E  6FC2      	MOVWF CompTempVar1827, 1
0870            label48
0870  B4D8      	BTFSC STATUS,Z
0874  90D8      	BCF STATUS,C
0876  33C1      	RRCF CompTempVarRet1822, F, 1
0878  07C2      	DECF CompTempVar1827, F, 1
087A  D7FA      	BRA	label48

		}
0872  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

// Delay by bytes
#define FCI_DELAYBYTE_S(count)     delay_s((count))
#define FCI_DELAYBYTE_MS(count)    delay_ms((count))
#define FCI_DELAYBYTE_US(count)    delay_us((count))
// With watchdog timer
#define FCI_DELAYBYTEWDT_S(count)  Wdt_Delay_S((count))
#define FCI_DELAYBYTEWDT_MS(count) Wdt_Delay_Ms((count))
#define FCI_DELAYBYTEWDT_US(count) delay_us((count))

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)
{
    char i;
    for (i=0; i<delay; i++)
    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
        delay_ms(1);
    }
}


void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)

{
  	while (Delay > 255)
1B66            label140
1B66  0EFF      	MOVLW 0xFF
1B68  65B7      	CPFSGT FCI_DELAYI_00046_arg_Delay, 1
1B6A  67B8      	TSTFSZ FCI_DELAYI_00046_arg_Delay+D'1', 1
1B6C  D001      	BRA	label141
1B6E  D00C      	BRA	label142
1B70            label141
1B86  D7EF      	BRA	label140
1B88            label142

  	{
	  	delay_ms(255);
1B70  69BE      	SETF delay_ms_00000_arg_del, 1
1B72  EC06F000  	CALL delay_ms_00000

	  	Delay = Delay - 255;
1B76  0EFF      	MOVLW 0xFF
1B78  5DB7      	SUBWF FCI_DELAYI_00046_arg_Delay, W, 1
1B7A  6FB9      	MOVWF CompTempVar1838, 1
1B7C  59B7      	SUBWFB FCI_DELAYI_00046_arg_Delay, W, 1
1B7E  08FF      	SUBLW 0xFF
1B80  5FB8      	SUBWF FCI_DELAYI_00046_arg_Delay+D'1', F, 1
1B82  51B9      	MOVF CompTempVar1838, W, 1
1B84  6FB7      	MOVWF FCI_DELAYI_00046_arg_Delay, 1

  	}
  	if (Delay > 0)
1B88  0E00      	MOVLW 0x00
1B8A  65B7      	CPFSGT FCI_DELAYI_00046_arg_Delay, 1
1B8C  67B8      	TSTFSZ FCI_DELAYI_00046_arg_Delay+D'1', 1
1B8E  D001      	BRA	label143
1B92            label143

  		delay_ms(Delay & 0xFF);
1B92  51B7      	MOVF FCI_DELAYI_00046_arg_Delay, W, 1
1B94  6FBE      	MOVWF delay_ms_00000_arg_del, 1
1B96  EC06F000  	CALL delay_ms_00000

}
1B90  0012      	RETURN
1B9A  0012      	RETURN


void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
0150  0101      	MOVLB 0x01
0152  6B02      	CLRF FCI_GETLEN_0004B_1_tmp, 1
0154            label15
0154  0100      	MOVLB 0x00
0156  51FF      	MOVF FCI_GETLEN_0004B_arg_iStr1_len, W, 1
0158  0101      	MOVLB 0x01
015A  6102      	CPFSLT FCI_GETLEN_0004B_1_tmp, 1
015C  D009      	BRA	label16
015E  5101      	MOVF FCI_GETLEN_0004B_arg_sStr1+D'1', W, 1
0160  6EEA      	MOVWF FSR0H
0162  5100      	MOVF FCI_GETLEN_0004B_arg_sStr1, W, 1
0164  2502      	ADDWF FCI_GETLEN_0004B_1_tmp, W, 1
0166  6EE9      	MOVWF FSR0L
0168  52EF      	MOVF INDF0, F
016A  E002      	BZ	label16
016C  2B02      	INCF FCI_GETLEN_0004B_1_tmp, F, 1
016E  D7F2      	BRA	label15
0170            label16

	return (tmp);
0170  5102      	MOVF FCI_GETLEN_0004B_1_tmp, W, 1
0172  6F03      	MOVWF CompTempVarRet1850, 1

}
0174  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	if (iDst_len == 0) return sDst;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (sDst);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BatailleNavale\Gestion_toucher_couler.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Monday, March 20, 2017 15:54:31
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xF9
#endif
#ifdef HI_TECH_C
__CONFIG(0xF9);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x79
#endif
#ifdef HI_TECH_C
__CONFIG(0x79);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_TABLEAU 101
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_CROISEUR = (0x0);
1CBA  6BA3      	CLRF gbl_FCV_CROISEUR, 1

MX_GLOBAL MX_UINT8 FCV_TORPILLEUR = (0x0);
1CBC  6BA4      	CLRF gbl_FCV_TORPILLEUR, 1

MX_GLOBAL MX_UINT16 FCV_Y_LIGNE = (0x18);
1CBE  0E18      	MOVLW 0x18
1CC0  6F84      	MOVWF gbl_FCV_Y_LIGNE, 1
1CC2  6B85      	CLRF gbl_FCV_Y_LIGNE+D'1', 1

MX_GLOBAL MX_UINT8 FCV_NUM_CASE = (0x0);
1CC4  6BA5      	CLRF gbl_FCV_NUM_CASE, 1

MX_GLOBAL MX_UINT16 FCV_X_SORTIE = (0x0);
1CC6  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1CC8  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

MX_GLOBAL MX_UINT16 FCV_Y_TOUCH = (0x0);
1CCA  6B88      	CLRF gbl_FCV_Y_TOUCH, 1
1CCC  6B89      	CLRF gbl_FCV_Y_TOUCH+D'1', 1

MX_GLOBAL MX_UINT8 FCV_HITBOX = (0x1);
1CCE  0E01      	MOVLW 0x01
1CD0  6FA6      	MOVWF gbl_FCV_HITBOX, 1

MX_GLOBAL MX_UINT16 FCV_X_LIGNE = (0x18);
1CD2  0E18      	MOVLW 0x18
1CD4  6F8A      	MOVWF gbl_FCV_X_LIGNE, 1
1CD6  6B8B      	CLRF gbl_FCV_X_LIGNE+D'1', 1

MX_GLOBAL MX_UINT16 FCV_Y = (0x18);
1CD8  0E18      	MOVLW 0x18
1CDA  6F8C      	MOVWF gbl_FCV_Y, 1
1CDC  6B8D      	CLRF gbl_FCV_Y+D'1', 1

MX_GLOBAL MX_UINT16 FCV_X = (0x18);
1CDE  0E18      	MOVLW 0x18
1CE0  6F8E      	MOVWF gbl_FCV_X, 1
1CE2  6B8F      	CLRF gbl_FCV_X+D'1', 1

MX_GLOBAL MX_UINT8 FCV_SOUS_MARIN = (0x0);
1CE4  6BA7      	CLRF gbl_FCV_SOUS_MARIN, 1

MX_GLOBAL MX_UINT16 FCV_X_TOUCH = (0x0);
1CE6  6B90      	CLRF gbl_FCV_X_TOUCH, 1
1CE8  6B91      	CLRF gbl_FCV_X_TOUCH+D'1', 1

MX_GLOBAL MX_UINT8 FCV_APPUI_ECRAN = (0x0);
1CEA  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

MX_GLOBAL MX_UINT8 FCV_HITBOX_2 = (0x0);
1CEC  6BA9      	CLRF gbl_FCV_HITBOX_2, 1

MX_GLOBAL MX_UINT8 FCV_BATEAU = (0x0);
1CEE  6BAA      	CLRF gbl_FCV_BATEAU, 1

MX_GLOBAL MX_UINT8 FCV_PORTE_AVION = (0x0);
1CF0  6BAB      	CLRF gbl_FCV_PORTE_AVION, 1

MX_GLOBAL MX_UINT8 FCV_JOUEUR1 = (0x0);
1CF2  6BAC      	CLRF gbl_FCV_JOUEUR1, 1

MX_GLOBAL MX_CHAR FCV_TABLEAU[FCVsz_TABLEAU];
MX_GLOBAL MX_UINT8 FCV_CONTRE_TORPILLEUR = (0x0);
1CF4  6BAD      	CLRF gbl_FCV_CONTRE_TORPILLEUR, 1


void FCM_Touche_Coule_TORP();
void FCM_Hitbox_v2();
void FCM_Touche_coule_PA();
void FCM_Lecture_Coordonnes();
void FCM_Croiseur();
void FCM_Torpilleur();
void FCM_Touche_Coule_SM();
void FCM_Initialisation();
void FCM_Message_bateau();
void FCM_Reinitialisation_tactile();
void FCM_Choix_Bateau_Toucher();
void FCM_Choix_Bateaux();
void FCM_affichage_bateau();
void FCM_Sous_marin();
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2, MX_UINT8 FCL_ROUGE, MX_UINT8 FCL_VERT, MX_UINT8 FCL_BLEU);
void FCM_Reinitialisation_texte();
void FCM_Appui_tactile();
void FCM_Manque();
void FCM_Recuperation_coordonees();
void FCM_Fin_Jeu();
void FCM_Touche_Coule_CT();
void FCM_affichage_bateau_touche();
void FCM_Porte_avion();
void FCM_Touche_coule_CR();
void FCM_phase_jeu();
void FCM_lignes();
void FCM_Contre_torpilleur();

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 porta
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 porta
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisa
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisa
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (2)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
1CF6  0E00      	MOVLW 0x00
1CF8  6FAE      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000, 1

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
1CFA  0E01      	MOVLW 0x01
1CFC  6FAF      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001, 1

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
1CFE  0E02      	MOVLW 0x02
1D00  6FB0      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002, 1

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
1D02  0E03      	MOVLW 0x03
1D04  6FB1      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003, 1

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
1D06  0E04      	MOVLW 0x04
1D08  6FB2      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004, 1

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
1D0A  0E05      	MOVLW 0x05
1D0C  6FB3      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005, 1

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
1D0E  0E06      	MOVLW 0x06
1D10  6FB4      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006, 1

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
1D12  0E07      	MOVLW 0x07
1D14  6FB5      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007, 1

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
1D16  6B80      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009, 1
1D18  6B81      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1', 1
1D1A  6B82      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2', 1
1D1C  6B83      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3', 1

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
1D1E  6BB6      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B, 1


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x63);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)

{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;
063C  6BBF      	CLRF FCD_0f051__00068_1_FCR_RETVAL, 1
063E  6BC0      	CLRF FCD_0f051__00068_1_FCR_RETVAL+D'1', 1


	if (FCL_AXIS == 0)
0640  53BE      	MOVF FCD_0f051__00068_arg_FCL_AXIS, F, 1
0642  E007      	BZ	label28

	{

	} else {

		if (FCL_AXIS == 'x')
0644  0E78      	MOVLW 0x78
0646  63BE      	CPFSEQ FCD_0f051__00068_arg_FCL_AXIS, 1
0648  D001      	BRA	label27
064C            label27

		{

		} else {
064A  D003      	BRA	label28


			if (FCL_AXIS == 'X')
064C  0E58      	MOVLW 0x58
064E  63BE      	CPFSEQ FCD_0f051__00068_arg_FCL_AXIS, 1
0650  D004      	BRA	label29
0652            label28

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;
0652  5198      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W, 1
0654  6FBF      	MOVWF FCD_0f051__00068_1_FCR_RETVAL, 1
0656  5199      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', W, 1
0658  6FC0      	MOVWF FCD_0f051__00068_1_FCR_RETVAL+D'1', 1


FCC_G4D_ReadTouchCoordinatesPicaso_A:
065A            label29

;

	if (FCL_AXIS == 1)
065A  05BE      	DECF FCD_0f051__00068_arg_FCL_AXIS, W, 1
065C  E007      	BZ	label31

	{

	} else {

		if (FCL_AXIS == 'y')
065E  0E79      	MOVLW 0x79
0660  63BE      	CPFSEQ FCD_0f051__00068_arg_FCL_AXIS, 1
0662  D001      	BRA	label30
0666            label30

		{

		} else {
0664  D003      	BRA	label31


			if (FCL_AXIS == 'Y')
0666  0E59      	MOVLW 0x59
0668  63BE      	CPFSEQ FCD_0f051__00068_arg_FCL_AXIS, 1
066A  D004      	BRA	label32
066C            label31

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;
066C  5196      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W, 1
066E  6FBF      	MOVWF FCD_0f051__00068_1_FCR_RETVAL, 1
0670  5197      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', W, 1
0672  6FC0      	MOVWF FCD_0f051__00068_1_FCR_RETVAL+D'1', 1


FCC_G4D_ReadTouchCoordinatesPicaso_B:
0674            label32

;

	return (FCR_RETVAL);
0674  51BF      	MOVF FCD_0f051__00068_1_FCR_RETVAL, W, 1
0676  6FC1      	MOVWF CompTempVarRet2714, 1
0678  51C0      	MOVF FCD_0f051__00068_1_FCR_RETVAL+D'1', W, 1
067A  6FC2      	MOVWF CompTempVarRet2714+D'1', 1


}
067C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x6F);
041E  0E6F      	MOVLW 0x6F
0420  0101      	MOVLB 0x01
0422  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0424  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0426  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(4);
042A  0E04      	MOVLW 0x04
042C  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
042E  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0430  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Receive_1(255);
0434  0100      	MOVLB 0x00
0436  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0438  EC50F000  	CALL FC_CAL_UAR_00086


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
043C  0100      	MOVLB 0x00
043E  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0440  EC50F000  	CALL FC_CAL_UAR_00086
0444  5108      	MOVF CompTempVarRet2891, W, 1
0446  0100      	MOVLB 0x00
0448  6FBF      	MOVWF FCD_0f051__0007C_1_FCR_RETVAL, 1


	FC_CAL_UART_Receive_1(255);
044A  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
044C  EC50F000  	CALL FC_CAL_UAR_00086


	FC_CAL_UART_Receive_1(255);
0450  0100      	MOVLB 0x00
0452  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0454  EC50F000  	CALL FC_CAL_UAR_00086


	if (FCR_RETVAL)
0458  0100      	MOVLB 0x00
045A  53BF      	MOVF FCD_0f051__0007C_1_FCR_RETVAL, F, 1
045C  E03C      	BZ	label20
04D6            label20

	{

		FC_CAL_UART_Send_1(0x6F);
045E  0E6F      	MOVLW 0x6F
0460  0101      	MOVLB 0x01
0462  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0464  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0466  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(5);
046A  0E05      	MOVLW 0x05
046C  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
046E  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0470  EC46F000  	CALL FC_CAL_UAR_00087


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_1(255);
0474  0100      	MOVLB 0x00
0476  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0478  EC50F000  	CALL FC_CAL_UAR_00086
047C  5108      	MOVF CompTempVarRet2891, W, 1
047E  0100      	MOVLB 0x00
0480  6F98      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F, 1
0482  0101      	MOVLB 0x01
0484  5109      	MOVF CompTempVarRet2891+D'1', W, 1
0486  0100      	MOVLB 0x00
0488  6F99      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', 1


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
048A  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
048C  EC50F000  	CALL FC_CAL_UAR_00086
0490  5108      	MOVF CompTempVarRet2891, W, 1
0492  0100      	MOVLB 0x00
0494  6FBE      	MOVWF FCD_0f051__0007C_1_FCL_TEMP, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
0496  6BC0      	CLRF CompTempVar2831, 1
0498  5198      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W, 1
049A  6F99      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', 1
049C  51C0      	MOVF CompTempVar2831, W, 1
049E  6F98      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F, 1

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;
04A0  51BE      	MOVF FCD_0f051__0007C_1_FCL_TEMP, W, 1
04A2  1398      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000F, F, 1
04A4  5399      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', F, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_1(255);
04A6  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
04A8  EC50F000  	CALL FC_CAL_UAR_00086
04AC  5108      	MOVF CompTempVarRet2891, W, 1
04AE  0100      	MOVLB 0x00
04B0  6F96      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E, 1
04B2  0101      	MOVLB 0x01
04B4  5109      	MOVF CompTempVarRet2891+D'1', W, 1
04B6  0100      	MOVLB 0x00
04B8  6F97      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', 1


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
04BA  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
04BC  EC50F000  	CALL FC_CAL_UAR_00086
04C0  5108      	MOVF CompTempVarRet2891, W, 1
04C2  0100      	MOVLB 0x00
04C4  6FBE      	MOVWF FCD_0f051__0007C_1_FCL_TEMP, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
04C6  6BC0      	CLRF CompTempVar2835, 1
04C8  5196      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W, 1
04CA  6F97      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', 1
04CC  51C0      	MOVF CompTempVar2835, W, 1
04CE  6F96      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E, 1

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;
04D0  51BE      	MOVF FCD_0f051__0007C_1_FCL_TEMP, W, 1
04D2  1396      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000E, F, 1
04D4  5397      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', F, 1


	// } else {

	}

	return (FCR_RETVAL);
04D6  51BF      	MOVF FCD_0f051__0007C_1_FCR_RETVAL, W, 1
04D8  6FC0      	MOVWF CompTempVarRet2830, 1


}
04DA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_1(FCL_RADIUS);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
0C52  6BC0      	CLRF FCD_0f051__00082_1_FCL_D1, 1
0C54  6BC1      	CLRF FCD_0f051__00082_1_FCL_D1+D'1', 1

	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
0C56  0E01      	MOVLW 0x01
0C58  6FC2      	MOVWF FCD_0f051__00082_1_FCL_YINC, 1
0C5A  6BC3      	CLRF FCD_0f051__00082_1_FCL_YINC+D'1', 1

	MX_SINT16 FCL_XINC = (1);
0C5C  0E01      	MOVLW 0x01
0C5E  6FC4      	MOVWF FCD_0f051__00082_1_FCL_XINC, 1
0C60  6BC5      	CLRF FCD_0f051__00082_1_FCL_XINC+D'1', 1



	FC_CAL_UART_Send_1(0x4C);
0C62  0E4C      	MOVLW 0x4C
0C64  0101      	MOVLB 0x01
0C66  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0C68  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0C6A  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0C6E  0100      	MOVLB 0x00
0C70  51B9      	MOVF FCD_0f051__00082_arg_FCL_X1+D'1', W, 1
0C72  0101      	MOVLB 0x01
0C74  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0C76  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0C78  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X1);
0C7C  0100      	MOVLB 0x00
0C7E  51B8      	MOVF FCD_0f051__00082_arg_FCL_X1, W, 1
0C80  0101      	MOVLB 0x01
0C82  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0C84  0100      	MOVLB 0x00
0C86  51B9      	MOVF FCD_0f051__00082_arg_FCL_X1+D'1', W, 1
0C88  0101      	MOVLB 0x01
0C8A  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0C8C  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0C90  0100      	MOVLB 0x00
0C92  51BB      	MOVF FCD_0f051__00082_arg_FCL_Y1+D'1', W, 1
0C94  0101      	MOVLB 0x01
0C96  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0C98  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0C9A  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y1);
0C9E  0100      	MOVLB 0x00
0CA0  51BA      	MOVF FCD_0f051__00082_arg_FCL_Y1, W, 1
0CA2  0101      	MOVLB 0x01
0CA4  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0CA6  0100      	MOVLB 0x00
0CA8  51BB      	MOVF FCD_0f051__00082_arg_FCL_Y1+D'1', W, 1
0CAA  0101      	MOVLB 0x01
0CAC  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0CAE  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
0CB2  0100      	MOVLB 0x00
0CB4  51BD      	MOVF FCD_0f051__00082_arg_FCL_X2+D'1', W, 1
0CB6  0101      	MOVLB 0x01
0CB8  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0CBA  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0CBC  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X2);
0CC0  0100      	MOVLB 0x00
0CC2  51BC      	MOVF FCD_0f051__00082_arg_FCL_X2, W, 1
0CC4  0101      	MOVLB 0x01
0CC6  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0CC8  0100      	MOVLB 0x00
0CCA  51BD      	MOVF FCD_0f051__00082_arg_FCL_X2+D'1', W, 1
0CCC  0101      	MOVLB 0x01
0CCE  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0CD0  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
0CD4  0100      	MOVLB 0x00
0CD6  51BF      	MOVF FCD_0f051__00082_arg_FCL_Y2+D'1', W, 1
0CD8  0101      	MOVLB 0x01
0CDA  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0CDC  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0CDE  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y2);
0CE2  0100      	MOVLB 0x00
0CE4  51BE      	MOVF FCD_0f051__00082_arg_FCL_Y2, W, 1
0CE6  0101      	MOVLB 0x01
0CE8  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0CEA  0100      	MOVLB 0x00
0CEC  51BF      	MOVF FCD_0f051__00082_arg_FCL_Y2+D'1', W, 1
0CEE  0101      	MOVLB 0x01
0CF0  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0CF2  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
0CF6  0100      	MOVLB 0x00
0CF8  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0CFA  0101      	MOVLB 0x01
0CFC  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0CFE  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0D00  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0D04  0100      	MOVLB 0x00
0D06  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
0D08  0101      	MOVLB 0x01
0D0A  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0D0C  0100      	MOVLB 0x00
0D0E  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0D10  0101      	MOVLB 0x01
0D12  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0D14  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Receive_1(255);
0D18  0100      	MOVLB 0x00
0D1A  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0D1C  EC50F000  	CALL FC_CAL_UAR_00086


}
0D20  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_POSH >> 8);

	FC_CAL_UART_Send_1(FCL_POSH);

	FC_CAL_UART_Send_1(FCL_POSL >> 8);

	FC_CAL_UART_Send_1(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
0548  0E59      	MOVLW 0x59
054A  0101      	MOVLB 0x01
054C  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
054E  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0550  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(0x05);
0554  0E05      	MOVLW 0x05
0556  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0558  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
055A  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(0x01);
055E  0E01      	MOVLW 0x01
0560  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0562  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0564  EC46F000  	CALL FC_CAL_UAR_00087


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0568  0100      	MOVLB 0x00
056A  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
056C  EC50F000  	CALL FC_CAL_UAR_00086
0570  5108      	MOVF CompTempVarRet2891, W, 1
0572  0100      	MOVLB 0x00
0574  6FBE      	MOVWF FCD_0f051__00072_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
0576  0E06      	MOVLW 0x06
0578  63BE      	CPFSEQ FCD_0f051__00072_1_FCR_RETVAL, 1
057A  D002      	BRA	label23
0580            label23

	{

		FCR_RETVAL = 0;
057C  6BBE      	CLRF FCD_0f051__00072_1_FCR_RETVAL, 1


	} else {
057E  D001      	BRA	label24
0582            label24


		FCR_RETVAL = 255;
0580  69BE      	SETF FCD_0f051__00072_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
0582  51BE      	MOVF FCD_0f051__00072_1_FCR_RETVAL, W, 1
0584  6FBF      	MOVWF CompTempVarRet2788, 1


}
0586  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x00);

	FC_CAL_UART_Send_1(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x01);

	FC_CAL_UART_Send_1(FCL_DISPLAY);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x02);

	FC_CAL_UART_Send_1(FCL_CONTRAST);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
04DC  0E59      	MOVLW 0x59
04DE  0101      	MOVLB 0x01
04E0  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
04E2  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
04E4  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(0x05);
04E8  0E05      	MOVLW 0x05
04EA  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
04EC  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
04EE  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(0x00);
04F2  6B00      	CLRF FC_CAL_UAR_00087_arg_nChar, 1
04F4  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
04F6  EC46F000  	CALL FC_CAL_UAR_00087


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
04FA  0100      	MOVLB 0x00
04FC  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
04FE  EC50F000  	CALL FC_CAL_UAR_00086
0502  5108      	MOVF CompTempVarRet2891, W, 1
0504  0100      	MOVLB 0x00
0506  6FBE      	MOVWF FCD_0f051__00073_1_FCR_RETVAL, 1


	FC_CAL_UART_Send_1(0x59);
0508  0E59      	MOVLW 0x59
050A  0101      	MOVLB 0x01
050C  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
050E  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0510  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(0x05);
0514  0E05      	MOVLW 0x05
0516  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0518  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
051A  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(0x02);
051E  0E02      	MOVLW 0x02
0520  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0522  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0524  EC46F000  	CALL FC_CAL_UAR_00087


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0528  0100      	MOVLB 0x00
052A  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
052C  EC50F000  	CALL FC_CAL_UAR_00086
0530  5108      	MOVF CompTempVarRet2891, W, 1
0532  0100      	MOVLB 0x00
0534  6FBE      	MOVWF FCD_0f051__00073_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
0536  0E06      	MOVLW 0x06
0538  63BE      	CPFSEQ FCD_0f051__00073_1_FCR_RETVAL, 1
053A  D002      	BRA	label21
0540            label21

	{

		FCR_RETVAL = 0;
053C  6BBE      	CLRF FCD_0f051__00073_1_FCR_RETVAL, 1


	} else {
053E  D001      	BRA	label22
0542            label22


		FCR_RETVAL = 255;
0540  69BE      	SETF FCD_0f051__00073_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
0542  51BE      	MOVF FCD_0f051__00073_1_FCR_RETVAL, W, 1
0544  6FBF      	MOVWF CompTempVarRet2789, 1


}
0546  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x56);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_1(0x10);

	} else {

		FC_CAL_UART_Send_1(0x08);

	}

	FC_CAL_UART_Send_1(FCL_DELAY);

	FC_CAL_UART_Send_1(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_1(FCL_FRAMES);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x76);

	FC_CAL_UART_Send_1(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_1(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_1(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_1(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_1(0x03);

		}
	}

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x65);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RX >> 8);

	FC_CAL_UART_Send_1(FCL_RX);

	FC_CAL_UART_Send_1(FCL_RY >> 8);

	FC_CAL_UART_Send_1(FCL_RY);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);
067E  6BFE      	CLRF FCD_0f051__0005D_1_FCL_IDX, 1



	FC_CAL_UART_Send_1(0x4F);
0680  0E4F      	MOVLW 0x4F
0682  0101      	MOVLB 0x01
0684  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0686  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0688  EC46F000  	CALL FC_CAL_UAR_00087


	if (FCL_TRANSPARENT)
068C  0100      	MOVLB 0x00
068E  53FC      	MOVF FCD_0f051__0005D_arg_FCL_T_0005E, F, 1
0690  E006      	BZ	label33
069E            label33

	{

		FC_CAL_UART_Send_1(0x00);
0692  0101      	MOVLB 0x01
0694  6B00      	CLRF FC_CAL_UAR_00087_arg_nChar, 1
0696  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0698  EC46F000  	CALL FC_CAL_UAR_00087


	} else {
069C  D006      	BRA	label34
06AA            label34


		FC_CAL_UART_Send_1(0x01);
069E  0E01      	MOVLW 0x01
06A0  0101      	MOVLB 0x01
06A2  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
06A4  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
06A6  EC46F000  	CALL FC_CAL_UAR_00087


	}

	FC_CAL_UART_Receive_1(255);
06AA  0100      	MOVLB 0x00
06AC  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
06AE  EC50F000  	CALL FC_CAL_UAR_00086


	FC_CAL_UART_Send_1(0x53);
06B2  0E53      	MOVLW 0x53
06B4  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
06B6  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
06B8  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
06BC  0100      	MOVLB 0x00
06BE  51F8      	MOVF FCD_0f051__0005D_arg_FCL_X1+D'1', W, 1
06C0  0101      	MOVLB 0x01
06C2  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
06C4  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
06C6  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X1);
06CA  0100      	MOVLB 0x00
06CC  51F7      	MOVF FCD_0f051__0005D_arg_FCL_X1, W, 1
06CE  0101      	MOVLB 0x01
06D0  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
06D2  0100      	MOVLB 0x00
06D4  51F8      	MOVF FCD_0f051__0005D_arg_FCL_X1+D'1', W, 1
06D6  0101      	MOVLB 0x01
06D8  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
06DA  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
06DE  0100      	MOVLB 0x00
06E0  51FA      	MOVF FCD_0f051__0005D_arg_FCL_Y1+D'1', W, 1
06E2  0101      	MOVLB 0x01
06E4  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
06E6  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
06E8  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y1);
06EC  0100      	MOVLB 0x00
06EE  51F9      	MOVF FCD_0f051__0005D_arg_FCL_Y1, W, 1
06F0  0101      	MOVLB 0x01
06F2  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
06F4  0100      	MOVLB 0x00
06F6  51FA      	MOVF FCD_0f051__0005D_arg_FCL_Y1+D'1', W, 1
06F8  0101      	MOVLB 0x01
06FA  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
06FC  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_FONT);
0700  0100      	MOVLB 0x00
0702  51FB      	MOVF FCD_0f051__0005D_arg_FCL_FONT, W, 1
0704  0101      	MOVLB 0x01
0706  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0708  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
070A  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
070E  0100      	MOVLB 0x00
0710  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0712  0101      	MOVLB 0x01
0714  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0716  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0718  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
071C  0100      	MOVLB 0x00
071E  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
0720  0101      	MOVLB 0x01
0722  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0724  0100      	MOVLB 0x00
0726  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0728  0101      	MOVLB 0x01
072A  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
072C  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(1);
0730  0E01      	MOVLW 0x01
0732  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0734  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0736  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(1);
073A  0E01      	MOVLW 0x01
073C  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
073E  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0740  EC46F000  	CALL FC_CAL_UAR_00087


	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);
0744  0100      	MOVLB 0x00
0746  51BE      	MOVF FCD_0f051__0005D_arg_FCL_STR, W, 1
0748  0101      	MOVLB 0x01
074A  6F00      	MOVWF FCI_GETLEN_0004B_arg_sStr1, 1
074C  0100      	MOVLB 0x00
074E  51BF      	MOVF FCD_0f051__0005D_arg_FCL_STR+D'1', W, 1
0750  0101      	MOVLB 0x01
0752  6F01      	MOVWF FCI_GETLEN_0004B_arg_sStr1+D'1', 1
0754  0100      	MOVLB 0x00
0756  51F5      	MOVF FCD_0f051__0005D_arg_FCLsz_STR, W, 1
0758  6FFF      	MOVWF FCI_GETLEN_0004B_arg_iStr1_len, 1
075A  ECA8F000  	CALL FCI_GETLEN_0004B
075E  5103      	MOVF CompTempVarRet1850, W, 1
0760  0100      	MOVLB 0x00
0762  6FFD      	MOVWF FCD_0f051__0005D_1_FCL_LEN_STR, 1


	while (FCL_IDX < FCL_LEN_STR)
0764            label35
0764  51FD      	MOVF FCD_0f051__0005D_1_FCL_LEN_STR, W, 1
0766  61FE      	CPFSLT FCD_0f051__0005D_1_FCL_IDX, 1
0768  D016      	BRA	label36
0794  D7E7      	BRA	label35
0796            label36

	{

		if (FCL_STR[FCL_IDX] == 0)
076A  51BF      	MOVF FCD_0f051__0005D_arg_FCL_STR+D'1', W, 1
076C  6EEA      	MOVWF FSR0H
076E  51BE      	MOVF FCD_0f051__0005D_arg_FCL_STR, W, 1
0770  25FE      	ADDWF FCD_0f051__0005D_1_FCL_IDX, W, 1
0772  6EE9      	MOVWF FSR0L
0774  52EF      	MOVF INDF0, F
0776  E00F      	BZ	label36

		{

			goto FCC_Print_A;


		// } else {

		}

		FC_CAL_UART_Send_1(FCL_STR[FCL_IDX]);
0778  51BF      	MOVF FCD_0f051__0005D_arg_FCL_STR+D'1', W, 1
077A  6EEA      	MOVWF FSR0H
077C  51BE      	MOVF FCD_0f051__0005D_arg_FCL_STR, W, 1
077E  25FE      	ADDWF FCD_0f051__0005D_1_FCL_IDX, W, 1
0780  6EE9      	MOVWF FSR0L
0782  50EF      	MOVF INDF0, W
0784  0101      	MOVLB 0x01
0786  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0788  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
078A  EC46F000  	CALL FC_CAL_UAR_00087


		FCL_IDX = FCL_IDX + 1;
078E  0100      	MOVLB 0x00
0790  29FE      	INCF FCD_0f051__0005D_1_FCL_IDX, W, 1
0792  6FFE      	MOVWF FCD_0f051__0005D_1_FCL_IDX, 1



	}

FCC_Print_A:
;

	FC_CAL_UART_Send_1(0);
0796  0101      	MOVLB 0x01
0798  6B00      	CLRF FC_CAL_UAR_00087_arg_nChar, 1
079A  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
079C  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Receive_1(255);
07A0  0100      	MOVLB 0x00
07A2  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
07A4  EC50F000  	CALL FC_CAL_UAR_00086


}
07A8  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x0c);

	FC_CAL_UART_Send_1(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
0D22  0100      	MOVLB 0x00
0D24  6BBB      	CLRF FCD_0f051__0006D_1_FCL_Y, 1
0D26  6BBC      	CLRF FCD_0f051__0006D_1_FCL_Y+D'1', 1

	MX_UINT16 FCL_X = (0x0);
0D28  6BBD      	CLRF FCD_0f051__0006D_1_FCL_X, 1
0D2A  6BBE      	CLRF FCD_0f051__0006D_1_FCL_X+D'1', 1



	FC_CAL_UART_Send_1(0x42);
0D2C  0E42      	MOVLW 0x42
0D2E  0101      	MOVLB 0x01
0D30  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0D32  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0D34  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
0D38  0100      	MOVLB 0x00
0D3A  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
0D3C  0101      	MOVLB 0x01
0D3E  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0D40  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0D42  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
0D46  0100      	MOVLB 0x00
0D48  5192      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W, 1
0D4A  0101      	MOVLB 0x01
0D4C  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0D4E  0100      	MOVLB 0x00
0D50  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
0D52  0101      	MOVLB 0x01
0D54  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0D56  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Receive_1(255);
0D5A  0100      	MOVLB 0x00
0D5C  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0D5E  EC50F000  	CALL FC_CAL_UAR_00086


	FC_CAL_UART_Send_1(0x45);
0D62  0E45      	MOVLW 0x45
0D64  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0D66  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0D68  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Receive_1(255);
0D6C  0100      	MOVLB 0x00
0D6E  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0D70  EC50F000  	CALL FC_CAL_UAR_00086


}
0D74  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x49);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)

{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
0346  33C9      	RRCF FCD_0f051__00076_arg_FCL_RED, F, 1
0348  33C9      	RRCF FCD_0f051__00076_arg_FCL_RED, F, 1
034A  33C9      	RRCF FCD_0f051__00076_arg_FCL_RED, F, 1
034C  0E1F      	MOVLW 0x1F
034E  17C9      	ANDWF FCD_0f051__00076_arg_FCL_RED, F, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
0350  33CA      	RRCF FCD_0f051__00076_arg_FCL_GREEN, F, 1
0352  33CA      	RRCF FCD_0f051__00076_arg_FCL_GREEN, F, 1
0354  0E3F      	MOVLW 0x3F
0356  17CA      	ANDWF FCD_0f051__00076_arg_FCL_GREEN, F, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0358  33CB      	RRCF FCD_0f051__00076_arg_FCL_BLUE, F, 1
035A  33CB      	RRCF FCD_0f051__00076_arg_FCL_BLUE, F, 1
035C  33CB      	RRCF FCD_0f051__00076_arg_FCL_BLUE, F, 1
035E  0E1F      	MOVLW 0x1F
0360  17CB      	ANDWF FCD_0f051__00076_arg_FCL_BLUE, F, 1


	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
0362  51CA      	MOVF FCD_0f051__00076_arg_FCL_GREEN, W, 1
0364  6FCC      	MOVWF CompTempVar2793, 1
0366  6B95      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', 1
0368  37CC      	RLCF CompTempVar2793, F, 1
036A  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
036C  37CC      	RLCF CompTempVar2793, F, 1
036E  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0370  37CC      	RLCF CompTempVar2793, F, 1
0372  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0374  37CC      	RLCF CompTempVar2793, F, 1
0376  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
0378  37CC      	RLCF CompTempVar2793, F, 1
037A  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
037C  0EE0      	MOVLW 0xE0
037E  17CC      	ANDWF CompTempVar2793, F, 1
0380  51CC      	MOVF CompTempVar2793, W, 1
0382  11CB      	IORWF FCD_0f051__00076_arg_FCL_BLUE, W, 1
0384  6F94      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
0386  6BCC      	CLRF CompTempVar2797, 1
0388  51C9      	MOVF FCD_0f051__00076_arg_FCL_RED, W, 1
038A  6FCD      	MOVWF CompTempVar2798, 1
038C  90D8      	BCF STATUS,C
038E  37CD      	RLCF CompTempVar2798, F, 1
0390  90D8      	BCF STATUS,C
0392  37CD      	RLCF CompTempVar2798, F, 1
0394  90D8      	BCF STATUS,C
0396  37CD      	RLCF CompTempVar2798, F, 1
0398  51CC      	MOVF CompTempVar2797, W, 1
039A  1394      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F, 1
039C  51CD      	MOVF CompTempVar2798, W, 1
039E  1395      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1


}
03A0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x75);
0588  0E75      	MOVLW 0x75
058A  0101      	MOVLB 0x01
058C  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
058E  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0590  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0594  0100      	MOVLB 0x00
0596  51BF      	MOVF FCD_0f051__0006E_arg_FCL_X1+D'1', W, 1
0598  0101      	MOVLB 0x01
059A  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
059C  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
059E  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X1);
05A2  0100      	MOVLB 0x00
05A4  51BE      	MOVF FCD_0f051__0006E_arg_FCL_X1, W, 1
05A6  0101      	MOVLB 0x01
05A8  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
05AA  0100      	MOVLB 0x00
05AC  51BF      	MOVF FCD_0f051__0006E_arg_FCL_X1+D'1', W, 1
05AE  0101      	MOVLB 0x01
05B0  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
05B2  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
05B6  0100      	MOVLB 0x00
05B8  51C1      	MOVF FCD_0f051__0006E_arg_FCL_Y1+D'1', W, 1
05BA  0101      	MOVLB 0x01
05BC  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
05BE  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
05C0  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y1);
05C4  0100      	MOVLB 0x00
05C6  51C0      	MOVF FCD_0f051__0006E_arg_FCL_Y1, W, 1
05C8  0101      	MOVLB 0x01
05CA  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
05CC  0100      	MOVLB 0x00
05CE  51C1      	MOVF FCD_0f051__0006E_arg_FCL_Y1+D'1', W, 1
05D0  0101      	MOVLB 0x01
05D2  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
05D4  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
05D8  0100      	MOVLB 0x00
05DA  51C3      	MOVF FCD_0f051__0006E_arg_FCL_X2+D'1', W, 1
05DC  0101      	MOVLB 0x01
05DE  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
05E0  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
05E2  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X2);
05E6  0100      	MOVLB 0x00
05E8  51C2      	MOVF FCD_0f051__0006E_arg_FCL_X2, W, 1
05EA  0101      	MOVLB 0x01
05EC  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
05EE  0100      	MOVLB 0x00
05F0  51C3      	MOVF FCD_0f051__0006E_arg_FCL_X2+D'1', W, 1
05F2  0101      	MOVLB 0x01
05F4  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
05F6  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
05FA  0100      	MOVLB 0x00
05FC  51C5      	MOVF FCD_0f051__0006E_arg_FCL_Y2+D'1', W, 1
05FE  0101      	MOVLB 0x01
0600  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0602  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0604  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y2);
0608  0100      	MOVLB 0x00
060A  51C4      	MOVF FCD_0f051__0006E_arg_FCL_Y2, W, 1
060C  0101      	MOVLB 0x01
060E  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0610  0100      	MOVLB 0x00
0612  51C5      	MOVF FCD_0f051__0006E_arg_FCL_Y2+D'1', W, 1
0614  0101      	MOVLB 0x01
0616  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0618  EC46F000  	CALL FC_CAL_UAR_00087


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
061C  0100      	MOVLB 0x00
061E  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0620  EC50F000  	CALL FC_CAL_UAR_00086
0624  5108      	MOVF CompTempVarRet2891, W, 1
0626  0100      	MOVLB 0x00
0628  6FC6      	MOVWF FCD_0f051__0006E_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
062A  0E06      	MOVLW 0x06
062C  63C6      	CPFSEQ FCD_0f051__0006E_1_FCR_RETVAL, 1
062E  D002      	BRA	label25
0634            label25

	{

		FCR_RETVAL = 0;
0630  6BC6      	CLRF FCD_0f051__0006E_1_FCR_RETVAL, 1


	} else {
0632  D001      	BRA	label26
0636            label26


		FCR_RETVAL = 255;
0634  69C6      	SETF FCD_0f051__0006E_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
0636  51C6      	MOVF FCD_0f051__0006E_1_FCR_RETVAL, W, 1
0638  6FC7      	MOVWF CompTempVarRet2769, 1


}
063A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6C);

	FC_CAL_UART_Send_1(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)

{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
0176  53D1      	MOVF FCD_0f051__00077_arg_FCL_T_00078, F, 1
0178  E16E      	BNZ	label17
017A  53D2      	MOVF FCD_0f051__00077_arg_FCL_SOLID, F, 1
017C  E16C      	BNZ	label17
0256            label17

	{

		FC_CAL_UART_Send_1(0x70);
017E  0E70      	MOVLW 0x70
0180  0101      	MOVLB 0x01
0182  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0184  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0186  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(0x00);
018A  6B00      	CLRF FC_CAL_UAR_00087_arg_nChar, 1
018C  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
018E  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Receive_1(255);
0192  0100      	MOVLB 0x00
0194  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0196  EC50F000  	CALL FC_CAL_UAR_00086


		FC_CAL_UART_Send_1(0x72);
019A  0E72      	MOVLW 0x72
019C  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
019E  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
01A0  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(FCL_X1 >> 8);
01A4  0100      	MOVLB 0x00
01A6  51CA      	MOVF FCD_0f051__00077_arg_FCL_X1+D'1', W, 1
01A8  0101      	MOVLB 0x01
01AA  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
01AC  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
01AE  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(FCL_X1);
01B2  0100      	MOVLB 0x00
01B4  51C9      	MOVF FCD_0f051__00077_arg_FCL_X1, W, 1
01B6  0101      	MOVLB 0x01
01B8  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
01BA  0100      	MOVLB 0x00
01BC  51CA      	MOVF FCD_0f051__00077_arg_FCL_X1+D'1', W, 1
01BE  0101      	MOVLB 0x01
01C0  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
01C2  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(FCL_Y1 >> 8);
01C6  0100      	MOVLB 0x00
01C8  51CC      	MOVF FCD_0f051__00077_arg_FCL_Y1+D'1', W, 1
01CA  0101      	MOVLB 0x01
01CC  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
01CE  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
01D0  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(FCL_Y1);
01D4  0100      	MOVLB 0x00
01D6  51CB      	MOVF FCD_0f051__00077_arg_FCL_Y1, W, 1
01D8  0101      	MOVLB 0x01
01DA  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
01DC  0100      	MOVLB 0x00
01DE  51CC      	MOVF FCD_0f051__00077_arg_FCL_Y1+D'1', W, 1
01E0  0101      	MOVLB 0x01
01E2  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
01E4  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(FCL_X2 >> 8);
01E8  0100      	MOVLB 0x00
01EA  51CE      	MOVF FCD_0f051__00077_arg_FCL_X2+D'1', W, 1
01EC  0101      	MOVLB 0x01
01EE  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
01F0  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
01F2  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(FCL_X2);
01F6  0100      	MOVLB 0x00
01F8  51CD      	MOVF FCD_0f051__00077_arg_FCL_X2, W, 1
01FA  0101      	MOVLB 0x01
01FC  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
01FE  0100      	MOVLB 0x00
0200  51CE      	MOVF FCD_0f051__00077_arg_FCL_X2+D'1', W, 1
0202  0101      	MOVLB 0x01
0204  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0206  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(FCL_Y2 >> 8);
020A  0100      	MOVLB 0x00
020C  51D0      	MOVF FCD_0f051__00077_arg_FCL_Y2+D'1', W, 1
020E  0101      	MOVLB 0x01
0210  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0212  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0214  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(FCL_Y2);
0218  0100      	MOVLB 0x00
021A  51CF      	MOVF FCD_0f051__00077_arg_FCL_Y2, W, 1
021C  0101      	MOVLB 0x01
021E  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0220  0100      	MOVLB 0x00
0222  51D0      	MOVF FCD_0f051__00077_arg_FCL_Y2+D'1', W, 1
0224  0101      	MOVLB 0x01
0226  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0228  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
022C  0100      	MOVLB 0x00
022E  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
0230  0101      	MOVLB 0x01
0232  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0234  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0236  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
023A  0100      	MOVLB 0x00
023C  5192      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W, 1
023E  0101      	MOVLB 0x01
0240  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0242  0100      	MOVLB 0x00
0244  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
0246  0101      	MOVLB 0x01
0248  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
024A  EC46F000  	CALL FC_CAL_UAR_00087


		FC_CAL_UART_Receive_1(255);
024E  0100      	MOVLB 0x00
0250  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0252  EC50F000  	CALL FC_CAL_UAR_00086


	// } else {

	}

	FC_CAL_UART_Send_1(0x70);
0256  0E70      	MOVLW 0x70
0258  0101      	MOVLB 0x01
025A  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
025C  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
025E  EC46F000  	CALL FC_CAL_UAR_00087


	if (FCL_SOLID)
0262  0100      	MOVLB 0x00
0264  53D2      	MOVF FCD_0f051__00077_arg_FCL_SOLID, F, 1
0266  E006      	BZ	label18
0274            label18

	{

		FC_CAL_UART_Send_1(0x00);
0268  0101      	MOVLB 0x01
026A  6B00      	CLRF FC_CAL_UAR_00087_arg_nChar, 1
026C  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
026E  EC46F000  	CALL FC_CAL_UAR_00087


	} else {
0272  D006      	BRA	label19
0280            label19


		FC_CAL_UART_Send_1(0x01);
0274  0E01      	MOVLW 0x01
0276  0101      	MOVLB 0x01
0278  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
027A  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
027C  EC46F000  	CALL FC_CAL_UAR_00087


	}

	FC_CAL_UART_Receive_1(255);
0280  0100      	MOVLB 0x00
0282  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0284  EC50F000  	CALL FC_CAL_UAR_00086


	FC_CAL_UART_Send_1(0x72);
0288  0E72      	MOVLW 0x72
028A  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
028C  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
028E  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0292  0100      	MOVLB 0x00
0294  51CA      	MOVF FCD_0f051__00077_arg_FCL_X1+D'1', W, 1
0296  0101      	MOVLB 0x01
0298  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
029A  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
029C  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X1);
02A0  0100      	MOVLB 0x00
02A2  51C9      	MOVF FCD_0f051__00077_arg_FCL_X1, W, 1
02A4  0101      	MOVLB 0x01
02A6  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
02A8  0100      	MOVLB 0x00
02AA  51CA      	MOVF FCD_0f051__00077_arg_FCL_X1+D'1', W, 1
02AC  0101      	MOVLB 0x01
02AE  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
02B0  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
02B4  0100      	MOVLB 0x00
02B6  51CC      	MOVF FCD_0f051__00077_arg_FCL_Y1+D'1', W, 1
02B8  0101      	MOVLB 0x01
02BA  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
02BC  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
02BE  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y1);
02C2  0100      	MOVLB 0x00
02C4  51CB      	MOVF FCD_0f051__00077_arg_FCL_Y1, W, 1
02C6  0101      	MOVLB 0x01
02C8  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
02CA  0100      	MOVLB 0x00
02CC  51CC      	MOVF FCD_0f051__00077_arg_FCL_Y1+D'1', W, 1
02CE  0101      	MOVLB 0x01
02D0  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
02D2  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
02D6  0100      	MOVLB 0x00
02D8  51CE      	MOVF FCD_0f051__00077_arg_FCL_X2+D'1', W, 1
02DA  0101      	MOVLB 0x01
02DC  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
02DE  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
02E0  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_X2);
02E4  0100      	MOVLB 0x00
02E6  51CD      	MOVF FCD_0f051__00077_arg_FCL_X2, W, 1
02E8  0101      	MOVLB 0x01
02EA  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
02EC  0100      	MOVLB 0x00
02EE  51CE      	MOVF FCD_0f051__00077_arg_FCL_X2+D'1', W, 1
02F0  0101      	MOVLB 0x01
02F2  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
02F4  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
02F8  0100      	MOVLB 0x00
02FA  51D0      	MOVF FCD_0f051__00077_arg_FCL_Y2+D'1', W, 1
02FC  0101      	MOVLB 0x01
02FE  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0300  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0302  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCL_Y2);
0306  0100      	MOVLB 0x00
0308  51CF      	MOVF FCD_0f051__00077_arg_FCL_Y2, W, 1
030A  0101      	MOVLB 0x01
030C  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
030E  0100      	MOVLB 0x00
0310  51D0      	MOVF FCD_0f051__00077_arg_FCL_Y2+D'1', W, 1
0312  0101      	MOVLB 0x01
0314  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0316  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
031A  0100      	MOVLB 0x00
031C  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
031E  0101      	MOVLB 0x01
0320  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0322  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0324  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0328  0100      	MOVLB 0x00
032A  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
032C  0101      	MOVLB 0x01
032E  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
0330  0100      	MOVLB 0x00
0332  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0334  0101      	MOVLB 0x01
0336  6F01      	MOVWF FC_CAL_UAR_00087_arg_nChar+D'1', 1
0338  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Receive_1(255);
033C  0100      	MOVLB 0x00
033E  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
0340  EC50F000  	CALL FC_CAL_UAR_00086


}
0344  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, C, 0x20, 0x5, 0);
15AA  0100      	MOVLB 0x00
15AC  6BBB      	CLRF FCD_0f051__0006C_2_ptmp, 1
15AE  9A94      	BCF gbl_trisc,5
15B0  53BB      	MOVF FCD_0f051__0006C_2_ptmp, F, 1
15B2  E004      	BZ	label108
15B4  0E20      	MOVLW 0x20
15B6  108B      	IORWF gbl_latc, W
15B8  6E82      	MOVWF gbl_portc
15BA  D003      	BRA	label109
15BC            label108
15BC  0EDF      	MOVLW 0xDF
15BE  148B      	ANDWF gbl_latc, W
15C0  6E82      	MOVWF gbl_portc
15C2            label109


	FC_CAL_UART_Init_1();
15C2  ECD5F003  	CALL FC_CAL_UAR_00088


	FCI_DELAYBYTE_US(100);
15C6  0E64      	MOVLW 0x64
15C8  6FBB      	MOVWF delay_us_00000_arg_del, 1
15CA  EC2EF000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, C, 0x20, 0x5);
15CE  0E0F      	MOVLW HIGH(gbl_portc+D'0')
15D0  6FBC      	MOVWF FC_CAL_Por_00042_arg_Port+D'1', 1
15D2  0E82      	MOVLW LOW(gbl_portc+D'0')
15D4  6FBB      	MOVWF FC_CAL_Por_00042_arg_Port, 1
15D6  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
15D8  6FBE      	MOVWF FC_CAL_Por_00042_arg_Tris+D'1', 1
15DA  0E94      	MOVLW LOW(gbl_trisc+D'0')
15DC  6FBD      	MOVWF FC_CAL_Por_00042_arg_Tris, 1
15DE  0E20      	MOVLW 0x20
15E0  6FBF      	MOVWF FC_CAL_Por_00042_arg_InMask, 1
15E2  0E05      	MOVLW 0x05
15E4  6FC0      	MOVWF FC_CAL_Por_00042_arg_Shift, 1
15E6  EC26F004  	CALL FC_CAL_Por_00042
15EA  51C1      	MOVF CompTempVarRet1822, W, 1
15EC  6FBA      	MOVWF FCD_0f051__0006C_1_FCL_DUMMY, 1


	FCI_DELAYBYTE_S(3);
15EE  0E03      	MOVLW 0x03
15F0  6FBB      	MOVWF delay_s_00000_arg_del, 1
15F2  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_1(0);
15F6  6BFF      	CLRF FC_CAL_UAR_00086_arg_nTimeout, 1
15F8  EC50F000  	CALL FC_CAL_UAR_00086


	FC_CAL_UART_Receive_1(0);
15FC  0100      	MOVLB 0x00
15FE  6BFF      	CLRF FC_CAL_UAR_00086_arg_nTimeout, 1
1600  EC50F000  	CALL FC_CAL_UAR_00086


	FC_CAL_UART_Receive_1(0);
1604  0100      	MOVLB 0x00
1606  6BFF      	CLRF FC_CAL_UAR_00086_arg_nTimeout, 1
1608  EC50F000  	CALL FC_CAL_UAR_00086


	FC_CAL_UART_Send_1(0x55);
160C  0E55      	MOVLW 0x55
160E  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
1610  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
1612  EC46F000  	CALL FC_CAL_UAR_00087


	FC_CAL_UART_Receive_1(255);
1616  0100      	MOVLB 0x00
1618  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
161A  EC50F000  	CALL FC_CAL_UAR_00086


	#if (1) // 1 == 1

		#if (1) // 1 != 0

			FC_CAL_UART_Send_1(0x51);
161E  0E51      	MOVLW 0x51
1620  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
1622  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
1624  EC46F000  	CALL FC_CAL_UAR_00087


			FC_CAL_UART_Send_1(0x0C);
1628  0E0C      	MOVLW 0x0C
162A  6F00      	MOVWF FC_CAL_UAR_00087_arg_nChar, 1
162C  6B01      	CLRF FC_CAL_UAR_00087_arg_nChar+D'1', 1
162E  EC46F000  	CALL FC_CAL_UAR_00087


			FC_CAL_UART_Receive_1(255);
1632  0100      	MOVLB 0x00
1634  69FF      	SETF FC_CAL_UAR_00086_arg_nTimeout, 1
1636  EC50F000  	CALL FC_CAL_UAR_00086


			FC_CAL_UART_UpdateBaud_1(6);
163A  0E06      	MOVLW 0x06
163C  0100      	MOVLB 0x00
163E  6FBB      	MOVWF FC_CAL_UAR_00084_arg_new_baud, 1
1640  ECDEF003  	CALL FC_CAL_UAR_00084



		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_1(10);
1644  0E0A      	MOVLW 0x0A
1646  6FFF      	MOVWF FC_CAL_UAR_00086_arg_nTimeout, 1
1648  EC50F000  	CALL FC_CAL_UAR_00086


	FC_CAL_UART_Receive_1(10);
164C  0E0A      	MOVLW 0x0A
164E  0100      	MOVLB 0x00
1650  6FFF      	MOVWF FC_CAL_UAR_00086_arg_nTimeout, 1
1652  EC50F000  	CALL FC_CAL_UAR_00086


	FCL_RED = 0 & 0xFF;
1656  0100      	MOVLB 0x00
1658  6BB7      	CLRF FCD_0f051__0006C_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
165A  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
165C  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
165E  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
1660  0E1F      	MOVLW 0x1F
1662  17B7      	ANDWF FCD_0f051__0006C_1_FCL_RED, F, 1

	FCL_GREEN = (0 >> 8) & 0xFF;
1664  6BB8      	CLRF FCD_0f051__0006C_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
1666  33B8      	RRCF FCD_0f051__0006C_1_FCL_GREEN, F, 1
1668  33B8      	RRCF FCD_0f051__0006C_1_FCL_GREEN, F, 1
166A  0E3F      	MOVLW 0x3F
166C  17B8      	ANDWF FCD_0f051__0006C_1_FCL_GREEN, F, 1

	FCL_BLUE = (0 >> 16) & 0xFF;
166E  6BB9      	CLRF FCD_0f051__0006C_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
1670  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
1672  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
1674  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
1676  0E1F      	MOVLW 0x1F
1678  17B9      	ANDWF FCD_0f051__0006C_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
167A  51B8      	MOVF FCD_0f051__0006C_1_FCL_GREEN, W, 1
167C  6FBB      	MOVWF CompTempVar2742, 1
167E  6B95      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', 1
1680  37BB      	RLCF CompTempVar2742, F, 1
1682  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
1684  37BB      	RLCF CompTempVar2742, F, 1
1686  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
1688  37BB      	RLCF CompTempVar2742, F, 1
168A  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
168C  37BB      	RLCF CompTempVar2742, F, 1
168E  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
1690  37BB      	RLCF CompTempVar2742, F, 1
1692  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
1694  0EE0      	MOVLW 0xE0
1696  17BB      	ANDWF CompTempVar2742, F, 1
1698  51BB      	MOVF CompTempVar2742, W, 1
169A  11B9      	IORWF FCD_0f051__0006C_1_FCL_BLUE, W, 1
169C  6F94      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
169E  6BBB      	CLRF CompTempVar2746, 1
16A0  51B7      	MOVF FCD_0f051__0006C_1_FCL_RED, W, 1
16A2  6FBC      	MOVWF CompTempVar2747, 1
16A4  90D8      	BCF STATUS,C
16A6  37BC      	RLCF CompTempVar2747, F, 1
16A8  90D8      	BCF STATUS,C
16AA  37BC      	RLCF CompTempVar2747, F, 1
16AC  90D8      	BCF STATUS,C
16AE  37BC      	RLCF CompTempVar2747, F, 1
16B0  51BB      	MOVF CompTempVar2746, W, 1
16B2  1394      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F, 1
16B4  51BC      	MOVF CompTempVar2747, W, 1
16B6  1395      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1

	FCL_RED = 16777215 & 0xFF;
16B8  69B7      	SETF FCD_0f051__0006C_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
16BA  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
16BC  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
16BE  33B7      	RRCF FCD_0f051__0006C_1_FCL_RED, F, 1
16C0  0E1F      	MOVLW 0x1F
16C2  17B7      	ANDWF FCD_0f051__0006C_1_FCL_RED, F, 1

	FCL_GREEN = (16777215 >> 8) & 0xFF;
16C4  69B8      	SETF FCD_0f051__0006C_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
16C6  33B8      	RRCF FCD_0f051__0006C_1_FCL_GREEN, F, 1
16C8  33B8      	RRCF FCD_0f051__0006C_1_FCL_GREEN, F, 1
16CA  0E3F      	MOVLW 0x3F
16CC  17B8      	ANDWF FCD_0f051__0006C_1_FCL_GREEN, F, 1

	FCL_BLUE = (16777215 >> 16) & 0xFF;
16CE  69B9      	SETF FCD_0f051__0006C_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
16D0  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
16D2  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
16D4  33B9      	RRCF FCD_0f051__0006C_1_FCL_BLUE, F, 1
16D6  0E1F      	MOVLW 0x1F
16D8  17B9      	ANDWF FCD_0f051__0006C_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
16DA  51B8      	MOVF FCD_0f051__0006C_1_FCL_GREEN, W, 1
16DC  6FBB      	MOVWF CompTempVar2753, 1
16DE  6B93      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', 1
16E0  37BB      	RLCF CompTempVar2753, F, 1
16E2  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
16E4  37BB      	RLCF CompTempVar2753, F, 1
16E6  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
16E8  37BB      	RLCF CompTempVar2753, F, 1
16EA  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
16EC  37BB      	RLCF CompTempVar2753, F, 1
16EE  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
16F0  37BB      	RLCF CompTempVar2753, F, 1
16F2  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
16F4  0EE0      	MOVLW 0xE0
16F6  17BB      	ANDWF CompTempVar2753, F, 1
16F8  51BB      	MOVF CompTempVar2753, W, 1
16FA  11B9      	IORWF FCD_0f051__0006C_1_FCL_BLUE, W, 1
16FC  6F92      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
16FE  6BBB      	CLRF CompTempVar2757, 1
1700  51B7      	MOVF FCD_0f051__0006C_1_FCL_RED, W, 1
1702  6FBC      	MOVWF CompTempVar2758, 1
1704  90D8      	BCF STATUS,C
1706  37BC      	RLCF CompTempVar2758, F, 1
1708  90D8      	BCF STATUS,C
170A  37BC      	RLCF CompTempVar2758, F, 1
170C  90D8      	BCF STATUS,C
170E  37BC      	RLCF CompTempVar2758, F, 1
1710  51BB      	MOVF CompTempVar2757, W, 1
1712  1392      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F, 1
1714  51BC      	MOVF CompTempVar2758, W, 1
1716  1393      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
1718  EC91F006  	CALL FCD_0f051__0006D


	FC_CAL_UART_Receive_1(10);
171C  0E0A      	MOVLW 0x0A
171E  0100      	MOVLB 0x00
1720  6FFF      	MOVWF FC_CAL_UAR_00086_arg_nTimeout, 1
1722  EC50F000  	CALL FC_CAL_UAR_00086


	FC_CAL_UART_Receive_1(10);
1726  0E0A      	MOVLW 0x0A
1728  0100      	MOVLB 0x00
172A  6FFF      	MOVWF FC_CAL_UAR_00086_arg_nTimeout, 1
172C  EC50F000  	CALL FC_CAL_UAR_00086


}
1730  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_Coule_TORP()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
10D2  0100      	MOVLB 0x00
10D4  518E      	MOVF gbl_FCV_X, W, 1
10D6  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
10D8  518F      	MOVF gbl_FCV_X+D'1', W, 1
10DA  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
10DC  0E18      	MOVLW 0x18
10DE  5D8E      	SUBWF gbl_FCV_X, W, 1
10E0  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
10E2  598E      	SUBWFB gbl_FCV_X, W, 1
10E4  0818      	SUBLW 0x18
10E6  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
10E8  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
10EA  518C      	MOVF gbl_FCV_Y, W, 1
10EC  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
10EE  518D      	MOVF gbl_FCV_Y+D'1', W, 1
10F0  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
10F2  0E18      	MOVLW 0x18
10F4  5D8C      	SUBWF gbl_FCV_Y, W, 1
10F6  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
10F8  598C      	SUBWFB gbl_FCV_Y, W, 1
10FA  0818      	SUBLW 0x18
10FC  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
10FE  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
1100  69C6      	SETF FCM_parame_0005C_arg_FCL_ROUGE, 1
1102  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
1104  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
1106  ECD4F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
110A  0E20      	MOVLW 0x20
110C  0100      	MOVLB 0x00
110E  6FC0      	MOVWF CompTempVar2637, 1
1110  6FC1      	MOVWF CompTempVar2637+D'1', 1
1112  6FC2      	MOVWF CompTempVar2637+D'2', 1
1114  6FC3      	MOVWF CompTempVar2637+D'3', 1
1116  6FC4      	MOVWF CompTempVar2637+D'4', 1
1118  6FC5      	MOVWF CompTempVar2637+D'5', 1
111A  6FC6      	MOVWF CompTempVar2637+D'6', 1
111C  6FC7      	MOVWF CompTempVar2637+D'7', 1
111E  6FC8      	MOVWF CompTempVar2637+D'8', 1
1120  6FC9      	MOVWF CompTempVar2637+D'9', 1
1122  6FCA      	MOVWF CompTempVar2637+D'10', 1
1124  6FCB      	MOVWF CompTempVar2637+D'11', 1
1126  6FD2      	MOVWF CompTempVar2637+D'18', 1
1128  6FD3      	MOVWF CompTempVar2637+D'19', 1
112A  6FD4      	MOVWF CompTempVar2637+D'20', 1
112C  0E54      	MOVLW 0x54
112E  6FCC      	MOVWF CompTempVar2637+D'12', 1
1130  0E63      	MOVLW 0x63
1132  6FCF      	MOVWF CompTempVar2637+D'15', 1
1134  0E65      	MOVLW 0x65
1136  6FD1      	MOVWF CompTempVar2637+D'17', 1
1138  0E68      	MOVLW 0x68
113A  6FD0      	MOVWF CompTempVar2637+D'16', 1
113C  0E6F      	MOVLW 0x6F
113E  6FCD      	MOVWF CompTempVar2637+D'13', 1
1140  0E75      	MOVLW 0x75
1142  6FCE      	MOVWF CompTempVar2637+D'14', 1
1144  6BD5      	CLRF CompTempVar2637+D'21', 1
1146  0E00      	MOVLW HIGH(CompTempVar2637+D'0')
1148  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
114A  0EC0      	MOVLW LOW(CompTempVar2637+D'0')
114C  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
114E  0E16      	MOVLW 0x16
1150  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1152  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
1154  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1156  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1158  0EF1      	MOVLW 0xF1
115A  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
115C  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
115E  0E02      	MOVLW 0x02
1160  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
1162  0E01      	MOVLW 0x01
1164  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1166  EC3FF003  	CALL FCD_0f051__0005D


	// Calcul
	// Calcul:
	//  Tableau[hitbox] = tableau[hitbox] || 0b00000011
	//  Torpilleur = Torpilleur - 1
	FCV_TABLEAU[FCV_HITBOX] = FCV_TABLEAU[FCV_HITBOX] || 3;
116A  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
116E  50E9      	MOVF FSR0L, W
1170  0100      	MOVLB 0x00
1172  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1174  26E9      	ADDWF FSR0L, F
1176  6BB8      	CLRF CompTempVar2641, 1
1178  2BB8      	INCF CompTempVar2641, F, 1
117A  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
117C  6EE9      	MOVWF FSR0L
117E  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1180  26E9      	ADDWF FSR0L, F
1182  51B8      	MOVF CompTempVar2641, W, 1
1184  6EEF      	MOVWF INDF0

	FCV_TORPILLEUR = FCV_TORPILLEUR - 1;
1186  05A4      	DECF gbl_FCV_TORPILLEUR, W, 1
1188  6FA4      	MOVWF gbl_FCV_TORPILLEUR, 1


}
118A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Hitbox_v2()

{

	// Boucle
	// Boucle: While Appui_Ecran = 0
	while (1)
1AB2            label127

	{

		// Boucle
		// Boucle: While Porte_avion = 5
		while (!(FCV_PORTE_AVION == 5))
1AB2  0100      	MOVLB 0x00
1AB4  6BB8      	CLRF CompTempVar2654, 1
1AB6  0E05      	MOVLW 0x05
1AB8  63AB      	CPFSEQ gbl_FCV_PORTE_AVION, 1
1ABA  D001      	BRA	label128
1ABC  2BB8      	INCF CompTempVar2654, F, 1
1ABE            label128
1ABE  67B8      	TSTFSZ CompTempVar2654, 1
1AC0  D008      	BRA	label129
1AD0  D7F0      	BRA	label127
1AD2            label129

		{

			// Décision
			// Décision: Porte_avion < 5?
			if (FCV_PORTE_AVION < 5)
1AC2  0E05      	MOVLW 0x05
1AC4  61AB      	CPFSLT gbl_FCV_PORTE_AVION, 1
1AC6  D7F5      	BRA	label127

			{

				// Appel d'une Macro
				// Appel d'une Macro: Choix_Bateaux()
				FCM_Choix_Bateaux();
1AC8  ECC2F00A  	CALL FCM_Choix__00060


				// Appel d'une Macro
				// Appel d'une Macro: Porte_avion()
				FCM_Porte_avion();
1ACC  EC72F009  	CALL FCM_Porte__00061


			// } else {

			}


		}

		// Boucle
		// Boucle: While Croiseur = 4
		while (!(FCV_CROISEUR == 4))
1AD2  6BB9      	CLRF CompTempVar2656, 1
1AD4  0E04      	MOVLW 0x04
1AD6  63A3      	CPFSEQ gbl_FCV_CROISEUR, 1
1AD8  D001      	BRA	label130
1ADA  2BB9      	INCF CompTempVar2656, F, 1
1ADC            label130
1ADC  67B9      	TSTFSZ CompTempVar2656, 1
1ADE  D008      	BRA	label131
1AEE  D7F1      	BRA	label129
1AF0            label131

		{

			// Décision
			// Décision: Porte_avion = 5?
			if (FCV_PORTE_AVION == 5)
1AE0  0E05      	MOVLW 0x05
1AE2  63AB      	CPFSEQ gbl_FCV_PORTE_AVION, 1
1AE4  D7F6      	BRA	label129

			{

				// Appel d'une Macro
				// Appel d'une Macro: Choix_Bateaux()
				FCM_Choix_Bateaux();
1AE6  ECC2F00A  	CALL FCM_Choix__00060


				// Appel d'une Macro
				// Appel d'une Macro: Croiseur()
				FCM_Croiseur();
1AEA  EC16F00A  	CALL FCM_Croise_00062


			// } else {

			}


		}

		// Boucle
		// Boucle: While Contre_torpilleur = 3
		while (!(FCV_CONTRE_TORPILLEUR == 3))
1AF0  6BBA      	CLRF CompTempVar2658, 1
1AF2  0E03      	MOVLW 0x03
1AF4  63AD      	CPFSEQ gbl_FCV_CONTRE_TORPILLEUR, 1
1AF6  D001      	BRA	label132
1AF8  2BBA      	INCF CompTempVar2658, F, 1
1AFA            label132
1AFA  67BA      	TSTFSZ CompTempVar2658, 1
1AFC  D005      	BRA	label133
1B06  D7F4      	BRA	label131
1B08            label133

		{

			// Appel d'une Macro
			// Appel d'une Macro: Choix_Bateaux()
			FCM_Choix_Bateaux();
1AFE  ECC2F00A  	CALL FCM_Choix__00060


			// Appel d'une Macro
			// Appel d'une Macro: Contre_torpilleur()
			FCM_Contre_torpilleur();
1B02  EC6CF00A  	CALL FCM_Contre_00063



		}

		// Boucle
		// Boucle: While Sous_marin = 3
		while (!(FCV_SOUS_MARIN == 3))
1B08  6BBB      	CLRF CompTempVar2660, 1
1B0A  0E03      	MOVLW 0x03
1B0C  63A7      	CPFSEQ gbl_FCV_SOUS_MARIN, 1
1B0E  D001      	BRA	label134
1B10  2BBB      	INCF CompTempVar2660, F, 1
1B12            label134
1B12  67BB      	TSTFSZ CompTempVar2660, 1
1B14  D005      	BRA	label135
1B1E  D7F4      	BRA	label133
1B20            label135

		{

			// Appel d'une Macro
			// Appel d'une Macro: Choix_Bateaux()
			FCM_Choix_Bateaux();
1B16  ECC2F00A  	CALL FCM_Choix__00060


			// Appel d'une Macro
			// Appel d'une Macro: Sous_marin()
			FCM_Sous_marin();
1B1A  EC1CF009  	CALL FCM_Sous_m_00064



		}

		// Boucle
		// Boucle: While Torpilleur = 2
		while (!(FCV_TORPILLEUR == 2))
1B20  6BBC      	CLRF CompTempVar2662, 1
1B22  0E02      	MOVLW 0x02
1B24  63A4      	CPFSEQ gbl_FCV_TORPILLEUR, 1
1B26  D001      	BRA	label136
1B28  2BBC      	INCF CompTempVar2662, F, 1
1B2A            label136
1B2A  67BC      	TSTFSZ CompTempVar2662, 1
1B2C  D005      	BRA	label137
1B36  D7F4      	BRA	label135
1B38            label137

		{

			// Appel d'une Macro
			// Appel d'une Macro: Choix_Bateaux()
			FCM_Choix_Bateaux();
1B2E  ECC2F00A  	CALL FCM_Choix__00060


			// Appel d'une Macro
			// Appel d'une Macro: Torpilleur()
			FCM_Torpilleur();
1B32  ECC6F008  	CALL FCM_Torpil_00065



		}


		if ((FCV_APPUI_ECRAN == 0) != 0) break;
1B38  6BBD      	CLRF CompTempVar2663, 1
1B3A  2BBD      	INCF CompTempVar2663, F, 1
1B3C  67A8      	TSTFSZ gbl_FCV_APPUI_ECRAN, 1
1B3E  91BD      	BCF CompTempVar2663,0, 1
1B40  53BD      	MOVF CompTempVar2663, F, 1
1B42  E0B7      	BZ	label127

	}

}
1B44  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_coule_PA()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
1018  0100      	MOVLB 0x00
101A  518E      	MOVF gbl_FCV_X, W, 1
101C  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
101E  518F      	MOVF gbl_FCV_X+D'1', W, 1
1020  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
1022  0E18      	MOVLW 0x18
1024  5D8E      	SUBWF gbl_FCV_X, W, 1
1026  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
1028  598E      	SUBWFB gbl_FCV_X, W, 1
102A  0818      	SUBLW 0x18
102C  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
102E  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
1030  518C      	MOVF gbl_FCV_Y, W, 1
1032  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
1034  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1036  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
1038  0E18      	MOVLW 0x18
103A  5D8C      	SUBWF gbl_FCV_Y, W, 1
103C  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
103E  598C      	SUBWFB gbl_FCV_Y, W, 1
1040  0818      	SUBLW 0x18
1042  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
1044  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
1046  69C6      	SETF FCM_parame_0005C_arg_FCL_ROUGE, 1
1048  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
104A  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
104C  ECD4F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
1050  0E20      	MOVLW 0x20
1052  0100      	MOVLB 0x00
1054  6FC0      	MOVWF CompTempVar2708, 1
1056  6FC1      	MOVWF CompTempVar2708+D'1', 1
1058  6FC2      	MOVWF CompTempVar2708+D'2', 1
105A  6FC3      	MOVWF CompTempVar2708+D'3', 1
105C  6FC4      	MOVWF CompTempVar2708+D'4', 1
105E  6FC5      	MOVWF CompTempVar2708+D'5', 1
1060  6FC6      	MOVWF CompTempVar2708+D'6', 1
1062  6FC7      	MOVWF CompTempVar2708+D'7', 1
1064  6FC8      	MOVWF CompTempVar2708+D'8', 1
1066  6FC9      	MOVWF CompTempVar2708+D'9', 1
1068  6FCA      	MOVWF CompTempVar2708+D'10', 1
106A  6FCB      	MOVWF CompTempVar2708+D'11', 1
106C  6FD2      	MOVWF CompTempVar2708+D'18', 1
106E  6FD3      	MOVWF CompTempVar2708+D'19', 1
1070  6FD4      	MOVWF CompTempVar2708+D'20', 1
1072  0E54      	MOVLW 0x54
1074  6FCC      	MOVWF CompTempVar2708+D'12', 1
1076  0E63      	MOVLW 0x63
1078  6FCF      	MOVWF CompTempVar2708+D'15', 1
107A  0E65      	MOVLW 0x65
107C  6FD1      	MOVWF CompTempVar2708+D'17', 1
107E  0E68      	MOVLW 0x68
1080  6FD0      	MOVWF CompTempVar2708+D'16', 1
1082  0E6F      	MOVLW 0x6F
1084  6FCD      	MOVWF CompTempVar2708+D'13', 1
1086  0E75      	MOVLW 0x75
1088  6FCE      	MOVWF CompTempVar2708+D'14', 1
108A  6BD5      	CLRF CompTempVar2708+D'21', 1
108C  0E00      	MOVLW HIGH(CompTempVar2708+D'0')
108E  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1090  0EC0      	MOVLW LOW(CompTempVar2708+D'0')
1092  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
1094  0E16      	MOVLW 0x16
1096  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1098  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
109A  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
109C  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
109E  0EF1      	MOVLW 0xF1
10A0  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
10A2  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
10A4  0E02      	MOVLW 0x02
10A6  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
10A8  0E01      	MOVLW 0x01
10AA  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
10AC  EC3FF003  	CALL FCD_0f051__0005D


	// Calcul
	// Calcul:
	//  Tableau[hitbox] = tableau[hitbox] || 0b00000011
	//  Porte_avion = Porte_avion - 1
	FCV_TABLEAU[FCV_HITBOX] = FCV_TABLEAU[FCV_HITBOX] || 3;
10B0  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
10B4  50E9      	MOVF FSR0L, W
10B6  0100      	MOVLB 0x00
10B8  51A6      	MOVF gbl_FCV_HITBOX, W, 1
10BA  26E9      	ADDWF FSR0L, F
10BC  6BB8      	CLRF CompTempVar2712, 1
10BE  2BB8      	INCF CompTempVar2712, F, 1
10C0  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
10C2  6EE9      	MOVWF FSR0L
10C4  51A6      	MOVF gbl_FCV_HITBOX, W, 1
10C6  26E9      	ADDWF FSR0L, F
10C8  51B8      	MOVF CompTempVar2712, W, 1
10CA  6EEF      	MOVWF INDF0

	FCV_PORTE_AVION = FCV_PORTE_AVION - 1;
10CC  05AB      	DECF gbl_FCV_PORTE_AVION, W, 1
10CE  6FAB      	MOVWF gbl_FCV_PORTE_AVION, 1


}
10D0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Lecture_Coordonnes()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: X_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);
0C30  0100      	MOVLB 0x00
0C32  6BBE      	CLRF FCD_0f051__00068_arg_FCL_AXIS, 1
0C34  EC1EF003  	CALL FCD_0f051__00068
0C38  51C1      	MOVF CompTempVarRet2714, W, 1
0C3A  6F90      	MOVWF gbl_FCV_X_TOUCH, 1
0C3C  51C2      	MOVF CompTempVarRet2714+D'1', W, 1
0C3E  6F91      	MOVWF gbl_FCV_X_TOUCH+D'1', 1


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);
0C40  0E01      	MOVLW 0x01
0C42  6FBE      	MOVWF FCD_0f051__00068_arg_FCL_AXIS, 1
0C44  EC1EF003  	CALL FCD_0f051__00068
0C48  51C1      	MOVF CompTempVarRet2714, W, 1
0C4A  6F88      	MOVWF gbl_FCV_Y_TOUCH, 1
0C4C  51C2      	MOVF CompTempVarRet2714+D'1', W, 1
0C4E  6F89      	MOVWF gbl_FCV_Y_TOUCH+D'1', 1


}
0C50  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Croiseur()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
142C  0E01      	MOVLW 0x01
142E  0100      	MOVLB 0x00
1430  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
1432  0E18      	MOVLW 0x18
1434  6F8C      	MOVWF gbl_FCV_Y, 1
1436  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
1438  0E18      	MOVLW 0x18
143A  6F8E      	MOVWF gbl_FCV_X, 1
143C  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
143E            label88
143E  0E01      	MOVLW 0x01
1440  0100      	MOVLB 0x00
1442  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
1444  E236      	BC	label96
1446  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
1448  D034      	BRA	label96
14B0  D7C6      	BRA	label88
14B2            label96

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
144A  518D      	MOVF gbl_FCV_Y+D'1', W, 1
144C  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
144E  E102      	BNZ	label89
1450  518C      	MOVF gbl_FCV_Y, W, 1
1452  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
1454            label89
1454  E223      	BC	label95
1456            label90
149C            label95

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
1456  518F      	MOVF gbl_FCV_X+D'1', W, 1
1458  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
145A  E102      	BNZ	label91
145C  518E      	MOVF gbl_FCV_X, W, 1
145E  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
1460            label91
1460  E309      	BNC	label92

				{

				} else {
1474            label92


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
1462  29A6      	INCF gbl_FCV_HITBOX, W, 1
1464  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
1466  6BBF      	CLRF CompTempVar2674, 1
1468  0E18      	MOVLW 0x18
146A  278E      	ADDWF gbl_FCV_X, F, 1
146C  518F      	MOVF gbl_FCV_X+D'1', W, 1
146E  23BF      	ADDWFC CompTempVar2674, F, 1
1470  51BF      	MOVF CompTempVar2674, W, 1
1472  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
1474  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
1476  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
1478  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
147A  B4D8      	BTFSC STATUS,Z
147C  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
147E  6BBE      	CLRF CompTempVar2672, 1
1480  518F      	MOVF gbl_FCV_X+D'1', W, 1
1482  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1484  E104      	BNZ	label93
1486  518E      	MOVF gbl_FCV_X, W, 1
1488  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
148A  D001      	BRA	label93
148C  D001      	BRA	label94
148E            label93
148E  A0D8      	BTFSS STATUS,C
1490  71BE      	BTG CompTempVar2672,0, 1
1492  53BE      	MOVF CompTempVar2672, F, 1
1494  E0E0      	BZ	label90

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
1496  EC3EF004  	CALL FCM_affich_00069


		} else {
149A  D7D1      	BRA	label88


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
149C  0E0A      	MOVLW 0x0A
149E  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
14A0  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
14A2  6BBE      	CLRF CompTempVar2678, 1
14A4  0E18      	MOVLW 0x18
14A6  278C      	ADDWF gbl_FCV_Y, F, 1
14A8  518D      	MOVF gbl_FCV_Y+D'1', W, 1
14AA  23BE      	ADDWFC CompTempVar2678, F, 1
14AC  51BE      	MOVF CompTempVar2678, W, 1
14AE  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000010
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Croiseur = Croiseur + 1
	FCV_TABLEAU[FCV_HITBOX] = 2;
14B2  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
14B6  50E9      	MOVF FSR0L, W
14B8  51A6      	MOVF gbl_FCV_HITBOX, W, 1
14BA  26E9      	ADDWF FSR0L, F
14BC  0E02      	MOVLW 0x02
14BE  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
14C0  29AA      	INCF gbl_FCV_BATEAU, W, 1
14C2  6FAA      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
14C4  6B86      	CLRF gbl_FCV_X_SORTIE, 1
14C6  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
14C8  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
14CA  6B8E      	CLRF gbl_FCV_X, 1
14CC  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
14CE  6B8C      	CLRF gbl_FCV_Y, 1
14D0  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_CROISEUR = FCV_CROISEUR + 1;
14D2  29A3      	INCF gbl_FCV_CROISEUR, W, 1
14D4  6FA3      	MOVWF gbl_FCV_CROISEUR, 1


}
14D6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Torpilleur()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
118C  0E01      	MOVLW 0x01
118E  0100      	MOVLB 0x00
1190  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
1192  0E18      	MOVLW 0x18
1194  6F8C      	MOVWF gbl_FCV_Y, 1
1196  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
1198  0E18      	MOVLW 0x18
119A  6F8E      	MOVWF gbl_FCV_X, 1
119C  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
119E            label61
119E  0E01      	MOVLW 0x01
11A0  0100      	MOVLB 0x00
11A2  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
11A4  E236      	BC	label69
11A6  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
11A8  D034      	BRA	label69
1210  D7C6      	BRA	label61
1212            label69

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
11AA  518D      	MOVF gbl_FCV_Y+D'1', W, 1
11AC  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
11AE  E102      	BNZ	label62
11B0  518C      	MOVF gbl_FCV_Y, W, 1
11B2  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
11B4            label62
11B4  E223      	BC	label68
11B6            label63
11FC            label68

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
11B6  518F      	MOVF gbl_FCV_X+D'1', W, 1
11B8  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
11BA  E102      	BNZ	label64
11BC  518E      	MOVF gbl_FCV_X, W, 1
11BE  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
11C0            label64
11C0  E309      	BNC	label65

				{

				} else {
11D4            label65


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
11C2  29A6      	INCF gbl_FCV_HITBOX, W, 1
11C4  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
11C6  6BBF      	CLRF CompTempVar2698, 1
11C8  0E18      	MOVLW 0x18
11CA  278E      	ADDWF gbl_FCV_X, F, 1
11CC  518F      	MOVF gbl_FCV_X+D'1', W, 1
11CE  23BF      	ADDWFC CompTempVar2698, F, 1
11D0  51BF      	MOVF CompTempVar2698, W, 1
11D2  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
11D4  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
11D6  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
11D8  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
11DA  B4D8      	BTFSC STATUS,Z
11DC  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
11DE  6BBE      	CLRF CompTempVar2696, 1
11E0  518F      	MOVF gbl_FCV_X+D'1', W, 1
11E2  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
11E4  E104      	BNZ	label66
11E6  518E      	MOVF gbl_FCV_X, W, 1
11E8  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
11EA  D001      	BRA	label66
11EC  D001      	BRA	label67
11EE            label66
11EE  A0D8      	BTFSS STATUS,C
11F0  71BE      	BTG CompTempVar2696,0, 1
11F2  53BE      	MOVF CompTempVar2696, F, 1
11F4  E0E0      	BZ	label63

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
11F6  EC3EF004  	CALL FCM_affich_00069


		} else {
11FA  D7D1      	BRA	label61


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
11FC  0E0A      	MOVLW 0x0A
11FE  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
1200  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
1202  6BBE      	CLRF CompTempVar2702, 1
1204  0E18      	MOVLW 0x18
1206  278C      	ADDWF gbl_FCV_Y, F, 1
1208  518D      	MOVF gbl_FCV_Y+D'1', W, 1
120A  23BE      	ADDWFC CompTempVar2702, F, 1
120C  51BE      	MOVF CompTempVar2702, W, 1
120E  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000101
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Torpilleur = Torpilleur + 1
	FCV_TABLEAU[FCV_HITBOX] = 5;
1212  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
1216  50E9      	MOVF FSR0L, W
1218  51A6      	MOVF gbl_FCV_HITBOX, W, 1
121A  26E9      	ADDWF FSR0L, F
121C  0E05      	MOVLW 0x05
121E  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
1220  29AA      	INCF gbl_FCV_BATEAU, W, 1
1222  6FAA      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
1224  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1226  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
1228  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
122A  6B8E      	CLRF gbl_FCV_X, 1
122C  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
122E  6B8C      	CLRF gbl_FCV_Y, 1
1230  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_TORPILLEUR = FCV_TORPILLEUR + 1;
1232  29A4      	INCF gbl_FCV_TORPILLEUR, W, 1
1234  6FA4      	MOVWF gbl_FCV_TORPILLEUR, 1


}
1236  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_Coule_SM()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0F5E  0100      	MOVLB 0x00
0F60  518E      	MOVF gbl_FCV_X, W, 1
0F62  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
0F64  518F      	MOVF gbl_FCV_X+D'1', W, 1
0F66  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
0F68  0E18      	MOVLW 0x18
0F6A  5D8E      	SUBWF gbl_FCV_X, W, 1
0F6C  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
0F6E  598E      	SUBWFB gbl_FCV_X, W, 1
0F70  0818      	SUBLW 0x18
0F72  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0F74  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
0F76  518C      	MOVF gbl_FCV_Y, W, 1
0F78  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
0F7A  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0F7C  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
0F7E  0E18      	MOVLW 0x18
0F80  5D8C      	SUBWF gbl_FCV_Y, W, 1
0F82  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
0F84  598C      	SUBWFB gbl_FCV_Y, W, 1
0F86  0818      	SUBLW 0x18
0F88  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0F8A  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
0F8C  69C6      	SETF FCM_parame_0005C_arg_FCL_ROUGE, 1
0F8E  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
0F90  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
0F92  ECD4F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0F96  0E20      	MOVLW 0x20
0F98  0100      	MOVLB 0x00
0F9A  6FC0      	MOVWF CompTempVar2723, 1
0F9C  6FC1      	MOVWF CompTempVar2723+D'1', 1
0F9E  6FC2      	MOVWF CompTempVar2723+D'2', 1
0FA0  6FC3      	MOVWF CompTempVar2723+D'3', 1
0FA2  6FC4      	MOVWF CompTempVar2723+D'4', 1
0FA4  6FC5      	MOVWF CompTempVar2723+D'5', 1
0FA6  6FC6      	MOVWF CompTempVar2723+D'6', 1
0FA8  6FC7      	MOVWF CompTempVar2723+D'7', 1
0FAA  6FC8      	MOVWF CompTempVar2723+D'8', 1
0FAC  6FC9      	MOVWF CompTempVar2723+D'9', 1
0FAE  6FCA      	MOVWF CompTempVar2723+D'10', 1
0FB0  6FCB      	MOVWF CompTempVar2723+D'11', 1
0FB2  6FD2      	MOVWF CompTempVar2723+D'18', 1
0FB4  6FD3      	MOVWF CompTempVar2723+D'19', 1
0FB6  6FD4      	MOVWF CompTempVar2723+D'20', 1
0FB8  0E54      	MOVLW 0x54
0FBA  6FCC      	MOVWF CompTempVar2723+D'12', 1
0FBC  0E63      	MOVLW 0x63
0FBE  6FCF      	MOVWF CompTempVar2723+D'15', 1
0FC0  0E65      	MOVLW 0x65
0FC2  6FD1      	MOVWF CompTempVar2723+D'17', 1
0FC4  0E68      	MOVLW 0x68
0FC6  6FD0      	MOVWF CompTempVar2723+D'16', 1
0FC8  0E6F      	MOVLW 0x6F
0FCA  6FCD      	MOVWF CompTempVar2723+D'13', 1
0FCC  0E75      	MOVLW 0x75
0FCE  6FCE      	MOVWF CompTempVar2723+D'14', 1
0FD0  6BD5      	CLRF CompTempVar2723+D'21', 1
0FD2  0E00      	MOVLW HIGH(CompTempVar2723+D'0')
0FD4  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0FD6  0EC0      	MOVLW LOW(CompTempVar2723+D'0')
0FD8  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0FDA  0E16      	MOVLW 0x16
0FDC  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0FDE  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0FE0  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0FE2  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0FE4  0EF1      	MOVLW 0xF1
0FE6  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0FE8  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0FEA  0E02      	MOVLW 0x02
0FEC  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0FEE  0E01      	MOVLW 0x01
0FF0  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0FF2  EC3FF003  	CALL FCD_0f051__0005D


	// Calcul
	// Calcul:
	//  Tableau[hitbox] = tableau[hitbox] || 0b00000011
	//  Sous_marin = Sous_marin - 1
	FCV_TABLEAU[FCV_HITBOX] = FCV_TABLEAU[FCV_HITBOX] || 3;
0FF6  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0FFA  50E9      	MOVF FSR0L, W
0FFC  0100      	MOVLB 0x00
0FFE  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1000  26E9      	ADDWF FSR0L, F
1002  6BB8      	CLRF CompTempVar2727, 1
1004  2BB8      	INCF CompTempVar2727, F, 1
1006  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
1008  6EE9      	MOVWF FSR0L
100A  51A6      	MOVF gbl_FCV_HITBOX, W, 1
100C  26E9      	ADDWF FSR0L, F
100E  51B8      	MOVF CompTempVar2727, W, 1
1010  6EEF      	MOVWF INDF0

	FCV_SOUS_MARIN = FCV_SOUS_MARIN - 1;
1012  05A7      	DECF gbl_FCV_SOUS_MARIN, W, 1
1014  6FA7      	MOVWF gbl_FCV_SOUS_MARIN, 1


}
1016  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Initialisation()

{

	// Calcul
	// Calcul:

	// Boucle
	// Boucle: While hitbox = 101
	while (1)
1A4C            label125

	{

		// Calcul
		// Calcul:
		//  tableau[hitbox] = 0b00000000
		//  hitbox = hitbox + 1
		FCV_TABLEAU[FCV_HITBOX] = 0;
1A4C  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
1A50  50E9      	MOVF FSR0L, W
1A52  0100      	MOVLB 0x00
1A54  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1A56  26E9      	ADDWF FSR0L, F
1A58  0E00      	MOVLW 0x00
1A5A  6EEF      	MOVWF INDF0

		FCV_HITBOX = FCV_HITBOX + 1;
1A5C  29A6      	INCF gbl_FCV_HITBOX, W, 1
1A5E  6FA6      	MOVWF gbl_FCV_HITBOX, 1



		if ((FCV_HITBOX == 101) != 0) break;
1A60  6BB7      	CLRF CompTempVar2729, 1
1A62  0E65      	MOVLW 0x65
1A64  63A6      	CPFSEQ gbl_FCV_HITBOX, 1
1A66  D001      	BRA	label126
1A68  2BB7      	INCF CompTempVar2729, F, 1
1A6A            label126
1A6A  53B7      	MOVF CompTempVar2729, F, 1
1A6C  E0EF      	BZ	label125

	}

	// Calcul
	// Calcul:
	//  tableau[Joueur1] = tableau[hitbox]
	FCV_TABLEAU[FCV_JOUEUR1] = FCV_TABLEAU[FCV_HITBOX];
1A6E  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
1A72  50E9      	MOVF FSR0L, W
1A74  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1A76  6FB7      	MOVWF CompTempVar2733, 1
1A78  51B7      	MOVF CompTempVar2733, W, 1
1A7A  26E9      	ADDWF FSR0L, F
1A7C  50EF      	MOVF INDF0, W
1A7E  6FB8      	MOVWF CompTempVar2734, 1
1A80  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
1A82  6EE9      	MOVWF FSR0L
1A84  51AC      	MOVF gbl_FCV_JOUEUR1, W, 1
1A86  26E9      	ADDWF FSR0L, F
1A88  51B8      	MOVF CompTempVar2734, W, 1
1A8A  6EEF      	MOVWF INDF0


	#if 0 // Disabled code
	// Calcul
	// Calcul:
	//  tableau[23] = 0b00000001
	//  tableau[24] = 0b00000001
	//  tableau[25] = 0b00000001
	FCV_TABLEAU[23] = 1;
	FCV_TABLEAU[24] = 1;
	FCV_TABLEAU[25] = 1;

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
1A8C  ECD5F00A  	CALL FCD_0f051__0006C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
1A90  EC91F006  	CALL FCD_0f051__0006D


	// Appel d'une Macro
	// Appel d'une Macro: lignes()
	FCM_lignes();
1A94  ECBBF006  	CALL FCM_lignes_00000


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_SetTouchRegionPicaso(0, 0, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(0, 0, 240, 240);
1A98  6BBE      	CLRF FCD_0f051__0006E_arg_FCL_X1, 1
1A9A  6BBF      	CLRF FCD_0f051__0006E_arg_FCL_X1+D'1', 1
1A9C  6BC0      	CLRF FCD_0f051__0006E_arg_FCL_Y1, 1
1A9E  6BC1      	CLRF FCD_0f051__0006E_arg_FCL_Y1+D'1', 1
1AA0  0EF0      	MOVLW 0xF0
1AA2  6FC2      	MOVWF FCD_0f051__0006E_arg_FCL_X2, 1
1AA4  6BC3      	CLRF FCD_0f051__0006E_arg_FCL_X2+D'1', 1
1AA6  0EF0      	MOVLW 0xF0
1AA8  6FC4      	MOVWF FCD_0f051__0006E_arg_FCL_Y2, 1
1AAA  6BC5      	CLRF FCD_0f051__0006E_arg_FCL_Y2+D'1', 1
1AAC  ECC4F002  	CALL FCD_0f051__0006E


}
1AB0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Message_bateau()

{

	// Décision
	// Décision: bateau >= 5?
	if (FCV_BATEAU >= 5)
08E4  0E05      	MOVLW 0x05
08E6  0100      	MOVLB 0x00
08E8  61AA      	CPFSLT gbl_FCV_BATEAU, 1
08EA  D001      	BRA	label49
08EC  D153      	BRA	label56
08EE            label49
0B94            label56

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_texte()
		FCM_Reinitialisation_texte();
08EE  ECF2F001  	CALL FCM_Reinit_00070


		// Décision
		// Décision: bateau >= 9?
		if (FCV_BATEAU >= 9)
08F2  0E09      	MOVLW 0x09
08F4  61AA      	CPFSLT gbl_FCV_BATEAU, 1
08F6  D001      	BRA	label50
08F8  D105      	BRA	label55
08FA            label50
0B04            label55

		{

			// Appel d'une Macro
			// Appel d'une Macro: Reinitialisation_texte()
			FCM_Reinitialisation_texte();
08FA  ECF2F001  	CALL FCM_Reinit_00070


			// Décision
			// Décision: bateau >= 12?
			if (FCV_BATEAU >= 12)
08FE  0E0C      	MOVLW 0x0C
0900  61AA      	CPFSLT gbl_FCV_BATEAU, 1
0902  D001      	BRA	label51
0904  D0A5      	BRA	label54
0906            label51
0A50            label54

			{

				// Appel d'une Macro
				// Appel d'une Macro: Reinitialisation_texte()
				FCM_Reinitialisation_texte();
0906  ECF2F001  	CALL FCM_Reinit_00070


				// Décision
				// Décision: bateau >= 15?
				if (FCV_BATEAU >= 15)
090A  0E0F      	MOVLW 0x0F
090C  61AA      	CPFSLT gbl_FCV_BATEAU, 1
090E  D001      	BRA	label52
0910  D051      	BRA	label53
0912            label52
09B4            label53

				{

					// Appel d'une Macro
					// Appel d'une Macro: Reinitialisation_texte()
					FCM_Reinitialisation_texte();
0912  ECF2F001  	CALL FCM_Reinit_00070


					// Décision
					// Décision: bateau >= 17?
					if (FCV_BATEAU >= 17)
0916  0E11      	MOVLW 0x11
0918  61AA      	CPFSLT gbl_FCV_BATEAU, 1

					{

					} else {

						// Appel de la Routine Composant
						// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le torpilleur (2 cases)", 0, 241, 2, 1)
						FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le torpilleur (2 cases)", 40, 0, 241, 2, 1);
091C  0E20      	MOVLW 0x20
091E  6FC8      	MOVWF CompTempVar2778+D'8', 1
0920  6FCF      	MOVWF CompTempVar2778+D'15', 1
0922  6FD2      	MOVWF CompTempVar2778+D'18', 1
0924  6FDD      	MOVWF CompTempVar2778+D'29', 1
0926  6FE0      	MOVWF CompTempVar2778+D'32', 1
0928  0E28      	MOVLW 0x28
092A  6FDE      	MOVWF CompTempVar2778+D'30', 1
092C  0E29      	MOVLW 0x29
092E  6FE6      	MOVWF CompTempVar2778+D'38', 1
0930  0E32      	MOVLW 0x32
0932  6FDF      	MOVWF CompTempVar2778+D'31', 1
0934  0E56      	MOVLW 0x56
0936  6FC0      	MOVWF CompTempVar2778, 1
0938  0E61      	MOVLW 0x61
093A  6FCB      	MOVWF CompTempVar2778+D'11', 1
093C  6FE2      	MOVWF CompTempVar2778+D'34', 1
093E  0E63      	MOVLW 0x63
0940  6FCC      	MOVWF CompTempVar2778+D'12', 1
0942  6FE1      	MOVWF CompTempVar2778+D'33', 1
0944  0E65      	MOVLW 0x65
0946  6FC1      	MOVWF CompTempVar2778+D'1', 1
0948  6FC6      	MOVWF CompTempVar2778+D'6', 1
094A  6FCD      	MOVWF CompTempVar2778+D'13', 1
094C  6FD1      	MOVWF CompTempVar2778+D'17', 1
094E  6FDA      	MOVWF CompTempVar2778+D'26', 1
0950  6FE4      	MOVWF CompTempVar2778+D'36', 1
0952  0E69      	MOVLW 0x69
0954  6FC3      	MOVWF CompTempVar2778+D'3', 1
0956  6FD7      	MOVWF CompTempVar2778+D'23', 1
0958  0E6C      	MOVLW 0x6C
095A  6FC4      	MOVWF CompTempVar2778+D'4', 1
095C  6FC5      	MOVWF CompTempVar2778+D'5', 1
095E  6FCA      	MOVWF CompTempVar2778+D'10', 1
0960  6FD0      	MOVWF CompTempVar2778+D'16', 1
0962  6FD8      	MOVWF CompTempVar2778+D'24', 1
0964  6FD9      	MOVWF CompTempVar2778+D'25', 1
0966  0E6F      	MOVLW 0x6F
0968  6FD4      	MOVWF CompTempVar2778+D'20', 1
096A  0E70      	MOVLW 0x70
096C  6FC9      	MOVWF CompTempVar2778+D'9', 1
096E  6FD6      	MOVWF CompTempVar2778+D'22', 1
0970  0E72      	MOVLW 0x72
0972  6FCE      	MOVWF CompTempVar2778+D'14', 1
0974  6FD5      	MOVWF CompTempVar2778+D'21', 1
0976  6FDC      	MOVWF CompTempVar2778+D'28', 1
0978  0E73      	MOVLW 0x73
097A  6FE3      	MOVWF CompTempVar2778+D'35', 1
097C  6FE5      	MOVWF CompTempVar2778+D'37', 1
097E  0E74      	MOVLW 0x74
0980  6FD3      	MOVWF CompTempVar2778+D'19', 1
0982  0E75      	MOVLW 0x75
0984  6FC2      	MOVWF CompTempVar2778+D'2', 1
0986  6FDB      	MOVWF CompTempVar2778+D'27', 1
0988  0E7A      	MOVLW 0x7A
098A  6FC7      	MOVWF CompTempVar2778+D'7', 1
098C  6BE7      	CLRF CompTempVar2778+D'39', 1
098E  0E00      	MOVLW HIGH(CompTempVar2778+D'0')
0990  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0992  0EC0      	MOVLW LOW(CompTempVar2778+D'0')
0994  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0996  0E28      	MOVLW 0x28
0998  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
099A  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
099C  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
099E  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
09A0  0EF1      	MOVLW 0xF1
09A2  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
09A4  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
09A6  0E02      	MOVLW 0x02
09A8  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
09AA  0E01      	MOVLW 0x01
09AC  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
09AE  EC3FF003  	CALL FCD_0f051__0005D


					}

				} else {

					// Appel de la Routine Composant
					// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le sous-marin (3 cases)", 0, 241, 2, 1)
					FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le sous-marin (3 cases)", 40, 0, 241, 2, 1);
09B4  0E20      	MOVLW 0x20
09B6  6FC8      	MOVWF CompTempVar2780+D'8', 1
09B8  6FCF      	MOVWF CompTempVar2780+D'15', 1
09BA  6FD2      	MOVWF CompTempVar2780+D'18', 1
09BC  6FDD      	MOVWF CompTempVar2780+D'29', 1
09BE  6FE0      	MOVWF CompTempVar2780+D'32', 1
09C0  0E28      	MOVLW 0x28
09C2  6FDE      	MOVWF CompTempVar2780+D'30', 1
09C4  0E29      	MOVLW 0x29
09C6  6FE6      	MOVWF CompTempVar2780+D'38', 1
09C8  0E2D      	MOVLW 0x2D
09CA  6FD7      	MOVWF CompTempVar2780+D'23', 1
09CC  0E33      	MOVLW 0x33
09CE  6FDF      	MOVWF CompTempVar2780+D'31', 1
09D0  0E56      	MOVLW 0x56
09D2  6FC0      	MOVWF CompTempVar2780, 1
09D4  0E61      	MOVLW 0x61
09D6  6FCB      	MOVWF CompTempVar2780+D'11', 1
09D8  6FD9      	MOVWF CompTempVar2780+D'25', 1
09DA  6FE2      	MOVWF CompTempVar2780+D'34', 1
09DC  0E63      	MOVLW 0x63
09DE  6FCC      	MOVWF CompTempVar2780+D'12', 1
09E0  6FE1      	MOVWF CompTempVar2780+D'33', 1
09E2  0E65      	MOVLW 0x65
09E4  6FC1      	MOVWF CompTempVar2780+D'1', 1
09E6  6FC6      	MOVWF CompTempVar2780+D'6', 1
09E8  6FCD      	MOVWF CompTempVar2780+D'13', 1
09EA  6FD1      	MOVWF CompTempVar2780+D'17', 1
09EC  6FE4      	MOVWF CompTempVar2780+D'36', 1
09EE  0E69      	MOVLW 0x69
09F0  6FC3      	MOVWF CompTempVar2780+D'3', 1
09F2  6FDB      	MOVWF CompTempVar2780+D'27', 1
09F4  0E6C      	MOVLW 0x6C
09F6  6FC4      	MOVWF CompTempVar2780+D'4', 1
09F8  6FC5      	MOVWF CompTempVar2780+D'5', 1
09FA  6FCA      	MOVWF CompTempVar2780+D'10', 1
09FC  6FD0      	MOVWF CompTempVar2780+D'16', 1
09FE  0E6D      	MOVLW 0x6D
0A00  6FD8      	MOVWF CompTempVar2780+D'24', 1
0A02  0E6E      	MOVLW 0x6E
0A04  6FDC      	MOVWF CompTempVar2780+D'28', 1
0A06  0E6F      	MOVLW 0x6F
0A08  6FD4      	MOVWF CompTempVar2780+D'20', 1
0A0A  0E70      	MOVLW 0x70
0A0C  6FC9      	MOVWF CompTempVar2780+D'9', 1
0A0E  0E72      	MOVLW 0x72
0A10  6FCE      	MOVWF CompTempVar2780+D'14', 1
0A12  6FDA      	MOVWF CompTempVar2780+D'26', 1
0A14  0E73      	MOVLW 0x73
0A16  6FD3      	MOVWF CompTempVar2780+D'19', 1
0A18  6FD6      	MOVWF CompTempVar2780+D'22', 1
0A1A  6FE3      	MOVWF CompTempVar2780+D'35', 1
0A1C  6FE5      	MOVWF CompTempVar2780+D'37', 1
0A1E  0E75      	MOVLW 0x75
0A20  6FC2      	MOVWF CompTempVar2780+D'2', 1
0A22  6FD5      	MOVWF CompTempVar2780+D'21', 1
0A24  0E7A      	MOVLW 0x7A
0A26  6FC7      	MOVWF CompTempVar2780+D'7', 1
0A28  6BE7      	CLRF CompTempVar2780+D'39', 1
0A2A  0E00      	MOVLW HIGH(CompTempVar2780+D'0')
0A2C  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0A2E  0EC0      	MOVLW LOW(CompTempVar2780+D'0')
0A30  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0A32  0E28      	MOVLW 0x28
0A34  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0A36  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0A38  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0A3A  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0A3C  0EF1      	MOVLW 0xF1
0A3E  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0A40  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0A42  0E02      	MOVLW 0x02
0A44  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0A46  0E01      	MOVLW 0x01
0A48  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0A4A  EC3FF003  	CALL FCD_0f051__0005D


				}

			} else {

				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le contre        torpilleur(3 cases)", 0, 241, 2, 1)
				FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le contre        torpilleur(3 cases)", 53, 0, 241, 2, 1);
0A50  0E20      	MOVLW 0x20
0A52  6FC8      	MOVWF CompTempVar2782+D'8', 1
0A54  6FCF      	MOVWF CompTempVar2782+D'15', 1
0A56  6FD2      	MOVWF CompTempVar2782+D'18', 1
0A58  6FD9      	MOVWF CompTempVar2782+D'25', 1
0A5A  6FDA      	MOVWF CompTempVar2782+D'26', 1
0A5C  6FDB      	MOVWF CompTempVar2782+D'27', 1
0A5E  6FDC      	MOVWF CompTempVar2782+D'28', 1
0A60  6FDD      	MOVWF CompTempVar2782+D'29', 1
0A62  6FDE      	MOVWF CompTempVar2782+D'30', 1
0A64  6FDF      	MOVWF CompTempVar2782+D'31', 1
0A66  6FE0      	MOVWF CompTempVar2782+D'32', 1
0A68  6FED      	MOVWF CompTempVar2782+D'45', 1
0A6A  0E28      	MOVLW 0x28
0A6C  6FEB      	MOVWF CompTempVar2782+D'43', 1
0A6E  0E29      	MOVLW 0x29
0A70  6FF3      	MOVWF CompTempVar2782+D'51', 1
0A72  0E33      	MOVLW 0x33
0A74  6FEC      	MOVWF CompTempVar2782+D'44', 1
0A76  0E56      	MOVLW 0x56
0A78  6FC0      	MOVWF CompTempVar2782, 1
0A7A  0E61      	MOVLW 0x61
0A7C  6FCB      	MOVWF CompTempVar2782+D'11', 1
0A7E  6FEF      	MOVWF CompTempVar2782+D'47', 1
0A80  0E63      	MOVLW 0x63
0A82  6FCC      	MOVWF CompTempVar2782+D'12', 1
0A84  6FD3      	MOVWF CompTempVar2782+D'19', 1
0A86  6FEE      	MOVWF CompTempVar2782+D'46', 1
0A88  0E65      	MOVLW 0x65
0A8A  6FC1      	MOVWF CompTempVar2782+D'1', 1
0A8C  6FC6      	MOVWF CompTempVar2782+D'6', 1
0A8E  6FCD      	MOVWF CompTempVar2782+D'13', 1
0A90  6FD1      	MOVWF CompTempVar2782+D'17', 1
0A92  6FD8      	MOVWF CompTempVar2782+D'24', 1
0A94  6FE8      	MOVWF CompTempVar2782+D'40', 1
0A96  6FF1      	MOVWF CompTempVar2782+D'49', 1
0A98  0E69      	MOVLW 0x69
0A9A  6FC3      	MOVWF CompTempVar2782+D'3', 1
0A9C  6FE5      	MOVWF CompTempVar2782+D'37', 1
0A9E  0E6C      	MOVLW 0x6C
0AA0  6FC4      	MOVWF CompTempVar2782+D'4', 1
0AA2  6FC5      	MOVWF CompTempVar2782+D'5', 1
0AA4  6FCA      	MOVWF CompTempVar2782+D'10', 1
0AA6  6FD0      	MOVWF CompTempVar2782+D'16', 1
0AA8  6FE6      	MOVWF CompTempVar2782+D'38', 1
0AAA  6FE7      	MOVWF CompTempVar2782+D'39', 1
0AAC  0E6E      	MOVLW 0x6E
0AAE  6FD5      	MOVWF CompTempVar2782+D'21', 1
0AB0  0E6F      	MOVLW 0x6F
0AB2  6FD4      	MOVWF CompTempVar2782+D'20', 1
0AB4  6FE2      	MOVWF CompTempVar2782+D'34', 1
0AB6  0E70      	MOVLW 0x70
0AB8  6FC9      	MOVWF CompTempVar2782+D'9', 1
0ABA  6FE4      	MOVWF CompTempVar2782+D'36', 1
0ABC  0E72      	MOVLW 0x72
0ABE  6FCE      	MOVWF CompTempVar2782+D'14', 1
0AC0  6FD7      	MOVWF CompTempVar2782+D'23', 1
0AC2  6FE3      	MOVWF CompTempVar2782+D'35', 1
0AC4  6FEA      	MOVWF CompTempVar2782+D'42', 1
0AC6  0E73      	MOVLW 0x73
0AC8  6FF0      	MOVWF CompTempVar2782+D'48', 1
0ACA  6FF2      	MOVWF CompTempVar2782+D'50', 1
0ACC  0E74      	MOVLW 0x74
0ACE  6FD6      	MOVWF CompTempVar2782+D'22', 1
0AD0  6FE1      	MOVWF CompTempVar2782+D'33', 1
0AD2  0E75      	MOVLW 0x75
0AD4  6FC2      	MOVWF CompTempVar2782+D'2', 1
0AD6  6FE9      	MOVWF CompTempVar2782+D'41', 1
0AD8  0E7A      	MOVLW 0x7A
0ADA  6FC7      	MOVWF CompTempVar2782+D'7', 1
0ADC  6BF4      	CLRF CompTempVar2782+D'52', 1
0ADE  0E00      	MOVLW HIGH(CompTempVar2782+D'0')
0AE0  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0AE2  0EC0      	MOVLW LOW(CompTempVar2782+D'0')
0AE4  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0AE6  0E35      	MOVLW 0x35
0AE8  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0AEA  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0AEC  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0AEE  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0AF0  0EF1      	MOVLW 0xF1
0AF2  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0AF4  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0AF6  0E02      	MOVLW 0x02
0AF8  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0AFA  0E01      	MOVLW 0x01
0AFC  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0AFE  EC3FF003  	CALL FCD_0f051__0005D


			}

		} else {

			// Appel de la Routine Composant
			// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le croiseur(4 cases)", 0, 241, 2, 1)
			FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le croiseur(4 cases)", 37, 0, 241, 2, 1);
0B04  0E20      	MOVLW 0x20
0B06  6FC8      	MOVWF CompTempVar2784+D'8', 1
0B08  6FCF      	MOVWF CompTempVar2784+D'15', 1
0B0A  6FD2      	MOVWF CompTempVar2784+D'18', 1
0B0C  6FDD      	MOVWF CompTempVar2784+D'29', 1
0B0E  0E28      	MOVLW 0x28
0B10  6FDB      	MOVWF CompTempVar2784+D'27', 1
0B12  0E29      	MOVLW 0x29
0B14  6FE3      	MOVWF CompTempVar2784+D'35', 1
0B16  0E34      	MOVLW 0x34
0B18  6FDC      	MOVWF CompTempVar2784+D'28', 1
0B1A  0E56      	MOVLW 0x56
0B1C  6FC0      	MOVWF CompTempVar2784, 1
0B1E  0E61      	MOVLW 0x61
0B20  6FCB      	MOVWF CompTempVar2784+D'11', 1
0B22  6FDF      	MOVWF CompTempVar2784+D'31', 1
0B24  0E63      	MOVLW 0x63
0B26  6FCC      	MOVWF CompTempVar2784+D'12', 1
0B28  6FD3      	MOVWF CompTempVar2784+D'19', 1
0B2A  6FDE      	MOVWF CompTempVar2784+D'30', 1
0B2C  0E65      	MOVLW 0x65
0B2E  6FC1      	MOVWF CompTempVar2784+D'1', 1
0B30  6FC6      	MOVWF CompTempVar2784+D'6', 1
0B32  6FCD      	MOVWF CompTempVar2784+D'13', 1
0B34  6FD1      	MOVWF CompTempVar2784+D'17', 1
0B36  6FD8      	MOVWF CompTempVar2784+D'24', 1
0B38  6FE1      	MOVWF CompTempVar2784+D'33', 1
0B3A  0E69      	MOVLW 0x69
0B3C  6FC3      	MOVWF CompTempVar2784+D'3', 1
0B3E  6FD6      	MOVWF CompTempVar2784+D'22', 1
0B40  0E6C      	MOVLW 0x6C
0B42  6FC4      	MOVWF CompTempVar2784+D'4', 1
0B44  6FC5      	MOVWF CompTempVar2784+D'5', 1
0B46  6FCA      	MOVWF CompTempVar2784+D'10', 1
0B48  6FD0      	MOVWF CompTempVar2784+D'16', 1
0B4A  0E6F      	MOVLW 0x6F
0B4C  6FD5      	MOVWF CompTempVar2784+D'21', 1
0B4E  0E70      	MOVLW 0x70
0B50  6FC9      	MOVWF CompTempVar2784+D'9', 1
0B52  0E72      	MOVLW 0x72
0B54  6FCE      	MOVWF CompTempVar2784+D'14', 1
0B56  6FD4      	MOVWF CompTempVar2784+D'20', 1
0B58  6FDA      	MOVWF CompTempVar2784+D'26', 1
0B5A  0E73      	MOVLW 0x73
0B5C  6FD7      	MOVWF CompTempVar2784+D'23', 1
0B5E  6FE0      	MOVWF CompTempVar2784+D'32', 1
0B60  6FE2      	MOVWF CompTempVar2784+D'34', 1
0B62  0E75      	MOVLW 0x75
0B64  6FC2      	MOVWF CompTempVar2784+D'2', 1
0B66  6FD9      	MOVWF CompTempVar2784+D'25', 1
0B68  0E7A      	MOVLW 0x7A
0B6A  6FC7      	MOVWF CompTempVar2784+D'7', 1
0B6C  6BE4      	CLRF CompTempVar2784+D'36', 1
0B6E  0E00      	MOVLW HIGH(CompTempVar2784+D'0')
0B70  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0B72  0EC0      	MOVLW LOW(CompTempVar2784+D'0')
0B74  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0B76  0E25      	MOVLW 0x25
0B78  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0B7A  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0B7C  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0B7E  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0B80  0EF1      	MOVLW 0xF1
0B82  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0B84  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0B86  0E02      	MOVLW 0x02
0B88  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0B8A  0E01      	MOVLW 0x01
0B8C  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0B8E  EC3FF003  	CALL FCD_0f051__0005D


		}

	} else {

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Veuillez placer le porte avion(5 cases)", 0, 241, 2, 1)
		FCD_0f051_gLCD_EB076_4D1__Print("Veuillez placer le porte avion(5 cases)", 40, 0, 241, 2, 1);
0B94  0E20      	MOVLW 0x20
0B96  6FC8      	MOVWF CompTempVar2786+D'8', 1
0B98  6FCF      	MOVWF CompTempVar2786+D'15', 1
0B9A  6FD2      	MOVWF CompTempVar2786+D'18', 1
0B9C  6FD8      	MOVWF CompTempVar2786+D'24', 1
0B9E  6FE0      	MOVWF CompTempVar2786+D'32', 1
0BA0  0E28      	MOVLW 0x28
0BA2  6FDE      	MOVWF CompTempVar2786+D'30', 1
0BA4  0E29      	MOVLW 0x29
0BA6  6FE6      	MOVWF CompTempVar2786+D'38', 1
0BA8  0E35      	MOVLW 0x35
0BAA  6FDF      	MOVWF CompTempVar2786+D'31', 1
0BAC  0E56      	MOVLW 0x56
0BAE  6FC0      	MOVWF CompTempVar2786, 1
0BB0  0E61      	MOVLW 0x61
0BB2  6FCB      	MOVWF CompTempVar2786+D'11', 1
0BB4  6FD9      	MOVWF CompTempVar2786+D'25', 1
0BB6  6FE2      	MOVWF CompTempVar2786+D'34', 1
0BB8  0E63      	MOVLW 0x63
0BBA  6FCC      	MOVWF CompTempVar2786+D'12', 1
0BBC  6FE1      	MOVWF CompTempVar2786+D'33', 1
0BBE  0E65      	MOVLW 0x65
0BC0  6FC1      	MOVWF CompTempVar2786+D'1', 1
0BC2  6FC6      	MOVWF CompTempVar2786+D'6', 1
0BC4  6FCD      	MOVWF CompTempVar2786+D'13', 1
0BC6  6FD1      	MOVWF CompTempVar2786+D'17', 1
0BC8  6FD7      	MOVWF CompTempVar2786+D'23', 1
0BCA  6FE4      	MOVWF CompTempVar2786+D'36', 1
0BCC  0E69      	MOVLW 0x69
0BCE  6FC3      	MOVWF CompTempVar2786+D'3', 1
0BD0  6FDB      	MOVWF CompTempVar2786+D'27', 1
0BD2  0E6C      	MOVLW 0x6C
0BD4  6FC4      	MOVWF CompTempVar2786+D'4', 1
0BD6  6FC5      	MOVWF CompTempVar2786+D'5', 1
0BD8  6FCA      	MOVWF CompTempVar2786+D'10', 1
0BDA  6FD0      	MOVWF CompTempVar2786+D'16', 1
0BDC  0E6E      	MOVLW 0x6E
0BDE  6FDD      	MOVWF CompTempVar2786+D'29', 1
0BE0  0E6F      	MOVLW 0x6F
0BE2  6FD4      	MOVWF CompTempVar2786+D'20', 1
0BE4  6FDC      	MOVWF CompTempVar2786+D'28', 1
0BE6  0E70      	MOVLW 0x70
0BE8  6FC9      	MOVWF CompTempVar2786+D'9', 1
0BEA  6FD3      	MOVWF CompTempVar2786+D'19', 1
0BEC  0E72      	MOVLW 0x72
0BEE  6FCE      	MOVWF CompTempVar2786+D'14', 1
0BF0  6FD5      	MOVWF CompTempVar2786+D'21', 1
0BF2  0E73      	MOVLW 0x73
0BF4  6FE3      	MOVWF CompTempVar2786+D'35', 1
0BF6  6FE5      	MOVWF CompTempVar2786+D'37', 1
0BF8  0E74      	MOVLW 0x74
0BFA  6FD6      	MOVWF CompTempVar2786+D'22', 1
0BFC  0E75      	MOVLW 0x75
0BFE  6FC2      	MOVWF CompTempVar2786+D'2', 1
0C00  0E76      	MOVLW 0x76
0C02  6FDA      	MOVWF CompTempVar2786+D'26', 1
0C04  0E7A      	MOVLW 0x7A
0C06  6FC7      	MOVWF CompTempVar2786+D'7', 1
0C08  6BE7      	CLRF CompTempVar2786+D'39', 1
0C0A  0E00      	MOVLW HIGH(CompTempVar2786+D'0')
0C0C  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0C0E  0EC0      	MOVLW LOW(CompTempVar2786+D'0')
0C10  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0C12  0E28      	MOVLW 0x28
0C14  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0C16  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0C18  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0C1A  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0C1C  0EF1      	MOVLW 0xF1
0C1E  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0C20  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0C22  0E02      	MOVLW 0x02
0C24  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0C26  0E01      	MOVLW 0x01
0C28  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0C2A  EC3FF003  	CALL FCD_0f051__0005D


	}

}
091A  0012      	RETURN
09B2  0012      	RETURN
0A4E  0012      	RETURN
0B02  0012      	RETURN
0B92  0012      	RETURN
0C2E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_tactile()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_DisableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
08B8  ECA4F002  	CALL FCD_0f051__00072


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_EnableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
08BC  EC6EF002  	CALL FCD_0f051__00073


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_SetTouchRegionPicaso(0, 0, 240, 240)
	FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(0, 0, 240, 240);
08C0  6BBE      	CLRF FCD_0f051__0006E_arg_FCL_X1, 1
08C2  6BBF      	CLRF FCD_0f051__0006E_arg_FCL_X1+D'1', 1
08C4  6BC0      	CLRF FCD_0f051__0006E_arg_FCL_Y1, 1
08C6  6BC1      	CLRF FCD_0f051__0006E_arg_FCL_Y1+D'1', 1
08C8  0EF0      	MOVLW 0xF0
08CA  6FC2      	MOVWF FCD_0f051__0006E_arg_FCL_X2, 1
08CC  6BC3      	CLRF FCD_0f051__0006E_arg_FCL_X2+D'1', 1
08CE  0EF0      	MOVLW 0xF0
08D0  6FC4      	MOVWF FCD_0f051__0006E_arg_FCL_Y2, 1
08D2  6BC5      	CLRF FCD_0f051__0006E_arg_FCL_Y2+D'1', 1
08D4  ECC4F002  	CALL FCD_0f051__0006E


}
08D8  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Choix_Bateau_Toucher()

{

	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_texte()
	FCM_Reinitialisation_texte();
1B46  ECF2F001  	CALL FCM_Reinit_00070


	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_tactile()
	FCM_Reinitialisation_tactile();
1B4A  EC5CF004  	CALL FCM_Reinit_00071


	// Boucle
	// Boucle: While Appui_Ecran = 0
	while (FCV_APPUI_ECRAN == 0)
1B4E            label138
1B4E  53A8      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
1B50  E103      	BNZ	label139
1B56  D7FB      	BRA	label138
1B58            label139

	{

		// Appel d'une Macro
		// Appel d'une Macro: Recuperation_coordonees()
		FCM_Recuperation_coordonees();
1B52  EC6DF004  	CALL FCM_Recupe_00075



	}

	// Appel d'une Macro
	// Appel d'une Macro: Lecture_Coordonnes()
	FCM_Lecture_Coordonnes();
1B58  EC18F006  	CALL FCM_Lectur_00067


	// Pause
	// Pause: 100 ms
	FCI_DELAYBYTE_MS(100);
1B5C  0E64      	MOVLW 0x64
1B5E  6FBE      	MOVWF delay_ms_00000_arg_del, 1
1B60  EC06F000  	CALL delay_ms_00000


}
1B64  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Choix_Bateaux()

{

	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_texte()
	FCM_Reinitialisation_texte();
1584  ECF2F001  	CALL FCM_Reinit_00070


	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_tactile()
	FCM_Reinitialisation_tactile();
1588  EC5CF004  	CALL FCM_Reinit_00071


	// Appel d'une Macro
	// Appel d'une Macro: Message_bateau()
	FCM_Message_bateau();
158C  EC72F004  	CALL FCM_Messag_0006F


	// Boucle
	// Boucle: While Appui_Ecran = 0
	while (FCV_APPUI_ECRAN == 0)
1590            label106
1590  0100      	MOVLB 0x00
1592  53A8      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
1594  E103      	BNZ	label107
159A  D7FA      	BRA	label106
159C            label107

	{

		// Appel d'une Macro
		// Appel d'une Macro: Recuperation_coordonees()
		FCM_Recuperation_coordonees();
1596  EC6DF004  	CALL FCM_Recupe_00075



	}

	// Appel d'une Macro
	// Appel d'une Macro: Lecture_Coordonnes()
	FCM_Lecture_Coordonnes();
159C  EC18F006  	CALL FCM_Lectur_00067


	#if 0 // Disabled code
	// Appel d'une Macro
	// Appel d'une Macro: Hitbox_v2()
	FCM_Hitbox_v2();

	#endif // #if 0: Disabled code
	// Pause
	// Pause: 100 ms
	FCI_DELAYBYTE_MS(100);
15A0  0E64      	MOVLW 0x64
15A2  6FBE      	MOVWF delay_ms_00000_arg_del, 1
15A4  EC06F000  	CALL delay_ms_00000


}
15A8  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_affichage_bateau()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 70, 70, 70)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 70, 70, 70);
087C  0100      	MOVLB 0x00
087E  518E      	MOVF gbl_FCV_X, W, 1
0880  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
0882  518F      	MOVF gbl_FCV_X+D'1', W, 1
0884  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
0886  0E18      	MOVLW 0x18
0888  5D8E      	SUBWF gbl_FCV_X, W, 1
088A  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
088C  598E      	SUBWFB gbl_FCV_X, W, 1
088E  0818      	SUBLW 0x18
0890  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0892  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
0894  518C      	MOVF gbl_FCV_Y, W, 1
0896  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
0898  518D      	MOVF gbl_FCV_Y+D'1', W, 1
089A  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
089C  0E18      	MOVLW 0x18
089E  5D8C      	SUBWF gbl_FCV_Y, W, 1
08A0  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
08A2  598C      	SUBWFB gbl_FCV_Y, W, 1
08A4  0818      	SUBLW 0x18
08A6  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
08A8  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
08AA  0E46      	MOVLW 0x46
08AC  6FC6      	MOVWF FCM_parame_0005C_arg_FCL_ROUGE, 1
08AE  6FC7      	MOVWF FCM_parame_0005C_arg_FCL_VERT, 1
08B0  6FC8      	MOVWF FCM_parame_0005C_arg_FCL_BLEU, 1
08B2  ECD4F001  	CALL FCM_parame_0005C


}
08B6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Sous_marin()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
1238  0E01      	MOVLW 0x01
123A  0100      	MOVLB 0x00
123C  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
123E  0E18      	MOVLW 0x18
1240  6F8C      	MOVWF gbl_FCV_Y, 1
1242  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
1244  0E18      	MOVLW 0x18
1246  6F8E      	MOVWF gbl_FCV_X, 1
1248  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
124A            label70
124A  0E01      	MOVLW 0x01
124C  0100      	MOVLB 0x00
124E  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
1250  E236      	BC	label78
1252  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
1254  D034      	BRA	label78
12BC  D7C6      	BRA	label70
12BE            label78

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
1256  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1258  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
125A  E102      	BNZ	label71
125C  518C      	MOVF gbl_FCV_Y, W, 1
125E  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
1260            label71
1260  E223      	BC	label77
1262            label72
12A8            label77

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
1262  518F      	MOVF gbl_FCV_X+D'1', W, 1
1264  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1266  E102      	BNZ	label73
1268  518E      	MOVF gbl_FCV_X, W, 1
126A  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
126C            label73
126C  E309      	BNC	label74

				{

				} else {
1280            label74


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
126E  29A6      	INCF gbl_FCV_HITBOX, W, 1
1270  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
1272  6BBF      	CLRF CompTempVar2690, 1
1274  0E18      	MOVLW 0x18
1276  278E      	ADDWF gbl_FCV_X, F, 1
1278  518F      	MOVF gbl_FCV_X+D'1', W, 1
127A  23BF      	ADDWFC CompTempVar2690, F, 1
127C  51BF      	MOVF CompTempVar2690, W, 1
127E  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
1280  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
1282  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
1284  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
1286  B4D8      	BTFSC STATUS,Z
1288  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
128A  6BBE      	CLRF CompTempVar2688, 1
128C  518F      	MOVF gbl_FCV_X+D'1', W, 1
128E  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1290  E104      	BNZ	label75
1292  518E      	MOVF gbl_FCV_X, W, 1
1294  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
1296  D001      	BRA	label75
1298  D001      	BRA	label76
129A            label75
129A  A0D8      	BTFSS STATUS,C
129C  71BE      	BTG CompTempVar2688,0, 1
129E  53BE      	MOVF CompTempVar2688, F, 1
12A0  E0E0      	BZ	label72

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
12A2  EC3EF004  	CALL FCM_affich_00069


		} else {
12A6  D7D1      	BRA	label70


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
12A8  0E0A      	MOVLW 0x0A
12AA  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
12AC  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
12AE  6BBE      	CLRF CompTempVar2694, 1
12B0  0E18      	MOVLW 0x18
12B2  278C      	ADDWF gbl_FCV_Y, F, 1
12B4  518D      	MOVF gbl_FCV_Y+D'1', W, 1
12B6  23BE      	ADDWFC CompTempVar2694, F, 1
12B8  51BE      	MOVF CompTempVar2694, W, 1
12BA  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000100
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Sous_marin = Sous_marin + 1
	FCV_TABLEAU[FCV_HITBOX] = 4;
12BE  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
12C2  50E9      	MOVF FSR0L, W
12C4  51A6      	MOVF gbl_FCV_HITBOX, W, 1
12C6  26E9      	ADDWF FSR0L, F
12C8  0E04      	MOVLW 0x04
12CA  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
12CC  29AA      	INCF gbl_FCV_BATEAU, W, 1
12CE  6FAA      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
12D0  6B86      	CLRF gbl_FCV_X_SORTIE, 1
12D2  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
12D4  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
12D6  6B8E      	CLRF gbl_FCV_X, 1
12D8  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
12DA  6B8C      	CLRF gbl_FCV_Y, 1
12DC  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_SOUS_MARIN = FCV_SOUS_MARIN + 1;
12DE  29A7      	INCF gbl_FCV_SOUS_MARIN, W, 1
12E0  6FA7      	MOVWF gbl_FCV_SOUS_MARIN, 1


}
12E2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro parametres_bateau :
       :  pos_x1 : MX_UINT16
       :  pos_x2 : MX_UINT16
       :  pos_y1 : MX_UINT16
       :  pos_y2 : MX_UINT16
       :  Rouge : MX_UINT8
       :  Vert : MX_UINT8
       :  Bleu : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2, MX_UINT8 FCL_ROUGE, MX_UINT8 FCL_VERT, MX_UINT8 FCL_BLEU)

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(.Rouge, .Vert, .Bleu)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(FCL_ROUGE, FCL_VERT, FCL_BLEU);
03A8  51C6      	MOVF FCM_parame_0005C_arg_FCL_ROUGE, W, 1
03AA  6FC9      	MOVWF FCD_0f051__00076_arg_FCL_RED, 1
03AC  51C7      	MOVF FCM_parame_0005C_arg_FCL_VERT, W, 1
03AE  6FCA      	MOVWF FCD_0f051__00076_arg_FCL_GREEN, 1
03B0  51C8      	MOVF FCM_parame_0005C_arg_FCL_BLEU, W, 1
03B2  6FCB      	MOVWF FCD_0f051__00076_arg_FCL_BLUE, 1
03B4  ECA3F001  	CALL FCD_0f051__00076


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(.pos_x1, .pos_y1, .pos_x2, .pos_y2, 0, 1)
	FCD_0f051_gLCD_EB076_4D1__DrawRectangle(FCL_POS_X1, FCL_POS_Y1, FCL_POS_X2, FCL_POS_Y2, 0, 1);
03B8  51BE      	MOVF FCM_parame_0005C_arg_FCL_POS_X1, W, 1
03BA  6FC9      	MOVWF FCD_0f051__00077_arg_FCL_X1, 1
03BC  51BF      	MOVF FCM_parame_0005C_arg_FCL_POS_X1+D'1', W, 1
03BE  6FCA      	MOVWF FCD_0f051__00077_arg_FCL_X1+D'1', 1
03C0  51C2      	MOVF FCM_parame_0005C_arg_FCL_POS_Y1, W, 1
03C2  6FCB      	MOVWF FCD_0f051__00077_arg_FCL_Y1, 1
03C4  51C3      	MOVF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', W, 1
03C6  6FCC      	MOVWF FCD_0f051__00077_arg_FCL_Y1+D'1', 1
03C8  51C0      	MOVF FCM_parame_0005C_arg_FCL_POS_X2, W, 1
03CA  6FCD      	MOVWF FCD_0f051__00077_arg_FCL_X2, 1
03CC  51C1      	MOVF FCM_parame_0005C_arg_FCL_POS_X2+D'1', W, 1
03CE  6FCE      	MOVWF FCD_0f051__00077_arg_FCL_X2+D'1', 1
03D0  51C4      	MOVF FCM_parame_0005C_arg_FCL_POS_Y2, W, 1
03D2  6FCF      	MOVWF FCD_0f051__00077_arg_FCL_Y2, 1
03D4  51C5      	MOVF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', W, 1
03D6  6FD0      	MOVWF FCD_0f051__00077_arg_FCL_Y2+D'1', 1
03D8  6BD1      	CLRF FCD_0f051__00077_arg_FCL_T_00078, 1
03DA  0E01      	MOVLW 0x01
03DC  6FD2      	MOVWF FCD_0f051__00077_arg_FCL_SOLID, 1
03DE  ECBBF000  	CALL FCD_0f051__00077


}
03E2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_texte()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(255, 255, 255)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(255, 255, 255);
03E4  0100      	MOVLB 0x00
03E6  69C9      	SETF FCD_0f051__00076_arg_FCL_RED, 1
03E8  69CA      	SETF FCD_0f051__00076_arg_FCL_GREEN, 1
03EA  69CB      	SETF FCD_0f051__00076_arg_FCL_BLUE, 1
03EC  ECA3F001  	CALL FCD_0f051__00076


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 241, 240, 320, 1, 1)
	FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 241, 240, 320, 1, 1);
03F0  6BC9      	CLRF FCD_0f051__00077_arg_FCL_X1, 1
03F2  6BCA      	CLRF FCD_0f051__00077_arg_FCL_X1+D'1', 1
03F4  0EF1      	MOVLW 0xF1
03F6  6FCB      	MOVWF FCD_0f051__00077_arg_FCL_Y1, 1
03F8  6BCC      	CLRF FCD_0f051__00077_arg_FCL_Y1+D'1', 1
03FA  0EF0      	MOVLW 0xF0
03FC  6FCD      	MOVWF FCD_0f051__00077_arg_FCL_X2, 1
03FE  6BCE      	CLRF FCD_0f051__00077_arg_FCL_X2+D'1', 1
0400  0E40      	MOVLW 0x40
0402  6FCF      	MOVWF FCD_0f051__00077_arg_FCL_Y2, 1
0404  0E01      	MOVLW 0x01
0406  6FD0      	MOVWF FCD_0f051__00077_arg_FCL_Y2+D'1', 1
0408  6FD1      	MOVWF FCD_0f051__00077_arg_FCL_T_00078, 1
040A  6FD2      	MOVWF FCD_0f051__00077_arg_FCL_SOLID, 1
040C  ECBBF000  	CALL FCD_0f051__00077


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(0, 0, 0)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(0, 0, 0);
0410  0100      	MOVLB 0x00
0412  6BC9      	CLRF FCD_0f051__00076_arg_FCL_RED, 1
0414  6BCA      	CLRF FCD_0f051__00076_arg_FCL_GREEN, 1
0416  6BCB      	CLRF FCD_0f051__00076_arg_FCL_BLUE, 1
0418  ECA3F001  	CALL FCD_0f051__00076


}
041C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Appui_tactile()
{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	#if 0 // Disabled code
	//Commentaire:
	//Coordonnée pour X

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: X=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);

	#if 0 // Disabled code
	//Commentaire:
	//Coordonée pour Y

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(X, 80, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_X, 80, 150, 2, 1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(Y, 120, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_Y, 120, 150, 2, 1);

	// Pause
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	// Calcul
	// Calcul:
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	FCV_APPUI_ECRAN = 0;
	FCV_X = 0;
	FCV_Y = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Manque()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 0, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 0, 0, 0);
1390  0100      	MOVLB 0x00
1392  518E      	MOVF gbl_FCV_X, W, 1
1394  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
1396  518F      	MOVF gbl_FCV_X+D'1', W, 1
1398  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
139A  0E18      	MOVLW 0x18
139C  5D8E      	SUBWF gbl_FCV_X, W, 1
139E  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
13A0  598E      	SUBWFB gbl_FCV_X, W, 1
13A2  0818      	SUBLW 0x18
13A4  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
13A6  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
13A8  518C      	MOVF gbl_FCV_Y, W, 1
13AA  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
13AC  518D      	MOVF gbl_FCV_Y+D'1', W, 1
13AE  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
13B0  0E18      	MOVLW 0x18
13B2  5D8C      	SUBWF gbl_FCV_Y, W, 1
13B4  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
13B6  598C      	SUBWFB gbl_FCV_Y, W, 1
13B8  0818      	SUBLW 0x18
13BA  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
13BC  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
13BE  6BC6      	CLRF FCM_parame_0005C_arg_FCL_ROUGE, 1
13C0  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
13C2  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
13C4  ECD4F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Manque   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Manque   ", 22, 0, 241, 2, 1);
13C8  0E20      	MOVLW 0x20
13CA  0100      	MOVLB 0x00
13CC  6FC0      	MOVWF CompTempVar2828, 1
13CE  6FC1      	MOVWF CompTempVar2828+D'1', 1
13D0  6FC2      	MOVWF CompTempVar2828+D'2', 1
13D2  6FC3      	MOVWF CompTempVar2828+D'3', 1
13D4  6FC4      	MOVWF CompTempVar2828+D'4', 1
13D6  6FC5      	MOVWF CompTempVar2828+D'5', 1
13D8  6FC6      	MOVWF CompTempVar2828+D'6', 1
13DA  6FC7      	MOVWF CompTempVar2828+D'7', 1
13DC  6FC8      	MOVWF CompTempVar2828+D'8', 1
13DE  6FC9      	MOVWF CompTempVar2828+D'9', 1
13E0  6FCA      	MOVWF CompTempVar2828+D'10', 1
13E2  6FCB      	MOVWF CompTempVar2828+D'11', 1
13E4  6FD2      	MOVWF CompTempVar2828+D'18', 1
13E6  6FD3      	MOVWF CompTempVar2828+D'19', 1
13E8  6FD4      	MOVWF CompTempVar2828+D'20', 1
13EA  0E4D      	MOVLW 0x4D
13EC  6FCC      	MOVWF CompTempVar2828+D'12', 1
13EE  0E61      	MOVLW 0x61
13F0  6FCD      	MOVWF CompTempVar2828+D'13', 1
13F2  0E65      	MOVLW 0x65
13F4  6FD1      	MOVWF CompTempVar2828+D'17', 1
13F6  0E6E      	MOVLW 0x6E
13F8  6FCE      	MOVWF CompTempVar2828+D'14', 1
13FA  0E71      	MOVLW 0x71
13FC  6FCF      	MOVWF CompTempVar2828+D'15', 1
13FE  0E75      	MOVLW 0x75
1400  6FD0      	MOVWF CompTempVar2828+D'16', 1
1402  6BD5      	CLRF CompTempVar2828+D'21', 1
1404  0E00      	MOVLW HIGH(CompTempVar2828+D'0')
1406  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1408  0EC0      	MOVLW LOW(CompTempVar2828+D'0')
140A  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
140C  0E16      	MOVLW 0x16
140E  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1410  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
1412  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1414  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1416  0EF1      	MOVLW 0xF1
1418  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
141A  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
141C  0E02      	MOVLW 0x02
141E  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
1420  0E01      	MOVLW 0x01
1422  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1424  EC3FF003  	CALL FCD_0f051__0005D


}
1428  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Recuperation_coordonees()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Appui_Ecran=gLCD_EB076_4D1::G4D_GetTouchCoordinatesPicaso()
	FCV_APPUI_ECRAN = FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
08DA  EC0FF002  	CALL FCD_0f051__0007C
08DE  51C0      	MOVF CompTempVarRet2830, W, 1
08E0  6FA8      	MOVWF gbl_FCV_APPUI_ECRAN, 1


}
08E2  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Fin_Jeu()

{

}
142A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_Coule_CT()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0EBE  0100      	MOVLB 0x00
0EC0  518E      	MOVF gbl_FCV_X, W, 1
0EC2  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
0EC4  518F      	MOVF gbl_FCV_X+D'1', W, 1
0EC6  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
0EC8  0E18      	MOVLW 0x18
0ECA  5D8E      	SUBWF gbl_FCV_X, W, 1
0ECC  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
0ECE  598E      	SUBWFB gbl_FCV_X, W, 1
0ED0  0818      	SUBLW 0x18
0ED2  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0ED4  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
0ED6  518C      	MOVF gbl_FCV_Y, W, 1
0ED8  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
0EDA  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0EDC  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
0EDE  0E18      	MOVLW 0x18
0EE0  5D8C      	SUBWF gbl_FCV_Y, W, 1
0EE2  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
0EE4  598C      	SUBWFB gbl_FCV_Y, W, 1
0EE6  0818      	SUBLW 0x18
0EE8  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0EEA  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
0EEC  69C6      	SETF FCM_parame_0005C_arg_FCL_ROUGE, 1
0EEE  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
0EF0  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
0EF2  ECD4F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0EF6  0E20      	MOVLW 0x20
0EF8  0100      	MOVLB 0x00
0EFA  6FC0      	MOVWF CompTempVar2843, 1
0EFC  6FC1      	MOVWF CompTempVar2843+D'1', 1
0EFE  6FC2      	MOVWF CompTempVar2843+D'2', 1
0F00  6FC3      	MOVWF CompTempVar2843+D'3', 1
0F02  6FC4      	MOVWF CompTempVar2843+D'4', 1
0F04  6FC5      	MOVWF CompTempVar2843+D'5', 1
0F06  6FC6      	MOVWF CompTempVar2843+D'6', 1
0F08  6FC7      	MOVWF CompTempVar2843+D'7', 1
0F0A  6FC8      	MOVWF CompTempVar2843+D'8', 1
0F0C  6FC9      	MOVWF CompTempVar2843+D'9', 1
0F0E  6FCA      	MOVWF CompTempVar2843+D'10', 1
0F10  6FCB      	MOVWF CompTempVar2843+D'11', 1
0F12  6FD2      	MOVWF CompTempVar2843+D'18', 1
0F14  6FD3      	MOVWF CompTempVar2843+D'19', 1
0F16  6FD4      	MOVWF CompTempVar2843+D'20', 1
0F18  0E54      	MOVLW 0x54
0F1A  6FCC      	MOVWF CompTempVar2843+D'12', 1
0F1C  0E63      	MOVLW 0x63
0F1E  6FCF      	MOVWF CompTempVar2843+D'15', 1
0F20  0E65      	MOVLW 0x65
0F22  6FD1      	MOVWF CompTempVar2843+D'17', 1
0F24  0E68      	MOVLW 0x68
0F26  6FD0      	MOVWF CompTempVar2843+D'16', 1
0F28  0E6F      	MOVLW 0x6F
0F2A  6FCD      	MOVWF CompTempVar2843+D'13', 1
0F2C  0E75      	MOVLW 0x75
0F2E  6FCE      	MOVWF CompTempVar2843+D'14', 1
0F30  6BD5      	CLRF CompTempVar2843+D'21', 1
0F32  0E00      	MOVLW HIGH(CompTempVar2843+D'0')
0F34  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0F36  0EC0      	MOVLW LOW(CompTempVar2843+D'0')
0F38  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0F3A  0E16      	MOVLW 0x16
0F3C  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0F3E  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0F40  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0F42  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0F44  0EF1      	MOVLW 0xF1
0F46  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0F48  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0F4A  0E02      	MOVLW 0x02
0F4C  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0F4E  0E01      	MOVLW 0x01
0F50  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0F52  EC3FF003  	CALL FCD_0f051__0005D


	// Calcul
	// Calcul:
	//  Contre_torpilleur = Contre_torpilleur - 1
	FCV_CONTRE_TORPILLEUR = FCV_CONTRE_TORPILLEUR - 1;
0F56  0100      	MOVLB 0x00
0F58  05AD      	DECF gbl_FCV_CONTRE_TORPILLEUR, W, 1
0F5A  6FAD      	MOVWF gbl_FCV_CONTRE_TORPILLEUR, 1


}
0F5C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_affichage_bateau_touche()
{

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Porte_avion()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
12E4  0E01      	MOVLW 0x01
12E6  0100      	MOVLB 0x00
12E8  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
12EA  0E18      	MOVLW 0x18
12EC  6F8C      	MOVWF gbl_FCV_Y, 1
12EE  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
12F0  0E18      	MOVLW 0x18
12F2  6F8E      	MOVWF gbl_FCV_X, 1
12F4  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
12F6            label79
12F6  0E01      	MOVLW 0x01
12F8  0100      	MOVLB 0x00
12FA  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
12FC  E236      	BC	label87
12FE  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
1300  D034      	BRA	label87
1368  D7C6      	BRA	label79
136A            label87

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
1302  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1304  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
1306  E102      	BNZ	label80
1308  518C      	MOVF gbl_FCV_Y, W, 1
130A  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
130C            label80
130C  E223      	BC	label86
130E            label81
1354            label86

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
130E  518F      	MOVF gbl_FCV_X+D'1', W, 1
1310  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1312  E102      	BNZ	label82
1314  518E      	MOVF gbl_FCV_X, W, 1
1316  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
1318            label82
1318  E309      	BNC	label83

				{

				} else {
132C            label83


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
131A  29A6      	INCF gbl_FCV_HITBOX, W, 1
131C  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
131E  6BBF      	CLRF CompTempVar2666, 1
1320  0E18      	MOVLW 0x18
1322  278E      	ADDWF gbl_FCV_X, F, 1
1324  518F      	MOVF gbl_FCV_X+D'1', W, 1
1326  23BF      	ADDWFC CompTempVar2666, F, 1
1328  51BF      	MOVF CompTempVar2666, W, 1
132A  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
132C  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
132E  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
1330  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
1332  B4D8      	BTFSC STATUS,Z
1334  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
1336  6BBE      	CLRF CompTempVar2664, 1
1338  518F      	MOVF gbl_FCV_X+D'1', W, 1
133A  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
133C  E104      	BNZ	label84
133E  518E      	MOVF gbl_FCV_X, W, 1
1340  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
1342  D001      	BRA	label84
1344  D001      	BRA	label85
1346            label84
1346  A0D8      	BTFSS STATUS,C
1348  71BE      	BTG CompTempVar2664,0, 1
134A  53BE      	MOVF CompTempVar2664, F, 1
134C  E0E0      	BZ	label81

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
134E  EC3EF004  	CALL FCM_affich_00069


		} else {
1352  D7D1      	BRA	label79


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
1354  0E0A      	MOVLW 0x0A
1356  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
1358  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
135A  6BBE      	CLRF CompTempVar2670, 1
135C  0E18      	MOVLW 0x18
135E  278C      	ADDWF gbl_FCV_Y, F, 1
1360  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1362  23BE      	ADDWFC CompTempVar2670, F, 1
1364  51BE      	MOVF CompTempVar2670, W, 1
1366  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000001
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Porte_avion = Porte_avion + 1
	FCV_TABLEAU[FCV_HITBOX] = 1;
136A  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
136E  50E9      	MOVF FSR0L, W
1370  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1372  26E9      	ADDWF FSR0L, F
1374  0E01      	MOVLW 0x01
1376  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
1378  29AA      	INCF gbl_FCV_BATEAU, W, 1
137A  6FAA      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
137C  6B86      	CLRF gbl_FCV_X_SORTIE, 1
137E  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
1380  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
1382  6B8E      	CLRF gbl_FCV_X, 1
1384  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
1386  6B8C      	CLRF gbl_FCV_Y, 1
1388  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_PORTE_AVION = FCV_PORTE_AVION + 1;
138A  29AB      	INCF gbl_FCV_PORTE_AVION, W, 1
138C  6FAB      	MOVWF gbl_FCV_PORTE_AVION, 1


}
138E  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Touche_coule_CR()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24, 255, 0, 0)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24, 255, 0, 0);
0E04  0100      	MOVLB 0x00
0E06  518E      	MOVF gbl_FCV_X, W, 1
0E08  6FBE      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1, 1
0E0A  518F      	MOVF gbl_FCV_X+D'1', W, 1
0E0C  6FBF      	MOVWF FCM_parame_0005C_arg_FCL_POS_X1+D'1', 1
0E0E  0E18      	MOVLW 0x18
0E10  5D8E      	SUBWF gbl_FCV_X, W, 1
0E12  6FC0      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2, 1
0E14  598E      	SUBWFB gbl_FCV_X, W, 1
0E16  0818      	SUBLW 0x18
0E18  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
0E1A  6FC1      	MOVWF FCM_parame_0005C_arg_FCL_POS_X2+D'1', 1
0E1C  518C      	MOVF gbl_FCV_Y, W, 1
0E1E  6FC2      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1, 1
0E20  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0E22  6FC3      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y1+D'1', 1
0E24  0E18      	MOVLW 0x18
0E26  5D8C      	SUBWF gbl_FCV_Y, W, 1
0E28  6FC4      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2, 1
0E2A  598C      	SUBWFB gbl_FCV_Y, W, 1
0E2C  0818      	SUBLW 0x18
0E2E  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0E30  6FC5      	MOVWF FCM_parame_0005C_arg_FCL_POS_Y2+D'1', 1
0E32  69C6      	SETF FCM_parame_0005C_arg_FCL_ROUGE, 1
0E34  6BC7      	CLRF FCM_parame_0005C_arg_FCL_VERT, 1
0E36  6BC8      	CLRF FCM_parame_0005C_arg_FCL_BLEU, 1
0E38  ECD4F001  	CALL FCM_parame_0005C


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Touche   ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("            Touche   ", 22, 0, 241, 2, 1);
0E3C  0E20      	MOVLW 0x20
0E3E  0100      	MOVLB 0x00
0E40  6FC0      	MOVWF CompTempVar2849, 1
0E42  6FC1      	MOVWF CompTempVar2849+D'1', 1
0E44  6FC2      	MOVWF CompTempVar2849+D'2', 1
0E46  6FC3      	MOVWF CompTempVar2849+D'3', 1
0E48  6FC4      	MOVWF CompTempVar2849+D'4', 1
0E4A  6FC5      	MOVWF CompTempVar2849+D'5', 1
0E4C  6FC6      	MOVWF CompTempVar2849+D'6', 1
0E4E  6FC7      	MOVWF CompTempVar2849+D'7', 1
0E50  6FC8      	MOVWF CompTempVar2849+D'8', 1
0E52  6FC9      	MOVWF CompTempVar2849+D'9', 1
0E54  6FCA      	MOVWF CompTempVar2849+D'10', 1
0E56  6FCB      	MOVWF CompTempVar2849+D'11', 1
0E58  6FD2      	MOVWF CompTempVar2849+D'18', 1
0E5A  6FD3      	MOVWF CompTempVar2849+D'19', 1
0E5C  6FD4      	MOVWF CompTempVar2849+D'20', 1
0E5E  0E54      	MOVLW 0x54
0E60  6FCC      	MOVWF CompTempVar2849+D'12', 1
0E62  0E63      	MOVLW 0x63
0E64  6FCF      	MOVWF CompTempVar2849+D'15', 1
0E66  0E65      	MOVLW 0x65
0E68  6FD1      	MOVWF CompTempVar2849+D'17', 1
0E6A  0E68      	MOVLW 0x68
0E6C  6FD0      	MOVWF CompTempVar2849+D'16', 1
0E6E  0E6F      	MOVLW 0x6F
0E70  6FCD      	MOVWF CompTempVar2849+D'13', 1
0E72  0E75      	MOVLW 0x75
0E74  6FCE      	MOVWF CompTempVar2849+D'14', 1
0E76  6BD5      	CLRF CompTempVar2849+D'21', 1
0E78  0E00      	MOVLW HIGH(CompTempVar2849+D'0')
0E7A  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
0E7C  0EC0      	MOVLW LOW(CompTempVar2849+D'0')
0E7E  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
0E80  0E16      	MOVLW 0x16
0E82  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
0E84  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
0E86  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
0E88  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
0E8A  0EF1      	MOVLW 0xF1
0E8C  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
0E8E  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
0E90  0E02      	MOVLW 0x02
0E92  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
0E94  0E01      	MOVLW 0x01
0E96  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
0E98  EC3FF003  	CALL FCD_0f051__0005D


	// Calcul
	// Calcul:
	//  Tableau[hitbox] = tableau[hitbox] || 0b00000011
	//  Croiseur = Croiseur - 1
	FCV_TABLEAU[FCV_HITBOX] = FCV_TABLEAU[FCV_HITBOX] || 3;
0E9C  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0EA0  50E9      	MOVF FSR0L, W
0EA2  0100      	MOVLB 0x00
0EA4  51A6      	MOVF gbl_FCV_HITBOX, W, 1
0EA6  26E9      	ADDWF FSR0L, F
0EA8  6BB8      	CLRF CompTempVar2853, 1
0EAA  2BB8      	INCF CompTempVar2853, F, 1
0EAC  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
0EAE  6EE9      	MOVWF FSR0L
0EB0  51A6      	MOVF gbl_FCV_HITBOX, W, 1
0EB2  26E9      	ADDWF FSR0L, F
0EB4  51B8      	MOVF CompTempVar2853, W, 1
0EB6  6EEF      	MOVWF INDF0

	FCV_CROISEUR = FCV_CROISEUR - 1;
0EB8  05A3      	DECF gbl_FCV_CROISEUR, W, 1
0EBA  6FA3      	MOVWF gbl_FCV_CROISEUR, 1


}
0EBC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_phase_jeu()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
1732  0E01      	MOVLW 0x01
1734  0100      	MOVLB 0x00
1736  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
1738  0E18      	MOVLW 0x18
173A  6F8C      	MOVWF gbl_FCV_Y, 1
173C  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
173E  0E18      	MOVLW 0x18
1740  6F8E      	MOVWF gbl_FCV_X, 1
1742  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
1744            label110
1744  0E01      	MOVLW 0x01
1746  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
1748  E234      	BC	label118
174A  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
174C  D032      	BRA	label118
17B0  D7C9      	BRA	label110
17B2            label118

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
174E  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1750  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
1752  E102      	BNZ	label111
1754  518C      	MOVF gbl_FCV_Y, W, 1
1756  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
1758            label111
1758  E221      	BC	label117
175A            label112
179C            label117

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
175A  518F      	MOVF gbl_FCV_X+D'1', W, 1
175C  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
175E  E102      	BNZ	label113
1760  518E      	MOVF gbl_FCV_X, W, 1
1762  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
1764            label113
1764  E309      	BNC	label114

				{

				} else {
1778            label114


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
1766  29A6      	INCF gbl_FCV_HITBOX, W, 1
1768  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
176A  6BB9      	CLRF CompTempVar2859, 1
176C  0E18      	MOVLW 0x18
176E  278E      	ADDWF gbl_FCV_X, F, 1
1770  518F      	MOVF gbl_FCV_X+D'1', W, 1
1772  23B9      	ADDWFC CompTempVar2859, F, 1
1774  51B9      	MOVF CompTempVar2859, W, 1
1776  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
1778  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
177A  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
177C  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
177E  B4D8      	BTFSC STATUS,Z
1780  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
1782  6BB8      	CLRF CompTempVar2857, 1
1784  518F      	MOVF gbl_FCV_X+D'1', W, 1
1786  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1788  E104      	BNZ	label115
178A  518E      	MOVF gbl_FCV_X, W, 1
178C  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
178E  D001      	BRA	label115
1790  D001      	BRA	label116
1792            label115
1792  A0D8      	BTFSS STATUS,C
1794  71B8      	BTG CompTempVar2857,0, 1
1796  53B8      	MOVF CompTempVar2857, F, 1
1798  E0E0      	BZ	label112

			}

		} else {
179A  D7D4      	BRA	label110


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
179C  0E0A      	MOVLW 0x0A
179E  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
17A0  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
17A2  6BB8      	CLRF CompTempVar2863, 1
17A4  0E18      	MOVLW 0x18
17A6  278C      	ADDWF gbl_FCV_Y, F, 1
17A8  518D      	MOVF gbl_FCV_Y+D'1', W, 1
17AA  23B8      	ADDWFC CompTempVar2863, F, 1
17AC  51B8      	MOVF CompTempVar2863, W, 1
17AE  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	#if 0 // Disabled code
	// Multi-Décision
	// Multi-Décision: tableau[hitbox]?
	switch (FCV_TABLEAU[FCV_HITBOX])
	{
		case 1:
		{
			break;
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			break;
		}
		case 5:
		{
			break;
		}
		case 6:
		{
			break;
		}
		// default:

	}

	#endif // #if 0: Disabled code
	// Porte-avion
	// Décision: tableau[hitbox] = 0b00000001?
	if (FCV_TABLEAU[FCV_HITBOX] == 1)
17B2  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
17B6  50E9      	MOVF FSR0L, W
17B8  51A6      	MOVF gbl_FCV_HITBOX, W, 1
17BA  26E9      	ADDWF FSR0L, F
17BC  04EF      	DECF INDF0, W
17BE  E139      	BNZ	label119
1832            label119

	{

		// Appel d'une Macro
		// Appel d'une Macro: Touche_coule_PA()
		FCM_Touche_coule_PA();
17C0  EC0CF008  	CALL FCM_Touche_00066


		// Décision
		// Décision: Porte_avion = 0?
		if (FCV_PORTE_AVION == 0)
17C4  53AB      	MOVF gbl_FCV_PORTE_AVION, F, 1
17C6  A4D8      	BTFSS STATUS,Z
17C8  D128      	BRA	label124

		{

			// Appel d'une Macro
			// Appel d'une Macro: Reinitialisation_texte()
			FCM_Reinitialisation_texte();
17CA  ECF2F001  	CALL FCM_Reinit_00070


			// Pause
			// Pause: 100 ms
			FCI_DELAYBYTE_MS(100);
17CE  0E64      	MOVLW 0x64
17D0  6FBE      	MOVWF delay_ms_00000_arg_del, 1
17D2  EC06F000  	CALL delay_ms_00000


			// Appel de la Routine Composant
			// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
			FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
17D6  0E20      	MOVLW 0x20
17D8  6FC0      	MOVWF CompTempVar2864, 1
17DA  6FC1      	MOVWF CompTempVar2864+D'1', 1
17DC  6FC2      	MOVWF CompTempVar2864+D'2', 1
17DE  6FC3      	MOVWF CompTempVar2864+D'3', 1
17E0  6FC4      	MOVWF CompTempVar2864+D'4', 1
17E2  6FC5      	MOVWF CompTempVar2864+D'5', 1
17E4  6FC6      	MOVWF CompTempVar2864+D'6', 1
17E6  6FC7      	MOVWF CompTempVar2864+D'7', 1
17E8  6FC8      	MOVWF CompTempVar2864+D'8', 1
17EA  6FC9      	MOVWF CompTempVar2864+D'9', 1
17EC  6FCA      	MOVWF CompTempVar2864+D'10', 1
17EE  6FCB      	MOVWF CompTempVar2864+D'11', 1
17F0  6FD1      	MOVWF CompTempVar2864+D'17', 1
17F2  6FD2      	MOVWF CompTempVar2864+D'18', 1
17F4  6FD3      	MOVWF CompTempVar2864+D'19', 1
17F6  0E43      	MOVLW 0x43
17F8  6FCC      	MOVWF CompTempVar2864+D'12', 1
17FA  0E65      	MOVLW 0x65
17FC  6FD0      	MOVWF CompTempVar2864+D'16', 1
17FE  0E6C      	MOVLW 0x6C
1800  6FCF      	MOVWF CompTempVar2864+D'15', 1
1802  0E6F      	MOVLW 0x6F
1804  6FCD      	MOVWF CompTempVar2864+D'13', 1
1806  0E75      	MOVLW 0x75
1808  6FCE      	MOVWF CompTempVar2864+D'14', 1
180A  6BD4      	CLRF CompTempVar2864+D'20', 1
180C  0E00      	MOVLW HIGH(CompTempVar2864+D'0')
180E  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1810  0EC0      	MOVLW LOW(CompTempVar2864+D'0')
1812  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
1814  0E15      	MOVLW 0x15
1816  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1818  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
181A  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
181C  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
181E  0EF1      	MOVLW 0xF1
1820  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
1822  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
1824  0E02      	MOVLW 0x02
1826  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
1828  0E01      	MOVLW 0x01
182A  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
182C  EC3FF003  	CALL FCD_0f051__0005D


		// } else {

		}

	} else {
1830  D0F4      	BRA	label124


		// Croiseur
		// Décision: tableau[hitbox] = 0b00000010?
		if (FCV_TABLEAU[FCV_HITBOX] == 2)
1832  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
1836  50E9      	MOVF FSR0L, W
1838  51A6      	MOVF gbl_FCV_HITBOX, W, 1
183A  26E9      	ADDWF FSR0L, F
183C  0E02      	MOVLW 0x02
183E  62EF      	CPFSEQ INDF0
1840  D039      	BRA	label120
18B4            label120

		{

			// Appel d'une Macro
			// Appel d'une Macro: Touche_coule_CR()
			FCM_Touche_coule_CR();
1842  EC02F007  	CALL FCM_Touche_00080


			// Décision
			// Décision: Croiseur = 0?
			if (FCV_CROISEUR == 0)
1846  53A3      	MOVF gbl_FCV_CROISEUR, F, 1
1848  A4D8      	BTFSS STATUS,Z
184A  D0E7      	BRA	label124

			{

				// Appel d'une Macro
				// Appel d'une Macro: Reinitialisation_texte()
				FCM_Reinitialisation_texte();
184C  ECF2F001  	CALL FCM_Reinit_00070


				// Pause
				// Pause: 100 ms
				FCI_DELAYBYTE_MS(100);
1850  0E64      	MOVLW 0x64
1852  6FBE      	MOVWF delay_ms_00000_arg_del, 1
1854  EC06F000  	CALL delay_ms_00000


				// Appel de la Routine Composant
				// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
				FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
1858  0E20      	MOVLW 0x20
185A  6FC0      	MOVWF CompTempVar2867, 1
185C  6FC1      	MOVWF CompTempVar2867+D'1', 1
185E  6FC2      	MOVWF CompTempVar2867+D'2', 1
1860  6FC3      	MOVWF CompTempVar2867+D'3', 1
1862  6FC4      	MOVWF CompTempVar2867+D'4', 1
1864  6FC5      	MOVWF CompTempVar2867+D'5', 1
1866  6FC6      	MOVWF CompTempVar2867+D'6', 1
1868  6FC7      	MOVWF CompTempVar2867+D'7', 1
186A  6FC8      	MOVWF CompTempVar2867+D'8', 1
186C  6FC9      	MOVWF CompTempVar2867+D'9', 1
186E  6FCA      	MOVWF CompTempVar2867+D'10', 1
1870  6FCB      	MOVWF CompTempVar2867+D'11', 1
1872  6FD1      	MOVWF CompTempVar2867+D'17', 1
1874  6FD2      	MOVWF CompTempVar2867+D'18', 1
1876  6FD3      	MOVWF CompTempVar2867+D'19', 1
1878  0E43      	MOVLW 0x43
187A  6FCC      	MOVWF CompTempVar2867+D'12', 1
187C  0E65      	MOVLW 0x65
187E  6FD0      	MOVWF CompTempVar2867+D'16', 1
1880  0E6C      	MOVLW 0x6C
1882  6FCF      	MOVWF CompTempVar2867+D'15', 1
1884  0E6F      	MOVLW 0x6F
1886  6FCD      	MOVWF CompTempVar2867+D'13', 1
1888  0E75      	MOVLW 0x75
188A  6FCE      	MOVWF CompTempVar2867+D'14', 1
188C  6BD4      	CLRF CompTempVar2867+D'20', 1
188E  0E00      	MOVLW HIGH(CompTempVar2867+D'0')
1890  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1892  0EC0      	MOVLW LOW(CompTempVar2867+D'0')
1894  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
1896  0E15      	MOVLW 0x15
1898  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
189A  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
189C  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
189E  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
18A0  0EF1      	MOVLW 0xF1
18A2  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
18A4  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
18A6  0E02      	MOVLW 0x02
18A8  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
18AA  0E01      	MOVLW 0x01
18AC  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
18AE  EC3FF003  	CALL FCD_0f051__0005D


			// } else {

			}

		} else {
18B2  D0B3      	BRA	label124


			// Décision
			// Décision: tableau[hitbox] = 0b00000011?
			if (FCV_TABLEAU[FCV_HITBOX] == 3)
18B4  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
18B8  50E9      	MOVF FSR0L, W
18BA  51A6      	MOVF gbl_FCV_HITBOX, W, 1
18BC  26E9      	ADDWF FSR0L, F
18BE  0E03      	MOVLW 0x03
18C0  62EF      	CPFSEQ INDF0
18C2  D039      	BRA	label121
1936            label121

			{

				// Appel d'une Macro
				// Appel d'une Macro: Touche_Coule_CT()
				FCM_Touche_Coule_CT();
18C4  EC5FF007  	CALL FCM_Touche_0007E


				// Décision
				// Décision: Contre_torpilleur = 0?
				if (FCV_CONTRE_TORPILLEUR == 0)
18C8  53AD      	MOVF gbl_FCV_CONTRE_TORPILLEUR, F, 1
18CA  A4D8      	BTFSS STATUS,Z
18CC  D0A6      	BRA	label124

				{

					// Appel d'une Macro
					// Appel d'une Macro: Reinitialisation_texte()
					FCM_Reinitialisation_texte();
18CE  ECF2F001  	CALL FCM_Reinit_00070


					// Pause
					// Pause: 100 ms
					FCI_DELAYBYTE_MS(100);
18D2  0E64      	MOVLW 0x64
18D4  6FBE      	MOVWF delay_ms_00000_arg_del, 1
18D6  EC06F000  	CALL delay_ms_00000


					// Appel de la Routine Composant
					// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
					FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
18DA  0E20      	MOVLW 0x20
18DC  6FC0      	MOVWF CompTempVar2870, 1
18DE  6FC1      	MOVWF CompTempVar2870+D'1', 1
18E0  6FC2      	MOVWF CompTempVar2870+D'2', 1
18E2  6FC3      	MOVWF CompTempVar2870+D'3', 1
18E4  6FC4      	MOVWF CompTempVar2870+D'4', 1
18E6  6FC5      	MOVWF CompTempVar2870+D'5', 1
18E8  6FC6      	MOVWF CompTempVar2870+D'6', 1
18EA  6FC7      	MOVWF CompTempVar2870+D'7', 1
18EC  6FC8      	MOVWF CompTempVar2870+D'8', 1
18EE  6FC9      	MOVWF CompTempVar2870+D'9', 1
18F0  6FCA      	MOVWF CompTempVar2870+D'10', 1
18F2  6FCB      	MOVWF CompTempVar2870+D'11', 1
18F4  6FD1      	MOVWF CompTempVar2870+D'17', 1
18F6  6FD2      	MOVWF CompTempVar2870+D'18', 1
18F8  6FD3      	MOVWF CompTempVar2870+D'19', 1
18FA  0E43      	MOVLW 0x43
18FC  6FCC      	MOVWF CompTempVar2870+D'12', 1
18FE  0E65      	MOVLW 0x65
1900  6FD0      	MOVWF CompTempVar2870+D'16', 1
1902  0E6C      	MOVLW 0x6C
1904  6FCF      	MOVWF CompTempVar2870+D'15', 1
1906  0E6F      	MOVLW 0x6F
1908  6FCD      	MOVWF CompTempVar2870+D'13', 1
190A  0E75      	MOVLW 0x75
190C  6FCE      	MOVWF CompTempVar2870+D'14', 1
190E  6BD4      	CLRF CompTempVar2870+D'20', 1
1910  0E00      	MOVLW HIGH(CompTempVar2870+D'0')
1912  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1914  0EC0      	MOVLW LOW(CompTempVar2870+D'0')
1916  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
1918  0E15      	MOVLW 0x15
191A  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
191C  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
191E  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1920  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1922  0EF1      	MOVLW 0xF1
1924  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
1926  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
1928  0E02      	MOVLW 0x02
192A  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
192C  0E01      	MOVLW 0x01
192E  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1930  EC3FF003  	CALL FCD_0f051__0005D


				// } else {

				}

			} else {
1934  D072      	BRA	label124


				// Décision
				// Décision: tableau[hitbox] = 0b00000100?
				if (FCV_TABLEAU[FCV_HITBOX] == 4)
1936  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
193A  50E9      	MOVF FSR0L, W
193C  51A6      	MOVF gbl_FCV_HITBOX, W, 1
193E  26E9      	ADDWF FSR0L, F
1940  0E04      	MOVLW 0x04
1942  62EF      	CPFSEQ INDF0
1944  D038      	BRA	label122
19B6            label122

				{

					// Appel d'une Macro
					// Appel d'une Macro: Touche_Coule_SM()
					FCM_Touche_Coule_SM();
1946  ECAFF007  	CALL FCM_Touche_0006A


					// Décision
					// Décision: Sous_marin = 0?
					if (FCV_SOUS_MARIN == 0)
194A  53A7      	MOVF gbl_FCV_SOUS_MARIN, F, 1
194C  E166      	BNZ	label124

					{

						// Appel d'une Macro
						// Appel d'une Macro: Reinitialisation_texte()
						FCM_Reinitialisation_texte();
194E  ECF2F001  	CALL FCM_Reinit_00070


						// Pause
						// Pause: 100 ms
						FCI_DELAYBYTE_MS(100);
1952  0E64      	MOVLW 0x64
1954  6FBE      	MOVWF delay_ms_00000_arg_del, 1
1956  EC06F000  	CALL delay_ms_00000


						// Appel de la Routine Composant
						// Appel de la Routine Composant: gLCD_EB076_4D1::Print("            Coule   ", 0, 241, 2, 1)
						FCD_0f051_gLCD_EB076_4D1__Print("            Coule   ", 21, 0, 241, 2, 1);
195A  0E20      	MOVLW 0x20
195C  6FC0      	MOVWF CompTempVar2873, 1
195E  6FC1      	MOVWF CompTempVar2873+D'1', 1
1960  6FC2      	MOVWF CompTempVar2873+D'2', 1
1962  6FC3      	MOVWF CompTempVar2873+D'3', 1
1964  6FC4      	MOVWF CompTempVar2873+D'4', 1
1966  6FC5      	MOVWF CompTempVar2873+D'5', 1
1968  6FC6      	MOVWF CompTempVar2873+D'6', 1
196A  6FC7      	MOVWF CompTempVar2873+D'7', 1
196C  6FC8      	MOVWF CompTempVar2873+D'8', 1
196E  6FC9      	MOVWF CompTempVar2873+D'9', 1
1970  6FCA      	MOVWF CompTempVar2873+D'10', 1
1972  6FCB      	MOVWF CompTempVar2873+D'11', 1
1974  6FD1      	MOVWF CompTempVar2873+D'17', 1
1976  6FD2      	MOVWF CompTempVar2873+D'18', 1
1978  6FD3      	MOVWF CompTempVar2873+D'19', 1
197A  0E43      	MOVLW 0x43
197C  6FCC      	MOVWF CompTempVar2873+D'12', 1
197E  0E65      	MOVLW 0x65
1980  6FD0      	MOVWF CompTempVar2873+D'16', 1
1982  0E6C      	MOVLW 0x6C
1984  6FCF      	MOVWF CompTempVar2873+D'15', 1
1986  0E6F      	MOVLW 0x6F
1988  6FCD      	MOVWF CompTempVar2873+D'13', 1
198A  0E75      	MOVLW 0x75
198C  6FCE      	MOVWF CompTempVar2873+D'14', 1
198E  6BD4      	CLRF CompTempVar2873+D'20', 1
1990  0E00      	MOVLW HIGH(CompTempVar2873+D'0')
1992  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1994  0EC0      	MOVLW LOW(CompTempVar2873+D'0')
1996  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
1998  0E15      	MOVLW 0x15
199A  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
199C  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
199E  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
19A0  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
19A2  0EF1      	MOVLW 0xF1
19A4  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
19A6  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
19A8  0E02      	MOVLW 0x02
19AA  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
19AC  0E01      	MOVLW 0x01
19AE  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
19B0  EC3FF003  	CALL FCD_0f051__0005D


					// } else {

					}

				} else {
19B4  D032      	BRA	label124


					// Décision
					// Décision: tableau[hitbox] = 0b00000101?
					if (FCV_TABLEAU[FCV_HITBOX] == 5)
19B6  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
19BA  50E9      	MOVF FSR0L, W
19BC  51A6      	MOVF gbl_FCV_HITBOX, W, 1
19BE  26E9      	ADDWF FSR0L, F
19C0  0E05      	MOVLW 0x05
19C2  62EF      	CPFSEQ INDF0
19C4  D028      	BRA	label123
1A16            label123

					{

						// Appel d'une Macro
						// Appel d'une Macro: Touche_Coule_TORP()
						FCM_Touche_Coule_TORP();
19C6  EC69F008  	CALL FCM_Touche_0005B


						// Décision
						// Décision: Torpilleur = 0?
						if (FCV_TORPILLEUR == 0)
19CA  53A4      	MOVF gbl_FCV_TORPILLEUR, F, 1
19CC  E126      	BNZ	label124

						{

							// Appel d'une Macro
							// Appel d'une Macro: Reinitialisation_texte()
							FCM_Reinitialisation_texte();
19CE  ECF2F001  	CALL FCM_Reinit_00070


							// Pause
							// Pause: 100 ms
							FCI_DELAYBYTE_MS(100);
19D2  0E64      	MOVLW 0x64
19D4  6FBE      	MOVWF delay_ms_00000_arg_del, 1
19D6  EC06F000  	CALL delay_ms_00000


							// Appel de la Routine Composant
							// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Coule", 0, 241, 2, 1)
							FCD_0f051_gLCD_EB076_4D1__Print("Coule", 6, 0, 241, 2, 1);
19DA  0E43      	MOVLW 0x43
19DC  6FC0      	MOVWF CompTempVar2876, 1
19DE  0E6F      	MOVLW 0x6F
19E0  6FC1      	MOVWF CompTempVar2876+D'1', 1
19E2  0E75      	MOVLW 0x75
19E4  6FC2      	MOVWF CompTempVar2876+D'2', 1
19E6  0E6C      	MOVLW 0x6C
19E8  6FC3      	MOVWF CompTempVar2876+D'3', 1
19EA  0E65      	MOVLW 0x65
19EC  6FC4      	MOVWF CompTempVar2876+D'4', 1
19EE  6BC5      	CLRF CompTempVar2876+D'5', 1
19F0  0E00      	MOVLW HIGH(CompTempVar2876+D'0')
19F2  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
19F4  0EC0      	MOVLW LOW(CompTempVar2876+D'0')
19F6  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
19F8  0E06      	MOVLW 0x06
19FA  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
19FC  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
19FE  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1A00  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1A02  0EF1      	MOVLW 0xF1
1A04  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
1A06  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
1A08  0E02      	MOVLW 0x02
1A0A  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
1A0C  0E01      	MOVLW 0x01
1A0E  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1A10  EC3FF003  	CALL FCD_0f051__0005D


						// } else {

						}

					} else {
1A14  D002      	BRA	label124
1A1A            label124


						// Manque
						// Appel d'une Macro: Manque()
						FCM_Manque();
1A16  ECC8F009  	CALL FCM_Manque_00000


					}

				}

			}

		}

	}

	// Calcul
	// Calcul:
	//  X_SORTIE = 0
	//  X = 0
	//  Y = 0
	FCV_X_SORTIE = 0;
1A1A  0100      	MOVLB 0x00
1A1C  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1A1E  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_X = 0;
1A20  6B8E      	CLRF gbl_FCV_X, 1
1A22  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
1A24  6B8C      	CLRF gbl_FCV_Y, 1
1A26  6B8D      	CLRF gbl_FCV_Y+D'1', 1


	// 
	// Décision: (Torpilleur & Croiseur & Porte_avion & Contre_torpilleur & Sous_marin) = 0?
	if ((FCV_TORPILLEUR & FCV_CROISEUR & FCV_PORTE_AVION & FCV_CONTRE_TORPILLEUR & FCV_SOUS_MARIN) == 0)
1A28  51A3      	MOVF gbl_FCV_CROISEUR, W, 1
1A2A  15A4      	ANDWF gbl_FCV_TORPILLEUR, W, 1
1A2C  6FB7      	MOVWF CompTempVar2856, 1
1A2E  51AB      	MOVF gbl_FCV_PORTE_AVION, W, 1
1A30  17B7      	ANDWF CompTempVar2856, F, 1
1A32  51AD      	MOVF gbl_FCV_CONTRE_TORPILLEUR, W, 1
1A34  17B7      	ANDWF CompTempVar2856, F, 1
1A36  51A7      	MOVF gbl_FCV_SOUS_MARIN, W, 1
1A38  17B7      	ANDWF CompTempVar2856, F, 1
1A3A  53B7      	MOVF CompTempVar2856, F, 1
1A3C  B4D8      	BTFSC STATUS,Z

	{

		// Appel d'une Macro
		// Appel d'une Macro: Fin_Jeu()
		FCM_Fin_Jeu();
1A3E  EC15F00A  	CALL FCM_Fin_Je_0007D


	// } else {

	}

	// Pause
	// Pause: 100 ms
	FCI_DELAYBYTE_MS(100);
1A42  0E64      	MOVLW 0x64
1A44  6FBE      	MOVWF delay_ms_00000_arg_del, 1
1A46  EC06F000  	CALL delay_ms_00000


}
1A4A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_lignes()

{

	// Calcul
	// Calcul:
	//  X_ligne = 24
	//  Y_ligne = 24
	FCV_X_LIGNE = 24;
0D76  0E18      	MOVLW 0x18
0D78  0100      	MOVLB 0x00
0D7A  6F8A      	MOVWF gbl_FCV_X_LIGNE, 1
0D7C  6B8B      	CLRF gbl_FCV_X_LIGNE+D'1', 1

	FCV_Y_LIGNE = 24;
0D7E  0E18      	MOVLW 0x18
0D80  6F84      	MOVWF gbl_FCV_Y_LIGNE, 1
0D82  6B85      	CLRF gbl_FCV_Y_LIGNE+D'1', 1


	// tracé des verticales
	// Boucle: While X_ligne = 240
	while (1)
0D84            label57

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(X_ligne, 0, X_ligne, 240)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(FCV_X_LIGNE, 0, FCV_X_LIGNE, 240);
0D84  518A      	MOVF gbl_FCV_X_LIGNE, W, 1
0D86  6FB8      	MOVWF FCD_0f051__00082_arg_FCL_X1, 1
0D88  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
0D8A  6FB9      	MOVWF FCD_0f051__00082_arg_FCL_X1+D'1', 1
0D8C  6BBA      	CLRF FCD_0f051__00082_arg_FCL_Y1, 1
0D8E  6BBB      	CLRF FCD_0f051__00082_arg_FCL_Y1+D'1', 1
0D90  518A      	MOVF gbl_FCV_X_LIGNE, W, 1
0D92  6FBC      	MOVWF FCD_0f051__00082_arg_FCL_X2, 1
0D94  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
0D96  6FBD      	MOVWF FCD_0f051__00082_arg_FCL_X2+D'1', 1
0D98  0EF0      	MOVLW 0xF0
0D9A  6FBE      	MOVWF FCD_0f051__00082_arg_FCL_Y2, 1
0D9C  6BBF      	CLRF FCD_0f051__00082_arg_FCL_Y2+D'1', 1
0D9E  EC29F006  	CALL FCD_0f051__00082


		// Calcul
		// Calcul:
		//  X_ligne = X_ligne + 24
		FCV_X_LIGNE = FCV_X_LIGNE + 24;
0DA2  0100      	MOVLB 0x00
0DA4  6BB8      	CLRF CompTempVar2765, 1
0DA6  0E18      	MOVLW 0x18
0DA8  278A      	ADDWF gbl_FCV_X_LIGNE, F, 1
0DAA  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
0DAC  23B8      	ADDWFC CompTempVar2765, F, 1
0DAE  51B8      	MOVF CompTempVar2765, W, 1
0DB0  6F8B      	MOVWF gbl_FCV_X_LIGNE+D'1', 1



		if ((FCV_X_LIGNE == 240) != 0) break;
0DB2  6BB7      	CLRF CompTempVar2763, 1
0DB4  0EF0      	MOVLW 0xF0
0DB6  638A      	CPFSEQ gbl_FCV_X_LIGNE, 1
0DB8  D003      	BRA	label58
0DBA  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
0DBC  B4D8      	BTFSC STATUS,Z
0DBE  2BB7      	INCF CompTempVar2763, F, 1
0DC0            label58
0DC0  53B7      	MOVF CompTempVar2763, F, 1
0DC2  E0E0      	BZ	label57

	}

	// tracé des horizontales
	// Boucle: While Y_ligne <= 240
	while (1)
	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, Y_ligne, 240, Y_ligne)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(0, FCV_Y_LIGNE, 240, FCV_Y_LIGNE);
0DC4  6BB8      	CLRF FCD_0f051__00082_arg_FCL_X1, 1
0DC6  6BB9      	CLRF FCD_0f051__00082_arg_FCL_X1+D'1', 1
0DC8  5184      	MOVF gbl_FCV_Y_LIGNE, W, 1
0DCA  6FBA      	MOVWF FCD_0f051__00082_arg_FCL_Y1, 1
0DCC  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
0DCE  6FBB      	MOVWF FCD_0f051__00082_arg_FCL_Y1+D'1', 1
0DD0  0EF0      	MOVLW 0xF0
0DD2  6FBC      	MOVWF FCD_0f051__00082_arg_FCL_X2, 1
0DD4  6BBD      	CLRF FCD_0f051__00082_arg_FCL_X2+D'1', 1
0DD6  5184      	MOVF gbl_FCV_Y_LIGNE, W, 1
0DD8  6FBE      	MOVWF FCD_0f051__00082_arg_FCL_Y2, 1
0DDA  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
0DDC  6FBF      	MOVWF FCD_0f051__00082_arg_FCL_Y2+D'1', 1
0DDE  EC29F006  	CALL FCD_0f051__00082


		// Calcul
		// Calcul:
		//  Y_ligne = Y_ligne + 24
		FCV_Y_LIGNE = FCV_Y_LIGNE + 24;
0DE2  0100      	MOVLB 0x00
0DE4  6BB8      	CLRF CompTempVar2768, 1
0DE6  0E18      	MOVLW 0x18
0DE8  2784      	ADDWF gbl_FCV_Y_LIGNE, F, 1
0DEA  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
0DEC  23B8      	ADDWFC CompTempVar2768, F, 1
0DEE  51B8      	MOVF CompTempVar2768, W, 1
0DF0  6F85      	MOVWF gbl_FCV_Y_LIGNE+D'1', 1



		if ((FCV_Y_LIGNE <= 240) == 0) break;
0DF2  6BB7      	CLRF CompTempVar2766, 1
0DF4  0EF0      	MOVLW 0xF0
0DF6  6584      	CPFSGT gbl_FCV_Y_LIGNE, 1
0DF8  6785      	TSTFSZ gbl_FCV_Y_LIGNE+D'1', 1
0DFA  D001      	BRA	label60
0DFC  2BB7      	INCF CompTempVar2766, F, 1
0DFE            label60
0DFE  53B7      	MOVF CompTempVar2766, F, 1
0E00  E1E1      	BNZ	label59

	}

}
0E02  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Contre_torpilleur()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
14D8  0E01      	MOVLW 0x01
14DA  0100      	MOVLB 0x00
14DC  6FA6      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
14DE  0E18      	MOVLW 0x18
14E0  6F8C      	MOVWF gbl_FCV_Y, 1
14E2  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
14E4  0E18      	MOVLW 0x18
14E6  6F8E      	MOVWF gbl_FCV_X, 1
14E8  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
14EA            label97
14EA  0E01      	MOVLW 0x01
14EC  0100      	MOVLB 0x00
14EE  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
14F0  E236      	BC	label105
14F2  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
14F4  D034      	BRA	label105
155C  D7C6      	BRA	label97
155E            label105

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
14F6  518D      	MOVF gbl_FCV_Y+D'1', W, 1
14F8  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
14FA  E102      	BNZ	label98
14FC  518C      	MOVF gbl_FCV_Y, W, 1
14FE  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
1500            label98
1500  E223      	BC	label104
1502            label99
1548            label104

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
1502  518F      	MOVF gbl_FCV_X+D'1', W, 1
1504  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1506  E102      	BNZ	label100
1508  518E      	MOVF gbl_FCV_X, W, 1
150A  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
150C            label100
150C  E309      	BNC	label101

				{

				} else {
1520            label101


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
150E  29A6      	INCF gbl_FCV_HITBOX, W, 1
1510  6FA6      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
1512  6BBF      	CLRF CompTempVar2682, 1
1514  0E18      	MOVLW 0x18
1516  278E      	ADDWF gbl_FCV_X, F, 1
1518  518F      	MOVF gbl_FCV_X+D'1', W, 1
151A  23BF      	ADDWFC CompTempVar2682, F, 1
151C  51BF      	MOVF CompTempVar2682, W, 1
151E  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
1520  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
1522  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
1524  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
1526  B4D8      	BTFSC STATUS,Z
1528  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
152A  6BBE      	CLRF CompTempVar2680, 1
152C  518F      	MOVF gbl_FCV_X+D'1', W, 1
152E  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
1530  E104      	BNZ	label102
1532  518E      	MOVF gbl_FCV_X, W, 1
1534  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
1536  D001      	BRA	label102
1538  D001      	BRA	label103
153A            label102
153A  A0D8      	BTFSS STATUS,C
153C  71BE      	BTG CompTempVar2680,0, 1
153E  53BE      	MOVF CompTempVar2680, F, 1
1540  E0E0      	BZ	label99

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
1542  EC3EF004  	CALL FCM_affich_00069


		} else {
1546  D7D1      	BRA	label97


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
1548  0E0A      	MOVLW 0x0A
154A  25A6      	ADDWF gbl_FCV_HITBOX, W, 1
154C  6FA6      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
154E  6BBE      	CLRF CompTempVar2686, 1
1550  0E18      	MOVLW 0x18
1552  278C      	ADDWF gbl_FCV_Y, F, 1
1554  518D      	MOVF gbl_FCV_Y+D'1', W, 1
1556  23BE      	ADDWFC CompTempVar2686, F, 1
1558  51BE      	MOVF CompTempVar2686, W, 1
155A  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  Tableau[hitbox] = 0b00000011
	//  bateau = bateau + 1
	//  X_SORTIE = 0
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	//  Contre_torpilleur = Contre_torpilleur + 1
	FCV_TABLEAU[FCV_HITBOX] = 3;
155E  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
1562  50E9      	MOVF FSR0L, W
1564  51A6      	MOVF gbl_FCV_HITBOX, W, 1
1566  26E9      	ADDWF FSR0L, F
1568  0E03      	MOVLW 0x03
156A  6EEF      	MOVWF INDF0

	FCV_BATEAU = FCV_BATEAU + 1;
156C  29AA      	INCF gbl_FCV_BATEAU, W, 1
156E  6FAA      	MOVWF gbl_FCV_BATEAU, 1

	FCV_X_SORTIE = 0;
1570  6B86      	CLRF gbl_FCV_X_SORTIE, 1
1572  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

	FCV_APPUI_ECRAN = 0;
1574  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1

	FCV_X = 0;
1576  6B8E      	CLRF gbl_FCV_X, 1
1578  6B8F      	CLRF gbl_FCV_X+D'1', 1

	FCV_Y = 0;
157A  6B8C      	CLRF gbl_FCV_Y, 1
157C  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_CONTRE_TORPILLEUR = FCV_CONTRE_TORPILLEUR + 1;
157E  29AD      	INCF gbl_FCV_CONTRE_TORPILLEUR, W, 1
1580  6FAD      	MOVWF gbl_FCV_CONTRE_TORPILLEUR, 1


}
1582  0012      	RETURN




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
1B9C  0E0F      	MOVLW 0x0F
1B9E  6EC1      	MOVWF gbl_adcon1





	// Appel d'une Macro
	// Appel d'une Macro: Initialisation()
	FCM_Initialisation();
1BA0  EC26F00D  	CALL FCM_Initia_0006B


	// Boucle
	// Boucle: While bateau >= 17
	while (1)
1BA4            label144

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_texte()
		FCM_Reinitialisation_texte();
1BA4  ECF2F001  	CALL FCM_Reinit_00070


		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_tactile()
		FCM_Reinitialisation_tactile();
1BA8  EC5CF004  	CALL FCM_Reinit_00071


		// Appel d'une Macro
		// Appel d'une Macro: Message_bateau()
		FCM_Message_bateau();
1BAC  EC72F004  	CALL FCM_Messag_0006F


		// Boucle
		// Boucle: While Appui_Ecran = 0
		while (FCV_APPUI_ECRAN == 0)
1BB0            label145
1BB0  0100      	MOVLB 0x00
1BB2  53A8      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
1BB4  E103      	BNZ	label146
1BBA  D7FA      	BRA	label145
1BBC            label146

		{

			// Appel d'une Macro
			// Appel d'une Macro: Recuperation_coordonees()
			FCM_Recuperation_coordonees();
1BB6  EC6DF004  	CALL FCM_Recupe_00075



		}

		// Appel d'une Macro
		// Appel d'une Macro: Lecture_Coordonnes()
		FCM_Lecture_Coordonnes();
1BBC  EC18F006  	CALL FCM_Lectur_00067


		// Appel d'une Macro
		// Appel d'une Macro: Hitbox_v2()
		FCM_Hitbox_v2();
1BC0  EC59F00D  	CALL FCM_Hitbox_0005F


		// Pause
		// Pause: 100 ms
		FCI_DELAYBYTE_MS(100);
1BC4  0E64      	MOVLW 0x64
1BC6  6FBE      	MOVWF delay_ms_00000_arg_del, 1
1BC8  EC06F000  	CALL delay_ms_00000



		if ((FCV_BATEAU >= 17) != 0) break;
1BCC  6BB7      	CLRF CompTempVar3136, 1
1BCE  0E11      	MOVLW 0x11
1BD0  61AA      	CPFSLT gbl_FCV_BATEAU, 1
1BD2  2BB7      	INCF CompTempVar3136, F, 1
1BD4  53B7      	MOVF CompTempVar3136, F, 1
1BD6  E0E6      	BZ	label144

	}

	// Appel d'une Macro
	// Appel d'une Macro: Reinitialisation_texte()
	FCM_Reinitialisation_texte();
1BD8  ECF2F001  	CALL FCM_Reinit_00070


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Print("    En attente du joueur 2 ", 0, 241, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__Print("    En attente du joueur 2 ", 28, 0, 241, 2, 1);
1BDC  0E20      	MOVLW 0x20
1BDE  6FC0      	MOVWF CompTempVar3137, 1
1BE0  6FC1      	MOVWF CompTempVar3137+D'1', 1
1BE2  6FC2      	MOVWF CompTempVar3137+D'2', 1
1BE4  6FC3      	MOVWF CompTempVar3137+D'3', 1
1BE6  6FC6      	MOVWF CompTempVar3137+D'6', 1
1BE8  6FCE      	MOVWF CompTempVar3137+D'14', 1
1BEA  6FD1      	MOVWF CompTempVar3137+D'17', 1
1BEC  6FD8      	MOVWF CompTempVar3137+D'24', 1
1BEE  6FDA      	MOVWF CompTempVar3137+D'26', 1
1BF0  0E32      	MOVLW 0x32
1BF2  6FD9      	MOVWF CompTempVar3137+D'25', 1
1BF4  0E45      	MOVLW 0x45
1BF6  6FC4      	MOVWF CompTempVar3137+D'4', 1
1BF8  0E61      	MOVLW 0x61
1BFA  6FC7      	MOVWF CompTempVar3137+D'7', 1
1BFC  0E64      	MOVLW 0x64
1BFE  6FCF      	MOVWF CompTempVar3137+D'15', 1
1C00  0E65      	MOVLW 0x65
1C02  6FCA      	MOVWF CompTempVar3137+D'10', 1
1C04  6FCD      	MOVWF CompTempVar3137+D'13', 1
1C06  6FD5      	MOVWF CompTempVar3137+D'21', 1
1C08  0E6A      	MOVLW 0x6A
1C0A  6FD2      	MOVWF CompTempVar3137+D'18', 1
1C0C  0E6E      	MOVLW 0x6E
1C0E  6FC5      	MOVWF CompTempVar3137+D'5', 1
1C10  6FCB      	MOVWF CompTempVar3137+D'11', 1
1C12  0E6F      	MOVLW 0x6F
1C14  6FD3      	MOVWF CompTempVar3137+D'19', 1
1C16  0E72      	MOVLW 0x72
1C18  6FD7      	MOVWF CompTempVar3137+D'23', 1
1C1A  0E74      	MOVLW 0x74
1C1C  6FC8      	MOVWF CompTempVar3137+D'8', 1
1C1E  6FC9      	MOVWF CompTempVar3137+D'9', 1
1C20  6FCC      	MOVWF CompTempVar3137+D'12', 1
1C22  0E75      	MOVLW 0x75
1C24  6FD0      	MOVWF CompTempVar3137+D'16', 1
1C26  6FD4      	MOVWF CompTempVar3137+D'20', 1
1C28  6FD6      	MOVWF CompTempVar3137+D'22', 1
1C2A  6BDB      	CLRF CompTempVar3137+D'27', 1
1C2C  0E00      	MOVLW HIGH(CompTempVar3137+D'0')
1C2E  6FBF      	MOVWF FCD_0f051__0005D_arg_FCL_STR+D'1', 1
1C30  0EC0      	MOVLW LOW(CompTempVar3137+D'0')
1C32  6FBE      	MOVWF FCD_0f051__0005D_arg_FCL_STR, 1
1C34  0E1C      	MOVLW 0x1C
1C36  6FF5      	MOVWF FCD_0f051__0005D_arg_FCLsz_STR, 1
1C38  6BF6      	CLRF FCD_0f051__0005D_arg_FCLsz_STR+D'1', 1
1C3A  6BF7      	CLRF FCD_0f051__0005D_arg_FCL_X1, 1
1C3C  6BF8      	CLRF FCD_0f051__0005D_arg_FCL_X1+D'1', 1
1C3E  0EF1      	MOVLW 0xF1
1C40  6FF9      	MOVWF FCD_0f051__0005D_arg_FCL_Y1, 1
1C42  6BFA      	CLRF FCD_0f051__0005D_arg_FCL_Y1+D'1', 1
1C44  0E02      	MOVLW 0x02
1C46  6FFB      	MOVWF FCD_0f051__0005D_arg_FCL_FONT, 1
1C48  0E01      	MOVLW 0x01
1C4A  6FFC      	MOVWF FCD_0f051__0005D_arg_FCL_T_0005E, 1
1C4C  EC3FF003  	CALL FCD_0f051__0005D


	// mettre attente donnes joueur 2
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);
1C50  0E02      	MOVLW 0x02
1C52  0100      	MOVLB 0x00
1C54  6FBB      	MOVWF delay_s_00000_arg_del, 1
1C56  EC33F000  	CALL delay_s_00000


	// Boucle
	// Boucle: While 1
	while (1)
1C5A            label147
1C70  D7F4      	BRA	label147

	{

		// 
		// Appel d'une Macro: Choix_Bateau_Toucher()
		FCM_Choix_Bateau_Toucher();
1C5A  ECA3F00D  	CALL FCM_Choix__00074


		// Appel d'une Macro
		// Appel d'une Macro: phase_jeu()
		FCM_phase_jeu();
1C5E  EC99F00B  	CALL FCM_phase__00081


		// Calcul
		// Calcul:
		//  Appui_Ecran = 0
		FCV_APPUI_ECRAN = 0;
1C62  6BA8      	CLRF gbl_FCV_APPUI_ECRAN, 1


		// Pause
		// Pause: 500 ms
		FCI_DELAYINT_MS(500);
1C64  0EF4      	MOVLW 0xF4
1C66  6FB7      	MOVWF FCI_DELAYI_00046_arg_Delay, 1
1C68  0E01      	MOVLW 0x01
1C6A  6FB8      	MOVWF FCI_DELAYI_00046_arg_Delay+D'1', 1
1C6C  ECB3F00D  	CALL FCI_DELAYI_00046



	}

	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

}
1D24  CFEAF001  	MOVFF FSR0H,  Int1Context
1D28  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1D2C  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
1D30  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
1D34  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
1D38  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
1D3C  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
1D40  C001FFEA  	MOVFF Int1Context,  FSR0H
1D44  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
07AA  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
07AC  0E7F      	MOVLW 0x7F
07AE  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
07B0  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
07B2  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
07B4  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
07B6  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
07B8  9A9D      	BCF gbl_pie1,5

			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
07BA  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
03A2  6AAB      	CLRF gbl_rcsta

			txsta = 0;
03A4  6AAC      	CLRF gbl_txsta

		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}
03A6  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
008C            label5
008C  0E10      	MOVLW 0x10
008E  149E      	ANDWF gbl_pir1, W
0090  0100      	MOVLB 0x00
0092  6FFF      	MOVWF CompTempVar2895, 1
0094  53FF      	MOVF CompTempVar2895, F, 1
0096  E0FA      	BZ	label5


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0098  0101      	MOVLB 0x01
009A  5100      	MOVF FC_CAL_UAR_00087_arg_nChar, W, 1
009C  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
009E  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
00A0  0101      	MOVLB 0x01
00A2  6900      	SETF FC_CAL_UAR_00086_1_retVal, 1

  #endif

	MX_UINT8 delay1 = 0;
00A4  6B01      	CLRF FC_CAL_UAR_00086_1_delay1, 1

	MX_UINT8 regcheck = 0;
00A6  6B02      	CLRF FC_CAL_UAR_00086_1_regcheck, 1

	MX_UINT8 bWaitForever = 0;
00A8  6B03      	CLRF FC_CAL_UAR_00086_1_bWaitForever, 1

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
00AA  6B04      	CLRF FC_CAL_UAR_00086_1_rxStatus, 1

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
00AC  6B07      	CLRF FC_CAL_UAR_00086_1_dummy, 1

  #endif

	if (nTimeout == 255)
00AE  0100      	MOVLB 0x00
00B0  29FF      	INCF FC_CAL_UAR_00086_arg_nTimeout, W, 1
00B2  E103      	BNZ	label6
00BA            label6

		bWaitForever = 1;
00B4  0E01      	MOVLW 0x01
00B6  0101      	MOVLB 0x01
00B8  6F03      	MOVWF FC_CAL_UAR_00086_1_bWaitForever, 1


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00BA  0101      	MOVLB 0x01
00BC  5304      	MOVF FC_CAL_UAR_00086_1_rxStatus, F, 1
00BE  E129      	BNZ	label11
0110  D7D4      	BRA	label6
0112            label11

	{
		if (bWaitForever == 0)
00C0  5303      	MOVF FC_CAL_UAR_00086_1_bWaitForever, F, 1
00C2  E11D      	BNZ	label10

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00C4  0100      	MOVLB 0x00
00C6  53FF      	MOVF FC_CAL_UAR_00086_arg_nTimeout, F, 1
00C8  E104      	BNZ	label7
00D2            label7

			{
				rxStatus = UART_STATUS_TIMEOUT;
00CA  0E01      	MOVLW 0x01
00CC  0101      	MOVLB 0x01
00CE  6F04      	MOVWF FC_CAL_UAR_00086_1_rxStatus, 1

			}
			else
00D0  D016      	BRA	label10

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00D2  0101      	MOVLB 0x01
00D4  6B05      	CLRF FC_CAL_UAR_00086_1_delaycnt, 1
00D6  6B06      	CLRF FC_CAL_UAR_00086_1_delaycnt+D'1', 1
00D8            label8
00D8  0E31      	MOVLW 0x31
00DA  5D05      	SUBWF FC_CAL_UAR_00086_1_delaycnt, W, 1
00DC  E205      	BC	label9
00DE  6706      	TSTFSZ FC_CAL_UAR_00086_1_delaycnt+D'1', 1
00E0  D003      	BRA	label9
00E2  4B05      	INFSNZ FC_CAL_UAR_00086_1_delaycnt, F, 1
00E4  2B06      	INCF FC_CAL_UAR_00086_1_delaycnt+D'1', F, 1
00E6  D7F8      	BRA	label8
00E8            label9

				delay1 = delay1 + 1;
00E8  2901      	INCF FC_CAL_UAR_00086_1_delay1, W, 1
00EA  6F01      	MOVWF FC_CAL_UAR_00086_1_delay1, 1

				if(delay1 == 100)
00EC  0E64      	MOVLW 0x64
00EE  6301      	CPFSEQ FC_CAL_UAR_00086_1_delay1, 1
00F0  D006      	BRA	label10
00FE            label10

				{
					nTimeout = nTimeout - 1;
00F2  0100      	MOVLB 0x00
00F4  05FF      	DECF FC_CAL_UAR_00086_arg_nTimeout, W, 1
00F6  6FFF      	MOVWF FC_CAL_UAR_00086_arg_nTimeout, 1

					MX_CLEAR_WATCHDOG;
00F8  0004      	CLRWDT

					delay1 = 0;
00FA  0101      	MOVLB 0x01
00FC  6B01      	CLRF FC_CAL_UAR_00086_1_delay1, 1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00FE  0E20      	MOVLW 0x20
0100  149E      	ANDWF gbl_pir1, W
0102  6F08      	MOVWF CompTempVar2892, 1
0104  5108      	MOVF CompTempVar2892, W, 1
0106  6F02      	MOVWF FC_CAL_UAR_00086_1_regcheck, 1

			if (regcheck != 0)
0108  5302      	MOVF FC_CAL_UAR_00086_1_regcheck, F, 1
010A  E0D7      	BZ	label6

				rxStatus = UART_STATUS_RXBYTE;
010C  0E02      	MOVLW 0x02
010E  6F04      	MOVWF FC_CAL_UAR_00086_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
0112  0E02      	MOVLW 0x02
0114  6304      	CPFSEQ FC_CAL_UAR_00086_1_rxStatus, 1
0116  D018      	BRA	label14

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0118  0E04      	MOVLW 0x04
011A  14AB      	ANDWF gbl_rcsta, W
011C  6F08      	MOVWF CompTempVar2893, 1
011E  5108      	MOVF CompTempVar2893, W, 1
0120  6F02      	MOVWF FC_CAL_UAR_00086_1_regcheck, 1

			if (regcheck != 0)
0122  5302      	MOVF FC_CAL_UAR_00086_1_regcheck, F, 1
0124  E003      	BZ	label12
012C            label12

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0126  50AE      	MOVF gbl_rcreg, W
0128  6F07      	MOVWF FC_CAL_UAR_00086_1_dummy, 1

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
012A  D00E      	BRA	label14

			{
				regcheck = ts_bit(rcsta, OERR);
012C  0E02      	MOVLW 0x02
012E  14AB      	ANDWF gbl_rcsta, W
0130  6F08      	MOVWF CompTempVar2894, 1
0132  5108      	MOVF CompTempVar2894, W, 1
0134  6F02      	MOVWF FC_CAL_UAR_00086_1_regcheck, 1

				if (regcheck != 0)
0136  5302      	MOVF FC_CAL_UAR_00086_1_regcheck, F, 1
0138  E003      	BZ	label13
0140            label13

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
013A  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
013C  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
013E  D004      	BRA	label14
0148            label14

				{
					retVal = 0;
0140  6B00      	CLRF FC_CAL_UAR_00086_1_retVal, 1


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
0142  50AE      	MOVF gbl_rcreg, W
0144  1100      	IORWF FC_CAL_UAR_00086_1_retVal, W, 1
0146  6F00      	MOVWF FC_CAL_UAR_00086_1_retVal, 1

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0148  5100      	MOVF FC_CAL_UAR_00086_1_retVal, W, 1
014A  6F08      	MOVWF CompTempVarRet2891, 1
014C  6B09      	CLRF CompTempVarRet2891+D'1', 1

}
014E  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))

{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
07BC  0E07      	MOVLW 0x07
07BE  65BB      	CPFSGT FC_CAL_UAR_00084_arg_new_baud, 1
07C0  D001      	BRA	label37
07C4            label37

		return;

	if (new_baud == 0)
07C4  53BB      	MOVF FC_CAL_UAR_00084_arg_new_baud, F, 1
07C6  E104      	BNZ	label38
07D0            label38

	{
		baudrate = MX_HARD_BAUD_1200;
07C8  69BC      	SETF FC_CAL_UAR_00084_1_baudrate, 1

		baudmode = MX_HARD_SLOW_1200;
07CA  0E01      	MOVLW 0x01
07CC  6FBD      	MOVWF FC_CAL_UAR_00084_1_baudmode, 1

	}
	else if (new_baud == 1)
07CE  D02F      	BRA	label45
07D0  05BB      	DECF FC_CAL_UAR_00084_arg_new_baud, W, 1
07D2  E105      	BNZ	label39
07DE            label39

	{
		baudrate = MX_HARD_BAUD_2400;
07D4  0E7F      	MOVLW 0x7F
07D6  6FBC      	MOVWF FC_CAL_UAR_00084_1_baudrate, 1

		baudmode = MX_HARD_SLOW_2400;
07D8  0E01      	MOVLW 0x01
07DA  6FBD      	MOVWF FC_CAL_UAR_00084_1_baudmode, 1

	}
	else if (new_baud == 2)
07DC  D028      	BRA	label45
07DE  0E02      	MOVLW 0x02
07E0  63BB      	CPFSEQ FC_CAL_UAR_00084_arg_new_baud, 1
07E2  D003      	BRA	label40
07EA            label40

	{
		baudrate = MX_HARD_BAUD_4800;
07E4  69BC      	SETF FC_CAL_UAR_00084_1_baudrate, 1

		baudmode = MX_HARD_SLOW_4800;
07E6  6BBD      	CLRF FC_CAL_UAR_00084_1_baudmode, 1

	}
	else if (new_baud == 3)
07E8  D022      	BRA	label45
07EA  0E03      	MOVLW 0x03
07EC  63BB      	CPFSEQ FC_CAL_UAR_00084_arg_new_baud, 1
07EE  D004      	BRA	label41
07F8            label41

	{
		baudrate = MX_HARD_BAUD_9600;
07F0  0E7F      	MOVLW 0x7F
07F2  6FBC      	MOVWF FC_CAL_UAR_00084_1_baudrate, 1

		baudmode = MX_HARD_SLOW_9600;
07F4  6BBD      	CLRF FC_CAL_UAR_00084_1_baudmode, 1

	}
	else if (new_baud == 4)
07F6  D01B      	BRA	label45
07F8  0E04      	MOVLW 0x04
07FA  63BB      	CPFSEQ FC_CAL_UAR_00084_arg_new_baud, 1
07FC  D004      	BRA	label42
0806            label42

	{
		baudrate = MX_HARD_BAUD_19200;
07FE  0E3F      	MOVLW 0x3F
0800  6FBC      	MOVWF FC_CAL_UAR_00084_1_baudrate, 1

		baudmode = MX_HARD_SLOW_19200;
0802  6BBD      	CLRF FC_CAL_UAR_00084_1_baudmode, 1

	}
	else if (new_baud == 5)
0804  D014      	BRA	label45
0806  0E05      	MOVLW 0x05
0808  63BB      	CPFSEQ FC_CAL_UAR_00084_arg_new_baud, 1
080A  D004      	BRA	label43
0814            label43

	{
		baudrate = MX_HARD_BAUD_38400;
080C  0E1F      	MOVLW 0x1F
080E  6FBC      	MOVWF FC_CAL_UAR_00084_1_baudrate, 1

		baudmode = MX_HARD_SLOW_38400;
0810  6BBD      	CLRF FC_CAL_UAR_00084_1_baudmode, 1

	}
	else if (new_baud == 6)
0812  D00D      	BRA	label45
0814  0E06      	MOVLW 0x06
0816  63BB      	CPFSEQ FC_CAL_UAR_00084_arg_new_baud, 1
0818  D004      	BRA	label44
0822            label44

	{
		baudrate = MX_HARD_BAUD_57600;
081A  0E14      	MOVLW 0x14
081C  6FBC      	MOVWF FC_CAL_UAR_00084_1_baudrate, 1

		baudmode = MX_HARD_SLOW_57600;
081E  6BBD      	CLRF FC_CAL_UAR_00084_1_baudmode, 1

	}
	else if (new_baud == 7)
0820  D006      	BRA	label45
0822  0E07      	MOVLW 0x07
0824  63BB      	CPFSEQ FC_CAL_UAR_00084_arg_new_baud, 1
0826  D003      	BRA	label45
082E            label45

	{
		baudrate = MX_HARD_BAUD_115200;
0828  0E0A      	MOVLW 0x0A
082A  6FBC      	MOVWF FC_CAL_UAR_00084_1_baudrate, 1

		baudmode = MX_HARD_SLOW_115200;
082C  6BBD      	CLRF FC_CAL_UAR_00084_1_baudmode, 1

	}

	UART_Uninit();
082E  ECD1F001  	CALL FC_CAL_UAR_00085


	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
0832  05BD      	DECF FC_CAL_UAR_00084_1_baudmode, W, 1
0834  E102      	BNZ	label46
083A            label46

			cr_bit(txsta, BRGH);					//Low Speed
0836  94AC      	BCF gbl_txsta,2

	    else
0838  D001      	BRA	label47
083C            label47

			st_bit(txsta, BRGH);					//High Speed
083A  84AC      	BSF gbl_txsta,2


		spbrg = baudrate;   						// set the baud rate
083C  51BC      	MOVF FC_CAL_UAR_00084_1_baudrate, W, 1
083E  6EAF      	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
0840  6AAB      	CLRF gbl_rcsta


		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
0842  8EAB      	BSF gbl_rcsta,7

		st_bit(txsta, TXEN);
0844  8AAC      	BSF gbl_txsta,5

		st_bit(rcsta, CREN);
0846  88AB      	BSF gbl_rcsta,4


		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
0848  9A9D      	BCF gbl_pie1,5

		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
07C2  0012      	RETURN
084A  0012      	RETURN


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF39F00E  	GOTO	_startup

0008  EF92F00E  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  53BE      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF5      	MOVLW 0xF5
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0FFF      	ADDLW 0xFF
0038  A4D8      	BTFSS STATUS,Z
003A  D7ED      	BRA	label2
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  2FBE      	DECFSZ delay_ms_00000_arg_del, F, 1
0058  D7DD      	BRA	label1
005A  0012      	RETURN
005C            ; } delay_ms function end

005C            delay_us_00000
005C            ; { delay_us ; function begin
005C            label3
005C  0000      	NOP
005E  0000      	NOP
0060  2FBB      	DECFSZ delay_us_00000_arg_del, F, 1
0062  D7FC      	BRA	label3
0064  0012      	RETURN
0066            ; } delay_us function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6FBE      	MOVWF delay_ms_00000_arg_del, 1
006A  EC06F000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6FBE      	MOVWF delay_ms_00000_arg_del, 1
0072  EC06F000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6FBE      	MOVWF delay_ms_00000_arg_del, 1
007A  EC06F000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6FBE      	MOVWF delay_ms_00000_arg_del, 1
0082  EC06F000  	CALL delay_ms_00000
0086  2FBB      	DECFSZ delay_s_00000_arg_del, F, 1
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end




































































1C72            _startup
1C72  0ED5      	MOVLW 0xD5
1C74  6E6A      	MOVWF gbl_14_LSR
1C76  0EC4      	MOVLW 0xC4
1C78  6E6B      	MOVWF gbl_14_LSR+D'1'
1C7A  0EBB      	MOVLW 0xBB
1C7C  6E6C      	MOVWF gbl_14_LSR+D'2'
1C7E  0EDC      	MOVLW 0xDC
1C80  6E6D      	MOVWF gbl_14_LSR+D'3'
1C82  6A6E      	CLRF gbl_15_gbl_aSig
1C84  6A6F      	CLRF gbl_15_gbl_aSig+D'1'
1C86  6A70      	CLRF gbl_15_gbl_aSig+D'2'
1C88  6A71      	CLRF gbl_15_gbl_aSig+D'3'
1C8A  6A72      	CLRF gbl_15_gbl_bSig
1C8C  6A73      	CLRF gbl_15_gbl_bSig+D'1'
1C8E  6A74      	CLRF gbl_15_gbl_bSig+D'2'
1C90  6A75      	CLRF gbl_15_gbl_bSig+D'3'
1C92  6A76      	CLRF gbl_15_gbl_zSig
1C94  6A77      	CLRF gbl_15_gbl_zSig+D'1'
1C96  6A78      	CLRF gbl_15_gbl_zSig+D'2'
1C98  6A79      	CLRF gbl_15_gbl_zSig+D'3'
1C9A  0100      	MOVLB 0x00
1C9C  6B9D      	CLRF gbl_15_gbl_aExp, 1
1C9E  6B9E      	CLRF gbl_15_gbl_bExp, 1
1CA0  6A7E      	CLRF gbl_15_gbl_zExp
1CA2  6A7F      	CLRF gbl_15_gbl_zExp+D'1'
1CA4  6B9F      	CLRF gbl_15_gbl_aSign, 1
1CA6  6BA0      	CLRF gbl_15_gbl_bSign, 1
1CA8  6BA1      	CLRF gbl_15_gbl_zSign, 1
1CAA  6BA2      	CLRF gbl_15_gbl_zSigZero, 1
1CAC  6A7A      	CLRF gbl_15_gbl_ret
1CAE  6A7B      	CLRF gbl_15_gbl_ret+D'1'
1CB0  6A7C      	CLRF gbl_15_gbl_ret+D'2'
1CB2  6A7D      	CLRF gbl_15_gbl_ret+D'3'
1CB4  6B9B      	CLRF gbl_float_rounding_mode, 1
1CB6  6B9C      	CLRF gbl_float_exception_flags, 1
1CB8  6B9A      	CLRF gbl_float_detect_tininess, 1




















1D20  EFCEF00D  	GOTO	main

300000  32FF      	DW 0x32FF
300002  FEF9      	DW 0xFEF9
300004  79FF      	DW 0x79FF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
