;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL IO File
 *
 * File: PIC_CAL_IO.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | SK | Created
 * 050911 | BR | Added 10F and 12F compatible I/O functions
 *
 *
 */

#include "PIC_CAL_IO.h"

#ifdef FC_USEGPIO

	void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutValue, MX_UINT8 OutMask)
	{
		trisio = trisio & (~OutMask);
		gpio = (gpio & ~OutMask) | (OutValue & OutMask);
	}


	MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask)
	{
		return (gpio & InMask);
	}


	MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask)
	{
		trisio = trisio | InMask;
		return (gpio & InMask);
	}

#else

	#ifdef FC_USE10F

		MX_UINT8 tvar = 255;

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			tvar = tvar & (~OutMask);
			asm("movf(_tvar),w");
			asm("tris 6");

			gpio = (gpio & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (gpio & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			tvar = tvar | InMask;
			asm("movf(_tvar),w");
			asm("tris 6");

			return (gpio & InMask) >> Shift;
		}

	#else

		void FC_CAL_Port_Out__x (MX_UINT8* Port, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		void FC_CAL_Port_Out_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 OutMask, MX_UINT8 OutValue)
		{
			*Tris = *Tris & (~OutMask);
			*Port = (*Port & ~OutMask) | (OutValue & OutMask);
		}


		MX_UINT8 FC_CAL_Port_In__x (MX_UINT8* Port, MX_UINT8 InMask, MX_UINT8 Shift)
		{
			return (*Port & InMask) >> Shift;
		}


		MX_UINT8 FC_CAL_Port_In_DDR__x (MX_UINT8* Port, MX_UINT8* Tris, MX_UINT8 InMask, MX_UINT8 Shift)

		{
			*Tris = *Tris | InMask;
0384  51B8      	MOVF FC_CAL_Por_00042_arg_Tris+D'1', W, 1
0386  6EEA      	MOVWF FSR0H
0388  51B7      	MOVF FC_CAL_Por_00042_arg_Tris, W, 1
038A  6EE9      	MOVWF FSR0L
038C  51B9      	MOVF FC_CAL_Por_00042_arg_InMask, W, 1
038E  10EF      	IORWF INDF0, W
0390  6FBB      	MOVWF CompTempVar1825, 1
0392  51BB      	MOVF CompTempVar1825, W, 1
0394  6EEF      	MOVWF INDF0

			return (*Port & InMask) >> Shift;
0396  51B6      	MOVF FC_CAL_Por_00042_arg_Port+D'1', W, 1
0398  6EEA      	MOVWF FSR0H
039A  51B5      	MOVF FC_CAL_Por_00042_arg_Port, W, 1
039C  6EE9      	MOVWF FSR0L
039E  51B9      	MOVF FC_CAL_Por_00042_arg_InMask, W, 1
03A0  14EF      	ANDWF INDF0, W
03A2  6FBB      	MOVWF CompTempVarRet1822, 1
03A4  51BA      	MOVF FC_CAL_Por_00042_arg_Shift, W, 1
03A6  6FBC      	MOVWF CompTempVar1827, 1
03A8            label29
03A8  B4D8      	BTFSC STATUS,Z
03AC  90D8      	BCF STATUS,C
03AE  33BB      	RRCF CompTempVarRet1822, F, 1
03B0  07BC      	DECF CompTempVar1827, F, 1
03B2  D7FA      	BRA	label29

		}
03AA  0012      	RETURN


	#endif

#endif

#ifdef MX_10F_TRIS
  #ifndef porta
 	#define porta	gpio
  	#define trisa	tvar
  #endif
#endif

#ifdef FC_USEGPIO
  #ifndef porta
 	 #define porta gpio
	 #define trisa trisio
  #endif
#endif


/*
MX_UINT8 FC_CAL_Bit_I(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris |= (1<<bt);								// If DDR flag is set then adjust the DDR

    return ((*p_port & (1<<bt)) != 0);					// Return port pin input state
}


void FC_CAL_Bit_O(MX_UINT8 prt, MX_UINT8 bt, MX_UINT8 ddr, MX_UINT8 data)
{
	if (ddr)
    	char *p_tris = (char *)(&trisa) + (prt - 'a'); 	// NOTE: Assumes an array of ports and tris!

    char *p_port = (char *)(&porta) + (prt - 'a');		// NOTE: Assumes an array of ports and tris!

    if (ddr)
    	*p_tris &= ~(1<<bt);							// If DDR flag is set then adjust the DDR

    if (data)
    	*p_port |= (1<<bt);								// Set the output data pin
    else
    	*p_port &= ~(1<<bt);							// Clear the output data pin
}
*/


/*********************************************************************
 *                  Flowcode CAL Delays File
 *
 * File: PIC_CAL_Delay.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 *
 *
 *
 */

//Original Byte Delays
void Wdt_Delay_S(char delay);
void Wdt_Delay_Ms(char delay);

// Delay by bytes
#define FCI_DELAYBYTE_S(count)     delay_s((count))
#define FCI_DELAYBYTE_MS(count)    delay_ms((count))
#define FCI_DELAYBYTE_US(count)    delay_us((count))
// With watchdog timer
#define FCI_DELAYBYTEWDT_S(count)  Wdt_Delay_S((count))
#define FCI_DELAYBYTEWDT_MS(count) Wdt_Delay_Ms((count))
#define FCI_DELAYBYTEWDT_US(count) delay_us((count))

//New Int Delays
void FCI_DELAYINT_US(MX_UINT16 Delay);

void FCI_DELAYINT_MS(MX_UINT16 Delay);
void FCI_DELAYINTWDT_MS(MX_UINT16 Delay);

void FCI_DELAYINT_S(MX_UINT16 Delay);
void FCI_DELAYINTWDT_S(MX_UINT16 Delay);


#ifdef HI_TECH_C

	#define nop()	asm("NOP")

	void delay_10us(char del);
	void delay_us(char del);
	void delay_ms(char del);
	void delay_s(char del);

	void delay_10us(char del)
	{
		char count;
		for(count=0; count<10; count++)
		{
			delay_us(del);
		}
	}

	void delay_us(char del)
	{
		while (del > 1)
		{
			__delay_us(1);
			del = del - 1;
		}
	}

	void delay_ms(char del)
	{
		while (del > 1)
		{
			__delay_ms(1);
			del = del - 1;
		}
	}

	void delay_s(char del)
	{
		char i;
		for(i=0; i<del; i++)
		{
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
			delay_ms(250);
		}
	}

#endif

void Wdt_Delay_S(char delay)
{
    char i;
    short j;
    for (i=0; i<delay; i++)
    {
        for (j=0; j<999; j++)
        {
            Wdt_Delay_Ms(1);
        }
    }
}

void Wdt_Delay_Ms(char delay)
{
    char i;
    for (i=0; i<delay; i++)
    {
        MX_CLEAR_WATCHDOG;        //Clear Watchdog Timer
        delay_ms(1);
    }
}


void FCI_DELAYINT_US(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_us(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_us(Delay & 0xFF);
}

void FCI_DELAYINT_MS(MX_UINT16 Delay)

{
  	while (Delay > 255)
09DE            label60
09DE  0EFF      	MOVLW 0xFF
09E0  65B1      	CPFSGT FCI_DELAYI_00046_arg_Delay, 1
09E2  67B2      	TSTFSZ FCI_DELAYI_00046_arg_Delay+D'1', 1
09E4  D001      	BRA	label61
09E6  D00C      	BRA	label62
09E8            label61
09FE  D7EF      	BRA	label60
0A00            label62

  	{
	  	delay_ms(255);
09E8  69B6      	SETF delay_ms_00000_arg_del, 1
09EA  EC06F000  	CALL delay_ms_00000

	  	Delay = Delay - 255;
09EE  0EFF      	MOVLW 0xFF
09F0  5DB1      	SUBWF FCI_DELAYI_00046_arg_Delay, W, 1
09F2  6FB3      	MOVWF CompTempVar1838, 1
09F4  59B1      	SUBWFB FCI_DELAYI_00046_arg_Delay, W, 1
09F6  08FF      	SUBLW 0xFF
09F8  5FB2      	SUBWF FCI_DELAYI_00046_arg_Delay+D'1', F, 1
09FA  51B3      	MOVF CompTempVar1838, W, 1
09FC  6FB1      	MOVWF FCI_DELAYI_00046_arg_Delay, 1

  	}
  	if (Delay > 0)
0A00  0E00      	MOVLW 0x00
0A02  65B1      	CPFSGT FCI_DELAYI_00046_arg_Delay, 1
0A04  67B2      	TSTFSZ FCI_DELAYI_00046_arg_Delay+D'1', 1
0A06  D001      	BRA	label63
0A0A            label63

  		delay_ms(Delay & 0xFF);
0A0A  51B1      	MOVF FCI_DELAYI_00046_arg_Delay, W, 1
0A0C  6FB6      	MOVWF delay_ms_00000_arg_del, 1
0A0E  EC06F000  	CALL delay_ms_00000

}
0A08  0012      	RETURN
0A12  0012      	RETURN


void FCI_DELAYINTWDT_MS(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_Ms(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_Ms(Delay & 0xFF);
}

void FCI_DELAYINT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	delay_s(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		delay_s(Delay & 0xFF);
}

void FCI_DELAYINTWDT_S(MX_UINT16 Delay)
{
  	while (Delay > 255)
  	{
	  	Wdt_Delay_S(255);
	  	Delay = Delay - 255;
  	}
  	if (Delay > 0)
  		Wdt_Delay_S(Delay & 0xFF);
}



/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
057C  6BCB      	CLRF FCI_GETLEN_0004B_1_tmp, 1
057E            label34
057E  51CA      	MOVF FCI_GETLEN_0004B_arg_iStr1_len, W, 1
0580  61CB      	CPFSLT FCI_GETLEN_0004B_1_tmp, 1
0582  D009      	BRA	label35
0584  51C9      	MOVF FCI_GETLEN_0004B_arg_sStr1+D'1', W, 1
0586  6EEA      	MOVWF FSR0H
0588  51C8      	MOVF FCI_GETLEN_0004B_arg_sStr1, W, 1
058A  25CB      	ADDWF FCI_GETLEN_0004B_1_tmp, W, 1
058C  6EE9      	MOVWF FSR0L
058E  52EF      	MOVF INDF0, F
0590  E002      	BZ	label35
0592  2BCB      	INCF FCI_GETLEN_0004B_1_tmp, F, 1
0594  D7F4      	BRA	label34
0596            label35

	return (tmp);
0596  51CB      	MOVF FCI_GETLEN_0004B_1_tmp, W, 1
0598  6FCC      	MOVWF CompTempVarRet1850, 1

}
059A  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	if (iDst_len == 0) return sDst;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (sDst);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  Source name:   U:\Documents\SIN\BatailleNavale\affichage_bateau_v2_OK.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4520
//**  
//**  Generated by:  Flowcode v6.1.1.0
//**  Date:          Monday, January 30, 2017 16:13:46
//**  Users:         50
//**  Registered to: LYC-FERRY06-V6
//**  Licence key:   HY62PA
//**  
//**  
//**     POUR UN USAGE NON COMMERCIAL
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 19660800
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0xFE
#endif
#ifdef HI_TECH_C
__CONFIG(0xFE);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0xFB
#endif
#ifdef HI_TECH_C
__CONFIG(0xFB);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0xBA
#endif
#ifdef HI_TECH_C
__CONFIG(0xBA);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Inclure les définitions de type
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_TABLEAU 101
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT16 FCV_Y_LIGNE = (0x18);
0C3A  0E18      	MOVLW 0x18
0C3C  6F84      	MOVWF gbl_FCV_Y_LIGNE, 1
0C3E  6B85      	CLRF gbl_FCV_Y_LIGNE+D'1', 1

MX_GLOBAL MX_UINT8 FCV_NUM_CASE = (0x0);
0C40  6BA3      	CLRF gbl_FCV_NUM_CASE, 1

MX_GLOBAL MX_UINT16 FCV_X_SORTIE = (0x0);
0C42  6B86      	CLRF gbl_FCV_X_SORTIE, 1
0C44  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1

MX_GLOBAL MX_UINT16 FCV_Y_TOUCH = (0x0);
0C46  6B88      	CLRF gbl_FCV_Y_TOUCH, 1
0C48  6B89      	CLRF gbl_FCV_Y_TOUCH+D'1', 1

MX_GLOBAL MX_UINT8 FCV_HITBOX = (0x1);
0C4A  0E01      	MOVLW 0x01
0C4C  6FA4      	MOVWF gbl_FCV_HITBOX, 1

MX_GLOBAL MX_UINT16 FCV_X_LIGNE = (0x18);
0C4E  0E18      	MOVLW 0x18
0C50  6F8A      	MOVWF gbl_FCV_X_LIGNE, 1
0C52  6B8B      	CLRF gbl_FCV_X_LIGNE+D'1', 1

MX_GLOBAL MX_UINT16 FCV_Y = (0x18);
0C54  0E18      	MOVLW 0x18
0C56  6F8C      	MOVWF gbl_FCV_Y, 1
0C58  6B8D      	CLRF gbl_FCV_Y+D'1', 1

MX_GLOBAL MX_UINT16 FCV_X = (0x18);
0C5A  0E18      	MOVLW 0x18
0C5C  6F8E      	MOVWF gbl_FCV_X, 1
0C5E  6B8F      	CLRF gbl_FCV_X+D'1', 1

MX_GLOBAL MX_UINT16 FCV_X_TOUCH = (0x0);
0C60  6B90      	CLRF gbl_FCV_X_TOUCH, 1
0C62  6B91      	CLRF gbl_FCV_X_TOUCH+D'1', 1

MX_GLOBAL MX_UINT8 FCV_APPUI_ECRAN = (0x0);
0C64  6BA5      	CLRF gbl_FCV_APPUI_ECRAN, 1

MX_GLOBAL MX_UINT8 FCV_HITBOX_2 = (0x0);
0C66  6BA6      	CLRF gbl_FCV_HITBOX_2, 1

MX_GLOBAL MX_UINT8 FCV_JOUEUR1 = (0x0);
0C68  6BA7      	CLRF gbl_FCV_JOUEUR1, 1

MX_GLOBAL MX_CHAR FCV_TABLEAU[FCVsz_TABLEAU];

void FCM_X_144();
void FCM_Hitbox_v2();
void FCM_Lecture_Coordonnes();
void FCM_X_72();
void FCM_X_168();
void FCM_Initialisation();
void FCM_Reinitialisation_tactile();
void FCM_X_96();
void FCM_Hitbox();
void FCM_X_24();
void FCM_X_240();
void FCM_affichage_bateau();
void FCM_X_48();
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2);
void FCM_Appui_tactile();
void FCM_Recuperation_coordonees();
void FCM_X_192();
void FCM_X_120();
void FCM_X_216();
void FCM_lignes();

/*========================================================================*\
   Use :fcdhelper
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define MX_UART_TX_TRIS_1 trisc
#define MX_UART_REF1 
#define MX_UART_RTS_PIN_1 (3)
#define MX_UART_DBITS_1 (8)
#define MX_UART_RETURN_1 (0)
#define MX_UART_RX_PORT_1 portc
#define MX_UART_RTS_PORT_1 porta
#define MX_UART_ECHO_1 (0)
#define MX_UART_FLOWEN_1 (0)
#define MX_UART_CTS_PORT_1 porta
#define MX_UART_TX_PIN_1 (6)
#define MX_UART_RX_TRIS_1 trisc
#define MX_UART_RTS_TRIS_1 trisa
#define MX_UART_BAUD_1 (9600)
#define MX_UART_TX_PORT_1 portc
#define MX_UART_RX_PIN_1 (7)
#define MX_UART_CTS_TRIS_1 trisa
#define MX_UART_CHANNEL_1 (1)
#define MX_UART_CTS_PIN_1 (2)
#define MX_UART_INT_1 (0)

MX_GLOBAL MX_UINT32 FCV_05481_cal_uart__CONSOLE;

void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_UART_UpdateBaud_1(MX_UINT8 FCL_NEW_BAUD);
MX_SINT16 FC_CAL_UART_Receive_1(MX_UINT8 FCL_TIMEOUT);
void FC_CAL_UART_Send_1(MX_UINT16 FCL_CHAR);
void FC_CAL_UART_Init_1();
void FC_CAL_UART_Delay_1();
void FC_CAL_UART_Uninit_1();

/*========================================================================*\
   Use :ASCII6
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1
#define FCD_00fb8_ASCII6__INTLIST(ix) FCD_00fb8_ASCII6__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb8_ASCII6__INTLIST_LUT ROMARRAY_E =
{
0C6A  0E00      	MOVLW 0x00
0C6C  6FA8      	MOVWF gbl_FCD_00fb8_ASCII6__INTL_00000, 1

// Property added elements
  127, 4, 4, 120, 0, 0, 0, 125, 0, 0, 64, 128, 132, 125, 0, 127, 16,
 40, 68, 0, 0, 0, 127, 64, 0, 124, 4, 24, 4, 120, 124, 4, 4,
 120, 0, 56, 68, 68, 68, 56, 252, 68, 68, 68, 56, 56, 68, 68, 68,
 252, 68, 120, 68, 4, 8, 8, 84, 84, 84, 32
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII7
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1
#define FCD_00fb7_ASCII7__INTLIST(ix) FCD_00fb7_ASCII7__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb7_ASCII7__INTLIST_LUT ROMARRAY_E =
{
0C6E  0E01      	MOVLW 0x01
0C70  6FA9      	MOVWF gbl_FCD_00fb7_ASCII7__INTL_00001, 1

// Property added elements
  4, 62, 68, 36, 0, 60, 64, 32, 124, 0, 28, 32, 64, 32, 28, 60, 96,
 48, 96, 60, 108, 16, 16, 108, 0, 156, 160, 96, 60, 0, 100, 84, 84,
 76, 0, 8, 62, 65, 65, 0, 0, 0, 127, 0, 0, 0, 65, 65, 62,
 8, 2, 1, 2, 1, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII5
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1
#define FCD_00fb6_ASCII5__INTLIST(ix) FCD_00fb6_ASCII5__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb6_ASCII5__INTLIST_LUT ROMARRAY_E =
{
0C72  0E02      	MOVLW 0x02
0C74  6FAA      	MOVWF gbl_FCD_00fb6_ASCII5__INTL_00002, 1

// Property added elements
  2, 4, 8, 16, 32, 0, 65, 65, 127, 0, 4, 2, 1, 2, 4, 128, 128,
 128, 128, 128, 0, 3, 7, 0, 0, 32, 84, 84, 84, 120, 127, 68, 68,
 68, 56, 56, 68, 68, 68, 40, 56, 68, 68, 68, 127, 56, 84, 84, 84,
 24, 8, 126, 9, 9, 0, 24, 164, 164, 164, 124
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII4
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1
#define FCD_00fb5_ASCII4__INTLIST(ix) FCD_00fb5_ASCII4__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb5_ASCII4__INTLIST_LUT ROMARRAY_E =
{
0C76  0E03      	MOVLW 0x03
0C78  6FAB      	MOVWF gbl_FCD_00fb5_ASCII4__INTL_00003, 1

// Property added elements
  127, 9, 9, 9, 6, 62, 65, 81, 33, 94, 127, 9, 9, 25, 102, 38, 73,
 73, 73, 50, 1, 1, 127, 1, 1, 63, 64, 64, 64, 63, 31, 32, 64,
 32, 31, 63, 64, 60, 64, 63, 99, 20, 8, 20, 99, 7, 8, 112, 8,
 7, 113, 73, 69, 67, 0, 0, 127, 65, 65, 0
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII3
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1
#define FCD_00fb4_ASCII3__INTLIST(ix) FCD_00fb4_ASCII3__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb4_ASCII3__INTLIST_LUT ROMARRAY_E =
{
0C7A  0E04      	MOVLW 0x04
0C7C  6FAC      	MOVWF gbl_FCD_00fb4_ASCII3__INTL_00004, 1

// Property added elements
  127, 65, 65, 65, 62, 127, 73, 73, 73, 65, 127, 9, 9, 9, 1, 62, 65,
 73, 73, 122, 127, 8, 8, 8, 127, 0, 65, 127, 65, 0, 48, 64, 64,
 64, 63, 127, 8, 20, 34, 65, 127, 64, 64, 64, 64, 127, 2, 4, 2,
 127, 127, 2, 4, 8, 127, 62, 65, 65, 65, 62
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII2
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1
#define FCD_00fb3_ASCII2__INTLIST(ix) FCD_00fb3_ASCII2__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb3_ASCII2__INTLIST_LUT ROMARRAY_E =
{
0C7E  0E05      	MOVLW 0x05
0C80  6FAD      	MOVWF gbl_FCD_00fb3_ASCII2__INTL_00005, 1

// Property added elements
  54, 73, 73, 73, 54, 6, 73, 73, 41, 30, 0, 108, 108, 0, 0, 0, 236,
 108, 0, 0, 8, 20, 34, 65, 0, 36, 36, 36, 36, 36, 0, 65, 34,
 20, 8, 2, 1, 89, 9, 6, 62, 65, 93, 85, 30, 126, 9, 9, 9,
 126, 127, 73, 73, 73, 54, 62, 65, 65, 65, 34
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1
#define FCD_00fb2_ASCII1__INTLIST(ix) FCD_00fb2_ASCII1__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb2_ASCII1__INTLIST_LUT ROMARRAY_E =
{
0C82  0E06      	MOVLW 0x06
0C84  6FAE      	MOVWF gbl_FCD_00fb2_ASCII1__INTL_00006, 1

// Property added elements
  0, 224, 96, 0, 0, 8, 8, 8, 8, 8, 0, 96, 96, 0, 0, 32, 16,
 8, 4, 2, 62, 81, 73, 69, 62, 0, 66, 127, 64, 0, 98, 81, 73,
 73, 70, 34, 73, 73, 73, 54, 24, 20, 18, 127, 16, 47, 73, 73, 73,
 49, 60, 74, 73, 73, 48, 1, 113, 9, 5, 3
// Dynamically added elements
 
};


/*========================================================================*\
   Use :ASCII0
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1
#define FCD_00fb1_ASCII0__INTLIST(ix) FCD_00fb1_ASCII0__INTLIST_LUT[ix]
ROMARRAY_(MX_UINT8) FCD_00fb1_ASCII0__INTLIST_LUT ROMARRAY_E =
{
0C86  0E07      	MOVLW 0x07
0C88  6FAF      	MOVWF gbl_FCD_00fb1_ASCII0__INTL_00007, 1

// Property added elements
  0, 0, 0, 0, 0, 0, 6, 95, 6, 0, 7, 3, 0, 7, 3, 36, 126,
 36, 126, 36, 36, 43, 106, 18, 0, 99, 19, 8, 100, 99, 54, 73, 86,
 32, 80, 0, 7, 3, 0, 0, 0, 62, 65, 0, 0, 0, 65, 62, 0,
 0, 8, 62, 28, 62, 8, 8, 8, 62, 8, 8
// Dynamically added elements
 
};


/*========================================================================*\
   Use :Base_GLCD
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__POINTCLOUDHANDLE = (0x0);
0C8A  6B80      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009, 1
0C8C  6B81      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'1', 1
0C8E  6B82      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'2', 1
0C90  6B83      	CLRF gbl_FCV_0ba71_Base_GLCD__P_00009+D'3', 1

MX_GLOBAL MX_UINT32 FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT8 FCV_0ba71_Base_GLCD__ORIENTATION = (0x0);
0C92  6BB0      	CLRF gbl_FCV_0ba71_Base_GLCD__O_0000B, 1


void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0ba71_Base_GLCD__ClearDisplay();
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0ba71_Base_GLCD__Initialise();

/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Déclarations des variables
       :Déclarations de la fonction macro
\*========================================================================*/
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHY;
MX_GLOBAL MX_UINT16 FCV_0f051_gLCD_EB076_4D1__TOUCHX;

MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME);
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME);
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION);
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1);
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE);
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL);
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2);
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME);
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID);
void FCD_0f051_gLCD_EB076_4D1__Initialise();

/*========================================================================*\
   Use :Inclure la couche d'adaptation de puce
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :cal_uart
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro Prv_TextConsole :
       :  Str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_05481_cal_uart__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ASCII6
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Implémentations de la macro
\*========================================================================*/

/*========================================================================*\
   Use :Base_GLCD
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0ba71_Base_GLCD__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
	MX_SINT16 FCL_XINC = (1);


	FCL_PIXELX = FCL_X2 - FCL_X1;
	FCL_PIXELY = FCL_Y2 - FCL_Y1;

	if (FCL_PIXELX < 0)
	{

		FCL_XINC = -1;
		FCL_PIXELX = FCL_PIXELX * -1;

	// } else {

	}

	if (FCL_PIXELY < 0)
	{

		FCL_YINC = -1;
		FCL_PIXELY = FCL_PIXELY * -1;

	// } else {

	}

	if (FCL_PIXELY <= FCL_PIXELX)
	{

		FCL_C1 = 2 * FCL_PIXELX;
		FCL_M1 = 2 * FCL_PIXELY;

		while (FCL_X1 != FCL_X2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_X1 = FCL_X1 + FCL_XINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELX)
			{

				FCL_Y1 = FCL_Y1 + FCL_YINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	} else {

		FCL_C1 = 2 * FCL_PIXELY;
		FCL_M1 = 2 * FCL_PIXELX;

		while (FCL_Y1 != FCL_Y2)
		{

			FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

			FCL_Y1 = FCL_Y1 + FCL_YINC;

			FCL_D1 = FCL_D1 + FCL_M1;

			if (FCL_D1 > FCL_PIXELY)
			{

				FCL_X1 = FCL_X1 + FCL_XINC;

				FCL_D1 = FCL_D1 - FCL_C1;

			// } else {

			}


		}

	}

	FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{
	//Définitions des variables locales
	MX_UINT32 FCL_IDX;


	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FCV_0ba71_Base_GLCD__ORIENTATION = FCL_ORIENTATION;

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	#if (0) // 0 == 1

	//Le code a été optimisé par le préprocesseur
	#else



		switch (FCV_0ba71_Base_GLCD__ORIENTATION)
		{
			case 1:
			{

				break;
			}
			case 2:
			{

				break;
			}
			case 3:
			{

				break;
			}
			default:
			{

			}
		}


	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_XPIX;
	MX_UINT8 FCL_YPIX;
	MX_UINT8 FCL_POS_STR;
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_COUNT;
	MX_UINT8 FCL_XCOUNT;
	MX_UINT8 FCL_YCOUNT;
	MX_UINT8 FCL_HEIGHT;
	MX_UINT8 FCL_WIDTH;
	MX_UINT8 FCL_IDX;
	MX_UINT8 FCL_FONT_WIDTH = (0x1);
	MX_UINT8 FCL_FONT_HEIGHT = (0x1);
	#define FCLsz_TEMP 6
	MX_UINT8 FCL_TEMP[FCLsz_TEMP];


	switch (FCL_FONT)
	{
		case 1:
		{
			FCL_FONT_WIDTH = 2;

			break;
		}
		case 2:
		{
			FCL_FONT_WIDTH = 2;
			FCL_FONT_HEIGHT = 2;

			break;
		}
		case 3:
		{
			FCL_FONT_HEIGHT = 2;

			break;
		}
		default:
		{
		}
	}

	FCL_XCOUNT = 0;
	FCL_IDX = 0;

	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);

	while (FCL_IDX < FCL_LEN_STR)
	{

		FCL_POS_STR = FCL_STR[FCL_IDX] - 32;

		FCL_COUNT = 0;

		while (FCL_COUNT < 5)
		{

			FCL_TEMP[FCL_COUNT] = FCD_0ba71_Base_GLCD__ReadASCIILUT(FCL_POS_STR, FCL_COUNT);

			FCL_COUNT = FCL_COUNT + 1;


		}

		FCL_TEMP[FCL_COUNT] = 0;

		FCL_XPIX = 0;

		while (FCL_XPIX < 6)
		{

			FCL_WIDTH = 0;

			while (FCL_WIDTH < FCL_FONT_WIDTH)
			{

				FCL_YCOUNT = 0;

				FCL_YPIX = 0;

				while (FCL_YPIX < 8)
				{

					FCL_HEIGHT = 0;

					while (FCL_HEIGHT < FCL_FONT_HEIGHT)
					{

						if (FCL_TEMP[FCL_XPIX] & (0x01 << FCL_YPIX))
						{

							FCD_0ba71_Base_GLCD__Plot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

						} else {

							if (FCL_TRANSPARENT == 0)
							{

								FCD_0ba71_Base_GLCD__BPlot(FCL_X1 + FCL_XCOUNT, FCL_Y1 + FCL_YCOUNT);

							// } else {

							}

						}

						FCL_HEIGHT = FCL_HEIGHT + 1;
						FCL_YCOUNT = FCL_YCOUNT + 1;


					}

					FCL_YPIX = FCL_YPIX + 1;


				}

				FCL_WIDTH = FCL_WIDTH + 1;
				FCL_XCOUNT = FCL_XCOUNT + 1;


			}

			FCL_XPIX = FCL_XPIX + 1;


		}

		FCL_IDX = FCL_IDX + 1;


	}

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__ClearDisplay()
{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
	MX_UINT16 FCL_X = (0x0);


	if (FCV_0ba71_Base_GLCD__ORIENTATION & 0x01)
	{

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_Y, FCL_X);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	} else {

		while (FCL_Y < 320)
		{

			FCL_X = 0;

			while (FCL_X < 240)
			{

				FCD_0ba71_Base_GLCD__BPlot(FCL_X, FCL_Y);

				FCL_X = FCL_X + 1;


			}

			FCL_Y = FCL_Y + 1;


		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Param??tres pour la macro ReadASCIILUT :
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_Base_GLCD__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Définitions des variables locales
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (1) // 1 == 1

		FCL_POSITION = FCL_POS_STR / 12;

		switch (FCL_POSITION)
		{
			case 0:
			{
				FCL_POSITION = (FCL_POS_STR * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb1_ASCII0__INTLIST(FCL_POSITION);

				break;
			}
			case 1:
			{
				FCL_POSITION = ((FCL_POS_STR - 12) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb2_ASCII1__INTLIST(FCL_POSITION);

				break;
			}
			case 2:
			{
				FCL_POSITION = ((FCL_POS_STR - 24) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb3_ASCII2__INTLIST(FCL_POSITION);

				break;
			}
			case 3:
			{
				FCL_POSITION = ((FCL_POS_STR - 36) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb4_ASCII3__INTLIST(FCL_POSITION);

				break;
			}
			case 4:
			{
				FCL_POSITION = ((FCL_POS_STR - 48) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb5_ASCII4__INTLIST(FCL_POSITION);

				break;
			}
			case 5:
			{
				FCL_POSITION = ((FCL_POS_STR - 60) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb6_ASCII5__INTLIST(FCL_POSITION);

				break;
			}
			case 6:
			{
				FCL_POSITION = ((FCL_POS_STR - 72) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb8_ASCII6__INTLIST(FCL_POSITION);

				break;
			}
			case 7:
			{
				FCL_POSITION = ((FCL_POS_STR - 84) * 5) + FCL_COUNT;

				FCR_RETVAL = FCD_00fb7_ASCII7__INTLIST(FCL_POSITION);

				break;
			}
			default:
			{
				FCR_RETVAL = 0;

				FCR_RETVAL = 0xaa;

			}
		}

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_COLOUR = FCL_BLUE;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_GREEN;
	FCL_COLOUR = FCL_COLOUR * 256;
	FCL_COLOUR = FCL_COLOUR | FCL_RED;
	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = FCL_COLOUR;

}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)
{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X2, FCL_Y1);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X2, FCL_Y1, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y2, FCL_X2, FCL_Y2);

	FCD_0ba71_Base_GLCD__DrawLine(FCL_X1, FCL_Y1, FCL_X1, FCL_Y2);

	if (FCL_TRANSPARENT == 0)
	{

		if (FCL_X1 > FCL_X2)
		{

			FCL_XMAX = FCL_X1;
			FCL_XMIN = FCL_X2 + 1;

		} else {

			FCL_XMAX = FCL_X2;
			FCL_XMIN = FCL_X1 + 1;

		}

		if (FCL_Y1 > FCL_Y2)
		{

			FCL_YMAX = FCL_Y1;
			FCL_YMIN = FCL_Y2 + 1;

		} else {

			FCL_YMAX = FCL_Y2;
			FCL_YMIN = FCL_Y1 + 1;

		}

		FCL_Y1 = FCL_YMIN;

		while (FCL_Y1 < FCL_YMAX)
		{

			FCL_X1 = FCL_XMIN;

			while (FCL_X1 < FCL_XMAX)
			{

				if (FCL_SOLID)
				{

					FCD_0ba71_Base_GLCD__Plot(FCL_X1, FCL_Y1);

				} else {

					FCD_0ba71_Base_GLCD__BPlot(FCL_X1, FCL_Y1);

				}

				FCL_X1 = FCL_X1 + 1;


			}

			FCL_Y1 = FCL_Y1 + 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0ba71_Base_GLCD__Initialise()
{

	FCV_0ba71_Base_GLCD__FOREGROUND_COL_VAR = 0;
	FCV_0ba71_Base_GLCD__BACKGROUND_COL_VAR = 16777215;

	FCD_0ba71_Base_GLCD__ClearDisplay();

}


/*========================================================================*\
   Use :gLCD_EB076_4D1
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Initialises the micro SD card inserted into the module is available.
       :Returns 0 for succesful initialisation or 255 for a detected failure.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_InitialiseCard()
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x69);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DumpScreenToFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  Filename[20] : Assigns the name of the file on the card to store the data.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_CHAR *FCL_FILENAME, MX_UINT16 FCLsz_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x63);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DumpScreenToFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DumpScreenToFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Returns the coordinates of the last touch event.
       :Axis = 0 or 'x' or 'X' - Returns the X coordinate.
       :Axis = 1 or 'y' or 'Y' - Returns the Y coordinate.
       :
       :Param??tres pour la macro G4D_ReadTouchCoordinatesPicaso :
       :  Axis : MX_UINT8
       :
       :Renvoie : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(MX_UINT8 FCL_AXIS)

{
	//Définitions des variables locales
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = 0;
0850  6BB2      	CLRF FCD_0f051__0005E_1_FCR_RETVAL, 1
0852  6BB3      	CLRF FCD_0f051__0005E_1_FCR_RETVAL+D'1', 1


	if (FCL_AXIS == 0)
0854  53B1      	MOVF FCD_0f051__0005E_arg_FCL_AXIS, F, 1
0856  E007      	BZ	label44

	{

	} else {

		if (FCL_AXIS == 'x')
0858  0E78      	MOVLW 0x78
085A  63B1      	CPFSEQ FCD_0f051__0005E_arg_FCL_AXIS, 1
085C  D001      	BRA	label43
0860            label43

		{

		} else {
085E  D003      	BRA	label44


			if (FCL_AXIS == 'X')
0860  0E58      	MOVLW 0x58
0862  63B1      	CPFSEQ FCD_0f051__0005E_arg_FCL_AXIS, 1
0864  D004      	BRA	label45
0866            label44

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_A;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHX;
0866  5198      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W, 1
0868  6FB2      	MOVWF FCD_0f051__0005E_1_FCR_RETVAL, 1
086A  5199      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', W, 1
086C  6FB3      	MOVWF FCD_0f051__0005E_1_FCR_RETVAL+D'1', 1


FCC_G4D_ReadTouchCoordinatesPicaso_A:
086E            label45

;

	if (FCL_AXIS == 1)
086E  05B1      	DECF FCD_0f051__0005E_arg_FCL_AXIS, W, 1
0870  E007      	BZ	label47

	{

	} else {

		if (FCL_AXIS == 'y')
0872  0E79      	MOVLW 0x79
0874  63B1      	CPFSEQ FCD_0f051__0005E_arg_FCL_AXIS, 1
0876  D001      	BRA	label46
087A            label46

		{

		} else {
0878  D003      	BRA	label47


			if (FCL_AXIS == 'Y')
087A  0E59      	MOVLW 0x59
087C  63B1      	CPFSEQ FCD_0f051__0005E_arg_FCL_AXIS, 1
087E  D004      	BRA	label48
0880            label47

			{

			} else {

				goto FCC_G4D_ReadTouchCoordinatesPicaso_B;


			}

		}

	}

	FCR_RETVAL = FCV_0f051_gLCD_EB076_4D1__TOUCHY;
0880  5196      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W, 1
0882  6FB2      	MOVWF FCD_0f051__0005E_1_FCR_RETVAL, 1
0884  5197      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', W, 1
0886  6FB3      	MOVWF FCD_0f051__0005E_1_FCR_RETVAL+D'1', 1


FCC_G4D_ReadTouchCoordinatesPicaso_B:
0888            label48

;

	return (FCR_RETVAL);
0888  51B2      	MOVF FCD_0f051__0005E_1_FCR_RETVAL, W, 1
088A  6FB4      	MOVWF CompTempVarRet2649, 1
088C  51B3      	MOVF FCD_0f051__0005E_1_FCR_RETVAL+D'1', W, 1
088E  6FB5      	MOVWF CompTempVarRet2649+D'1', 1


}
0890  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Reads the value of the last touchscreen input from the display.
       :Returns a 0 if no new touch is detected.
       :Returns a 1 if a press is detected.
       :Returns a 2 if a release is detected.
       :Returns a 3 if a moving drag is detected.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCL_TEMP;
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x6F);
059C  0E6F      	MOVLW 0x6F
059E  0100      	MOVLB 0x00
05A0  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
05A2  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
05A4  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(4);
05A8  0E04      	MOVLW 0x04
05AA  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
05AC  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
05AE  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
05B2  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
05B4  EC4EF000  	CALL FC_CAL_UAR_00072


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
05B8  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
05BA  EC4EF000  	CALL FC_CAL_UAR_00072
05BE  51D1      	MOVF CompTempVarRet2748, W, 1
05C0  6FB2      	MOVWF FCD_0f051__0006D_1_FCR_RETVAL, 1


	FC_CAL_UART_Receive_1(255);
05C2  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
05C4  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(255);
05C8  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
05CA  EC4EF000  	CALL FC_CAL_UAR_00072


	if (FCR_RETVAL)
05CE  53B2      	MOVF FCD_0f051__0006D_1_FCR_RETVAL, F, 1
05D0  E032      	BZ	label36
0636            label36

	{

		FC_CAL_UART_Send_1(0x6F);
05D2  0E6F      	MOVLW 0x6F
05D4  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
05D6  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
05D8  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(5);
05DC  0E05      	MOVLW 0x05
05DE  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
05E0  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
05E2  EC46F000  	CALL FC_CAL_UAR_00073


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FC_CAL_UART_Receive_1(255);
05E6  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
05E8  EC4EF000  	CALL FC_CAL_UAR_00072
05EC  51D1      	MOVF CompTempVarRet2748, W, 1
05EE  6F98      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F, 1
05F0  51D2      	MOVF CompTempVarRet2748+D'1', W, 1
05F2  6F99      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', 1


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
05F4  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
05F6  EC4EF000  	CALL FC_CAL_UAR_00072
05FA  51D1      	MOVF CompTempVarRet2748, W, 1
05FC  6FB1      	MOVWF FCD_0f051__0006D_1_FCL_TEMP, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX << 8;
05FE  6BB3      	CLRF CompTempVar2730, 1
0600  5198      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F, W, 1
0602  6F99      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', 1
0604  51B3      	MOVF CompTempVar2730, W, 1
0606  6F98      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000F, 1

		FCV_0f051_gLCD_EB076_4D1__TOUCHX = FCV_0f051_gLCD_EB076_4D1__TOUCHX | FCL_TEMP;
0608  51B1      	MOVF FCD_0f051__0006D_1_FCL_TEMP, W, 1
060A  1398      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000F, F, 1
060C  5399      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000F+D'1', F, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FC_CAL_UART_Receive_1(255);
060E  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
0610  EC4EF000  	CALL FC_CAL_UAR_00072
0614  51D1      	MOVF CompTempVarRet2748, W, 1
0616  6F96      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E, 1
0618  51D2      	MOVF CompTempVarRet2748+D'1', W, 1
061A  6F97      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', 1


		FCL_TEMP = FC_CAL_UART_Receive_1(255);
061C  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
061E  EC4EF000  	CALL FC_CAL_UAR_00072
0622  51D1      	MOVF CompTempVarRet2748, W, 1
0624  6FB1      	MOVWF FCD_0f051__0006D_1_FCL_TEMP, 1


		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY << 8;
0626  6BB3      	CLRF CompTempVar2734, 1
0628  5196      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E, W, 1
062A  6F97      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', 1
062C  51B3      	MOVF CompTempVar2734, W, 1
062E  6F96      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000E, 1

		FCV_0f051_gLCD_EB076_4D1__TOUCHY = FCV_0f051_gLCD_EB076_4D1__TOUCHY | FCL_TEMP;
0630  51B1      	MOVF FCD_0f051__0006D_1_FCL_TEMP, W, 1
0632  1396      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000E, F, 1
0634  5397      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000E+D'1', F, 1


	// } else {

	}

	return (FCR_RETVAL);
0636  51B2      	MOVF FCD_0f051__0006D_1_FCR_RETVAL, W, 1
0638  6FB3      	MOVWF CompTempVarRet2729, 1


}
063A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Draws a circle on the screen centered at location X, Y.
       :Does not currently simulate.
       :
       :Param??tres pour la macro G4D_DrawCircle :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Radius : Configures the size of the circle.
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawCircle(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RADIUS, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RADIUS >> 8);

	FC_CAL_UART_Send_1(FCL_RADIUS);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a decimal number to the Graphical LCD.
       :
       :Param??tres pour la macro PrintNumber :
       :  Number : Byte or Integer number to send to the display.
       :  X : X pixel coordinate to set the output string position.
       :  Y : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__PrintNumber(MX_SINT16 FCL_NUMBER, MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)
{
	//Définitions des variables locales
	#define FCLsz_TEMP 6
	MX_CHAR FCL_TEMP[FCLsz_TEMP];


	FCI_TOSTRING(FCL_NUMBER, FCL_TEMP,6);

	FCD_0f051_gLCD_EB076_4D1__Print(FCL_TEMP, FCLsz_TEMP, FCL_X, FCL_Y, FCL_FONT, FCL_TRANSPARENT);

	//Définitions des variables locales
	#undef FCLsz_TEMP
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a line with the current foreground colour from pixel location X1, Y1 to pixel location X2, Y2.
       :
       :Param??tres pour la macro DrawLine :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawLine(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)

{
	//Définitions des variables locales
	MX_SINT16 FCL_C1;
	MX_SINT16 FCL_M1;
	MX_SINT16 FCL_D1 = (0);
03EC  6BBA      	CLRF FCD_0f051__0006E_1_FCL_D1, 1
03EE  6BBB      	CLRF FCD_0f051__0006E_1_FCL_D1+D'1', 1

	MX_SINT16 FCL_PIXELX;
	MX_SINT16 FCL_PIXELY;
	MX_SINT16 FCL_YINC = (1);
03F0  0E01      	MOVLW 0x01
03F2  6FBC      	MOVWF FCD_0f051__0006E_1_FCL_YINC, 1
03F4  6BBD      	CLRF FCD_0f051__0006E_1_FCL_YINC+D'1', 1

	MX_SINT16 FCL_XINC = (1);
03F6  0E01      	MOVLW 0x01
03F8  6FBE      	MOVWF FCD_0f051__0006E_1_FCL_XINC, 1
03FA  6BBF      	CLRF FCD_0f051__0006E_1_FCL_XINC+D'1', 1



	FC_CAL_UART_Send_1(0x4C);
03FC  0E4C      	MOVLW 0x4C
03FE  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0400  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0402  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0406  51B3      	MOVF FCD_0f051__0006E_arg_FCL_X1+D'1', W, 1
0408  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
040A  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
040C  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1);
0410  51B2      	MOVF FCD_0f051__0006E_arg_FCL_X1, W, 1
0412  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0414  51B3      	MOVF FCD_0f051__0006E_arg_FCL_X1+D'1', W, 1
0416  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0418  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
041C  51B5      	MOVF FCD_0f051__0006E_arg_FCL_Y1+D'1', W, 1
041E  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0420  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0422  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1);
0426  51B4      	MOVF FCD_0f051__0006E_arg_FCL_Y1, W, 1
0428  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
042A  51B5      	MOVF FCD_0f051__0006E_arg_FCL_Y1+D'1', W, 1
042C  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
042E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
0432  51B7      	MOVF FCD_0f051__0006E_arg_FCL_X2+D'1', W, 1
0434  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0436  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0438  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2);
043C  51B6      	MOVF FCD_0f051__0006E_arg_FCL_X2, W, 1
043E  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0440  51B7      	MOVF FCD_0f051__0006E_arg_FCL_X2+D'1', W, 1
0442  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0444  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
0448  51B9      	MOVF FCD_0f051__0006E_arg_FCL_Y2+D'1', W, 1
044A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
044C  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
044E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2);
0452  51B8      	MOVF FCD_0f051__0006E_arg_FCL_Y2, W, 1
0454  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0456  51B9      	MOVF FCD_0f051__0006E_arg_FCL_Y2+D'1', W, 1
0458  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
045A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
045E  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0460  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0462  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0464  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0468  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
046A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
046C  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
046E  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0470  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
0474  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
0476  EC4EF000  	CALL FC_CAL_UAR_00072


}
047A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card using the specified filename on the card.
       :The image is printed at location starting from X, Y.
       :PosH and PosL specify the sector address of the previously stored image icon.
       :
       :Param??tres pour la macro G4D_DisplayImageFromFilePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Filename[20] : MX_CHAR
       :  PosH : MX_UINT16
       :  PosL : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromFilePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_CHAR *PFCL_FILENAME, MX_UINT16 FCL_POSH, MX_UINT16 FCL_POSL)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6D);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_DisplayImageFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);

		FCL_IDX = FCL_IDX + 1;


	}

FCC_G4D_DisplayImageFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_POSH >> 8);

	FC_CAL_UART_Send_1(FCL_POSH);

	FC_CAL_UART_Send_1(FCL_POSL >> 8);

	FC_CAL_UART_Send_1(FCL_POSL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Disables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
069E  0E59      	MOVLW 0x59
06A0  0100      	MOVLB 0x00
06A2  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
06A4  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
06A6  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x05);
06AA  0E05      	MOVLW 0x05
06AC  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
06AE  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
06B0  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x01);
06B4  0E01      	MOVLW 0x01
06B6  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
06B8  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
06BA  EC46F000  	CALL FC_CAL_UAR_00073


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
06BE  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
06C0  EC4EF000  	CALL FC_CAL_UAR_00072
06C4  51D1      	MOVF CompTempVarRet2748, W, 1
06C6  6FB1      	MOVWF FCD_0f051__00063_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
06C8  0E06      	MOVLW 0x06
06CA  63B1      	CPFSEQ FCD_0f051__00063_1_FCR_RETVAL, 1
06CC  D002      	BRA	label39
06D2            label39

	{

		FCR_RETVAL = 0;
06CE  6BB1      	CLRF FCD_0f051__00063_1_FCR_RETVAL, 1


	} else {
06D0  D001      	BRA	label40
06D4            label40


		FCR_RETVAL = 255;
06D2  69B1      	SETF FCD_0f051__00063_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
06D4  51B1      	MOVF FCD_0f051__00063_1_FCR_RETVAL, W, 1
06D6  6FB2      	MOVWF CompTempVarRet2693, 1


}
06D8  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current foreground colour at pixel location X, Y.
       :
       :Param??tres pour la macro Plot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Plot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the operation, contrast and backlight on the display
       :
       :Param??tres pour la macro DisplayControl :
       :  Backlight : 0=Backlight Off, 1=Backlight On (default)
       :  Display : 0=Display off, 1=Display on (default)
       :  Contrast : Contrast Range 0 - 15
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DisplayControl(MX_UINT8 FCL_BACKLIGHT, MX_UINT8 FCL_DISPLAY, MX_UINT8 FCL_CONTRAST)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x00);

	FC_CAL_UART_Send_1(FCL_BACKLIGHT);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x01);

	FC_CAL_UART_Send_1(FCL_DISPLAY);

	FC_CAL_UART_Receive_1(255);

	FCI_DELAYBYTE_MS(1);

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x02);

	FC_CAL_UART_Send_1(FCL_CONTRAST);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables the touchscreen interface if available.
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso()

{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);
063C  0E59      	MOVLW 0x59
063E  0100      	MOVLB 0x00
0640  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0642  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0644  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x05);
0648  0E05      	MOVLW 0x05
064A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
064C  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
064E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x00);
0652  6BC8      	CLRF FC_CAL_UAR_00073_arg_nChar, 1
0654  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0656  EC46F000  	CALL FC_CAL_UAR_00073


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
065A  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
065C  EC4EF000  	CALL FC_CAL_UAR_00072
0660  51D1      	MOVF CompTempVarRet2748, W, 1
0662  6FB1      	MOVWF FCD_0f051__00064_1_FCR_RETVAL, 1


	FC_CAL_UART_Send_1(0x59);
0664  0E59      	MOVLW 0x59
0666  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0668  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
066A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x05);
066E  0E05      	MOVLW 0x05
0670  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0672  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0674  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(0x02);
0678  0E02      	MOVLW 0x02
067A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
067C  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
067E  EC46F000  	CALL FC_CAL_UAR_00073


	FCR_RETVAL = FC_CAL_UART_Receive_1(255);
0682  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
0684  EC4EF000  	CALL FC_CAL_UAR_00072
0688  51D1      	MOVF CompTempVarRet2748, W, 1
068A  6FB1      	MOVWF FCD_0f051__00064_1_FCR_RETVAL, 1


	if (FCR_RETVAL == 6)
068C  0E06      	MOVLW 0x06
068E  63B1      	CPFSEQ FCD_0f051__00064_1_FCR_RETVAL, 1
0690  D002      	BRA	label37
0696            label37

	{

		FCR_RETVAL = 0;
0692  6BB1      	CLRF FCD_0f051__00064_1_FCR_RETVAL, 1


	} else {
0694  D001      	BRA	label38
0698            label38


		FCR_RETVAL = 255;
0696  69B1      	SETF FCD_0f051__00064_1_FCR_RETVAL, 1


	}

	return (FCR_RETVAL);
0698  51B1      	MOVF FCD_0f051__00064_1_FCR_RETVAL, W, 1
069A  6FB2      	MOVWF CompTempVarRet2694, 1


}
069C  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Attempts to display a sequence of images from the micro SD card at the specified address location on the card.
       :The images are printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayVideoFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifes the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  Delay : Specifies the number of milliseconds to wait in between displaying each image.
       :  Frames : Specifies the number of frames to display.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayVideoFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_DELAY, MX_UINT16 FCL_FRAMES, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x56);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	if (FCL_COLOURMODE)
	{

		FC_CAL_UART_Send_1(0x10);

	} else {

		FC_CAL_UART_Send_1(0x08);

	}

	FC_CAL_UART_Send_1(FCL_DELAY);

	FC_CAL_UART_Send_1(FCL_FRAMES >> 8);

	FC_CAL_UART_Send_1(FCL_FRAMES);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the playback volume.
       :
       :Param??tres pour la macro G4D_SetVolumePicaso :
       :  Volume : Volume = 0 - Mute Enabled / 1 - Volume Down 8 / 3 - Volume Down 1 / 253 - Volume Up 1 / 254 - Volume Up 8 / 255 - Mute Disabled / 8 - Minimum Volume Level / 127 - Maximum Volume Level
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVolumePicaso(MX_UINT8 FCL_VOLUME)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x76);

	FC_CAL_UART_Send_1(FCL_VOLUME);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Controls the way data is printed out on the display allowing multiple different viewing orientations. Default is 0.
       :
       :Param??tres pour la macro SetDisplayOrientation :
       :  Orientation : 0=Default, 1=90??CW, 2=180??CW, 3=270??CW
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetDisplayOrientation(MX_UINT8 FCL_ORIENTATION)
{

	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x04);

	switch (FCL_ORIENTATION)
	{
		case 1:
		{
			FC_CAL_UART_Send_1(0x01);

			break;
		}
		case 2:
		{
			FC_CAL_UART_Send_1(0x04);

			break;
		}
		case 3:
		{
			FC_CAL_UART_Send_1(0x02);

			break;
		}
		default:
		{
			FC_CAL_UART_Send_1(0x03);

		}
	}

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Sets a pixel with the current background colour at pixel location X, Y.
       :
       :Param??tres pour la macro BPlot :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__BPlot(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1)
{

	FC_CAL_UART_Send_1(0x50);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :Draws an ellipse on the screen centered at location X, Y with width RX and height RY.
       :
       :Param??tres pour la macro G4D_DrawElipsePicaso :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  RX : MX_UINT16
       :  RY : MX_UINT16
       :  Solid : Chooses to fill the circle with colour - 0 = Circle contains transparency data, 1 = Circle contains foreground colour
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__G4D_DrawElipsePicaso(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_RX, MX_UINT16 FCL_RY, MX_UINT8 FCL_SOLID)
{

	FC_CAL_UART_Send_1(0x70);

	if (FCL_SOLID)
	{

		FC_CAL_UART_Send_1(0x00);

	} else {

		FC_CAL_UART_Send_1(0x01);

	}

	FC_CAL_UART_Receive_1(255);

	FC_CAL_UART_Send_1(0x65);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_RX >> 8);

	FC_CAL_UART_Send_1(FCL_RX);

	FC_CAL_UART_Send_1(FCL_RY >> 8);

	FC_CAL_UART_Send_1(FCL_RY);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);

	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);

	FC_CAL_UART_Receive_1(255);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro prints a string of characters to the Graphical LCD.
       :
       :Param??tres pour la macro Print :
       :  Str[20] : String of characters to send to the display.
       :  X1 : X pixel coordinate to set the output string position.
       :  Y1 : Y pixel coordinate to set the output string position.
       :  Font : Size of the font - 0 = Normal, 1 = Double Width, 2 = Double Width and Height, 3 = Double Height
       :  Transparent : Specifies if the background of the text is drawn - 0 = Background colour is drawn, 1 = Background colour not drawn.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Print(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR, MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT8 FCL_FONT, MX_UINT8 FCL_TRANSPARENT)

{
	//Définitions des variables locales
	MX_UINT8 FCL_LEN_STR;
	MX_UINT8 FCL_IDX = (0x0);
0A14  6BC7      	CLRF FCD_0f051__0008D_1_FCL_IDX, 1



	FC_CAL_UART_Send_1(0x4F);
0A16  0E4F      	MOVLW 0x4F
0A18  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A1A  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A1C  EC46F000  	CALL FC_CAL_UAR_00073


	if (FCL_TRANSPARENT)
0A20  53C5      	MOVF FCD_0f051__0008D_arg_FCL_T_0008E, F, 1
0A22  E005      	BZ	label64
0A2E            label64

	{

		FC_CAL_UART_Send_1(0x00);
0A24  6BC8      	CLRF FC_CAL_UAR_00073_arg_nChar, 1
0A26  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A28  EC46F000  	CALL FC_CAL_UAR_00073


	} else {
0A2C  D005      	BRA	label65
0A38            label65


		FC_CAL_UART_Send_1(0x01);
0A2E  0E01      	MOVLW 0x01
0A30  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A32  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A34  EC46F000  	CALL FC_CAL_UAR_00073


	}

	FC_CAL_UART_Receive_1(255);
0A38  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
0A3A  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Send_1(0x53);
0A3E  0E53      	MOVLW 0x53
0A40  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A42  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A44  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0A48  51C1      	MOVF FCD_0f051__0008D_arg_FCL_X1+D'1', W, 1
0A4A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A4C  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A4E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1);
0A52  51C0      	MOVF FCD_0f051__0008D_arg_FCL_X1, W, 1
0A54  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A56  51C1      	MOVF FCD_0f051__0008D_arg_FCL_X1+D'1', W, 1
0A58  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A5A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0A5E  51C3      	MOVF FCD_0f051__0008D_arg_FCL_Y1+D'1', W, 1
0A60  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A62  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A64  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1);
0A68  51C2      	MOVF FCD_0f051__0008D_arg_FCL_Y1, W, 1
0A6A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A6C  51C3      	MOVF FCD_0f051__0008D_arg_FCL_Y1+D'1', W, 1
0A6E  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A70  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_FONT);
0A74  51C4      	MOVF FCD_0f051__0008D_arg_FCL_FONT, W, 1
0A76  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A78  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A7A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
0A7E  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0A80  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A82  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A84  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0A88  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
0A8A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A8C  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0A8E  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A90  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(1);
0A94  0E01      	MOVLW 0x01
0A96  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0A98  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0A9A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(1);
0A9E  0E01      	MOVLW 0x01
0AA0  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0AA2  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0AA4  EC46F000  	CALL FC_CAL_UAR_00073


	FCL_LEN_STR = FCI_GETLENGTH(FCL_STR, FCLsz_STR);
0AA8  51B1      	MOVF FCD_0f051__0008D_arg_FCL_STR, W, 1
0AAA  6FC8      	MOVWF FCI_GETLEN_0004B_arg_sStr1, 1
0AAC  51B2      	MOVF FCD_0f051__0008D_arg_FCL_STR+D'1', W, 1
0AAE  6FC9      	MOVWF FCI_GETLEN_0004B_arg_sStr1+D'1', 1
0AB0  51BE      	MOVF FCD_0f051__0008D_arg_FCLsz_STR, W, 1
0AB2  6FCA      	MOVWF FCI_GETLEN_0004B_arg_iStr1_len, 1
0AB4  ECBEF002  	CALL FCI_GETLEN_0004B
0AB8  51CC      	MOVF CompTempVarRet1850, W, 1
0ABA  6FC6      	MOVWF FCD_0f051__0008D_1_FCL_LEN_STR, 1


	while (FCL_IDX < FCL_LEN_STR)
0ABC            label66
0ABC  51C6      	MOVF FCD_0f051__0008D_1_FCL_LEN_STR, W, 1
0ABE  61C7      	CPFSLT FCD_0f051__0008D_1_FCL_IDX, 1
0AC0  D014      	BRA	label67
0AE8  D7E9      	BRA	label66
0AEA            label67

	{

		if (FCL_STR[FCL_IDX] == 0)
0AC2  51B2      	MOVF FCD_0f051__0008D_arg_FCL_STR+D'1', W, 1
0AC4  6EEA      	MOVWF FSR0H
0AC6  51B1      	MOVF FCD_0f051__0008D_arg_FCL_STR, W, 1
0AC8  25C7      	ADDWF FCD_0f051__0008D_1_FCL_IDX, W, 1
0ACA  6EE9      	MOVWF FSR0L
0ACC  52EF      	MOVF INDF0, F
0ACE  E00D      	BZ	label67

		{

			goto FCC_Print_A;


		// } else {

		}

		FC_CAL_UART_Send_1(FCL_STR[FCL_IDX]);
0AD0  51B2      	MOVF FCD_0f051__0008D_arg_FCL_STR+D'1', W, 1
0AD2  6EEA      	MOVWF FSR0H
0AD4  51B1      	MOVF FCD_0f051__0008D_arg_FCL_STR, W, 1
0AD6  25C7      	ADDWF FCD_0f051__0008D_1_FCL_IDX, W, 1
0AD8  6EE9      	MOVWF FSR0L
0ADA  50EF      	MOVF INDF0, W
0ADC  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0ADE  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0AE0  EC46F000  	CALL FC_CAL_UAR_00073


		FCL_IDX = FCL_IDX + 1;
0AE4  29C7      	INCF FCD_0f051__0008D_1_FCL_IDX, W, 1
0AE6  6FC7      	MOVWF FCD_0f051__0008D_1_FCL_IDX, 1



	}

FCC_Print_A:
;

	FC_CAL_UART_Send_1(0);
0AEA  6BC8      	CLRF FC_CAL_UAR_00073_arg_nChar, 1
0AEC  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0AEE  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
0AF2  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
0AF4  EC4EF000  	CALL FC_CAL_UAR_00072


}
0AF8  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Copies a section of the display to the micro SD card starting from X, Y and ranging to Width, Height.
       :The address parameters assign where on the card to store the data.
       :
       :Param??tres pour la macro G4D_DumpScreenToCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DumpScreenToCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x43);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_WIDTH >> 8);

	FC_CAL_UART_Send_1(FCL_WIDTH);

	FC_CAL_UART_Send_1(FCL_HEIGHT >> 8);

	FC_CAL_UART_Send_1(FCL_HEIGHT);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the VGA display size in pixels.
       :Size = 0 - 320 x 240 Resolution.
       :Size = 1 - 640 x 480 Resolution.
       :Size = 2 - 800 x 480 Resolution.
       :Size = 3 - Custom Resolution
       :
       :Param??tres pour la macro G4D_SetVGADisplaySizePicaso :
       :  Size : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetVGADisplaySizePicaso(MX_UINT8 FCL_SIZE)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x59);

	FC_CAL_UART_Send_1(0x0c);

	FC_CAL_UART_Send_1(FCL_SIZE);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :This macro clears the display of any previous output by overwriting the entire display with the background colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__ClearDisplay()

{
	//Définitions des variables locales
	MX_UINT16 FCL_Y = (0x0);
047C  0100      	MOVLB 0x00
047E  6BB5      	CLRF FCD_0f051__00061_1_FCL_Y, 1
0480  6BB6      	CLRF FCD_0f051__00061_1_FCL_Y+D'1', 1

	MX_UINT16 FCL_X = (0x0);
0482  6BB7      	CLRF FCD_0f051__00061_1_FCL_X, 1
0484  6BB8      	CLRF FCD_0f051__00061_1_FCL_X+D'1', 1



	FC_CAL_UART_Send_1(0x42);
0486  0E42      	MOVLW 0x42
0488  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
048A  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
048C  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
0490  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
0492  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0494  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0496  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
049A  5192      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W, 1
049C  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
049E  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
04A0  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
04A2  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
04A6  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
04A8  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Send_1(0x45);
04AC  0E45      	MOVLW 0x45
04AE  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
04B0  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
04B2  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
04B6  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
04B8  EC4EF000  	CALL FC_CAL_UAR_00072


}
04BC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the background by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetBackgroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetBackgroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)
{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
	FCL_GREEN = FCL_GREEN >> (8 - 6);
	FCL_BLUE = FCL_BLUE >> (8 - 5);

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to print an image from the micro SD card at the specified address location on the card.
       :The image is printed at location starting from X, Y and ranging to Width, Height.
       :
       :Param??tres pour la macro G4D_DisplayImageFromCard :
       :  X : MX_UINT16
       :  Y : MX_UINT16
       :  Width : MX_UINT16
       :  Height : MX_UINT16
       :  ColourMode : Specifies the colour depth setting - 0 = 8-bit colour, 1 = 16-bit colour.
       :  AddH : MX_UINT8
       :  AddM : MX_UINT8
       :  AddL : MX_UINT8
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_DisplayImageFromCard(MX_UINT16 FCL_X, MX_UINT16 FCL_Y, MX_UINT16 FCL_WIDTH, MX_UINT16 FCL_HEIGHT, MX_UINT8 FCL_COLOURMODE, MX_UINT8 FCL_ADDH, MX_UINT8 FCL_ADDM, MX_UINT8 FCL_ADDL)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x49);

	FC_CAL_UART_Send_1(FCL_X >> 8);

	FC_CAL_UART_Send_1(FCL_X);

	FC_CAL_UART_Send_1(FCL_Y >> 8);

	FC_CAL_UART_Send_1(FCL_Y);

	FC_CAL_UART_Send_1(FCL_ADDH);

	FC_CAL_UART_Send_1(FCL_ADDM);

	FC_CAL_UART_Send_1(FCL_ADDL);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Specifies the colour of the foreground by creating a mixture of red, green and blue.
       :
       :Param??tres pour la macro SetForegroundColour :
       :  Red : 0 - 255 where 0 = no red and 255 = maximum red
       :  Green : 0 - 255 where 0 = no green and 255 = maximum green
       :  Blue : 0 - 255 where 0 = no blue and 255 = maximum blue
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(MX_UINT8 FCL_RED, MX_UINT8 FCL_GREEN, MX_UINT8 FCL_BLUE)

{
	//Définitions des variables locales
	MX_UINT32 FCL_COLOUR;


	FCL_RED = FCL_RED >> (8 - 5);
0286  33B9      	RRCF FCD_0f051__00066_arg_FCL_RED, F, 1
0288  33B9      	RRCF FCD_0f051__00066_arg_FCL_RED, F, 1
028A  33B9      	RRCF FCD_0f051__00066_arg_FCL_RED, F, 1
028C  0E1F      	MOVLW 0x1F
028E  17B9      	ANDWF FCD_0f051__00066_arg_FCL_RED, F, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
0290  33BA      	RRCF FCD_0f051__00066_arg_FCL_GREEN, F, 1
0292  33BA      	RRCF FCD_0f051__00066_arg_FCL_GREEN, F, 1
0294  0E3F      	MOVLW 0x3F
0296  17BA      	ANDWF FCD_0f051__00066_arg_FCL_GREEN, F, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0298  33BB      	RRCF FCD_0f051__00066_arg_FCL_BLUE, F, 1
029A  33BB      	RRCF FCD_0f051__00066_arg_FCL_BLUE, F, 1
029C  33BB      	RRCF FCD_0f051__00066_arg_FCL_BLUE, F, 1
029E  0E1F      	MOVLW 0x1F
02A0  17BB      	ANDWF FCD_0f051__00066_arg_FCL_BLUE, F, 1


	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
02A2  51BA      	MOVF FCD_0f051__00066_arg_FCL_GREEN, W, 1
02A4  6FBC      	MOVWF CompTempVar2698, 1
02A6  6B95      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', 1
02A8  37BC      	RLCF CompTempVar2698, F, 1
02AA  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
02AC  37BC      	RLCF CompTempVar2698, F, 1
02AE  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
02B0  37BC      	RLCF CompTempVar2698, F, 1
02B2  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
02B4  37BC      	RLCF CompTempVar2698, F, 1
02B6  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
02B8  37BC      	RLCF CompTempVar2698, F, 1
02BA  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
02BC  0EE0      	MOVLW 0xE0
02BE  17BC      	ANDWF CompTempVar2698, F, 1
02C0  51BC      	MOVF CompTempVar2698, W, 1
02C2  11BB      	IORWF FCD_0f051__00066_arg_FCL_BLUE, W, 1
02C4  6F94      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
02C6  6BBC      	CLRF CompTempVar2702, 1
02C8  51B9      	MOVF FCD_0f051__00066_arg_FCL_RED, W, 1
02CA  6FBD      	MOVWF CompTempVar2703, 1
02CC  90D8      	BCF STATUS,C
02CE  37BD      	RLCF CompTempVar2703, F, 1
02D0  90D8      	BCF STATUS,C
02D2  37BD      	RLCF CompTempVar2703, F, 1
02D4  90D8      	BCF STATUS,C
02D6  37BD      	RLCF CompTempVar2703, F, 1
02D8  51BC      	MOVF CompTempVar2702, W, 1
02DA  1394      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F, 1
02DC  51BD      	MOVF CompTempVar2703, W, 1
02DE  1395      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1


}
02E0  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Specifies the area of the screen which will respond to touchscreen inputs.
       :
       :Param??tres pour la macro G4D_SetTouchRegionPicaso :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_SetTouchRegionPicaso(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2)
{
	//Définitions des variables locales
	MX_UINT8 FCR_RETVAL;


	FC_CAL_UART_Send_1(0x75);

	FC_CAL_UART_Send_1(FCL_X1 >> 8);

	FC_CAL_UART_Send_1(FCL_X1);

	FC_CAL_UART_Send_1(FCL_Y1 >> 8);

	FC_CAL_UART_Send_1(FCL_Y1);

	FC_CAL_UART_Send_1(FCL_X2 >> 8);

	FC_CAL_UART_Send_1(FCL_X2);

	FC_CAL_UART_Send_1(FCL_Y2 >> 8);

	FC_CAL_UART_Send_1(FCL_Y2);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Attempts to stream an audio wav file from the micro SD card using the specified filename.
       :
       :Param??tres pour la macro G4D_PlayAudioFromFilePicaso :
       :  Play_Option : Play_Option = 0 - Return when playing complete / 1 - Return immediatley / 2 - Stop Playback / 3 - Pause Playback / 4 - Resume Playback / 5 - Loop Playing until stopped
       :  Filename[20] : MX_CHAR
       :
       :Renvoie : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0f051_gLCD_EB076_4D1__G4D_PlayAudioFromFilePicaso(MX_UINT8 FCL_PLAY_OPTION, MX_CHAR *PFCL_FILENAME)
{
	//Définitions des variables locales
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCR_RETVAL;


	#define FCLsz_FILENAME 20
	MX_CHAR FCL_FILENAME[FCLsz_FILENAME];
	FCI_CONCATENATE(PFCL_FILENAME,FCLsz_FILENAME,"",0,FCL_FILENAME,FCLsz_FILENAME);
	FC_CAL_UART_Send_1(0x40);

	FC_CAL_UART_Send_1(0x6C);

	FC_CAL_UART_Send_1(FCL_PLAY_OPTION);

	while (FCL_FILENAME[FCL_IDX])
	{

		if (FCL_FILENAME[FCL_IDX] == 0)
		{

			goto FCC_G4D_PlayAudioFromFilePicaso_A;

		// } else {

		}

		FC_CAL_UART_Send_1(FCL_FILENAME[FCL_IDX]);


	}

FCC_G4D_PlayAudioFromFilePicaso_A:
;

	FC_CAL_UART_Send_1(0);

	FCR_RETVAL = FC_CAL_UART_Receive_1(255);

	if (FCR_RETVAL == 6)
	{

		FCR_RETVAL = 0;

	} else {

		FCR_RETVAL = 255;

	}

	return (FCR_RETVAL);

	//Définitions des variables locales
	#undef FCLsz_FILENAME
}

/*=----------------------------------------------------------------------=*\
   Use :Draws a rectangle with the current foreground colour from pixel loaction X1, Y1 to pixel location X2, Y2
       :
       :Param??tres pour la macro DrawRectangle :
       :  X1 : MX_UINT16
       :  Y1 : MX_UINT16
       :  X2 : MX_UINT16
       :  Y2 : MX_UINT16
       :  Transparent : Chooses the transparency of the box - 0 = Box contains background colour, 1 = Box contains previous pixel data.
       :  Solid : Chooses to fill the box with colour - 0 = Box contains transparency data, 1 = Box contains foreground colour.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__DrawRectangle(MX_UINT16 FCL_X1, MX_UINT16 FCL_Y1, MX_UINT16 FCL_X2, MX_UINT16 FCL_Y2, MX_UINT8 FCL_TRANSPARENT, MX_UINT8 FCL_SOLID)

{
	//Définitions des variables locales
	MX_UINT16 FCL_XMIN;
	MX_UINT16 FCL_XMAX;
	MX_UINT16 FCL_YMIN;
	MX_UINT16 FCL_YMAX;


	if ((FCL_TRANSPARENT == 0) && (FCL_SOLID == 0))
0140  53C1      	MOVF FCD_0f051__00067_arg_FCL_T_00068, F, 1
0142  E14D      	BNZ	label15
0144  53C2      	MOVF FCD_0f051__00067_arg_FCL_SOLID, F, 1
0146  E14B      	BNZ	label15
01DE            label15

	{

		FC_CAL_UART_Send_1(0x70);
0148  0E70      	MOVLW 0x70
014A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
014C  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
014E  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(0x00);
0152  6BC8      	CLRF FC_CAL_UAR_00073_arg_nChar, 1
0154  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0156  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Receive_1(255);
015A  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
015C  EC4EF000  	CALL FC_CAL_UAR_00072


		FC_CAL_UART_Send_1(0x72);
0160  0E72      	MOVLW 0x72
0162  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0164  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0166  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X1 >> 8);
016A  51BA      	MOVF FCD_0f051__00067_arg_FCL_X1+D'1', W, 1
016C  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
016E  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0170  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X1);
0174  51B9      	MOVF FCD_0f051__00067_arg_FCL_X1, W, 1
0176  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0178  51BA      	MOVF FCD_0f051__00067_arg_FCL_X1+D'1', W, 1
017A  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
017C  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0180  51BC      	MOVF FCD_0f051__00067_arg_FCL_Y1+D'1', W, 1
0182  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0184  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0186  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y1);
018A  51BB      	MOVF FCD_0f051__00067_arg_FCL_Y1, W, 1
018C  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
018E  51BC      	MOVF FCD_0f051__00067_arg_FCL_Y1+D'1', W, 1
0190  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0192  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X2 >> 8);
0196  51BE      	MOVF FCD_0f051__00067_arg_FCL_X2+D'1', W, 1
0198  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
019A  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
019C  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_X2);
01A0  51BD      	MOVF FCD_0f051__00067_arg_FCL_X2, W, 1
01A2  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
01A4  51BE      	MOVF FCD_0f051__00067_arg_FCL_X2+D'1', W, 1
01A6  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
01A8  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y2 >> 8);
01AC  51C0      	MOVF FCD_0f051__00067_arg_FCL_Y2+D'1', W, 1
01AE  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
01B0  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
01B2  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCL_Y2);
01B6  51BF      	MOVF FCD_0f051__00067_arg_FCL_Y2, W, 1
01B8  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
01BA  51C0      	MOVF FCD_0f051__00067_arg_FCL_Y2+D'1', W, 1
01BC  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
01BE  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR >> 8);
01C2  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
01C4  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
01C6  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
01C8  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR);
01CC  5192      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C, W, 1
01CE  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
01D0  5193      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', W, 1
01D2  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
01D4  EC46F000  	CALL FC_CAL_UAR_00073


		FC_CAL_UART_Receive_1(255);
01D8  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
01DA  EC4EF000  	CALL FC_CAL_UAR_00072


	// } else {

	}

	FC_CAL_UART_Send_1(0x70);
01DE  0E70      	MOVLW 0x70
01E0  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
01E2  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
01E4  EC46F000  	CALL FC_CAL_UAR_00073


	if (FCL_SOLID)
01E8  53C2      	MOVF FCD_0f051__00067_arg_FCL_SOLID, F, 1
01EA  E005      	BZ	label16
01F6            label16

	{

		FC_CAL_UART_Send_1(0x00);
01EC  6BC8      	CLRF FC_CAL_UAR_00073_arg_nChar, 1
01EE  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
01F0  EC46F000  	CALL FC_CAL_UAR_00073


	} else {
01F4  D005      	BRA	label17
0200            label17


		FC_CAL_UART_Send_1(0x01);
01F6  0E01      	MOVLW 0x01
01F8  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
01FA  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
01FC  EC46F000  	CALL FC_CAL_UAR_00073


	}

	FC_CAL_UART_Receive_1(255);
0200  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
0202  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Send_1(0x72);
0206  0E72      	MOVLW 0x72
0208  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
020A  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
020C  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1 >> 8);
0210  51BA      	MOVF FCD_0f051__00067_arg_FCL_X1+D'1', W, 1
0212  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0214  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0216  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X1);
021A  51B9      	MOVF FCD_0f051__00067_arg_FCL_X1, W, 1
021C  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
021E  51BA      	MOVF FCD_0f051__00067_arg_FCL_X1+D'1', W, 1
0220  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0222  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1 >> 8);
0226  51BC      	MOVF FCD_0f051__00067_arg_FCL_Y1+D'1', W, 1
0228  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
022A  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
022C  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y1);
0230  51BB      	MOVF FCD_0f051__00067_arg_FCL_Y1, W, 1
0232  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0234  51BC      	MOVF FCD_0f051__00067_arg_FCL_Y1+D'1', W, 1
0236  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0238  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2 >> 8);
023C  51BE      	MOVF FCD_0f051__00067_arg_FCL_X2+D'1', W, 1
023E  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0240  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0242  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_X2);
0246  51BD      	MOVF FCD_0f051__00067_arg_FCL_X2, W, 1
0248  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
024A  51BE      	MOVF FCD_0f051__00067_arg_FCL_X2+D'1', W, 1
024C  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
024E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2 >> 8);
0252  51C0      	MOVF FCD_0f051__00067_arg_FCL_Y2+D'1', W, 1
0254  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0256  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0258  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCL_Y2);
025C  51BF      	MOVF FCD_0f051__00067_arg_FCL_Y2, W, 1
025E  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0260  51C0      	MOVF FCD_0f051__00067_arg_FCL_Y2+D'1', W, 1
0262  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0264  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR >> 8);
0268  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
026A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
026C  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
026E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Send_1(FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR);
0272  5194      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D, W, 1
0274  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0276  5195      	MOVF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', W, 1
0278  6FC9      	MOVWF FC_CAL_UAR_00073_arg_nChar+D'1', 1
027A  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
027E  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
0280  EC4EF000  	CALL FC_CAL_UAR_00072


}
0284  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :The Init macro must be called once to initialise the Graphical LCD display before any other Graphical LCD component macros are called.
\*=----------------------------------------------------------------------=*/
void FCD_0f051_gLCD_EB076_4D1__Initialise()

{
	//Définitions des variables locales
	MX_UINT8 FCL_RED;
	MX_UINT8 FCL_GREEN;
	MX_UINT8 FCL_BLUE;
	MX_UINT8 FCL_DUMMY;


	FCP_SET(B, C, 0x20, 0x5, 0);
06DA  0100      	MOVLB 0x00
06DC  6BB5      	CLRF FCD_0f051__00060_2_ptmp, 1
06DE  9A94      	BCF gbl_trisc,5
06E0  53B5      	MOVF FCD_0f051__00060_2_ptmp, F, 1
06E2  E004      	BZ	label41
06E4  0E20      	MOVLW 0x20
06E6  108B      	IORWF gbl_latc, W
06E8  6E82      	MOVWF gbl_portc
06EA  D003      	BRA	label42
06EC            label41
06EC  0EDF      	MOVLW 0xDF
06EE  148B      	ANDWF gbl_latc, W
06F0  6E82      	MOVWF gbl_portc
06F2            label42


	FC_CAL_UART_Init_1();
06F2  EC71F001  	CALL FC_CAL_UAR_00074


	FCI_DELAYBYTE_US(100);
06F6  0E64      	MOVLW 0x64
06F8  6FB5      	MOVWF delay_us_00000_arg_del, 1
06FA  EC2EF000  	CALL delay_us_00000


	FCL_DUMMY = FCP_GET(B, C, 0x20, 0x5);
06FE  0E0F      	MOVLW HIGH(gbl_portc+D'0')
0700  6FB6      	MOVWF FC_CAL_Por_00042_arg_Port+D'1', 1
0702  0E82      	MOVLW LOW(gbl_portc+D'0')
0704  6FB5      	MOVWF FC_CAL_Por_00042_arg_Port, 1
0706  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
0708  6FB8      	MOVWF FC_CAL_Por_00042_arg_Tris+D'1', 1
070A  0E94      	MOVLW LOW(gbl_trisc+D'0')
070C  6FB7      	MOVWF FC_CAL_Por_00042_arg_Tris, 1
070E  0E20      	MOVLW 0x20
0710  6FB9      	MOVWF FC_CAL_Por_00042_arg_InMask, 1
0712  0E05      	MOVLW 0x05
0714  6FBA      	MOVWF FC_CAL_Por_00042_arg_Shift, 1
0716  ECC2F001  	CALL FC_CAL_Por_00042
071A  51BB      	MOVF CompTempVarRet1822, W, 1
071C  6FB4      	MOVWF FCD_0f051__00060_1_FCL_DUMMY, 1


	FCI_DELAYBYTE_S(3);
071E  0E03      	MOVLW 0x03
0720  6FB5      	MOVWF delay_s_00000_arg_del, 1
0722  EC33F000  	CALL delay_s_00000


	FC_CAL_UART_Receive_1(0);
0726  6BC8      	CLRF FC_CAL_UAR_00072_arg_nTimeout, 1
0728  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(0);
072C  6BC8      	CLRF FC_CAL_UAR_00072_arg_nTimeout, 1
072E  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(0);
0732  6BC8      	CLRF FC_CAL_UAR_00072_arg_nTimeout, 1
0734  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Send_1(0x55);
0738  0E55      	MOVLW 0x55
073A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
073C  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
073E  EC46F000  	CALL FC_CAL_UAR_00073


	FC_CAL_UART_Receive_1(255);
0742  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
0744  EC4EF000  	CALL FC_CAL_UAR_00072


	#if (1) // 1 == 1

		#if (1) // 1 != 0

			FC_CAL_UART_Send_1(0x51);
0748  0E51      	MOVLW 0x51
074A  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
074C  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
074E  EC46F000  	CALL FC_CAL_UAR_00073


			FC_CAL_UART_Send_1(0x0C);
0752  0E0C      	MOVLW 0x0C
0754  6FC8      	MOVWF FC_CAL_UAR_00073_arg_nChar, 1
0756  6BC9      	CLRF FC_CAL_UAR_00073_arg_nChar+D'1', 1
0758  EC46F000  	CALL FC_CAL_UAR_00073


			FC_CAL_UART_Receive_1(255);
075C  69C8      	SETF FC_CAL_UAR_00072_arg_nTimeout, 1
075E  EC4EF000  	CALL FC_CAL_UAR_00072


			FC_CAL_UART_UpdateBaud_1(6);
0762  0E06      	MOVLW 0x06
0764  6FB5      	MOVWF FC_CAL_UAR_00070_arg_new_baud, 1
0766  EC7AF001  	CALL FC_CAL_UAR_00070



		// #else

		//Le code a été optimisé par le préprocesseur
		#endif

	// #else

	//Le code a été optimisé par le préprocesseur
	#endif

	FC_CAL_UART_Receive_1(10);
076A  0E0A      	MOVLW 0x0A
076C  6FC8      	MOVWF FC_CAL_UAR_00072_arg_nTimeout, 1
076E  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(10);
0772  0E0A      	MOVLW 0x0A
0774  6FC8      	MOVWF FC_CAL_UAR_00072_arg_nTimeout, 1
0776  EC4EF000  	CALL FC_CAL_UAR_00072


	FCL_RED = 0 & 0xFF;
077A  6BB1      	CLRF FCD_0f051__00060_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
077C  33B1      	RRCF FCD_0f051__00060_1_FCL_RED, F, 1
077E  33B1      	RRCF FCD_0f051__00060_1_FCL_RED, F, 1
0780  33B1      	RRCF FCD_0f051__00060_1_FCL_RED, F, 1
0782  0E1F      	MOVLW 0x1F
0784  17B1      	ANDWF FCD_0f051__00060_1_FCL_RED, F, 1

	FCL_GREEN = (0 >> 8) & 0xFF;
0786  6BB2      	CLRF FCD_0f051__00060_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
0788  33B2      	RRCF FCD_0f051__00060_1_FCL_GREEN, F, 1
078A  33B2      	RRCF FCD_0f051__00060_1_FCL_GREEN, F, 1
078C  0E3F      	MOVLW 0x3F
078E  17B2      	ANDWF FCD_0f051__00060_1_FCL_GREEN, F, 1

	FCL_BLUE = (0 >> 16) & 0xFF;
0790  6BB3      	CLRF FCD_0f051__00060_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
0792  33B3      	RRCF FCD_0f051__00060_1_FCL_BLUE, F, 1
0794  33B3      	RRCF FCD_0f051__00060_1_FCL_BLUE, F, 1
0796  33B3      	RRCF FCD_0f051__00060_1_FCL_BLUE, F, 1
0798  0E1F      	MOVLW 0x1F
079A  17B3      	ANDWF FCD_0f051__00060_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
079C  51B2      	MOVF FCD_0f051__00060_1_FCL_GREEN, W, 1
079E  6FB5      	MOVWF CompTempVar2666, 1
07A0  6B95      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', 1
07A2  37B5      	RLCF CompTempVar2666, F, 1
07A4  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
07A6  37B5      	RLCF CompTempVar2666, F, 1
07A8  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
07AA  37B5      	RLCF CompTempVar2666, F, 1
07AC  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
07AE  37B5      	RLCF CompTempVar2666, F, 1
07B0  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
07B2  37B5      	RLCF CompTempVar2666, F, 1
07B4  3795      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1
07B6  0EE0      	MOVLW 0xE0
07B8  17B5      	ANDWF CompTempVar2666, F, 1
07BA  51B5      	MOVF CompTempVar2666, W, 1
07BC  11B3      	IORWF FCD_0f051__00060_1_FCL_BLUE, W, 1
07BE  6F94      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000D, 1

	FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__FOREGROUND_COL_VAR | (FCL_RED << (6 + 5));
07C0  6BB5      	CLRF CompTempVar2670, 1
07C2  51B1      	MOVF FCD_0f051__00060_1_FCL_RED, W, 1
07C4  6FB6      	MOVWF CompTempVar2671, 1
07C6  90D8      	BCF STATUS,C
07C8  37B6      	RLCF CompTempVar2671, F, 1
07CA  90D8      	BCF STATUS,C
07CC  37B6      	RLCF CompTempVar2671, F, 1
07CE  90D8      	BCF STATUS,C
07D0  37B6      	RLCF CompTempVar2671, F, 1
07D2  51B5      	MOVF CompTempVar2670, W, 1
07D4  1394      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D, F, 1
07D6  51B6      	MOVF CompTempVar2671, W, 1
07D8  1395      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000D+D'1', F, 1

	FCL_RED = 16777215 & 0xFF;
07DA  69B1      	SETF FCD_0f051__00060_1_FCL_RED, 1

	FCL_RED = FCL_RED >> (8 - 5);
07DC  33B1      	RRCF FCD_0f051__00060_1_FCL_RED, F, 1
07DE  33B1      	RRCF FCD_0f051__00060_1_FCL_RED, F, 1
07E0  33B1      	RRCF FCD_0f051__00060_1_FCL_RED, F, 1
07E2  0E1F      	MOVLW 0x1F
07E4  17B1      	ANDWF FCD_0f051__00060_1_FCL_RED, F, 1

	FCL_GREEN = (16777215 >> 8) & 0xFF;
07E6  69B2      	SETF FCD_0f051__00060_1_FCL_GREEN, 1

	FCL_GREEN = FCL_GREEN >> (8 - 6);
07E8  33B2      	RRCF FCD_0f051__00060_1_FCL_GREEN, F, 1
07EA  33B2      	RRCF FCD_0f051__00060_1_FCL_GREEN, F, 1
07EC  0E3F      	MOVLW 0x3F
07EE  17B2      	ANDWF FCD_0f051__00060_1_FCL_GREEN, F, 1

	FCL_BLUE = (16777215 >> 16) & 0xFF;
07F0  69B3      	SETF FCD_0f051__00060_1_FCL_BLUE, 1

	FCL_BLUE = FCL_BLUE >> (8 - 5);
07F2  33B3      	RRCF FCD_0f051__00060_1_FCL_BLUE, F, 1
07F4  33B3      	RRCF FCD_0f051__00060_1_FCL_BLUE, F, 1
07F6  33B3      	RRCF FCD_0f051__00060_1_FCL_BLUE, F, 1
07F8  0E1F      	MOVLW 0x1F
07FA  17B3      	ANDWF FCD_0f051__00060_1_FCL_BLUE, F, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCL_BLUE | (FCL_GREEN << 5);
07FC  51B2      	MOVF FCD_0f051__00060_1_FCL_GREEN, W, 1
07FE  6FB5      	MOVWF CompTempVar2677, 1
0800  6B93      	CLRF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', 1
0802  37B5      	RLCF CompTempVar2677, F, 1
0804  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
0806  37B5      	RLCF CompTempVar2677, F, 1
0808  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
080A  37B5      	RLCF CompTempVar2677, F, 1
080C  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
080E  37B5      	RLCF CompTempVar2677, F, 1
0810  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
0812  37B5      	RLCF CompTempVar2677, F, 1
0814  3793      	RLCF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1
0816  0EE0      	MOVLW 0xE0
0818  17B5      	ANDWF CompTempVar2677, F, 1
081A  51B5      	MOVF CompTempVar2677, W, 1
081C  11B3      	IORWF FCD_0f051__00060_1_FCL_BLUE, W, 1
081E  6F92      	MOVWF gbl_FCV_0f051_gLCD_EB076_4_0000C, 1

	FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR = FCV_0f051_gLCD_EB076_4D1__BACKGROUND_COL_VAR | (FCL_RED << (6 + 5));
0820  6BB5      	CLRF CompTempVar2681, 1
0822  51B1      	MOVF FCD_0f051__00060_1_FCL_RED, W, 1
0824  6FB6      	MOVWF CompTempVar2682, 1
0826  90D8      	BCF STATUS,C
0828  37B6      	RLCF CompTempVar2682, F, 1
082A  90D8      	BCF STATUS,C
082C  37B6      	RLCF CompTempVar2682, F, 1
082E  90D8      	BCF STATUS,C
0830  37B6      	RLCF CompTempVar2682, F, 1
0832  51B5      	MOVF CompTempVar2681, W, 1
0834  1392      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C, F, 1
0836  51B6      	MOVF CompTempVar2682, W, 1
0838  1393      	IORWF gbl_FCV_0f051_gLCD_EB076_4_0000C+D'1', F, 1


	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
083A  EC3EF002  	CALL FCD_0f051__00061


	FC_CAL_UART_Receive_1(10);
083E  0E0A      	MOVLW 0x0A
0840  6FC8      	MOVWF FC_CAL_UAR_00072_arg_nTimeout, 1
0842  EC4EF000  	CALL FC_CAL_UAR_00072


	FC_CAL_UART_Receive_1(10);
0846  0E0A      	MOVLW 0x0A
0848  6FC8      	MOVWF FC_CAL_UAR_00072_arg_nTimeout, 1
084A  EC4EF000  	CALL FC_CAL_UAR_00072


}
084E  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Implémentations de la macro
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_144()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 6
		FCV_HITBOX = 6;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 16
			FCV_HITBOX = 16;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 26
				FCV_HITBOX = 26;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 36
					FCV_HITBOX = 36;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 46
						FCV_HITBOX = 46;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 56
							FCV_HITBOX = 56;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 66
								FCV_HITBOX = 66;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 76
									FCV_HITBOX = 76;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 86
										FCV_HITBOX = 86;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 96
											FCV_HITBOX = 96;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Hitbox_v2()

{

	// Calcul
	// Calcul:
	//  hitbox = 1
	//  Y = 24
	//  X = 24
	FCV_HITBOX = 1;
0926  0E01      	MOVLW 0x01
0928  0100      	MOVLB 0x00
092A  6FA4      	MOVWF gbl_FCV_HITBOX, 1

	FCV_Y = 24;
092C  0E18      	MOVLW 0x18
092E  6F8C      	MOVWF gbl_FCV_Y, 1
0930  6B8D      	CLRF gbl_FCV_Y+D'1', 1

	FCV_X = 24;
0932  0E18      	MOVLW 0x18
0934  6F8E      	MOVWF gbl_FCV_X, 1
0936  6B8F      	CLRF gbl_FCV_X+D'1', 1


	// Boucle
	// Boucle: While X_SORTIE < 1
	while (FCV_X_SORTIE < 1)
0938            label51
0938  0E01      	MOVLW 0x01
093A  5D86      	SUBWF gbl_FCV_X_SORTIE, W, 1
093C  E23A      	BC	label59
093E  6787      	TSTFSZ gbl_FCV_X_SORTIE+D'1', 1
0940  D038      	BRA	label59
09B0  D7C3      	BRA	label51
09B2            label59

	{

		// Décision
		// Décision: Y_Touch < Y?
		if (FCV_Y_TOUCH < FCV_Y)
0942  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0944  5D89      	SUBWF gbl_FCV_Y_TOUCH+D'1', W, 1
0946  E102      	BNZ	label52
0948  518C      	MOVF gbl_FCV_Y, W, 1
094A  5D88      	SUBWF gbl_FCV_Y_TOUCH, W, 1
094C            label52
094C  E227      	BC	label58
094E            label53
099C            label58

		{

			// Boucle
			// Boucle: While X > X_touch
			while (1)

			{

				// Décision
				// Décision: X_Touch < X?
				if (FCV_X_TOUCH < FCV_X)
094E  518F      	MOVF gbl_FCV_X+D'1', W, 1
0950  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
0952  E102      	BNZ	label54
0954  518E      	MOVF gbl_FCV_X, W, 1
0956  5D90      	SUBWF gbl_FCV_X_TOUCH, W, 1
0958            label54
0958  E309      	BNC	label55

				{

				} else {
096C            label55


					// Calcul
					// Calcul:
					//  hitbox = hitbox + 1
					//  X = X + 24
					FCV_HITBOX = FCV_HITBOX + 1;
095A  29A4      	INCF gbl_FCV_HITBOX, W, 1
095C  6FA4      	MOVWF gbl_FCV_HITBOX, 1

					FCV_X = FCV_X + 24;
095E  6BB2      	CLRF CompTempVar2635, 1
0960  0E18      	MOVLW 0x18
0962  278E      	ADDWF gbl_FCV_X, F, 1
0964  518F      	MOVF gbl_FCV_X+D'1', W, 1
0966  23B2      	ADDWFC CompTempVar2635, F, 1
0968  51B2      	MOVF CompTempVar2635, W, 1
096A  6F8F      	MOVWF gbl_FCV_X+D'1', 1


				}

				// Calcul
				// Calcul:
				//  X_SORTIE = X_SORTIE + 1
				FCV_X_SORTIE = FCV_X_SORTIE + 1;
096C  5386      	MOVF gbl_FCV_X_SORTIE, F, 1
096E  5387      	MOVF gbl_FCV_X_SORTIE+D'1', F, 1
0970  2B86      	INCF gbl_FCV_X_SORTIE, F, 1
0972  B4D8      	BTFSC STATUS,Z
0974  2B87      	INCF gbl_FCV_X_SORTIE+D'1', F, 1



				if ((FCV_X > FCV_X_TOUCH) != 0) break;
0976  6BB1      	CLRF CompTempVar2633, 1
0978  518F      	MOVF gbl_FCV_X+D'1', W, 1
097A  5D91      	SUBWF gbl_FCV_X_TOUCH+D'1', W, 1
097C  E104      	BNZ	label56
097E  518E      	MOVF gbl_FCV_X, W, 1
0980  6190      	CPFSLT gbl_FCV_X_TOUCH, 1
0982  D001      	BRA	label56
0984  D001      	BRA	label57
0986            label56
0986  A0D8      	BTFSS STATUS,C
0988  71B1      	BTG CompTempVar2633,0, 1
098A  53B1      	MOVF CompTempVar2633, F, 1
098C  E0E0      	BZ	label53

			}

			// Appel d'une Macro
			// Appel d'une Macro: affichage_bateau()
			FCM_affichage_bateau();
098E  ECA4F002  	CALL FCM_affich_0005C


			// Calcul
			// Calcul:
			//  X = 0
			//  Y = 0
			FCV_X = 0;
0992  6B8E      	CLRF gbl_FCV_X, 1
0994  6B8F      	CLRF gbl_FCV_X+D'1', 1

			FCV_Y = 0;
0996  6B8C      	CLRF gbl_FCV_Y, 1
0998  6B8D      	CLRF gbl_FCV_Y+D'1', 1


		} else {
099A  D7CE      	BRA	label51


			// Calcul
			// Calcul:
			//  hitbox = hitbox + 10
			//  Y = Y + 24
			FCV_HITBOX = FCV_HITBOX + 10;
099C  0E0A      	MOVLW 0x0A
099E  25A4      	ADDWF gbl_FCV_HITBOX, W, 1
09A0  6FA4      	MOVWF gbl_FCV_HITBOX, 1

			FCV_Y = FCV_Y + 24;
09A2  6BB1      	CLRF CompTempVar2639, 1
09A4  0E18      	MOVLW 0x18
09A6  278C      	ADDWF gbl_FCV_Y, F, 1
09A8  518D      	MOVF gbl_FCV_Y+D'1', W, 1
09AA  23B1      	ADDWFC CompTempVar2639, F, 1
09AC  51B1      	MOVF CompTempVar2639, W, 1
09AE  6F8D      	MOVWF gbl_FCV_Y+D'1', 1


		}


	}

	// Calcul
	// Calcul:
	//  X_SORTIE = 0
	FCV_X_SORTIE = 0;
09B2  6B86      	CLRF gbl_FCV_X_SORTIE, 1
09B4  6B87      	CLRF gbl_FCV_X_SORTIE+D'1', 1


	// Calcul
	// Calcul:
	//  Tableau[Joueur1] = hitbox
	//  tableau[Joueur1] = tableau[Joueur1] || 0b00000001
	FCV_TABLEAU[FCV_JOUEUR1] = FCV_HITBOX;
09B6  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
09BA  50E9      	MOVF FSR0L, W
09BC  51A7      	MOVF gbl_FCV_JOUEUR1, W, 1
09BE  26E9      	ADDWF FSR0L, F
09C0  51A4      	MOVF gbl_FCV_HITBOX, W, 1
09C2  6EEF      	MOVWF INDF0

	FCV_TABLEAU[FCV_JOUEUR1] = FCV_TABLEAU[FCV_JOUEUR1] || 1;
09C4  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
09C6  6EE9      	MOVWF FSR0L
09C8  51A7      	MOVF gbl_FCV_JOUEUR1, W, 1
09CA  26E9      	ADDWF FSR0L, F
09CC  6BB1      	CLRF CompTempVar2643, 1
09CE  2BB1      	INCF CompTempVar2643, F, 1
09D0  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
09D2  6EE9      	MOVWF FSR0L
09D4  51A7      	MOVF gbl_FCV_JOUEUR1, W, 1
09D6  26E9      	ADDWF FSR0L, F
09D8  51B1      	MOVF CompTempVar2643, W, 1
09DA  6EEF      	MOVWF INDF0


}
09DC  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Lecture_Coordonnes()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: X_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);
08A6  0100      	MOVLB 0x00
08A8  6BB1      	CLRF FCD_0f051__0005E_arg_FCL_AXIS, 1
08AA  EC28F004  	CALL FCD_0f051__0005E
08AE  51B4      	MOVF CompTempVarRet2649, W, 1
08B0  6F90      	MOVWF gbl_FCV_X_TOUCH, 1
08B2  51B5      	MOVF CompTempVarRet2649+D'1', W, 1
08B4  6F91      	MOVWF gbl_FCV_X_TOUCH+D'1', 1


	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y_Touch=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y_TOUCH = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);
08B6  0E01      	MOVLW 0x01
08B8  6FB1      	MOVWF FCD_0f051__0005E_arg_FCL_AXIS, 1
08BA  EC28F004  	CALL FCD_0f051__0005E
08BE  51B4      	MOVF CompTempVarRet2649, W, 1
08C0  6F88      	MOVWF gbl_FCV_Y_TOUCH, 1
08C2  51B5      	MOVF CompTempVarRet2649+D'1', W, 1
08C4  6F89      	MOVWF gbl_FCV_Y_TOUCH+D'1', 1


}
08C6  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_72()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 3
		FCV_HITBOX = 3;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 13
			FCV_HITBOX = 13;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 23
				FCV_HITBOX = 23;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 33
					FCV_HITBOX = 33;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// Calcul
						// Calcul:
						//  hitbox = 43
						FCV_HITBOX = 43;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 53
							FCV_HITBOX = 53;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 63
								FCV_HITBOX = 63;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 73
									FCV_HITBOX = 73;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 83
										FCV_HITBOX = 83;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 93
											FCV_HITBOX = 93;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_168()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 7
		FCV_HITBOX = 7;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 17
			FCV_HITBOX = 17;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 27
				FCV_HITBOX = 27;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 37
					FCV_HITBOX = 37;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 47
						FCV_HITBOX = 47;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 57
							FCV_HITBOX = 57;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 67
								FCV_HITBOX = 67;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 77
									FCV_HITBOX = 77;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 87
										FCV_HITBOX = 87;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 97
											FCV_HITBOX = 97;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Initialisation()

{

	// Calcul
	// Calcul:

	// Boucle
	// Boucle: While hitbox = 100
	while (1)
08C8            label49

	{

		// Calcul
		// Calcul:
		//  tableau[hitbox] = tableau[hitbox] || 0b00000000
		//  hitbox = hitbox + 1
		FCV_TABLEAU[FCV_HITBOX] = FCV_TABLEAU[FCV_HITBOX] || 0;
08C8  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
08CC  50E9      	MOVF FSR0L, W
08CE  0100      	MOVLB 0x00
08D0  51A4      	MOVF gbl_FCV_HITBOX, W, 1
08D2  6FB2      	MOVWF CompTempVar2653, 1
08D4  51B2      	MOVF CompTempVar2653, W, 1
08D6  26E9      	ADDWF FSR0L, F
08D8  50EF      	MOVF INDF0, W
08DA  6FB3      	MOVWF CompTempVar2654, 1
08DC  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
08DE  6EE9      	MOVWF FSR0L
08E0  51A4      	MOVF gbl_FCV_HITBOX, W, 1
08E2  26E9      	ADDWF FSR0L, F
08E4  51B3      	MOVF CompTempVar2654, W, 1
08E6  6EEF      	MOVWF INDF0

		FCV_HITBOX = FCV_HITBOX + 1;
08E8  29A4      	INCF gbl_FCV_HITBOX, W, 1
08EA  6FA4      	MOVWF gbl_FCV_HITBOX, 1



		if ((FCV_HITBOX == 100) != 0) break;
08EC  6BB1      	CLRF CompTempVar2650, 1
08EE  0E64      	MOVLW 0x64
08F0  63A4      	CPFSEQ gbl_FCV_HITBOX, 1
08F2  D001      	BRA	label50
08F4  2BB1      	INCF CompTempVar2650, F, 1
08F6            label50
08F6  53B1      	MOVF CompTempVar2650, F, 1
08F8  E0E7      	BZ	label49

	}

	// Calcul
	// Calcul:
	//  tableau[Joueur1] = tableau[hitbox]
	FCV_TABLEAU[FCV_JOUEUR1] = FCV_TABLEAU[FCV_HITBOX];
08FA  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
08FE  50E9      	MOVF FSR0L, W
0900  51A4      	MOVF gbl_FCV_HITBOX, W, 1
0902  6FB1      	MOVWF CompTempVar2657, 1
0904  51B1      	MOVF CompTempVar2657, W, 1
0906  26E9      	ADDWF FSR0L, F
0908  50EF      	MOVF INDF0, W
090A  6FB2      	MOVWF CompTempVar2658, 1
090C  0E05      	MOVLW LOW(gbl_FCV_TABLEAU+D'0')
090E  6EE9      	MOVWF FSR0L
0910  51A7      	MOVF gbl_FCV_JOUEUR1, W, 1
0912  26E9      	ADDWF FSR0L, F
0914  51B2      	MOVF CompTempVar2658, W, 1
0916  6EEF      	MOVWF INDF0


	#if 0 // Disabled code
	// Calcul
	// Calcul:
	//  tableau[23] = 0b00000001
	//  tableau[24] = 0b00000001
	//  tableau[25] = 0b00000001
	FCV_TABLEAU[23] = 1;
	FCV_TABLEAU[24] = 1;
	FCV_TABLEAU[25] = 1;

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::Initialise()
	FCD_0f051_gLCD_EB076_4D1__Initialise();
0918  EC6DF003  	CALL FCD_0f051__00060


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();
091C  EC3EF002  	CALL FCD_0f051__00061


	// Appel d'une Macro
	// Appel d'une Macro: lignes()
	FCM_lignes();
0920  EC5FF002  	CALL FCM_lignes_00000


}
0924  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Reinitialisation_tactile()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_DisableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_DisableTouchscreenPicaso();
0892  EC4FF003  	CALL FCD_0f051__00063


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::G4D_EnableTouchscreenPicaso()
	FCD_0f051_gLCD_EB076_4D1__G4D_EnableTouchscreenPicaso();
0896  EC1EF003  	CALL FCD_0f051__00064


}
089A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_96()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 4
		FCV_HITBOX = 4;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 14
			FCV_HITBOX = 14;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 24
				FCV_HITBOX = 24;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 34
					FCV_HITBOX = 34;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 44
						FCV_HITBOX = 44;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 54
							FCV_HITBOX = 54;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 64
								FCV_HITBOX = 64;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 74
									FCV_HITBOX = 74;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 84
										FCV_HITBOX = 84;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 94
											FCV_HITBOX = 94;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Hitbox()
{

	// Décision
	// Décision: X < 24?
	if (FCV_X < 24)
	{

		// Appel d'une Macro
		// Appel d'une Macro: X_24()
		FCM_X_24();

	} else {

		// Décision
		// Décision: X < 48?
		if (FCV_X < 48)
		{

			// Appel d'une Macro
			// Appel d'une Macro: X_48()
			FCM_X_48();

		} else {

			// Décision
			// Décision: X < 72?
			if (FCV_X < 72)
			{

				// Appel d'une Macro
				// Appel d'une Macro: X_72()
				FCM_X_72();

			} else {

				// Décision
				// Décision: X < 96?
				if (FCV_X < 96)
				{

					// Appel d'une Macro
					// Appel d'une Macro: X_96()
					FCM_X_96();

				} else {

					// Décision
					// Décision: X < 120?
					if (FCV_X < 120)
					{

						// Appel d'une Macro
						// Appel d'une Macro: X_120()
						FCM_X_120();

					} else {

						// Décision
						// Décision: X < 144?
						if (FCV_X < 144)
						{

							// Appel d'une Macro
							// Appel d'une Macro: X_144()
							FCM_X_144();

						} else {

							// Décision
							// Décision: X < 168?
							if (FCV_X < 168)
							{

								// Appel d'une Macro
								// Appel d'une Macro: X_168()
								FCM_X_168();

							} else {

								// Décision
								// Décision: X < 192?
								if (FCV_X < 192)
								{

									// Appel d'une Macro
									// Appel d'une Macro: X_192()
									FCM_X_192();

								} else {

									// Décision
									// Décision: X < 216?
									if (FCV_X < 216)
									{

										// Appel d'une Macro
										// Appel d'une Macro: X_216()
										FCM_X_216();

									} else {

										// Décision
										// Décision: X < 240?
										if (FCV_X < 240)
										{

											// Appel d'une Macro
											// Appel d'une Macro: X_240()
											FCM_X_240();

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_24()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 1
		FCV_HITBOX = 1;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 11
			FCV_HITBOX = 11;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 21
				FCV_HITBOX = 21;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 31
					FCV_HITBOX = 31;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 41
						FCV_HITBOX = 41;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 51
							FCV_HITBOX = 51;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 61
								FCV_HITBOX = 61;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 71
									FCV_HITBOX = 71;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 81
										FCV_HITBOX = 81;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 91
											FCV_HITBOX = 91;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_240()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 10
		FCV_HITBOX = 10;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 20
			FCV_HITBOX = 20;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 30
				FCV_HITBOX = 30;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 40
					FCV_HITBOX = 40;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 50
						FCV_HITBOX = 50;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 60
							FCV_HITBOX = 60;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 70
								FCV_HITBOX = 70;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 80
									FCV_HITBOX = 80;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 90
										FCV_HITBOX = 90;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 100
											FCV_HITBOX = 100;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_affichage_bateau()

{

	// Appel de la Routine Composant
	// Appel d'une Macro: parametres_bateau(X, X-24, Y, Y-24)
	FCM_parametres_bateau(FCV_X, FCV_X - 24, FCV_Y, FCV_Y - 24);
0548  0100      	MOVLB 0x00
054A  518E      	MOVF gbl_FCV_X, W, 1
054C  6FB1      	MOVWF FCM_parame_00065_arg_FCL_POS_X1, 1
054E  518F      	MOVF gbl_FCV_X+D'1', W, 1
0550  6FB2      	MOVWF FCM_parame_00065_arg_FCL_POS_X1+D'1', 1
0552  0E18      	MOVLW 0x18
0554  5D8E      	SUBWF gbl_FCV_X, W, 1
0556  6FB3      	MOVWF FCM_parame_00065_arg_FCL_POS_X2, 1
0558  598E      	SUBWFB gbl_FCV_X, W, 1
055A  0818      	SUBLW 0x18
055C  5D8F      	SUBWF gbl_FCV_X+D'1', W, 1
055E  6FB4      	MOVWF FCM_parame_00065_arg_FCL_POS_X2+D'1', 1
0560  518C      	MOVF gbl_FCV_Y, W, 1
0562  6FB5      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1, 1
0564  518D      	MOVF gbl_FCV_Y+D'1', W, 1
0566  6FB6      	MOVWF FCM_parame_00065_arg_FCL_POS_Y1+D'1', 1
0568  0E18      	MOVLW 0x18
056A  5D8C      	SUBWF gbl_FCV_Y, W, 1
056C  6FB7      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2, 1
056E  598C      	SUBWFB gbl_FCV_Y, W, 1
0570  0818      	SUBLW 0x18
0572  5D8D      	SUBWF gbl_FCV_Y+D'1', W, 1
0574  6FB8      	MOVWF FCM_parame_00065_arg_FCL_POS_Y2+D'1', 1
0576  ECDAF001  	CALL FCM_parame_00065


}
057A  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_48()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 2
		FCV_HITBOX = 2;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 12
			FCV_HITBOX = 12;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 22
				FCV_HITBOX = 22;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 32
					FCV_HITBOX = 32;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// Calcul
						// Calcul:
						//  hitbox = 42
						FCV_HITBOX = 42;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 52
							FCV_HITBOX = 52;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 62
								FCV_HITBOX = 62;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 72
									FCV_HITBOX = 72;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 82
										FCV_HITBOX = 82;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 92
											FCV_HITBOX = 92;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Param??tres pour la macro parametres_bateau :
       :  pos_x1 : MX_UINT16
       :  pos_x2 : MX_UINT16
       :  pos_y1 : MX_UINT16
       :  pos_y2 : MX_UINT16
\*=----------------------------------------------------------------------=*/
void FCM_parametres_bateau(MX_UINT16 FCL_POS_X1, MX_UINT16 FCL_POS_X2, MX_UINT16 FCL_POS_Y1, MX_UINT16 FCL_POS_Y2)

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(50, 50, 50)
	FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(50, 50, 50);
03B4  0E32      	MOVLW 0x32
03B6  6FB9      	MOVWF FCD_0f051__00066_arg_FCL_RED, 1
03B8  6FBA      	MOVWF FCD_0f051__00066_arg_FCL_GREEN, 1
03BA  6FBB      	MOVWF FCD_0f051__00066_arg_FCL_BLUE, 1
03BC  EC43F001  	CALL FCD_0f051__00066


	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(.pos_x1, .pos_y1, .pos_x2, .pos_y2, 0, 1)
	FCD_0f051_gLCD_EB076_4D1__DrawRectangle(FCL_POS_X1, FCL_POS_Y1, FCL_POS_X2, FCL_POS_Y2, 0, 1);
03C0  51B1      	MOVF FCM_parame_00065_arg_FCL_POS_X1, W, 1
03C2  6FB9      	MOVWF FCD_0f051__00067_arg_FCL_X1, 1
03C4  51B2      	MOVF FCM_parame_00065_arg_FCL_POS_X1+D'1', W, 1
03C6  6FBA      	MOVWF FCD_0f051__00067_arg_FCL_X1+D'1', 1
03C8  51B5      	MOVF FCM_parame_00065_arg_FCL_POS_Y1, W, 1
03CA  6FBB      	MOVWF FCD_0f051__00067_arg_FCL_Y1, 1
03CC  51B6      	MOVF FCM_parame_00065_arg_FCL_POS_Y1+D'1', W, 1
03CE  6FBC      	MOVWF FCD_0f051__00067_arg_FCL_Y1+D'1', 1
03D0  51B3      	MOVF FCM_parame_00065_arg_FCL_POS_X2, W, 1
03D2  6FBD      	MOVWF FCD_0f051__00067_arg_FCL_X2, 1
03D4  51B4      	MOVF FCM_parame_00065_arg_FCL_POS_X2+D'1', W, 1
03D6  6FBE      	MOVWF FCD_0f051__00067_arg_FCL_X2+D'1', 1
03D8  51B7      	MOVF FCM_parame_00065_arg_FCL_POS_Y2, W, 1
03DA  6FBF      	MOVWF FCD_0f051__00067_arg_FCL_Y2, 1
03DC  51B8      	MOVF FCM_parame_00065_arg_FCL_POS_Y2+D'1', W, 1
03DE  6FC0      	MOVWF FCD_0f051__00067_arg_FCL_Y2+D'1', 1
03E0  6BC1      	CLRF FCD_0f051__00067_arg_FCL_T_00068, 1
03E2  0E01      	MOVLW 0x01
03E4  6FC2      	MOVWF FCD_0f051__00067_arg_FCL_SOLID, 1
03E6  ECA0F000  	CALL FCD_0f051__00067


}
03EA  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Appui_tactile()
{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	#if 0 // Disabled code
	//Commentaire:
	//Coordonnée pour X

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: X=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(0)
	FCV_X = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(0);

	#if 0 // Disabled code
	//Commentaire:
	//Coordonée pour Y

	#endif // #if 0: Disabled code
	// Appel de la Routine Composant
	// Appel de la Routine Composant: Y=gLCD_EB076_4D1::G4D_ReadTouchCoordinatesPicaso(1)
	FCV_Y = FCD_0f051_gLCD_EB076_4D1__G4D_ReadTouchCoordinatesPicaso(1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(X, 80, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_X, 80, 150, 2, 1);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::PrintNumber(Y, 120, 150, 2, 1)
	FCD_0f051_gLCD_EB076_4D1__PrintNumber(FCV_Y, 120, 150, 2, 1);

	// Pause
	// Pause: 2 s
	FCI_DELAYBYTE_S(2);

	// Appel de la Routine Composant
	// Appel de la Routine Composant: gLCD_EB076_4D1::ClearDisplay()
	FCD_0f051_gLCD_EB076_4D1__ClearDisplay();

	// Calcul
	// Calcul:
	//  Appui_Ecran = 0
	//  X = 0
	//  Y = 0
	FCV_APPUI_ECRAN = 0;
	FCV_X = 0;
	FCV_Y = 0;

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_Recuperation_coordonees()

{

	// Appel de la Routine Composant
	// Appel de la Routine Composant: Appui_Ecran=gLCD_EB076_4D1::G4D_GetTouchCoordinatesPicaso()
	FCV_APPUI_ECRAN = FCD_0f051_gLCD_EB076_4D1__G4D_GetTouchCoordinatesPicaso();
089C  ECCEF002  	CALL FCD_0f051__0006D
08A0  51B3      	MOVF CompTempVarRet2729, W, 1
08A2  6FA5      	MOVWF gbl_FCV_APPUI_ECRAN, 1


}
08A4  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_192()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 8
		FCV_HITBOX = 8;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 18
			FCV_HITBOX = 18;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 28
				FCV_HITBOX = 28;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 38
					FCV_HITBOX = 38;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 48
						FCV_HITBOX = 48;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 58
							FCV_HITBOX = 58;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 68
								FCV_HITBOX = 68;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 78
									FCV_HITBOX = 78;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 88
										FCV_HITBOX = 88;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 98
											FCV_HITBOX = 98;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_120()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 5
		FCV_HITBOX = 5;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 15
			FCV_HITBOX = 15;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 25
				FCV_HITBOX = 25;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 35
					FCV_HITBOX = 35;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 45
						FCV_HITBOX = 45;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 55
							FCV_HITBOX = 55;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 65
								FCV_HITBOX = 65;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 75
									FCV_HITBOX = 75;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 85
										FCV_HITBOX = 85;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 95
											FCV_HITBOX = 95;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_X_216()
{

	// Décision
	// Décision: Y < 24?
	if (FCV_Y < 24)
	{

		// Calcul
		// Calcul:
		//  hitbox = 9
		FCV_HITBOX = 9;

	} else {

		// Décision
		// Décision: Y < 48?
		if (FCV_Y < 48)
		{

			// Calcul
			// Calcul:
			//  hitbox = 19
			FCV_HITBOX = 19;

		} else {

			// Décision
			// Décision: Y < 72?
			if (FCV_Y < 72)
			{

				// Calcul
				// Calcul:
				//  hitbox = 29
				FCV_HITBOX = 29;

			} else {

				// Décision
				// Décision: Y < 96?
				if (FCV_Y < 96)
				{

					// Calcul
					// Calcul:
					//  hitbox = 39
					FCV_HITBOX = 39;

				} else {

					// Décision
					// Décision: Y < 120?
					if (FCV_Y < 120)
					{

						// 
						// Calcul:
						//  hitbox = 49
						FCV_HITBOX = 49;

					} else {

						// Décision
						// Décision: Y < 144?
						if (FCV_Y < 144)
						{

							// Calcul
							// Calcul:
							//  hitbox = 59
							FCV_HITBOX = 59;

						} else {

							// Décision
							// Décision: Y < 168?
							if (FCV_Y < 168)
							{

								// Calcul
								// Calcul:
								//  hitbox = 69
								FCV_HITBOX = 69;

							} else {

								// Décision
								// Décision: Y < 192?
								if (FCV_Y < 192)
								{

									// Calcul
									// Calcul:
									//  hitbox = 79
									FCV_HITBOX = 79;

								} else {

									// Décision
									// Décision: Y < 216?
									if (FCV_Y < 216)
									{

										// Calcul
										// Calcul:
										//  hitbox = 89
										FCV_HITBOX = 89;

									} else {

										// Décision
										// Décision: Y < 240?
										if (FCV_Y < 240)
										{

											// Calcul
											// Calcul:
											//  hitbox = 99
											FCV_HITBOX = 99;

										// } else {

										}

									}

								}

							}

						}

					}

				}

			}

		}

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_lignes()

{

	// Calcul
	// Calcul:
	//  X_ligne = 24
	//  Y_ligne = 24
	FCV_X_LIGNE = 24;
04BE  0E18      	MOVLW 0x18
04C0  0100      	MOVLB 0x00
04C2  6F8A      	MOVWF gbl_FCV_X_LIGNE, 1
04C4  6B8B      	CLRF gbl_FCV_X_LIGNE+D'1', 1

	FCV_Y_LIGNE = 24;
04C6  0E18      	MOVLW 0x18
04C8  6F84      	MOVWF gbl_FCV_Y_LIGNE, 1
04CA  6B85      	CLRF gbl_FCV_Y_LIGNE+D'1', 1


	// tracé des verticales
	// Boucle: While X_ligne = 240
	while (1)
04CC            label30

	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(X_ligne, 0, X_ligne, 240)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(FCV_X_LIGNE, 0, FCV_X_LIGNE, 240);
04CC  518A      	MOVF gbl_FCV_X_LIGNE, W, 1
04CE  6FB2      	MOVWF FCD_0f051__0006E_arg_FCL_X1, 1
04D0  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
04D2  6FB3      	MOVWF FCD_0f051__0006E_arg_FCL_X1+D'1', 1
04D4  6BB4      	CLRF FCD_0f051__0006E_arg_FCL_Y1, 1
04D6  6BB5      	CLRF FCD_0f051__0006E_arg_FCL_Y1+D'1', 1
04D8  518A      	MOVF gbl_FCV_X_LIGNE, W, 1
04DA  6FB6      	MOVWF FCD_0f051__0006E_arg_FCL_X2, 1
04DC  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
04DE  6FB7      	MOVWF FCD_0f051__0006E_arg_FCL_X2+D'1', 1
04E0  0EF0      	MOVLW 0xF0
04E2  6FB8      	MOVWF FCD_0f051__0006E_arg_FCL_Y2, 1
04E4  6BB9      	CLRF FCD_0f051__0006E_arg_FCL_Y2+D'1', 1
04E6  ECF6F001  	CALL FCD_0f051__0006E


		// Calcul
		// Calcul:
		//  X_ligne = X_ligne + 24
		FCV_X_LIGNE = FCV_X_LIGNE + 24;
04EA  6BB2      	CLRF CompTempVar2689, 1
04EC  0E18      	MOVLW 0x18
04EE  278A      	ADDWF gbl_FCV_X_LIGNE, F, 1
04F0  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
04F2  23B2      	ADDWFC CompTempVar2689, F, 1
04F4  51B2      	MOVF CompTempVar2689, W, 1
04F6  6F8B      	MOVWF gbl_FCV_X_LIGNE+D'1', 1



		if ((FCV_X_LIGNE == 240) != 0) break;
04F8  6BB1      	CLRF CompTempVar2687, 1
04FA  0EF0      	MOVLW 0xF0
04FC  638A      	CPFSEQ gbl_FCV_X_LIGNE, 1
04FE  D003      	BRA	label31
0500  518B      	MOVF gbl_FCV_X_LIGNE+D'1', W, 1
0502  B4D8      	BTFSC STATUS,Z
0504  2BB1      	INCF CompTempVar2687, F, 1
0506            label31
0506  53B1      	MOVF CompTempVar2687, F, 1
0508  E0E1      	BZ	label30

	}

	// tracé des horizontales
	// Boucle: While Y_ligne <= 240
	while (1)
	{

		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawLine(0, Y_ligne, 240, Y_ligne)
		FCD_0f051_gLCD_EB076_4D1__DrawLine(0, FCV_Y_LIGNE, 240, FCV_Y_LIGNE);
050A  6BB2      	CLRF FCD_0f051__0006E_arg_FCL_X1, 1
050C  6BB3      	CLRF FCD_0f051__0006E_arg_FCL_X1+D'1', 1
050E  5184      	MOVF gbl_FCV_Y_LIGNE, W, 1
0510  6FB4      	MOVWF FCD_0f051__0006E_arg_FCL_Y1, 1
0512  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
0514  6FB5      	MOVWF FCD_0f051__0006E_arg_FCL_Y1+D'1', 1
0516  0EF0      	MOVLW 0xF0
0518  6FB6      	MOVWF FCD_0f051__0006E_arg_FCL_X2, 1
051A  6BB7      	CLRF FCD_0f051__0006E_arg_FCL_X2+D'1', 1
051C  5184      	MOVF gbl_FCV_Y_LIGNE, W, 1
051E  6FB8      	MOVWF FCD_0f051__0006E_arg_FCL_Y2, 1
0520  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
0522  6FB9      	MOVWF FCD_0f051__0006E_arg_FCL_Y2+D'1', 1
0524  ECF6F001  	CALL FCD_0f051__0006E


		// Calcul
		// Calcul:
		//  Y_ligne = Y_ligne + 24
		FCV_Y_LIGNE = FCV_Y_LIGNE + 24;
0528  6BB2      	CLRF CompTempVar2692, 1
052A  0E18      	MOVLW 0x18
052C  2784      	ADDWF gbl_FCV_Y_LIGNE, F, 1
052E  5185      	MOVF gbl_FCV_Y_LIGNE+D'1', W, 1
0530  23B2      	ADDWFC CompTempVar2692, F, 1
0532  51B2      	MOVF CompTempVar2692, W, 1
0534  6F85      	MOVWF gbl_FCV_Y_LIGNE+D'1', 1



		if ((FCV_Y_LIGNE <= 240) == 0) break;
0536  6BB1      	CLRF CompTempVar2690, 1
0538  0EF0      	MOVLW 0xF0
053A  6584      	CPFSGT gbl_FCV_Y_LIGNE, 1
053C  6785      	TSTFSZ gbl_FCV_Y_LIGNE+D'1', 1
053E  D001      	BRA	label33
0540  2BB1      	INCF CompTempVar2690, F, 1
0542            label33
0542  53B1      	MOVF CompTempVar2690, F, 1
0544  E1E2      	BNZ	label32

	}

}
0546  0012      	RETURN




/*========================================================================*\
   Use :Principale
\*========================================================================*/
void main()

{
adcon1 = 0x0F;
0AFA  0E0F      	MOVLW 0x0F
0AFC  6EC1      	MOVWF gbl_adcon1





	// Appel d'une Macro
	// Appel d'une Macro: Initialisation()
	FCM_Initialisation();
0AFE  EC64F004  	CALL FCM_Initia_0005F


	// Boucle
	// Boucle: While 1
	while (1)
0B02            label68
0BF0  D788      	BRA	label68

	{

		// Appel d'une Macro
		// Appel d'une Macro: Reinitialisation_tactile()
		FCM_Reinitialisation_tactile();
0B02  EC49F004  	CALL FCM_Reinit_00062


		// Boucle
		// Boucle: While Appui_Ecran = 0
		while (FCV_APPUI_ECRAN == 0)
0B06            label69
0B06  53A5      	MOVF gbl_FCV_APPUI_ECRAN, F, 1
0B08  E103      	BNZ	label70
0B0E  D7FB      	BRA	label69
0B10            label70

		{

			// Appel d'une Macro
			// Appel d'une Macro: Recuperation_coordonees()
			FCM_Recuperation_coordonees();
0B0A  EC4EF004  	CALL FCM_Recupe_0006C



		}

		// Appel d'une Macro
		// Appel d'une Macro: Lecture_Coordonnes()
		FCM_Lecture_Coordonnes();
0B10  EC53F004  	CALL FCM_Lectur_0005D


		// Appel d'une Macro
		// Appel d'une Macro: Hitbox_v2()
		FCM_Hitbox_v2();
0B14  EC93F004  	CALL FCM_Hitbox_0005B


		#if 0 // Disabled code
		// Appel d'une Macro
		// Appel d'une Macro: affichage_bateau()
		FCM_affichage_bateau();

		#endif // #if 0: Disabled code
		#if 0 // Disabled code
		// Pause
		// Pause: 2 s
		FCI_DELAYBYTE_S(2);

		#endif // #if 0: Disabled code
		// Calcul
		// Calcul:
		//  Appui_Ecran = 0
		FCV_APPUI_ECRAN = 0;
0B18  6BA5      	CLRF gbl_FCV_APPUI_ECRAN, 1


		// Décision
		// Décision: tableau[Joueur1] = 0b00000001?
		if (FCV_TABLEAU[FCV_JOUEUR1] == 1)
0B1A  EE00F005  	LFSR 0x00, gbl_FCV_TABLEAU
0B1E  50E9      	MOVF FSR0L, W
0B20  51A7      	MOVF gbl_FCV_JOUEUR1, W, 1
0B22  26E9      	ADDWF FSR0L, F
0B24  04EF      	DECF INDF0, W
0B26  E122      	BNZ	label71
0B6C            label71

		{

			// Appel de la Routine Composant
			// Appel de la Routine Composant: gLCD_EB076_4D1::Print("Touche", 120, 260, 2, 1)
			FCD_0f051_gLCD_EB076_4D1__Print("Touche", 7, 120, 260, 2, 1);
0B28  0E54      	MOVLW 0x54
0B2A  6FB3      	MOVWF CompTempVar3013, 1
0B2C  0E6F      	MOVLW 0x6F
0B2E  6FB4      	MOVWF CompTempVar3013+D'1', 1
0B30  0E75      	MOVLW 0x75
0B32  6FB5      	MOVWF CompTempVar3013+D'2', 1
0B34  0E63      	MOVLW 0x63
0B36  6FB6      	MOVWF CompTempVar3013+D'3', 1
0B38  0E68      	MOVLW 0x68
0B3A  6FB7      	MOVWF CompTempVar3013+D'4', 1
0B3C  0E65      	MOVLW 0x65
0B3E  6FB8      	MOVWF CompTempVar3013+D'5', 1
0B40  6BB9      	CLRF CompTempVar3013+D'6', 1
0B42  0E00      	MOVLW HIGH(CompTempVar3013+D'0')
0B44  6FB2      	MOVWF FCD_0f051__0008D_arg_FCL_STR+D'1', 1
0B46  0EB3      	MOVLW LOW(CompTempVar3013+D'0')
0B48  6FB1      	MOVWF FCD_0f051__0008D_arg_FCL_STR, 1
0B4A  0E07      	MOVLW 0x07
0B4C  6FBE      	MOVWF FCD_0f051__0008D_arg_FCLsz_STR, 1
0B4E  6BBF      	CLRF FCD_0f051__0008D_arg_FCLsz_STR+D'1', 1
0B50  0E78      	MOVLW 0x78
0B52  6FC0      	MOVWF FCD_0f051__0008D_arg_FCL_X1, 1
0B54  6BC1      	CLRF FCD_0f051__0008D_arg_FCL_X1+D'1', 1
0B56  0E04      	MOVLW 0x04
0B58  6FC2      	MOVWF FCD_0f051__0008D_arg_FCL_Y1, 1
0B5A  0E01      	MOVLW 0x01
0B5C  6FC3      	MOVWF FCD_0f051__0008D_arg_FCL_Y1+D'1', 1
0B5E  0E02      	MOVLW 0x02
0B60  6FC4      	MOVWF FCD_0f051__0008D_arg_FCL_FONT, 1
0B62  0E01      	MOVLW 0x01
0B64  6FC5      	MOVWF FCD_0f051__0008D_arg_FCL_T_0008E, 1
0B66  EC0AF005  	CALL FCD_0f051__0008D


		} else {
0B6A  D027      	BRA	label72
0BBA            label72


			// Appel de la Routine Composant
			// Appel de la Routine Composant: gLCD_EB076_4D1::Print("non Touche", 120, 260, 2, 1)
			FCD_0f051_gLCD_EB076_4D1__Print("non Touche", 11, 120, 260, 2, 1);
0B6C  0E20      	MOVLW 0x20
0B6E  6FB6      	MOVWF CompTempVar3015+D'3', 1
0B70  0E54      	MOVLW 0x54
0B72  6FB7      	MOVWF CompTempVar3015+D'4', 1
0B74  0E63      	MOVLW 0x63
0B76  6FBA      	MOVWF CompTempVar3015+D'7', 1
0B78  0E65      	MOVLW 0x65
0B7A  6FBC      	MOVWF CompTempVar3015+D'9', 1
0B7C  0E68      	MOVLW 0x68
0B7E  6FBB      	MOVWF CompTempVar3015+D'8', 1
0B80  0E6E      	MOVLW 0x6E
0B82  6FB3      	MOVWF CompTempVar3015, 1
0B84  6FB5      	MOVWF CompTempVar3015+D'2', 1
0B86  0E6F      	MOVLW 0x6F
0B88  6FB4      	MOVWF CompTempVar3015+D'1', 1
0B8A  6FB8      	MOVWF CompTempVar3015+D'5', 1
0B8C  0E75      	MOVLW 0x75
0B8E  6FB9      	MOVWF CompTempVar3015+D'6', 1
0B90  6BBD      	CLRF CompTempVar3015+D'10', 1
0B92  0E00      	MOVLW HIGH(CompTempVar3015+D'0')
0B94  6FB2      	MOVWF FCD_0f051__0008D_arg_FCL_STR+D'1', 1
0B96  0EB3      	MOVLW LOW(CompTempVar3015+D'0')
0B98  6FB1      	MOVWF FCD_0f051__0008D_arg_FCL_STR, 1
0B9A  0E0B      	MOVLW 0x0B
0B9C  6FBE      	MOVWF FCD_0f051__0008D_arg_FCLsz_STR, 1
0B9E  6BBF      	CLRF FCD_0f051__0008D_arg_FCLsz_STR+D'1', 1
0BA0  0E78      	MOVLW 0x78
0BA2  6FC0      	MOVWF FCD_0f051__0008D_arg_FCL_X1, 1
0BA4  6BC1      	CLRF FCD_0f051__0008D_arg_FCL_X1+D'1', 1
0BA6  0E04      	MOVLW 0x04
0BA8  6FC2      	MOVWF FCD_0f051__0008D_arg_FCL_Y1, 1
0BAA  0E01      	MOVLW 0x01
0BAC  6FC3      	MOVWF FCD_0f051__0008D_arg_FCL_Y1+D'1', 1
0BAE  0E02      	MOVLW 0x02
0BB0  6FC4      	MOVWF FCD_0f051__0008D_arg_FCL_FONT, 1
0BB2  0E01      	MOVLW 0x01
0BB4  6FC5      	MOVWF FCD_0f051__0008D_arg_FCL_T_0008E, 1
0BB6  EC0AF005  	CALL FCD_0f051__0008D


		}

		// Pause
		// Pause: 500 ms
		FCI_DELAYINT_MS(500);
0BBA  0EF4      	MOVLW 0xF4
0BBC  6FB1      	MOVWF FCI_DELAYI_00046_arg_Delay, 1
0BBE  0E01      	MOVLW 0x01
0BC0  6FB2      	MOVWF FCI_DELAYI_00046_arg_Delay+D'1', 1
0BC2  ECEFF004  	CALL FCI_DELAYI_00046


		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::SetForegroundColour(255, 255, 255)
		FCD_0f051_gLCD_EB076_4D1__SetForegroundColour(255, 255, 255);
0BC6  69B9      	SETF FCD_0f051__00066_arg_FCL_RED, 1
0BC8  69BA      	SETF FCD_0f051__00066_arg_FCL_GREEN, 1
0BCA  69BB      	SETF FCD_0f051__00066_arg_FCL_BLUE, 1
0BCC  EC43F001  	CALL FCD_0f051__00066


		// Appel de la Routine Composant
		// Appel de la Routine Composant: gLCD_EB076_4D1::DrawRectangle(0, 241, 240, 320, 1, 1)
		FCD_0f051_gLCD_EB076_4D1__DrawRectangle(0, 241, 240, 320, 1, 1);
0BD0  6BB9      	CLRF FCD_0f051__00067_arg_FCL_X1, 1
0BD2  6BBA      	CLRF FCD_0f051__00067_arg_FCL_X1+D'1', 1
0BD4  0EF1      	MOVLW 0xF1
0BD6  6FBB      	MOVWF FCD_0f051__00067_arg_FCL_Y1, 1
0BD8  6BBC      	CLRF FCD_0f051__00067_arg_FCL_Y1+D'1', 1
0BDA  0EF0      	MOVLW 0xF0
0BDC  6FBD      	MOVWF FCD_0f051__00067_arg_FCL_X2, 1
0BDE  6BBE      	CLRF FCD_0f051__00067_arg_FCL_X2+D'1', 1
0BE0  0E40      	MOVLW 0x40
0BE2  6FBF      	MOVWF FCD_0f051__00067_arg_FCL_Y2, 1
0BE4  0E01      	MOVLW 0x01
0BE6  6FC0      	MOVWF FCD_0f051__00067_arg_FCL_Y2+D'1', 1
0BE8  6FC1      	MOVWF FCD_0f051__00067_arg_FCL_T_00068, 1
0BEA  6FC2      	MOVWF FCD_0f051__00067_arg_FCL_SOLID, 1
0BEC  ECA0F000  	CALL FCD_0f051__00067



	}

	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interruption
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

}
0C98  CFEAF001  	MOVFF FSR0H,  Int1Context
0C9C  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
0CA0  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
0CA4  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
0CA8  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
0CAC  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
0CB0  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
0CB4  C001FFEA  	MOVFF Int1Context,  FSR0H
0CB8  0011      	RETFIE 1






/*********************************************************************
 *                  Flowcode CAL UART File
 *
 * File: PIC_CAL_UART.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 020911 | BR | Updated variables with typedef alternatives
 * 011211 | BR | Converted to new dynamic defines mechanism
 * 160112 | BR | Fixed issues with rx return type and low bauds on fast devices
 * 020212 | ST | Added <MX_UART_2_PIE4> routing to account for differences in 16F and 18F devices with 2 UARTs
 * 270212 | BR | Fixed a bug in the receive functionality
 * 280212 | BR | Sorted out auto echo functionality
 * 160412 | BR | Addition of HW change baud function
 * 100912 | BR | Minor bug fix for UART 2 where pir3 was referenced instead of definition
 * 240413 | LM | Fixed typo re PORT_1 -> PORT_X for Software UART
 * 030713 | LM | Standard API calls
 * 220713 | LM | Remappable registers to lower case (for @ defs)
 * 300914 | BR | Tried to make the baud calculation a bit more reliable for higher speed bauds at odd crystal frequencies
 * 161014 | LM | Register redefinitions (for PIC18F24K50)
 */


#if (!defined(BAUDCON) && defined(BAUDCON1))
	#define baudcon baudcon1
#endif
#if (!defined(RCSTA) && defined(RCSTA1))
	#define rcsta rcsta1
#endif
#if (!defined(SPBRG) && defined(SPBRG1))
	#define spbrg spbrg1
#endif
#if (!defined(SPBRGH) && defined(SPBRGH1))
	#define spbrgh spbrgh1
#endif
#if (!defined(TXREG) && defined(TXREG1))
	#define txreg txreg1
#endif
#if (!defined(RCREG) && defined(RCREG1))
	#define rcreg rcreg1
#endif
#if (!defined(TXSTA) && defined(TXSTA1))
	#define txsta txsta1
#endif

#ifndef MX_UART_SW_DEFS
	#define MX_UART_SW_DEFS

	#ifdef _BOOSTC
		#define INST_COUNT	45	//65 for lower speeds or 40 for higher speeds.
	#endif
	#ifdef HI_TECH_C
		#define INST_COUNT	315
	#endif

	//Work out number of nops for software baud rate
	#define MX_INSTRUCTION_SPEED 	(MX_CLK_SPEED / 4)
	#define MX_OVERHEAD				(MX_INSTRUCTION_SPEED / INST_COUNT)
	#define SW_OFFSET				(1000000 / MX_OVERHEAD)

#endif

 #if defined(MX_UART_CHANNEL_1) && (MX_UART_NUM==1)
	#if (MX_UART_CHANNEL_1 == 0)

		#define MX_SOFT_BAUD_1 (1000000 / MX_UART_BAUD_1) - SW_OFFSET

		#if (MX_SOFT_BAUD_1 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_1	1
		#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1	0

		#if (MX_HARD_BAUD_1 > 255)
			#undef MX_HARD_BAUD_1
			#undef MX_HARD_SLOW_1
			#define MX_HARD_BAUD_1	(((MX_CLK_SPEED / MX_UART_BAUD_1) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_1	1

			#if (MX_HARD_BAUD_1 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif

	#endif
 #endif
 #if defined(MX_UART_CHANNEL_2) && (MX_UART_NUM==2)
	#if (MX_UART_CHANNEL_2 == 0)

		#define MX_SOFT_BAUD_2 (1000000 / MX_UART_BAUD_2) - SW_OFFSET

		#if (MX_SOFT_BAUD_2 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_2	1
		#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2	0

		#if (MX_HARD_BAUD_2 > 255)
			#undef MX_HARD_BAUD_2
			#undef MX_HARD_SLOW_2
			#define MX_HARD_BAUD_2	(((MX_CLK_SPEED / MX_UART_BAUD_2) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_2	1

			#if (MX_HARD_BAUD_2 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif
		#endif
 	#endif
 #endif
 #if defined(MX_UART_CHANNEL_3) && (MX_UART_NUM==3)
	#if (MX_UART_CHANNEL_3 == 0)

		#define MX_SOFT_BAUD_3 (1000000 / MX_UART_BAUD_3) - SW_OFFSET

		#if (MX_SOFT_BAUD_3 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_3	1
		#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_3	0

		#if (MX_HARD_BAUD_3 > 255)
			#undef MX_HARD_BAUD_3
			#undef MX_HARD_SLOW_3
			#define MX_HARD_BAUD_3	(((MX_CLK_SPEED / MX_UART_BAUD_3) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_3	1

			#if (MX_HARD_BAUD_3 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif
 #if defined(MX_UART_CHANNEL_4) && (MX_UART_NUM==4)
	#if (MX_UART_CHANNEL_4 == 0)

		#define MX_SOFT_BAUD_4 (1000000 / MX_UART_BAUD_4) - SW_OFFSET

		#if (MX_SOFT_BAUD_4 < 1)
			#error "Software UART Baud Rate Not Available At This Clock Speed"
		#endif

	#else
		#define MX_SOFT_BAUD_4	1
		#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8) / 16)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4	0

		#if (MX_HARD_BAUD_4 > 255)
			#undef MX_HARD_BAUD_4
			#undef MX_HARD_SLOW_4
			#define MX_HARD_BAUD_4	(((MX_CLK_SPEED / MX_UART_BAUD_4) - 8)	/ 64)		//Was - 16 but had issues with rounding down
			#define MX_HARD_SLOW_4	1

			#if (MX_HARD_BAUD_4 > 255)
				#warning "The baud rate you have entered cannot be reached (too slow for crystal speed)"
			#endif

		#endif
	#endif
 #endif


//Hardware Baud update definitions
#ifndef MX_HARD_BAUD_CHANGE_DEFS
	#define MX_HARD_BAUD_CHANGE_DEFS

	#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_1200 > 255)
		#undef MX_HARD_BAUD_1200
		#define MX_HARD_BAUD_1200	(((MX_CLK_SPEED / 1200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_1200	1
	#else
		#define MX_HARD_SLOW_1200	0
	#endif

	#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_2400 > 255)
		#undef MX_HARD_BAUD_2400
		#define MX_HARD_BAUD_2400	(((MX_CLK_SPEED / 2400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_2400	1
	#else
		#define MX_HARD_SLOW_2400	0
	#endif

	#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_4800 > 255)
		#undef MX_HARD_BAUD_4800
		#define MX_HARD_BAUD_4800	(((MX_CLK_SPEED / 4800) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_4800	1
	#else
		#define MX_HARD_SLOW_4800	0
	#endif

	#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_9600 > 255)
		#undef MX_HARD_BAUD_9600
		#define MX_HARD_BAUD_9600	(((MX_CLK_SPEED / 9600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_9600	1
	#else
		#define MX_HARD_SLOW_9600	0
	#endif

	#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_19200 > 255)
		#undef MX_HARD_BAUD_19200
		#define MX_HARD_BAUD_19200	(((MX_CLK_SPEED / 19200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_19200	1
	#else
		#define MX_HARD_SLOW_19200	0
	#endif

	#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_38400 > 255)
		#undef MX_HARD_BAUD_38400
		#define MX_HARD_BAUD_38400	(((MX_CLK_SPEED / 38400) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_38400	1
	#else
		#define MX_HARD_SLOW_38400	0
	#endif

	#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_57600 > 255)
		#undef MX_HARD_BAUD_57600
		#define MX_HARD_BAUD_57600	(((MX_CLK_SPEED / 57600) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_57600	1
	#else
		#define MX_HARD_SLOW_57600	0
	#endif

	#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 16)		//Was - 16 but had issues with rounding down
	#if (MX_HARD_BAUD_115200 > 255)
		#undef MX_HARD_BAUD_115200
		#define MX_HARD_BAUD_115200	(((MX_CLK_SPEED / 115200) - 8) / 64)		//Was - 16 but had issues with rounding down
		#define MX_HARD_SLOW_115200	1
	#else
		#define MX_HARD_SLOW_115200	0
	#endif
#endif

#define MX_RECEIVE_DELAY 	(MX_CLK_SPEED / 400000)


//Dynamic function naming based on defines and index number
#define MX_UART_CHANNEL_X	CAL_APPEND(MX_UART_CHANNEL_, MX_UART_NUM)
#define MX_UART_TX_PIN_X	CAL_APPEND(MX_UART_TX_PIN_, MX_UART_NUM)
#define MX_UART_TX_PORT_X	CAL_APPEND(MX_UART_TX_PORT_, MX_UART_NUM)
#define MX_UART_TX_TRIS_X	CAL_APPEND(MX_UART_TX_TRIS_, MX_UART_NUM)
#define MX_UART_RX_PIN_X	CAL_APPEND(MX_UART_RX_PIN_, MX_UART_NUM)
#define MX_UART_RX_PORT_X	CAL_APPEND(MX_UART_RX_PORT_, MX_UART_NUM)
#define MX_UART_RX_TRIS_X	CAL_APPEND(MX_UART_RX_TRIS_, MX_UART_NUM)
#define MX_UART_FLOWEN_X	CAL_APPEND(MX_UART_FLOWEN_, MX_UART_NUM)
#define MX_UART_CTS_PIN_X	CAL_APPEND(MX_UART_CTS_PIN_, MX_UART_NUM)
#define MX_UART_CTS_PORT_X	CAL_APPEND(MX_UART_CTS_PORT_, MX_UART_NUM)
#define MX_UART_CTS_TRIS_X	CAL_APPEND(MX_UART_CTS_TRIS_, MX_UART_NUM)
#define MX_UART_RTS_PIN_X	CAL_APPEND(MX_UART_RTS_PIN_, MX_UART_NUM)
#define MX_UART_RTS_PORT_X	CAL_APPEND(MX_UART_RTS_PORT_, MX_UART_NUM)
#define MX_UART_RTS_TRIS_X	CAL_APPEND(MX_UART_RTS_TRIS_, MX_UART_NUM)
#define MX_UART_DBITS_X		CAL_APPEND(MX_UART_DBITS_, MX_UART_NUM)
#define MX_UART_RETURN_X	CAL_APPEND(MX_UART_RETURN_, MX_UART_NUM)
#define MX_UART_ECHO_X		CAL_APPEND(MX_UART_ECHO_, MX_UART_NUM)
#define MX_UART_INT_X		CAL_APPEND(MX_UART_INT_, MX_UART_NUM)
#define MX_UART_BAUD_X		CAL_APPEND(MX_HARD_BAUD_, MX_UART_NUM)
#define MX_SOFT_BAUD_X		CAL_APPEND(MX_SOFT_BAUD_, MX_UART_NUM)
#define MX_HARD_SLOW_X		CAL_APPEND(MX_HARD_SLOW_, MX_UART_NUM)

#define UART_Delay_CAL		CAL_APPEND(FC_CAL_UART_Delay_, MX_UART_NUM)
#define UART_Send			CAL_APPEND(FC_CAL_UART_Send_, MX_UART_NUM)
#define UART_Uninit			CAL_APPEND(FC_CAL_UART_Uninit_, MX_UART_NUM)


//Component Definitions
#define UART_STATUS_LOOP	0
#define UART_STATUS_TIMEOUT	1
#define UART_STATUS_RXBYTE	2


//Interrupt Definitions
#ifdef MX_UART_2_PIE4
  #define MX_UART2_PIE pie4
  #define MX_UART2_PIR pir4
  #define MX_UART2_TXSTA tx2sta
  #define MX_UART2_RCSTA rc2sta
  #define MX_UART2_TXREG tx2reg
  #define MX_UART2_RCREG rc2reg
#else
  #define MX_UART2_PIE pie3
  #define MX_UART2_PIR pir3
  #define MX_UART2_TXSTA txsta2
  #define MX_UART2_RCSTA rcsta2
  #define MX_UART2_TXREG txreg2
  #define MX_UART2_RCREG rcreg2
#endif

#if (MX_UART_INT_X == 1)

	#ifndef MX_UART_INT_DEFS
	#define MX_UART_INT_DEFS

		#define MX_UART_INT_CH1_FUNC
		#define MX_UART_INT_CH2_FUNC
		#define MX_UART_INT_FUNC_END

		#define MX_UART_INT_CH1_DET		ts_bit(pir1, RCIF) && ts_bit(pie1, RCIE)
		#define MX_UART_INT_CH2_DET		ts_bit(MX_UART2_PIR, RC2IF) && ts_bit(MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_EN		st_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_EN		st_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_DIS		cr_bit (pie1, RCIE)
		#define MX_UART_INT_CH2_DIS		cr_bit (MX_UART2_PIE, RC2IE)

		#define MX_UART_INT_CH1_CLR		cr_bit (pir1, RCIF)
		#define MX_UART_INT_CH2_CLR		cr_bit (MX_UART2_PIR, RC2IF)

	#endif
#endif


//Function Prototypes
CALFUNCTION(void, FC_CAL_UART_Init_, (void));
CALFUNCTION(void, FC_CAL_UART_Uninit_, (void));
CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar));
CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout));
CALFUNCTION(void, FC_CAL_UART_Delay_, (void));
CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud));


//Peripheral Functions
CALFUNCTION(void, FC_CAL_UART_Init_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR 	(MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)

		  #ifdef MX_UART_1_REMAPPABLE
			MX_UART_1_TX_RPOR = MX_UART_1_TX_UTX;
			MX_UART_1_RX_RPINR = MX_UART_1_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(txsta, BRGH);						//Low Speed
		  #else
			st_bit(txsta, BRGH);						//High Speed
02E2  84AC      	BSF gbl_txsta,2

		  #endif
			spbrg = MX_UART_BAUD_X;   					// set the baud rate
02E4  0E7F      	MOVLW 0x7F
02E6  6EAF      	MOVWF gbl_spbrg

			rcsta = 0;                    				// 8-bit, disabled
02E8  6AAB      	CLRF gbl_rcsta


			#if(MX_UART_DBITS_X == 9)
				st_bit(txsta, TX9);   					// 9-bit TX
				st_bit(rcsta, RX9);                    	// 9-bit RX
			#endif

			st_bit(rcsta, SPEN);         				// turn on serial interface
02EA  8EAB      	BSF gbl_rcsta,7

			st_bit(txsta, TXEN);
02EC  8AAC      	BSF gbl_txsta,5

			st_bit(rcsta, CREN);
02EE  88AB      	BSF gbl_rcsta,4


			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH1_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (pie1, RCIE);
02F0  9A9D      	BCF gbl_pie1,5

			#endif

	#endif


	#if (MX_UART_CHANNEL_X == 2)

		  #ifdef MX_UART_2_REMAPPABLE
			MX_UART_2_TX_RPOR = MX_UART_2_TX_UTX;
			MX_UART_2_RX_RPINR = MX_UART_2_RX_RP;
		  #endif

		  #if (MX_HARD_SLOW_X == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);				//Low Speed
		  #else
			st_bit(MX_UART2_TXSTA, BRGH);				//High Speed
		  #endif

			spbrg2 = MX_UART_BAUD_X;   					// set the baud rate
			MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

			#if(MX_UART_DBITS_X == 9)
				st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
				st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
			#endif

			st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
			st_bit(MX_UART2_TXSTA, TXEN);
			st_bit(MX_UART2_RCSTA, CREN);

			#if (MX_UART_INT_X == 1)
				MX_UART_INT_CH2_EN;
				st_bit(intcon, PEIE);
				st_bit(intcon, GIE);
			#else
				cr_bit (MX_UART2_PIE, RC2IE);
			#endif

	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
02F2  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Uninit_, (void))

{

	#if (MX_UART_CHANNEL_X == 0)
		FC_CAL_Bit_In_DDR (MX_UART_RX_PORT_X, MX_UART_RX_TRIS_X, MX_UART_RX_PIN_X);		// Receive pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_TX_PORT_X, MX_UART_TX_TRIS_X, MX_UART_TX_PIN_X);		// Transmit pin is default high
	#endif

	#if (MX_UART_CHANNEL_X == 1)
			rcsta = 0;                    								// 8-bit, disabled
013A  6AAB      	CLRF gbl_rcsta

			txsta = 0;
013C  6AAC      	CLRF gbl_txsta

		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH1_DIS;
		  #endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)
			MX_UART2_RCSTA = 0;                    								// 8-bit, disabled
			MX_UART2_TXSTA = 0;
		  #ifdef MX_UART_RXINT
			MX_UART_INT_CH2_DIS;
		  #endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)										//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);		// CTS pin is a input
		FC_CAL_Bit_In_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);		// RTS not ready to accept data
	#endif
}
013E  0012      	RETURN




CALFUNCTION(void, FC_CAL_UART_Send_, (MX_UINT16 nChar))

{
	#if (MX_UART_FLOWEN_X == 1)
		while (FC_CAL_Bit_In(MX_UART_CTS_PORT_X, MX_UART_CTS_PIN_X) != 0);	// Wait until CTS is low
	#endif

	#if (MX_UART_CHANNEL_X == 0)													// Software UART TX
		MX_UINT8 idx;
		FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Start bit
		UART_Delay_CAL();
		for (idx = 0; idx < MX_UART_DBITS_X; idx++)
		{
			if (nChar & 0x01)														// Mask off data bit
				FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			else
				FC_CAL_Bit_Low(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);
			UART_Delay_CAL();
			nChar = nChar >> 1;														// Move to next data bit
		}
		FC_CAL_Bit_High(MX_UART_TX_PORT_X, MX_UART_TX_PIN_X);					// Send Stop bit
		UART_Delay_CAL();
	#endif

	#if (MX_UART_CHANNEL_X == 1)
		while (ts_bit(pir1, TXIF) == 0);
008C            label5
008C  0E10      	MOVLW 0x10
008E  149E      	ANDWF gbl_pir1, W
0090  6FCA      	MOVWF CompTempVar2752, 1
0092  53CA      	MOVF CompTempVar2752, F, 1
0094  E0FB      	BZ	label5


		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(txsta, TX9D);
			else
				cr_bit(txsta, TX9D);
	  	#endif
		txreg = nChar;
0096  51C8      	MOVF FC_CAL_UAR_00073_arg_nChar, W, 1
0098  6EAD      	MOVWF gbl_txreg

	#endif

	#if (MX_UART_CHANNEL_X == 2)
		while (ts_bit(MX_UART2_PIR, TX2IF) == 0);

		#if (MX_UART_DBITS_X == 9)
			if (test_bit(nChar, 8))
				st_bit(MX_UART2_TXSTA, TX9D);
			else
				cr_bit(MX_UART2_TXSTA, TX9D);
		#endif
		MX_UART2_TXREG = nChar;
	#endif
}
009A  0012      	RETURN



CALFUNCTION(MX_SINT16, FC_CAL_UART_Receive_, (MX_UINT8 nTimeout))

{
  #if (MX_UART_RETURN_X == 1)
	MX_UINT16 retVal = 512;
  #else
  	MX_UINT8 retVal = 255;
009C  69C9      	SETF FC_CAL_UAR_00072_1_retVal, 1

  #endif

	MX_UINT8 delay1 = 0;
009E  6BCA      	CLRF FC_CAL_UAR_00072_1_delay1, 1

	MX_UINT8 regcheck = 0;
00A0  6BCB      	CLRF FC_CAL_UAR_00072_1_regcheck, 1

	MX_UINT8 bWaitForever = 0;
00A2  6BCC      	CLRF FC_CAL_UAR_00072_1_bWaitForever, 1

	MX_UINT8 rxStatus = UART_STATUS_LOOP;
00A4  6BCD      	CLRF FC_CAL_UAR_00072_1_rxStatus, 1

	MX_UINT16 delaycnt;

  #if (MX_UART_CHANNEL_X == 0)
  	MX_UINT8 idx;
  #else
  	MX_UINT8 dummy = 0;
00A6  6BD0      	CLRF FC_CAL_UAR_00072_1_dummy, 1

  #endif

	if (nTimeout == 255)
00A8  29C8      	INCF FC_CAL_UAR_00072_arg_nTimeout, W, 1
00AA  E102      	BNZ	label6
00B0            label6

		bWaitForever = 1;
00AC  0E01      	MOVLW 0x01
00AE  6FCC      	MOVWF FC_CAL_UAR_00072_1_bWaitForever, 1


	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_Low (MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);			// Ready to accept data
	#endif

	while (rxStatus == UART_STATUS_LOOP)
00B0  53CD      	MOVF FC_CAL_UAR_00072_1_rxStatus, F, 1
00B2  E124      	BNZ	label11
00FA  D7DA      	BRA	label6
00FC            label11

	{
		if (bWaitForever == 0)
00B4  53CC      	MOVF FC_CAL_UAR_00072_1_bWaitForever, F, 1
00B6  E118      	BNZ	label10

		{
			if (nTimeout == 0)							//don't wait forever, so do timeout thing...
00B8  53C8      	MOVF FC_CAL_UAR_00072_arg_nTimeout, F, 1
00BA  E103      	BNZ	label7
00C2            label7

			{
				rxStatus = UART_STATUS_TIMEOUT;
00BC  0E01      	MOVLW 0x01
00BE  6FCD      	MOVWF FC_CAL_UAR_00072_1_rxStatus, 1

			}
			else
00C0  D013      	BRA	label10

			{
				for (delaycnt = 0; delaycnt < MX_RECEIVE_DELAY; delaycnt++);	//Delay without calling delay function
00C2  6BCE      	CLRF FC_CAL_UAR_00072_1_delaycnt, 1
00C4  6BCF      	CLRF FC_CAL_UAR_00072_1_delaycnt+D'1', 1
00C6            label8
00C6  0E31      	MOVLW 0x31
00C8  5DCE      	SUBWF FC_CAL_UAR_00072_1_delaycnt, W, 1
00CA  E205      	BC	label9
00CC  67CF      	TSTFSZ FC_CAL_UAR_00072_1_delaycnt+D'1', 1
00CE  D003      	BRA	label9
00D0  4BCE      	INFSNZ FC_CAL_UAR_00072_1_delaycnt, F, 1
00D2  2BCF      	INCF FC_CAL_UAR_00072_1_delaycnt+D'1', F, 1
00D4  D7F8      	BRA	label8
00D6            label9

				delay1 = delay1 + 1;
00D6  29CA      	INCF FC_CAL_UAR_00072_1_delay1, W, 1
00D8  6FCA      	MOVWF FC_CAL_UAR_00072_1_delay1, 1

				if(delay1 == 100)
00DA  0E64      	MOVLW 0x64
00DC  63CA      	CPFSEQ FC_CAL_UAR_00072_1_delay1, 1
00DE  D004      	BRA	label10
00E8            label10

				{
					nTimeout = nTimeout - 1;
00E0  05C8      	DECF FC_CAL_UAR_00072_arg_nTimeout, W, 1
00E2  6FC8      	MOVWF FC_CAL_UAR_00072_arg_nTimeout, 1

					MX_CLEAR_WATCHDOG;
00E4  0004      	CLRWDT

					delay1 = 0;
00E6  6BCA      	CLRF FC_CAL_UAR_00072_1_delay1, 1

				}
			}
		}

		#if (MX_UART_CHANNEL_X == 0)
			regcheck = FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X);	//Test for start bit
			if (regcheck == 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(pir1, RCIF);
00E8  0E20      	MOVLW 0x20
00EA  149E      	ANDWF gbl_pir1, W
00EC  6FD1      	MOVWF CompTempVar2749, 1
00EE  51D1      	MOVF CompTempVar2749, W, 1
00F0  6FCB      	MOVWF FC_CAL_UAR_00072_1_regcheck, 1

			if (regcheck != 0)
00F2  53CB      	MOVF FC_CAL_UAR_00072_1_regcheck, F, 1
00F4  E0DD      	BZ	label6

				rxStatus = UART_STATUS_RXBYTE;
00F6  0E02      	MOVLW 0x02
00F8  6FCD      	MOVWF FC_CAL_UAR_00072_1_rxStatus, 1

		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_PIR, RC2IF);
			if (regcheck != 0)
				rxStatus = UART_STATUS_RXBYTE;
		#endif

	}

	if (rxStatus == UART_STATUS_RXBYTE)
00FC  0E02      	MOVLW 0x02
00FE  63CD      	CPFSEQ FC_CAL_UAR_00072_1_rxStatus, 1
0100  D018      	BRA	label14

	{
		#if (MX_UART_CHANNEL_X == 0)

			retVal = 0;
			UART_Delay_CAL();

			for (idx = 0; idx < MX_UART_DBITS_X; idx++)
			{
				if (FC_CAL_Bit_In(MX_UART_RX_PORT_X, MX_UART_RX_PIN_X))
					retVal = retVal | (0x01 << idx);

				UART_Delay_CAL();
			}
		#endif

		#if (MX_UART_CHANNEL_X == 1)
			regcheck = ts_bit(rcsta, FERR);
0102  0E04      	MOVLW 0x04
0104  14AB      	ANDWF gbl_rcsta, W
0106  6FD1      	MOVWF CompTempVar2750, 1
0108  51D1      	MOVF CompTempVar2750, W, 1
010A  6FCB      	MOVWF FC_CAL_UAR_00072_1_regcheck, 1

			if (regcheck != 0)
010C  53CB      	MOVF FC_CAL_UAR_00072_1_regcheck, F, 1
010E  E003      	BZ	label12
0116            label12

			{
				dummy = rcreg;						//need to read the rcreg to clear FERR
0110  50AE      	MOVF gbl_rcreg, W
0112  6FD0      	MOVWF FC_CAL_UAR_00072_1_dummy, 1

				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
0114  D00E      	BRA	label14

			{
				regcheck = ts_bit(rcsta, OERR);
0116  0E02      	MOVLW 0x02
0118  14AB      	ANDWF gbl_rcsta, W
011A  6FD1      	MOVWF CompTempVar2751, 1
011C  51D1      	MOVF CompTempVar2751, W, 1
011E  6FCB      	MOVWF FC_CAL_UAR_00072_1_regcheck, 1

				if (regcheck != 0)
0120  53CB      	MOVF FC_CAL_UAR_00072_1_regcheck, F, 1
0122  E003      	BZ	label13
012A            label13

				{
					cr_bit(rcsta, CREN);			//Reset receiver to clear error
0124  98AB      	BCF gbl_rcsta,4

					st_bit(rcsta, CREN);
0126  88AB      	BSF gbl_rcsta,4


					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
0128  D004      	BRA	label14
0132            label14

				{
					retVal = 0;
012A  6BC9      	CLRF FC_CAL_UAR_00072_1_retVal, 1


					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(rcsta, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | rcreg; 			//no error, so rx byte is valid
012C  50AE      	MOVF gbl_rcreg, W
012E  11C9      	IORWF FC_CAL_UAR_00072_1_retVal, W, 1
0130  6FC9      	MOVWF FC_CAL_UAR_00072_1_retVal, 1

				}
			}
		#endif

		#if (MX_UART_CHANNEL_X == 2)
			regcheck = ts_bit(MX_UART2_RCSTA, FERR);
			if (regcheck != 0)
			{
				dummy = MX_UART2_RCREG;			//need to read the rcreg to clear FERR
				#if (MX_UART_RETURN_X == 1)
					retVal = 0x400;					//Framing Error Flag
				#endif
			}
			else
			{
				regcheck = ts_bit(MX_UART2_RCSTA, OERR);
				if (regcheck != 0)
				{
					cr_bit(MX_UART2_RCSTA, CREN);	//Reset receiver to clear error
					st_bit(MX_UART2_RCSTA, CREN);
					#if (MX_UART_RETURN_X == 1)
						retVal = 0x800;				//Overrun Error Flag
					#endif
				}
				else
				{
					retVal = 0;

					#if (MX_UART_DBITS_X == 9)
						if(ts_bit(MX_UART2_RCSTA, RX9D))
							retVal = 0x100;
					#endif

					retVal = retVal | MX_UART2_RCREG; 			//no error, so rx byte is valid
				}
			}

		#endif

		#if (MX_UART_ECHO_X == 1)
			UART_Send(retVal);
		#endif
	}

	#if (MX_UART_FLOWEN_X == 1)
		FC_CAL_Bit_High(MX_UART_RTS_PORT_X, MX_UART_RTS_PIN_X);		//not ready to accept data
	#endif

	return (retVal);
0132  51C9      	MOVF FC_CAL_UAR_00072_1_retVal, W, 1
0134  6FD1      	MOVWF CompTempVarRet2748, 1
0136  6BD2      	CLRF CompTempVarRet2748+D'1', 1

}
0138  0012      	RETURN



CALFUNCTION(void, FC_CAL_UART_Delay_, (void))
{
  #if (MX_UART_CHANNEL_X == 0)

	MX_UINT16 delay = MX_SOFT_BAUD_X;

	while (delay > 255)
	{
		delay_us(255);
		delay = delay - 255;
		MX_CLEAR_WATCHDOG;
	}
	delay_us(delay);
	MX_CLEAR_WATCHDOG;

  #endif
}


CALFUNCTION(void, FC_CAL_UART_UpdateBaud_, (MX_UINT8 new_baud))

{
	//Baud Rates - Function compatible with hardware mode only
	/*
	0 - 1200
	1 - 2400
	2 - 4800
	3 - 9600
	4 - 19200
	5 - 38400
	6 - 57600
	7 - 115200
	*/

	MX_UINT8 baudrate, baudmode;

	if (new_baud > 7)
02F4  0E07      	MOVLW 0x07
02F6  65B5      	CPFSGT FC_CAL_UAR_00070_arg_new_baud, 1
02F8  D001      	BRA	label18
02FC            label18

		return;

	if (new_baud == 0)
02FC  53B5      	MOVF FC_CAL_UAR_00070_arg_new_baud, F, 1
02FE  E104      	BNZ	label19
0308            label19

	{
		baudrate = MX_HARD_BAUD_1200;
0300  69B6      	SETF FC_CAL_UAR_00070_1_baudrate, 1

		baudmode = MX_HARD_SLOW_1200;
0302  0E01      	MOVLW 0x01
0304  6FB7      	MOVWF FC_CAL_UAR_00070_1_baudmode, 1

	}
	else if (new_baud == 1)
0306  D02F      	BRA	label26
0308  05B5      	DECF FC_CAL_UAR_00070_arg_new_baud, W, 1
030A  E105      	BNZ	label20
0316            label20

	{
		baudrate = MX_HARD_BAUD_2400;
030C  0E7F      	MOVLW 0x7F
030E  6FB6      	MOVWF FC_CAL_UAR_00070_1_baudrate, 1

		baudmode = MX_HARD_SLOW_2400;
0310  0E01      	MOVLW 0x01
0312  6FB7      	MOVWF FC_CAL_UAR_00070_1_baudmode, 1

	}
	else if (new_baud == 2)
0314  D028      	BRA	label26
0316  0E02      	MOVLW 0x02
0318  63B5      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud, 1
031A  D003      	BRA	label21
0322            label21

	{
		baudrate = MX_HARD_BAUD_4800;
031C  69B6      	SETF FC_CAL_UAR_00070_1_baudrate, 1

		baudmode = MX_HARD_SLOW_4800;
031E  6BB7      	CLRF FC_CAL_UAR_00070_1_baudmode, 1

	}
	else if (new_baud == 3)
0320  D022      	BRA	label26
0322  0E03      	MOVLW 0x03
0324  63B5      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud, 1
0326  D004      	BRA	label22
0330            label22

	{
		baudrate = MX_HARD_BAUD_9600;
0328  0E7F      	MOVLW 0x7F
032A  6FB6      	MOVWF FC_CAL_UAR_00070_1_baudrate, 1

		baudmode = MX_HARD_SLOW_9600;
032C  6BB7      	CLRF FC_CAL_UAR_00070_1_baudmode, 1

	}
	else if (new_baud == 4)
032E  D01B      	BRA	label26
0330  0E04      	MOVLW 0x04
0332  63B5      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud, 1
0334  D004      	BRA	label23
033E            label23

	{
		baudrate = MX_HARD_BAUD_19200;
0336  0E3F      	MOVLW 0x3F
0338  6FB6      	MOVWF FC_CAL_UAR_00070_1_baudrate, 1

		baudmode = MX_HARD_SLOW_19200;
033A  6BB7      	CLRF FC_CAL_UAR_00070_1_baudmode, 1

	}
	else if (new_baud == 5)
033C  D014      	BRA	label26
033E  0E05      	MOVLW 0x05
0340  63B5      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud, 1
0342  D004      	BRA	label24
034C            label24

	{
		baudrate = MX_HARD_BAUD_38400;
0344  0E1F      	MOVLW 0x1F
0346  6FB6      	MOVWF FC_CAL_UAR_00070_1_baudrate, 1

		baudmode = MX_HARD_SLOW_38400;
0348  6BB7      	CLRF FC_CAL_UAR_00070_1_baudmode, 1

	}
	else if (new_baud == 6)
034A  D00D      	BRA	label26
034C  0E06      	MOVLW 0x06
034E  63B5      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud, 1
0350  D004      	BRA	label25
035A            label25

	{
		baudrate = MX_HARD_BAUD_57600;
0352  0E14      	MOVLW 0x14
0354  6FB6      	MOVWF FC_CAL_UAR_00070_1_baudrate, 1

		baudmode = MX_HARD_SLOW_57600;
0356  6BB7      	CLRF FC_CAL_UAR_00070_1_baudmode, 1

	}
	else if (new_baud == 7)
0358  D006      	BRA	label26
035A  0E07      	MOVLW 0x07
035C  63B5      	CPFSEQ FC_CAL_UAR_00070_arg_new_baud, 1
035E  D003      	BRA	label26
0366            label26

	{
		baudrate = MX_HARD_BAUD_115200;
0360  0E0A      	MOVLW 0x0A
0362  6FB6      	MOVWF FC_CAL_UAR_00070_1_baudrate, 1

		baudmode = MX_HARD_SLOW_115200;
0364  6BB7      	CLRF FC_CAL_UAR_00070_1_baudmode, 1

	}

	UART_Uninit();
0366  EC9DF000  	CALL FC_CAL_UAR_00071


	#if (MX_UART_CHANNEL_X == 1)

	    if (baudmode == 1)
036A  05B7      	DECF FC_CAL_UAR_00070_1_baudmode, W, 1
036C  E102      	BNZ	label27
0372            label27

			cr_bit(txsta, BRGH);					//Low Speed
036E  94AC      	BCF gbl_txsta,2

	    else
0370  D001      	BRA	label28
0374            label28

			st_bit(txsta, BRGH);					//High Speed
0372  84AC      	BSF gbl_txsta,2


		spbrg = baudrate;   						// set the baud rate
0374  51B6      	MOVF FC_CAL_UAR_00070_1_baudrate, W, 1
0376  6EAF      	MOVWF gbl_spbrg

		rcsta = 0;                    				// 8-bit, disabled
0378  6AAB      	CLRF gbl_rcsta


		#if(MX_UART_DBITS_X == 9)
			st_bit(txsta, TX9);   					// 9-bit TX
			st_bit(rcsta, RX9);                    	// 9-bit RX
		#endif

		st_bit(rcsta, SPEN);         				// turn on serial interface
037A  8EAB      	BSF gbl_rcsta,7

		st_bit(txsta, TXEN);
037C  8AAC      	BSF gbl_txsta,5

		st_bit(rcsta, CREN);
037E  88AB      	BSF gbl_rcsta,4


		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH1_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (pie1, RCIE);
0380  9A9D      	BCF gbl_pie1,5

		#endif
	#endif

	#if (MX_UART_CHANNEL_X == 2)

	  	if (baudmode == 1)
			cr_bit(MX_UART2_TXSTA, BRGH);			//Low Speed
	  	else
			st_bit(MX_UART2_TXSTA, BRGH);			//High Speed

		spbrg2 = baudrate;   						// set the baud rate
		MX_UART2_RCSTA = 0;                    		// 8-bit, disabled

		#if(MX_UART_DBITS_X == 9)
			st_bit(MX_UART2_TXSTA, TX9);   			// 9-bit TX
			st_bit(MX_UART2_RCSTA, RX9);            // 9-bit RX
		#endif

		st_bit(MX_UART2_RCSTA, SPEN);         		// turn on serial interface
		st_bit(MX_UART2_TXSTA, TXEN);
		st_bit(MX_UART2_RCSTA, CREN);

		#if (MX_UART_INT_X == 1)
			MX_UART_INT_CH2_EN;
			st_bit(intcon, PEIE);
			st_bit(intcon, GIE);
		#else
			cr_bit (MX_UART2_PIE, RC2IE);
		#endif
	#endif

	#if (MX_UART_FLOWEN_X == 1)						//Flowcontrol enabled?
		FC_CAL_Bit_In_DDR (MX_UART_CTS_PORT_X, MX_UART_CTS_TRIS_X, MX_UART_CTS_PIN_X);	// CTS pin is a input
		FC_CAL_Bit_High_DDR (MX_UART_RTS_PORT_X, MX_UART_RTS_TRIS_X, MX_UART_RTS_PIN_X);	// RTS not ready to accept data
	#endif

}
02FA  0012      	RETURN
0382  0012      	RETURN


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EFF9F005  	GOTO	_startup

0008  EF4CF006  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  53B6      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF5      	MOVLW 0xF5
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0FFF      	ADDLW 0xFF
0038  A4D8      	BTFSS STATUS,Z
003A  D7ED      	BRA	label2
003C  0000      	NOP
003E  0000      	NOP
0040  0000      	NOP
0042  0000      	NOP
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  2FB6      	DECFSZ delay_ms_00000_arg_del, F, 1
0058  D7DD      	BRA	label1
005A  0012      	RETURN
005C            ; } delay_ms function end

005C            delay_us_00000
005C            ; { delay_us ; function begin
005C            label3
005C  0000      	NOP
005E  0000      	NOP
0060  2FB5      	DECFSZ delay_us_00000_arg_del, F, 1
0062  D7FC      	BRA	label3
0064  0012      	RETURN
0066            ; } delay_us function end

0066            delay_s_00000
0066            ; { delay_s ; function begin
0066            label4
0066  0EFA      	MOVLW 0xFA
0068  6FB6      	MOVWF delay_ms_00000_arg_del, 1
006A  EC06F000  	CALL delay_ms_00000
006E  0EFA      	MOVLW 0xFA
0070  6FB6      	MOVWF delay_ms_00000_arg_del, 1
0072  EC06F000  	CALL delay_ms_00000
0076  0EFA      	MOVLW 0xFA
0078  6FB6      	MOVWF delay_ms_00000_arg_del, 1
007A  EC06F000  	CALL delay_ms_00000
007E  0EFA      	MOVLW 0xFA
0080  6FB6      	MOVWF delay_ms_00000_arg_del, 1
0082  EC06F000  	CALL delay_ms_00000
0086  2FB5      	DECFSZ delay_s_00000_arg_del, F, 1
0088  D7EE      	BRA	label4
008A  0012      	RETURN
008C            ; } delay_s function end

























































0BF2            _startup
0BF2  0ED5      	MOVLW 0xD5
0BF4  6E6A      	MOVWF gbl_14_LSR
0BF6  0EC4      	MOVLW 0xC4
0BF8  6E6B      	MOVWF gbl_14_LSR+D'1'
0BFA  0EBB      	MOVLW 0xBB
0BFC  6E6C      	MOVWF gbl_14_LSR+D'2'
0BFE  0EDC      	MOVLW 0xDC
0C00  6E6D      	MOVWF gbl_14_LSR+D'3'
0C02  6A6E      	CLRF gbl_15_gbl_aSig
0C04  6A6F      	CLRF gbl_15_gbl_aSig+D'1'
0C06  6A70      	CLRF gbl_15_gbl_aSig+D'2'
0C08  6A71      	CLRF gbl_15_gbl_aSig+D'3'
0C0A  6A72      	CLRF gbl_15_gbl_bSig
0C0C  6A73      	CLRF gbl_15_gbl_bSig+D'1'
0C0E  6A74      	CLRF gbl_15_gbl_bSig+D'2'
0C10  6A75      	CLRF gbl_15_gbl_bSig+D'3'
0C12  6A76      	CLRF gbl_15_gbl_zSig
0C14  6A77      	CLRF gbl_15_gbl_zSig+D'1'
0C16  6A78      	CLRF gbl_15_gbl_zSig+D'2'
0C18  6A79      	CLRF gbl_15_gbl_zSig+D'3'
0C1A  0100      	MOVLB 0x00
0C1C  6B9D      	CLRF gbl_15_gbl_aExp, 1
0C1E  6B9E      	CLRF gbl_15_gbl_bExp, 1
0C20  6A7E      	CLRF gbl_15_gbl_zExp
0C22  6A7F      	CLRF gbl_15_gbl_zExp+D'1'
0C24  6B9F      	CLRF gbl_15_gbl_aSign, 1
0C26  6BA0      	CLRF gbl_15_gbl_bSign, 1
0C28  6BA1      	CLRF gbl_15_gbl_zSign, 1
0C2A  6BA2      	CLRF gbl_15_gbl_zSigZero, 1
0C2C  6A7A      	CLRF gbl_15_gbl_ret
0C2E  6A7B      	CLRF gbl_15_gbl_ret+D'1'
0C30  6A7C      	CLRF gbl_15_gbl_ret+D'2'
0C32  6A7D      	CLRF gbl_15_gbl_ret+D'3'
0C34  6B9B      	CLRF gbl_float_rounding_mode, 1
0C36  6B9C      	CLRF gbl_float_exception_flags, 1
0C38  6B9A      	CLRF gbl_float_detect_tininess, 1














0C94  EF7DF005  	GOTO	main

300000  32FF      	DW 0x32FF
300002  FEFF      	DW 0xFEFF
300004  FBFF      	DW 0xFBFF
300006  FFBA      	DW 0xFFBA
300008  FFFF      	DW 0xFFFF
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
